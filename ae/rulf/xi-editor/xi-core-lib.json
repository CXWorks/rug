{"dependencies":{"<<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<annotations::AnnotationRange as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<annotations::AnnotationRange as serde::Serialize>::serialize":["annotations::AnnotationRange","serde::Serializer","std::marker::Sized","std::result::Result"],"<annotations::AnnotationRange as std::clone::Clone>::clone":["annotations::AnnotationRange"],"<annotations::AnnotationRange as std::cmp::PartialEq>::eq":["annotations::AnnotationRange"],"<annotations::AnnotationRange as std::default::Default>::default":["annotations::AnnotationRange"],"<annotations::AnnotationRange as std::fmt::Debug>::fmt":["annotations::AnnotationRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<annotations::AnnotationSlice as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationSlice","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<annotations::AnnotationSlice as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationSlice","annotations::AnnotationType","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<annotations::AnnotationType as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<annotations::AnnotationType as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<annotations::AnnotationType as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationType","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<annotations::Annotations as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationType","annotations::Annotations","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<annotations::Annotations as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationType","annotations::Annotations","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<backspace::offset_for_delete_backwards::State as std::cmp::PartialEq>::eq":["backspace::offset_for_delete_backwards::State"],"<client::Client as width_cache::WidthMeasure>::measure_width":["alloc::raw_vec::RawVec","client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::WidthReq"],"<client::OpType as std::clone::Clone>::clone":["client::OpType"],"<client::OpType as std::fmt::Debug>::fmt":["client::OpType","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<client::Update as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","client::Update","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<client::UpdateOp as std::fmt::Debug>::fmt":["client::OpType","client::UpdateOp","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<config::BufferItems as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","config::BufferItems","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<config::BufferItems as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","config::BufferItems","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<config::BufferItems as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","config::BufferItems","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<config::Config<T> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","config::Config","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<config::Config<T> as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","config::Config","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<config::Config<T> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","config::Config","config::TableStack","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<config::ConfigDomain as std::clone::Clone>::clone":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::cmp::Eq>::assert_receiver_is_total_eq":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::cmp::PartialEq>::eq":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::convert::From<syntax::LanguageId>>::from":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::convert::From<tabs::BufferId>>::from":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::fmt::Debug>::fmt":["config::ConfigDomain","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomain as std::hash::Hash>::hash":["config::ConfigDomain","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"<config::ConfigDomainExternal as std::clone::Clone>::clone":["config::ConfigDomainExternal","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<config::ConfigDomainExternal as std::cmp::Eq>::assert_receiver_is_total_eq":["config::ConfigDomainExternal","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<config::ConfigDomainExternal as std::cmp::PartialEq>::eq":["config::ConfigDomainExternal","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<config::ConfigDomainExternal as std::fmt::Debug>::fmt":["config::ConfigDomainExternal","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<config::ConfigDomainExternal as std::hash::Hash>::hash":["config::ConfigDomainExternal","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<config::ConfigError as std::convert::From<serde_json::Error>>::from":["alloc::raw_vec::RawVec","config::ConfigError","serde_json::Error","std::alloc::Allocator","std::boxed::Box","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","toml::de::Error"],"<config::ConfigError as std::convert::From<std::io::Error>>::from":["alloc::raw_vec::RawVec","config::ConfigError","serde_json::Error","std::alloc::Allocator","std::boxed::Box","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","toml::de::Error"],"<config::ConfigError as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","config::ConfigError","serde_json::Error","std::alloc::Allocator","std::boxed::Box","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","toml::de::Error"],"<config::ConfigError as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","config::ConfigError","serde_json::Error","std::alloc::Allocator","std::boxed::Box","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","toml::de::Error"],"<config::ConfigManager as std::fmt::Debug>::fmt":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","syntax::Languages"],"<config::ConfigPair as std::fmt::Debug>::fmt":["config::ConfigPair","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc"],"<config::LanguageTag as std::clone::Clone>::clone":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<config::LanguageTag as std::fmt::Debug>::fmt":["config::LanguageTag","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"<config::TableStack as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<config::TableStack as std::default::Default>::default":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<config::TableStack as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","std::marker::PhantomData"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","std::marker::PhantomData"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor<'de, T> as serde::de::Visitor<'de>>::expecting":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","serde::Deserialize","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor<'de, T> as serde::de::Visitor<'de>>::visit_map":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","serde::Deserialize","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor<'de, T> as serde::de::Visitor<'de>>::visit_seq":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","serde::Deserialize","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<core::WeakXiCore as std::clone::Clone>::clone":["core::WeakXiCore","std::ptr::NonNull","std::sync::Weak"],"<core::WeakXiCore as xi_rpc::Handler>::handle_notification":["core::WeakXiCore","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Weak","xi_rpc::RpcCtx"],"<core::WeakXiCore as xi_rpc::Handler>::handle_request":["core::WeakXiCore","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Weak","xi_rpc::RpcCtx"],"<core::XiCore as xi_rpc::Handler>::handle_notification":["core::XiCore","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","xi_rpc::RpcCtx"],"<core::XiCore as xi_rpc::Handler>::handle_request":["core::XiCore","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","xi_rpc::RpcCtx"],"<core::XiCore as xi_rpc::Handler>::idle":["core::XiCore","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","xi_rpc::RpcCtx"],"<edit_ops::IndentDirection as std::clone::Clone>::clone":["edit_ops::IndentDirection"],"<edit_ops::IndentDirection as std::fmt::Debug>::fmt":["edit_ops::IndentDirection","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<edit_types::BufferEvent as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","edit_types::BufferEvent","movement::Movement","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<edit_types::BufferEvent as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","edit_types::BufferEvent","movement::Movement","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<edit_types::BufferEvent as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","edit_types::BufferEvent","movement::Movement","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<edit_types::EventDomain as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::convert::From<edit_types::BufferEvent>>::from":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::convert::From<edit_types::SpecialEvent>>::from":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::convert::From<edit_types::ViewEvent>>::from":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::convert::From<rpc::EditNotification>>::from":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::EventDomain as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Size"],"<edit_types::SpecialEvent as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","edit_types::SpecialEvent","rpc::LineRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::SpecialEvent as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","edit_types::SpecialEvent","rpc::LineRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<edit_types::SpecialEvent as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","edit_types::SpecialEvent","rpc::LineRange","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Size"],"<edit_types::ViewEvent as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<edit_types::ViewEvent as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<edit_types::ViewEvent as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<editor::EditType as std::clone::Clone>::clone":["editor::EditType"],"<editor::EditType as std::cmp::Eq>::assert_receiver_is_total_eq":["editor::EditType"],"<editor::EditType as std::cmp::PartialEq>::eq":["editor::EditType"],"<editor::EditType as std::fmt::Debug>::fmt":["editor::EditType","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<file::CharacterEncoding as std::clone::Clone>::clone":["file::CharacterEncoding"],"<file::CharacterEncoding as std::fmt::Debug>::fmt":["file::CharacterEncoding","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<file::FileError as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","file::FileError","std::alloc::Allocator","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sys::unix::os_str::Buf","std::vec::Vec"],"<file::FileInfo as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","file::CharacterEncoding","file::FileInfo","std::alloc::Allocator","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sys::unix::os_str::Buf","std::vec::Vec"],"<find::Find as annotations::ToAnnotation>::get_annotations":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationStore","annotations::AnnotationType","find::Find","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<find::FindStatus as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","find::FindStatus","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<index_set::MinusIter<'a> as std::iter::DoubleEndedIterator>::next_back":["index_set::MinusIter","std::marker::Sized","std::option::Option"],"<index_set::MinusIter<'a> as std::iter::Iterator>::next":["index_set::MinusIter","std::marker::Sized","std::option::Option"],"<layers::Layers as std::default::Default>::default":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<layers::ScopeLayer as std::default::Default>::default":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<line_cache_shadow::LineCacheShadow as std::default::Default>::default":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<line_cache_shadow::LineCacheShadow as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<line_cache_shadow::PlanIterator<'a> as std::iter::Iterator>::next":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","line_cache_shadow::PlanIterator","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<line_cache_shadow::RenderTactic as std::clone::Clone>::clone":["line_cache_shadow::RenderTactic"],"<line_cache_shadow::RenderTactic as std::cmp::PartialEq>::eq":["line_cache_shadow::RenderTactic"],"<line_cache_shadow::Span as std::fmt::Debug>::fmt":["line_cache_shadow::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<line_ending::LineEnding as std::clone::Clone>::clone":["line_ending::LineEnding"],"<line_ending::LineEnding as std::cmp::Eq>::assert_receiver_is_total_eq":["line_ending::LineEnding"],"<line_ending::LineEnding as std::cmp::PartialEq>::eq":["line_ending::LineEnding"],"<line_ending::LineEnding as std::fmt::Debug>::fmt":["line_ending::LineEnding","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<line_ending::LineEnding as std::hash::Hash>::hash":["line_ending::LineEnding","std::hash::Hasher","std::marker::Sized"],"<line_ending::MixedLineEndingError as std::fmt::Debug>::fmt":["line_ending::MixedLineEndingError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<linewrap::Lines as line_offset::LineOffset>::line_of_offset":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<linewrap::Lines as line_offset::LineOffset>::offset_of_line":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<linewrap::Lines as std::default::Default>::default":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<linewrap::MergedBreaks<'a> as std::iter::Iterator>::next":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<linewrap::VisualLines<'a> as std::iter::Iterator>::next":["linewrap::MergedBreaks","linewrap::VisualLines","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<linewrap::WrapWidth as std::clone::Clone>::clone":["linewrap::WrapWidth"],"<linewrap::WrapWidth as std::cmp::PartialEq>::eq":["linewrap::WrapWidth"],"<linewrap::WrapWidth as std::default::Default>::default":["linewrap::WrapWidth"],"<linewrap::WrapWidth as std::fmt::Debug>::fmt":["linewrap::WrapWidth","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<movement::Movement as std::clone::Clone>::clone":["movement::Movement"],"<movement::Movement as std::cmp::PartialEq>::eq":["movement::Movement"],"<movement::Movement as std::fmt::Debug>::fmt":["movement::Movement","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::PluginPid as std::clone::Clone>::clone":["plugins::PluginPid"],"<plugins::PluginPid as std::cmp::Eq>::assert_receiver_is_total_eq":["plugins::PluginPid"],"<plugins::PluginPid as std::cmp::Ord>::cmp":["plugins::PluginPid","std::cmp::Ordering"],"<plugins::PluginPid as std::cmp::PartialEq>::eq":["plugins::PluginPid"],"<plugins::PluginPid as std::cmp::PartialOrd>::partial_cmp":["plugins::PluginPid","std::marker::Sized","std::option::Option"],"<plugins::PluginPid as std::default::Default>::default":["plugins::PluginPid"],"<plugins::PluginPid as std::fmt::Debug>::fmt":["plugins::PluginPid","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::PluginPid as std::fmt::Display>::fmt":["plugins::PluginPid","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::PluginPid as std::hash::Hash>::hash":["plugins::PluginPid","std::hash::Hasher","std::marker::Sized"],"<plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_newtype_struct":["plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::catalog::PluginCatalog as std::clone::Clone>::clone":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<plugins::catalog::PluginCatalog as std::default::Default>::default":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<plugins::catalog::PluginCatalog as std::fmt::Debug>::fmt":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result"],"<plugins::catalog::PluginLoadError as std::convert::From<std::io::Error>>::from":["plugins::catalog::PluginLoadError","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","toml::de::Error"],"<plugins::catalog::PluginLoadError as std::convert::From<toml::de::Error>>::from":["plugins::catalog::PluginLoadError","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","toml::de::Error"],"<plugins::catalog::PluginLoadError as std::fmt::Debug>::fmt":["plugins::catalog::PluginLoadError","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","toml::de::Error"],"<plugins::manifest::ArgumentOption as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::ArgumentOption as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::ArgumentOption as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::manifest::ArgumentType as std::clone::Clone>::clone":["plugins::manifest::ArgumentType"],"<plugins::manifest::ArgumentType as std::cmp::PartialEq>::eq":["plugins::manifest::ArgumentType"],"<plugins::manifest::ArgumentType as std::fmt::Debug>::fmt":["plugins::manifest::ArgumentType","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::Command as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::Command as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::manifest::CommandArgument as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::manifest::ArgumentType","plugins::manifest::CommandArgument","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::CommandArgument as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::manifest::ArgumentType","plugins::manifest::CommandArgument","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::manifest::PlaceholderRpc as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::PlaceholderRpc as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::manifest::PlaceholderRpc as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::manifest::PluginActivation as std::clone::Clone>::clone":["plugins::manifest::PluginActivation","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<plugins::manifest::PluginActivation as std::fmt::Debug>::fmt":["plugins::manifest::PluginActivation","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"<plugins::manifest::PluginDescription as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec"],"<plugins::manifest::PluginDescription as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","std::alloc::Allocator","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec"],"<plugins::manifest::PluginScope as std::clone::Clone>::clone":["plugins::manifest::PluginScope"],"<plugins::manifest::PluginScope as std::default::Default>::default":["plugins::manifest::PluginScope"],"<plugins::manifest::PluginScope as std::fmt::Debug>::fmt":["plugins::manifest::PluginScope","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::RpcType as std::clone::Clone>::clone":["plugins::manifest::RpcType"],"<plugins::manifest::RpcType as std::cmp::PartialEq>::eq":["plugins::manifest::RpcType"],"<plugins::manifest::RpcType as std::fmt::Debug>::fmt":["plugins::manifest::RpcType","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::ClientPluginInfo as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::ClientPluginInfo","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::rpc::DataSpan as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::DataSpan","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::rpc::DataSpan as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::DataSpan","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::rpc::EmptyStruct as std::clone::Clone>::clone":["plugins::rpc::EmptyStruct"],"<plugins::rpc::EmptyStruct as std::fmt::Debug>::fmt":["plugins::rpc::EmptyStruct","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::GetDataResponse as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::GetDataResponse","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::rpc::HostNotification as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::PluginPid","plugins::rpc::EmptyStruct","plugins::rpc::HostNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"<plugins::rpc::HostNotification as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::PluginPid","plugins::rpc::EmptyStruct","plugins::rpc::HostNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"<plugins::rpc::HostRequest as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::rpc::EmptyStruct","plugins::rpc::HostRequest","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"<plugins::rpc::HostRequest as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::EmptyStruct","plugins::rpc::HostRequest","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"<plugins::rpc::Hover as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::rpc::Hover","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<plugins::rpc::Hover as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::Hover","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::rpc::PluginBufferInfo as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","syntax::LanguageId","tabs::BufferId"],"<plugins::rpc::PluginBufferInfo as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::vec::Vec","syntax::LanguageId","tabs::BufferId"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds","plugins::PluginPid","tabs::ViewId"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds","plugins::PluginPid","tabs::ViewId"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","std::marker::PhantomData"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","std::marker::PhantomData"],"<plugins::rpc::PluginCommand<T> as serde::Serialize>::serialize":["plugins::PluginPid","plugins::rpc::PluginCommand","serde::Serializer","std::marker::Sized","std::result::Result","tabs::ViewId"],"<plugins::rpc::PluginEdit as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::rpc::PluginEdit","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"<plugins::rpc::PluginEdit as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::PluginEdit","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"<plugins::rpc::PluginNotification as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"<plugins::rpc::PluginNotification as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"<plugins::rpc::PluginRequest as std::clone::Clone>::clone":["plugins::rpc::PluginRequest","plugins::rpc::TextUnit"],"<plugins::rpc::PluginRequest as std::fmt::Debug>::fmt":["plugins::rpc::PluginRequest","plugins::rpc::TextUnit","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::PluginUpdate as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"<plugins::rpc::PluginUpdate as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"<plugins::rpc::Range as std::clone::Clone>::clone":["plugins::rpc::Range"],"<plugins::rpc::Range as std::fmt::Debug>::fmt":["plugins::rpc::Range","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::ScopeSpan as std::clone::Clone>::clone":["plugins::rpc::ScopeSpan"],"<plugins::rpc::ScopeSpan as std::fmt::Debug>::fmt":["plugins::rpc::ScopeSpan","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::TextUnit as std::clone::Clone>::clone":["plugins::rpc::TextUnit"],"<plugins::rpc::TextUnit as std::fmt::Debug>::fmt":["plugins::rpc::TextUnit","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"<plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["plugins::rpc::TextUnit","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::CoreNotification as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigDomainExternal","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::EditCommand","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"<rpc::CoreNotification as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigDomainExternal","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::EditCommand","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"<rpc::CoreRequest as std::cmp::PartialEq>::eq":["rpc::CoreRequest","rpc::EditCommand","std::marker::Sized","std::option::Option","tabs::ViewId"],"<rpc::CoreRequest as std::fmt::Debug>::fmt":["rpc::CoreRequest","rpc::EditCommand","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::ViewId"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId","tabs::ViewId"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor":["<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","std::marker::PhantomData"],"<rpc::EditCommand<T> as serde::Serialize>::serialize":["rpc::EditCommand","serde::Serializer","std::marker::Sized","std::result::Result","tabs::ViewId"],"<rpc::EditCommand<T> as std::clone::Clone>::clone":["rpc::EditCommand","std::marker::Sized","tabs::ViewId"],"<rpc::EditCommand<T> as std::cmp::PartialEq>::eq":["rpc::EditCommand","std::marker::Sized","tabs::ViewId"],"<rpc::EditCommand<T> as std::fmt::Debug>::fmt":["rpc::EditCommand","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::ViewId"],"<rpc::EditNotification as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"<rpc::EditNotification as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Size"],"<rpc::EditRequest as std::cmp::PartialEq>::eq":["rpc::EditRequest"],"<rpc::EditRequest as std::fmt::Debug>::fmt":["rpc::EditRequest","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::EmptyStruct as std::cmp::PartialEq>::eq":["rpc::EmptyStruct"],"<rpc::EmptyStruct as std::fmt::Debug>::fmt":["rpc::EmptyStruct","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::FindQuery as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","rpc::FindQuery","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<rpc::FindQuery as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","rpc::FindQuery","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<rpc::FindQuery as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","rpc::FindQuery","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<rpc::FindQuery as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","rpc::FindQuery","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<rpc::GestureType as std::clone::Clone>::clone":["rpc::GestureType","rpc::SelectionGranularity"],"<rpc::GestureType as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::GestureType","rpc::SelectionGranularity"],"<rpc::GestureType as std::cmp::PartialEq>::eq":["rpc::GestureType","rpc::SelectionGranularity"],"<rpc::GestureType as std::fmt::Debug>::fmt":["rpc::GestureType","rpc::SelectionGranularity","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":["<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor":["<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor","std::marker::PhantomData"],"<rpc::LineRange as serde::Serialize>::serialize":["rpc::LineRange","serde::Serializer","std::marker::Sized","std::result::Result"],"<rpc::LineRange as std::clone::Clone>::clone":["rpc::LineRange"],"<rpc::LineRange as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::LineRange"],"<rpc::LineRange as std::cmp::PartialEq>::eq":["rpc::LineRange"],"<rpc::LineRange as std::fmt::Debug>::fmt":["rpc::LineRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::MouseAction as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::MouseAction as serde::Serialize>::serialize":["rpc::MouseAction","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::MouseAction as serde::Serialize>::serialize::Helper":["<rpc::MouseAction as serde::Serialize>::serialize::Helper","std::marker::Sized","std::option::Option"],"<rpc::MouseAction as serde::Serialize>::serialize::_IMPL_SERIALIZE_FOR_Helper::<impl serde::Serialize for <rpc::MouseAction as serde::Serialize>::serialize::Helper>::serialize":["<rpc::MouseAction as serde::Serialize>::serialize::Helper","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::MouseAction as std::clone::Clone>::clone":["rpc::MouseAction","std::marker::Sized","std::option::Option"],"<rpc::MouseAction as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::MouseAction","std::marker::Sized","std::option::Option"],"<rpc::MouseAction as std::cmp::PartialEq>::eq":["rpc::MouseAction","std::marker::Sized","std::option::Option"],"<rpc::MouseAction as std::fmt::Debug>::fmt":["rpc::MouseAction","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::PluginNotification as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"<rpc::PluginNotification as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"<rpc::Position as std::clone::Clone>::clone":["rpc::Position"],"<rpc::Position as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::Position"],"<rpc::Position as std::cmp::PartialEq>::eq":["rpc::Position"],"<rpc::Position as std::fmt::Debug>::fmt":["rpc::Position","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::SelectionGranularity as std::clone::Clone>::clone":["rpc::SelectionGranularity"],"<rpc::SelectionGranularity as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::SelectionGranularity"],"<rpc::SelectionGranularity as std::cmp::PartialEq>::eq":["rpc::SelectionGranularity"],"<rpc::SelectionGranularity as std::fmt::Debug>::fmt":["rpc::SelectionGranularity","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::SelectionModifier as std::clone::Clone>::clone":["rpc::SelectionModifier"],"<rpc::SelectionModifier as std::cmp::Eq>::assert_receiver_is_total_eq":["rpc::SelectionModifier"],"<rpc::SelectionModifier as std::cmp::PartialEq>::eq":["rpc::SelectionModifier"],"<rpc::SelectionModifier as std::default::Default>::default":["rpc::SelectionModifier"],"<rpc::SelectionModifier as std::fmt::Debug>::fmt":["rpc::SelectionModifier","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed","serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor":["<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","std::marker::PhantomData"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor","serde::de::EnumAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"<rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::result::Result","tabs::ViewId"],"<rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged<'__a> as serde::Serialize>::serialize":["alloc::raw_vec::RawVec","rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<selection::Affinity as std::clone::Clone>::clone":["selection::Affinity"],"<selection::Affinity as std::cmp::Eq>::assert_receiver_is_total_eq":["selection::Affinity"],"<selection::Affinity as std::cmp::PartialEq>::eq":["selection::Affinity"],"<selection::Affinity as std::default::Default>::default":["selection::Affinity"],"<selection::Affinity as std::fmt::Debug>::fmt":["selection::Affinity","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<selection::InsertDrift as std::clone::Clone>::clone":["selection::InsertDrift"],"<selection::SelRegion as std::clone::Clone>::clone":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"<selection::SelRegion as std::cmp::Eq>::assert_receiver_is_total_eq":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"<selection::SelRegion as std::cmp::PartialEq>::eq":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"<selection::SelRegion as std::convert::From<xi_rope::Interval>>::from":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option","xi_rope::Interval"],"<selection::SelRegion as std::fmt::Debug>::fmt":["selection::Affinity","selection::SelRegion","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<selection::SelRegion as std::fmt::Display>::fmt":["selection::Affinity","selection::SelRegion","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<selection::Selection as annotations::ToAnnotation>::get_annotations":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationStore","annotations::AnnotationType","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<selection::Selection as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<selection::Selection as std::convert::From<selection::SelRegion>>::from":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<selection::Selection as std::default::Default>::default":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<selection::Selection as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<selection::Selection as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<selection::Selection as std::ops::Deref>::deref":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<std::boxed::Box<(dyn xi_rpc::Peer + 'static)> as watcher::Notify>::notify":["std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<styles::Style as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","styles::Style"],"<styles::Style as std::cmp::Eq>::assert_receiver_is_total_eq":["std::marker::Sized","std::option::Option","styles::Style"],"<styles::Style as std::cmp::PartialEq>::eq":["std::marker::Sized","std::option::Option","styles::Style"],"<styles::Style as std::default::Default>::default":["std::marker::Sized","std::option::Option","styles::Style"],"<styles::Style as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","styles::Style"],"<styles::Style as std::fmt::Debug>::fmt::fmt_color":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<styles::Style as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","std::option::Option","styles::Style"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["serde::de::Error","std::marker::Sized","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["serde::de::Error","std::marker::Sized","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["serde::de::Error","std::marker::Sized","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor"],"<syntax::LanguageDefinition as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageDefinition","syntax::LanguageId"],"<syntax::LanguageDefinition as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageDefinition","syntax::LanguageId"],"<syntax::LanguageId as std::borrow::Borrow<str>>::borrow":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::clone::Clone>::clone":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::cmp::Eq>::assert_receiver_is_total_eq":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::cmp::Ord>::cmp":["std::cmp::Ordering","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::cmp::PartialEq>::eq":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::cmp::PartialOrd>::partial_cmp":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::convert::AsRef<str>>::as_ref":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::convert::From<&'a str>>::from":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::default::Default>::default":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"<syntax::LanguageId as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"<syntax::Languages as std::default::Default>::default":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"<syntax::Languages as std::fmt::Debug>::fmt":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","syntax::Languages"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["serde::de::Error","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["serde::de::Error","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["serde::de::Error","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_newtype_struct":["serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor"],"<tabs::BufferId as std::clone::Clone>::clone":["tabs::BufferId"],"<tabs::BufferId as std::cmp::Eq>::assert_receiver_is_total_eq":["tabs::BufferId"],"<tabs::BufferId as std::cmp::Ord>::cmp":["std::cmp::Ordering","tabs::BufferId"],"<tabs::BufferId as std::cmp::PartialEq>::eq":["tabs::BufferId"],"<tabs::BufferId as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","tabs::BufferId"],"<tabs::BufferId as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::BufferId"],"<tabs::BufferId as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::BufferId"],"<tabs::BufferId as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","tabs::BufferId"],"<tabs::Counter as std::default::Default>::default":["std::cell::Cell","std::cell::UnsafeCell","tabs::Counter"],"<tabs::Counter as std::fmt::Debug>::fmt":["std::cell::Cell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::Counter"],"<tabs::Iter<'a, I> as std::iter::Iterator>::next":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::Iter","watcher::FileWatcher"],"<tabs::ViewId as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<tabs::ViewId as serde::Serialize>::serialize":["serde::Serializer","std::marker::Sized","std::result::Result","tabs::ViewId"],"<tabs::ViewId as std::clone::Clone>::clone":["tabs::ViewId"],"<tabs::ViewId as std::cmp::Eq>::assert_receiver_is_total_eq":["tabs::ViewId"],"<tabs::ViewId as std::cmp::Ord>::cmp":["std::cmp::Ordering","tabs::ViewId"],"<tabs::ViewId as std::cmp::PartialEq>::eq":["tabs::ViewId"],"<tabs::ViewId as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","tabs::ViewId"],"<tabs::ViewId as std::convert::From<usize>>::from":["tabs::ViewId"],"<tabs::ViewId as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::ViewId"],"<tabs::ViewId as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","tabs::ViewId"],"<tabs::ViewId as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","tabs::ViewId"],"<tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor"],"<tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_newtype_struct":["serde::Deserializer","std::marker::PhantomData","std::marker::Sized","std::result::Result","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor"],"<tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor"],"<view::FindProgress as std::clone::Clone>::clone":["std::marker::Sized","std::ops::Range","view::FindProgress"],"<view::FindProgress as std::cmp::PartialEq>::eq":["std::marker::Sized","std::ops::Range","view::FindProgress"],"<view::FindProgress as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","view::FindProgress"],"<view::FindStatusChange as std::cmp::PartialEq>::eq":["view::FindStatusChange"],"<view::FindStatusChange as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","view::FindStatusChange"],"<view::Replace as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Replace"],"<view::Replace as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Replace"],"<view::Replace as std::default::Default>::default":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Replace"],"<view::Replace as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Replace"],"<view::Size as std::clone::Clone>::clone":["view::Size"],"<view::Size as std::cmp::PartialEq>::eq":["view::Size"],"<view::Size as std::default::Default>::default":["view::Size"],"<view::Size as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","view::Size"],"<view::View as line_offset::LineOffset>::line_of_offset":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<view::View as line_offset::LineOffset>::offset_of_line":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["serde::de::Error","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor"],"<watcher::WatchToken as std::clone::Clone>::clone":["watcher::WatchToken"],"<watcher::WatchToken as std::cmp::Eq>::assert_receiver_is_total_eq":["watcher::WatchToken"],"<watcher::WatchToken as std::cmp::PartialEq>::eq":["watcher::WatchToken"],"<watcher::WatchToken as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","watcher::WatchToken"],"<watcher::Watchee as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sys::unix::os_str::Buf","std::vec::Vec","watcher::WatchToken","watcher::Watchee"],"<watcher::WatcherState as std::default::Default>::default":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::collections::VecDeque","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","watcher::WatcherState"],"<watcher::WatcherState as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::collections::VecDeque","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","watcher::WatcherState"],"<whitespace::Indentation as std::clone::Clone>::clone":["whitespace::Indentation"],"<whitespace::Indentation as std::cmp::Eq>::assert_receiver_is_total_eq":["whitespace::Indentation"],"<whitespace::Indentation as std::cmp::PartialEq>::eq":["whitespace::Indentation"],"<whitespace::Indentation as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","whitespace::Indentation"],"<whitespace::Indentation as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","whitespace::Indentation"],"<whitespace::MixedIndentError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","whitespace::MixedIndentError"],"<width_cache::CodepointMono as width_cache::WidthMeasure>::measure_width":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::CodepointMono","width_cache::WidthReq"],"<width_cache::WidthCacheKey<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["std::borrow::Cow","std::borrow::ToOwned","width_cache::WidthCacheKey"],"<width_cache::WidthCacheKey<'a> as std::cmp::PartialEq>::eq":["std::borrow::Cow","std::borrow::ToOwned","width_cache::WidthCacheKey"],"<width_cache::WidthCacheKey<'a> as std::hash::Hash>::hash":["std::borrow::Cow","std::borrow::ToOwned","std::hash::Hasher","std::marker::Sized","width_cache::WidthCacheKey"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["serde::de::Error","std::marker::Sized","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["serde::de::Error","std::marker::Sized","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["serde::de::Error","std::marker::Sized","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor"],"<word_boundaries::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq":["word_boundaries::WordBoundary"],"<word_boundaries::WordBoundary as std::cmp::PartialEq>::eq":["word_boundaries::WordBoundary"],"<word_boundaries::WordProperty as std::clone::Clone>::clone":["word_boundaries::WordProperty"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::line_of_offset":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::offset_of_line":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::AnnotationRange":["annotations::AnnotationRange"],"annotations::AnnotationSlice":["alloc::raw_vec::RawVec","annotations::AnnotationSlice","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"annotations::AnnotationSlice::new":["alloc::raw_vec::RawVec","annotations::AnnotationSlice","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"annotations::AnnotationSlice::to_json":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"annotations::AnnotationStore":["annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"annotations::AnnotationStore::clear":["annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"annotations::AnnotationStore::invalidate":["annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","xi_rope::Interval"],"annotations::AnnotationStore::iter_range":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::AnnotationStore::new":["annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"annotations::AnnotationStore::update":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","annotations::AnnotationType","annotations::Annotations","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::AnnotationType":["alloc::raw_vec::RawVec","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"annotations::AnnotationType::as_str":["alloc::raw_vec::RawVec","annotations::AnnotationType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"annotations::Annotations":["alloc::raw_vec::RawVec","annotations::AnnotationType","annotations::Annotations","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::Annotations::invalidate":["alloc::raw_vec::RawVec","annotations::AnnotationType","annotations::Annotations","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::Annotations::update":["alloc::raw_vec::RawVec","annotations::AnnotationType","annotations::Annotations","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::ToAnnotation::get_annotations":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationStore","annotations::AnnotationType","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","std::marker::PhantomData"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor":["annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor","std::marker::PhantomData"],"annotations::_IMPL_SERIALIZE_FOR_AnnotationSlice::<impl serde::Serialize for annotations::AnnotationSlice>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationSlice","annotations::AnnotationType","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"annotations::_IMPL_SERIALIZE_FOR_AnnotationType::<impl serde::Serialize for annotations::AnnotationType>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationType","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"backspace::offset_for_delete_backwards":["alloc::raw_vec::RawVec","config::BufferItems","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"backspace::offset_for_delete_backwards::State":["backspace::offset_for_delete_backwards::State"],"client::Client":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"client::Client::add_status_item":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::alert":["client::Client","std::alloc::Allocator","std::boxed::Box","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","syntax::LanguageId"],"client::Client::available_languages":["alloc::raw_vec::RawVec","client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"client::Client::available_plugins":["alloc::raw_vec::RawVec","client::Client","plugins::rpc::ClientPluginInfo","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"client::Client::available_themes":["alloc::raw_vec::RawVec","client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"client::Client::config_changed":["annotations::AnnotationRange","client::Client","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::def_style":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"client::Client::find_status":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"client::Client::language_changed":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"client::Client::measure_width":["alloc::raw_vec::RawVec","client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::WidthReq"],"client::Client::new":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"client::Client::plugin_started":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::plugin_stopped":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::remove_status_item":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::replace_status":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"client::Client::schedule_idle":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"client::Client::schedule_timer":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::time::Nanoseconds","std::sys::unix::time::Timespec","std::sys::unix::time::inner::Instant","std::time::Instant"],"client::Client::scroll_to":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::show_hover":["alloc::raw_vec::RawVec","client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"client::Client::theme_changed":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","syntect::highlighting::ThemeSettings"],"client::Client::update_cmds":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"client::Client::update_status_item":["client::Client","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","tabs::ViewId"],"client::Client::update_view":["alloc::raw_vec::RawVec","client::Client","client::Update","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","tabs::ViewId"],"client::OpType":["client::OpType"],"client::Update":["alloc::raw_vec::RawVec","client::Update","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"client::UpdateOp":["client::OpType","client::UpdateOp","std::marker::Sized","std::option::Option"],"client::UpdateOp::copy":["client::OpType","client::UpdateOp","std::marker::Sized","std::option::Option"],"client::UpdateOp::insert":["alloc::raw_vec::RawVec","client::OpType","client::UpdateOp","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"client::UpdateOp::invalidate":["client::OpType","client::UpdateOp","std::marker::Sized","std::option::Option"],"client::UpdateOp::skip":["client::OpType","client::UpdateOp","std::marker::Sized","std::option::Option"],"client::UpdateOp::update":["alloc::raw_vec::RawVec","client::OpType","client::UpdateOp","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"client::_IMPL_SERIALIZE_FOR_OpType::<impl serde::Serialize for client::OpType>::serialize":["client::OpType","serde::Serializer","std::marker::Sized","std::result::Result"],"client::_IMPL_SERIALIZE_FOR_Update::<impl serde::Serialize for client::Update>::serialize":["alloc::raw_vec::RawVec","client::Update","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"client::_IMPL_SERIALIZE_FOR_UpdateOp::<impl serde::Serialize for client::UpdateOp>::serialize":["client::OpType","client::UpdateOp","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"config::BufferItems":["alloc::raw_vec::RawVec","config::BufferItems","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"config::Config":["alloc::raw_vec::RawVec","config::Config","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::Config::<T>::changes_from":["alloc::raw_vec::RawVec","config::Config","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::Config::<T>::to_table":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::Config","config::TableStack","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::ConfigDomain":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"config::ConfigDomain::file_stem":["config::ConfigDomain","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"config::ConfigDomainExternal":["config::ConfigDomainExternal","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"config::ConfigError":["alloc::raw_vec::RawVec","config::ConfigError","serde_json::Error","std::alloc::Allocator","std::boxed::Box","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","toml::de::Error"],"config::ConfigManager":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::add_buffer":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages","tabs::BufferId"],"config::ConfigManager::base_config_file_path":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::check_table":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","syntax::Languages"],"config::ConfigManager::domain_for_path":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::sys::unix::os_str::Slice","syntax::Languages"],"config::ConfigManager::generate_buffer_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::Config","config::ConfigManager","config::TableStack","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","syntax::Languages","tabs::BufferId"],"config::ConfigManager::get_buffer_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::Config","config::ConfigManager","config::TableStack","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","syntax::Languages","tabs::BufferId"],"config::ConfigManager::get_buffer_language":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","syntax::Languages","tabs::BufferId"],"config::ConfigManager::get_plugin_paths":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","syntax::Languages"],"config::ConfigManager::get_plugins_dir":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::get_themes_dir":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::language_for_path":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::sys::unix::os_str::Slice","syntax::Languages"],"config::ConfigManager::load_user_config_file":["annotations::AnnotationRange","config::ConfigDomain","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","syntax::Languages","tabs::BufferId"],"config::ConfigManager::new":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::override_language":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","syntax::Languages","tabs::BufferId"],"config::ConfigManager::remove_buffer":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages","tabs::BufferId"],"config::ConfigManager::set_languages":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"config::ConfigManager::set_user_config":["annotations::AnnotationRange","config::ConfigDomain","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","syntax::Languages","tabs::BufferId"],"config::ConfigManager::table_for_update":["annotations::AnnotationRange","config::ConfigDomain","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","syntax::Languages","tabs::BufferId"],"config::ConfigManager::update_all_buffer_configs":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","syntax::Languages"],"config::ConfigManager::update_buffer_config":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages","tabs::BufferId"],"config::ConfigManager::update_buffer_path":["annotations::AnnotationRange","config::ConfigManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::sys::unix::os_str::Slice","syntax::Languages","tabs::BufferId"],"config::ConfigPair":["config::ConfigPair","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::ConfigPair::new_with_base":["config::ConfigPair","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::ConfigPair::rebuild":["config::ConfigPair","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::ConfigPair::set_table":["annotations::AnnotationRange","config::ConfigPair","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::ConfigPair::table_for_update":["annotations::AnnotationRange","config::ConfigPair","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::ConfigPair::with_base":["config::ConfigPair","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"config::LanguageTag":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"config::LanguageTag::new":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"config::LanguageTag::resolve":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"config::LanguageTag::set_detected":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"config::LanguageTag::set_user":["config::LanguageTag","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"config::TableStack":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::TableStack::collate":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::TableStack","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::TableStack::diff":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::TableStack::get":["alloc::raw_vec::RawVec","config::TableStack","std::alloc::Allocator","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","syntax::LanguageId"],"config::TableStack::into_config":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","alloc::raw_vec::RawVec","config::Config","config::TableStack","serde::Deserialize","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor":["config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","std::marker::PhantomData"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor":["config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","serde::Deserialize","std::marker::PhantomData","std::marker::Sized"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor":["config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor","std::marker::PhantomData"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor":["config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor","std::marker::PhantomData"],"config::_IMPL_SERIALIZE_FOR_BufferItems::<impl serde::Serialize for config::BufferItems>::serialize":["alloc::raw_vec::RawVec","config::BufferItems","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"config::_IMPL_SERIALIZE_FOR_Config::<impl serde::Serialize for config::Config<T>>::serialize":["alloc::raw_vec::RawVec","config::Config","config::TableStack","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"config::_IMPL_SERIALIZE_FOR_ConfigDomain::<impl serde::Serialize for config::ConfigDomain>::serialize":["config::ConfigDomain","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","tabs::BufferId"],"config::_IMPL_SERIALIZE_FOR_ConfigDomainExternal::<impl serde::Serialize for config::ConfigDomainExternal>::serialize":["config::ConfigDomainExternal","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"config::deserialize_tab_size":["serde::Deserializer","std::marker::Sized","std::result::Result"],"config::from_toml_value":["alloc::raw_vec::RawVec","annotations::AnnotationRange","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","toml::Value","toml::map::Map","toml::value::Datetime"],"config::init_config_dir":["std::ffi::OsStr","std::marker::Sized","std::path::Path","std::result::Result","std::sys::unix::os_str::Slice"],"config::load_base_config":["annotations::AnnotationRange","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"config::load_base_config::load":["annotations::AnnotationRange","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"config::load_base_config::platform_overrides":["std::marker::Sized","std::option::Option"],"config::table_from_toml_str":["std::marker::Sized","std::result::Result"],"config::try_load_from_file":["std::ffi::OsStr","std::marker::Sized","std::path::Path","std::result::Result","std::sys::unix::os_str::Slice"],"core::WeakXiCore":["core::WeakXiCore","std::ptr::NonNull","std::sync::Weak"],"core::WeakXiCore::handle_plugin_update":["core::WeakXiCore","plugins::PluginPid","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Weak","tabs::ViewId"],"core::WeakXiCore::plugin_connect":["core::WeakXiCore","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Weak"],"core::WeakXiCore::plugin_exit":["core::WeakXiCore","plugins::PluginPid","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Weak"],"core::WeakXiCore::upgrade":["core::WeakXiCore","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Weak"],"core::XiCore":["core::XiCore","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc"],"core::XiCore::inner":["core::XiCore","std::cell::UnsafeCell","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::MutexGuard","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sync::poison::Guard","std::sys::unix::locks::futex_mutex::Mutex"],"core::XiCore::is_waiting":["core::XiCore","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc"],"core::XiCore::new":["core::XiCore","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc"],"core::XiCore::weak_self":["core::XiCore","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc"],"edit_ops::IndentDirection":["edit_ops::IndentDirection"],"edit_ops::capitalize_text":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::change_number":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::delete_backward":["alloc::raw_vec::RawVec","config::BufferItems","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::delete_by_movement":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","movement::Movement","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::delete_sel_regions":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::duplicate_line":["alloc::raw_vec::RawVec","config::BufferItems","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::extract_sel_regions":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::get_tab_text":["alloc::raw_vec::RawVec","config::BufferItems","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"edit_ops::indent":["alloc::raw_vec::RawVec","annotations::AnnotationRange","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::insert":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::insert_newline":["alloc::raw_vec::RawVec","config::BufferItems","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::insert_tab":["alloc::raw_vec::RawVec","config::BufferItems","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::last_selection_region":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"edit_ops::modify_indent":["alloc::raw_vec::RawVec","config::BufferItems","edit_ops::IndentDirection","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::n_spaces":[],"edit_ops::outdent":["alloc::raw_vec::RawVec","annotations::AnnotationRange","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::sel_region_to_interval_and_rope":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::surround":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::transform_text":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_ops::transpose":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"edit_types::BufferEvent":["alloc::raw_vec::RawVec","edit_types::BufferEvent","movement::Movement","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"edit_types::EventDomain":["alloc::raw_vec::RawVec","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"edit_types::SpecialEvent":["alloc::raw_vec::RawVec","edit_types::SpecialEvent","rpc::LineRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"edit_types::ViewEvent":["alloc::raw_vec::RawVec","edit_types::ViewEvent","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"editor::EditType":["editor::EditType"],"editor::EditType::breaks_undo_group":["editor::EditType"],"editor::Editor":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::add_delta":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::apply_plugin_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::rpc::PluginEdit","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::calculate_undo_group":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::commit_delta":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::dec_revs_in_flight":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::delta_rev_head":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_capitalize_text":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_change_number":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Fn","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_copy":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_cut":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_delete_backward":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_delete_by_movement":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","movement::Movement","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_duplicate_line":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","edit_types::BufferEvent","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","movement::Movement","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_insert":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_insert_newline":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_insert_tab":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_modify_indent":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","config::BufferItems","edit_ops::IndentDirection","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_paste":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_redo":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_replace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_transform_text":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Fn","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_transpose":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_undo":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::do_yank":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::gc_undos":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_active_undo_group":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_buffer":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_edit_type":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_head_rev_token":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_layers":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_layers_mut":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::get_rev":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::increment_revs_in_flight":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::is_pristine":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::merge_new_state":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::plugin_get_data":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::rpc::TextUnit","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::plugin_n_lines":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::reload":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::set_force_undo_group":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::set_pristine":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::set_session_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::sync_state_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::theme_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::update_annotations":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","annotations::AnnotationType","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","plugins::PluginPid","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::update_edit_type":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::update_spans":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","plugins::PluginPid","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::update_undos":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::Editor::with_text":["alloc::raw_vec::RawVec","annotations::AnnotationRange","editor::EditType","editor::Editor","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"editor::SyncStore":["editor::SyncStore"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor":["editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor","std::marker::PhantomData"],"editor::_IMPL_SERIALIZE_FOR_EditType::<impl serde::Serialize for editor::EditType>::serialize":["editor::EditType","serde::Serializer","std::marker::Sized","std::result::Result"],"editor::count_lines":[],"editor::last_selection_region":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"event_context::EventContext":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::_finish_delayed_render":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::after_edit":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::after_save":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::sys::unix::os_str::Slice","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::close_view":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::config_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::dispatch_event":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","event_context::EventContext","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::Size"],"event_context::EventContext::<'a>::do_debug_toggle_comment":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_edit":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::Size"],"event_context::EventContext::<'a>::do_edit_sync":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","rpc::EditRequest","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_incremental_find":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_plugin_cmd":["alloc::raw_vec::RawVec","annotations::AnnotationType","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","plugins::PluginPid","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","xi_rope::Delta","xi_rope::tree::NodeInfo"],"event_context::EventContext::<'a>::do_plugin_cmd_sync":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","plugins::PluginPid","plugins::rpc::PluginRequest","plugins::rpc::TextUnit","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_plugin_update":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_reindent":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_request_hover":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_request_lines":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_rewrap_batch":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_show_hover":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::do_special":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","edit_types::SpecialEvent","event_context::EventContext","rpc::LineRange","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::Size"],"event_context::EventContext::<'a>::find":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::finish_init":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::get_resolved_position":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::language_changed":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::plugin_info":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::plugin_started":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::sys::unix::process::process_inner::Process","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::plugin_stopped":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::sys::unix::process::process_inner::Process","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::reload":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"event_context::EventContext::<'a>::render":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::render_if_needed":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::rewrap":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::schedule_find":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::schedule_rewrap":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::selected_line_ranges":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::text_for_save":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"event_context::EventContext::<'a>::update_plugins":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","editor::EditType","editor::Editor","event_context::EventContext","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","xi_rope::Delta","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"event_context::EventContext::<'a>::update_views":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::BufferItems","core::WeakXiCore","editor::EditType","editor::Editor","event_context::EventContext","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","selection::InsertDrift","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::BTreeSet","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId","xi_rope::Delta","xi_rope::engine::Engine","xi_rope::engine::RevId","xi_rope::multiset::Subset","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"event_context::EventContext::<'a>::update_wrap_settings":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::view_init":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::with_each_plugin":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::with_editor":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"event_context::EventContext::<'a>::with_view":["alloc::raw_vec::RawVec","client::Client","config::BufferItems","core::WeakXiCore","event_context::EventContext","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Weak","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"file::<impl std::convert::From<file::FileError> for xi_rpc::RemoteError>::from":["alloc::raw_vec::RawVec","annotations::AnnotationRange","file::FileError","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","xi_rpc::RemoteError"],"file::CharacterEncoding":["file::CharacterEncoding"],"file::CharacterEncoding::guess":["file::CharacterEncoding"],"file::FileError":["alloc::raw_vec::RawVec","file::FileError","std::alloc::Allocator","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"file::FileError::error_code":["alloc::raw_vec::RawVec","file::FileError","std::alloc::Allocator","std::ffi::OsString","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"file::FileInfo":["alloc::raw_vec::RawVec","file::CharacterEncoding","file::FileInfo","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"file::FileManager":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher"],"file::FileManager::check_file":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","tabs::BufferId","watcher::FileWatcher"],"file::FileManager::close":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","tabs::BufferId","watcher::FileWatcher"],"file::FileManager::get_editor":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","watcher::FileWatcher"],"file::FileManager::get_info":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","tabs::BufferId","watcher::FileWatcher"],"file::FileManager::new":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher"],"file::FileManager::open":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","tabs::BufferId","watcher::FileWatcher"],"file::FileManager::save":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","tabs::BufferId","watcher::FileWatcher","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"file::FileManager::save_existing":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","tabs::BufferId","watcher::FileWatcher","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"file::FileManager::save_new":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","tabs::BufferId","watcher::FileWatcher","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"file::FileManager::watcher":["annotations::AnnotationRange","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher"],"file::get_mod_time":["std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"file::get_permissions":["std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"file::try_decode":["alloc::raw_vec::RawVec","file::CharacterEncoding","std::alloc::Allocator","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sys::unix::os_str::Slice","std::vec::Vec"],"file::try_load_file":["std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"file::try_save":["file::CharacterEncoding","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::ptr::NonNull","std::result::Result","std::sync::Arc","std::sys::unix::os_str::Slice","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::Find":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::find_status":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","find::Find","find::FindStatus","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::Find::hls_dirty":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::id":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::is_matching_whole_words":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::Find::is_multiline_regex":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::new":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::next_occurrence":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::Find::occurrences":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::set_find":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::set_hls_dirty":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::unset":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::find::CaseMatching"],"find::Find::update_find":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::Find::update_highlights":["alloc::raw_vec::RawVec","find::Find","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::find::CaseMatching","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"find::FindStatus":["alloc::raw_vec::RawVec","find::FindStatus","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor":["find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","std::marker::PhantomData"],"find::_IMPL_SERIALIZE_FOR_FindStatus::<impl serde::Serialize for find::FindStatus>::serialize":["alloc::raw_vec::RawVec","find::FindStatus","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"index_set::IndexSet":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::IndexSet::apply_delta":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"index_set::IndexSet::clear":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::IndexSet::delete_range":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::IndexSet::minus_one_range":["alloc::raw_vec::RawVec","index_set::IndexSet","index_set::MinusIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::IndexSet::new":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::IndexSet::union_one_range":["alloc::raw_vec::RawVec","index_set::IndexSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"index_set::MinusIter":["index_set::MinusIter"],"index_set::remove_n_at":["alloc::raw_vec::RawVec","annotations::AnnotationRange","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"layers::Layers":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::add_scopes":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::create_if_missing":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::debug_print_spans":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::get_merged":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::remove_layer":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::resolve_styles":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::theme_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::update_all":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::Layers::update_layer":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","layers::Layers","plugins::PluginPid","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::add_scopes":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::blank_scopes":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::styles_for_stacks":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::theme_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::update_scopes":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"layers::ScopeLayer::update_styles":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","layers::ScopeLayer","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_cache_shadow::Builder":["alloc::raw_vec::RawVec","line_cache_shadow::Builder","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::Builder::add_span":["alloc::raw_vec::RawVec","line_cache_shadow::Builder","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::Builder::build":["alloc::raw_vec::RawVec","line_cache_shadow::Builder","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::Builder::new":["alloc::raw_vec::RawVec","line_cache_shadow::Builder","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::Builder::set_dirty":["alloc::raw_vec::RawVec","line_cache_shadow::Builder","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow::edit":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow::iter_with_plan":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","line_cache_shadow::PlanIterator","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow::needs_render":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow::partial_invalidate":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::LineCacheShadow::spans":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","line_cache_shadow::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::PlanIterator":["alloc::raw_vec::RawVec","line_cache_shadow::LineCacheShadow","line_cache_shadow::PlanIterator","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::PlanSegment":["line_cache_shadow::PlanSegment","line_cache_shadow::RenderTactic"],"line_cache_shadow::RenderPlan":["alloc::raw_vec::RawVec","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::RenderPlan::create":["alloc::raw_vec::RawVec","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::RenderPlan::request_lines":["alloc::raw_vec::RawVec","line_cache_shadow::RenderPlan","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"line_cache_shadow::RenderTactic":["line_cache_shadow::RenderTactic"],"line_cache_shadow::Span":["line_cache_shadow::Span"],"line_ending::LineEnding":["line_ending::LineEnding"],"line_ending::LineEnding::parse":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_ending::LineEnding::parse_chunk":["std::marker::Sized","std::result::Result"],"line_ending::MixedLineEndingError":["line_ending::MixedLineEndingError"],"line_offset::LineOffset::get_line_range":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_offset::LineOffset::line_col_to_offset":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_offset::LineOffset::line_of_offset":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_offset::LineOffset::offset_of_line":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_offset::LineOffset::offset_to_line_col":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"line_offset::LogicalLines":["line_offset::LogicalLines"],"linewrap::InvalLines":["linewrap::InvalLines"],"linewrap::LineBreakCursor":["linewrap::LineBreakCursor","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::LineBreakCursor::<'a>::new":["linewrap::LineBreakCursor","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::LineBreakCursor::<'a>::next":["linewrap::LineBreakCursor","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::Lines":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::add_task":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::after_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::do_wrap_task":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::Lines","linewrap::WrapSummary","linewrap::WrapWidth","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::get_next_task":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::interval_needs_wrap":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::is_converged":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::iter_lines":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::logical_line_range":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::offset_of_visual_line":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::patchup_tasks":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::rewrap_chunk":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::set_wrap_width":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::update_tasks_after_wrap":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::Lines::visual_line_of_offset":["alloc::raw_vec::RawVec","linewrap::Lines","linewrap::WrapWidth","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::at_eof":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::eof_without_newline":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::is_hard_break":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::new":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::offset_of_line":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::offset_of_line_bsearch":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::offset_of_line_linear":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::MergedBreaks::<'a>::set_offset":["linewrap::MergedBreaks","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::PotentialBreak":["linewrap::PotentialBreak"],"linewrap::RewrapCtx":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::LineBreakCursor","linewrap::RewrapCtx","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::RewrapCtx::<'a>::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::LineBreakCursor","linewrap::RewrapCtx","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::RewrapCtx::<'a>::refill_pot_breaks":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::LineBreakCursor","linewrap::RewrapCtx","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::RewrapCtx::<'a>::wrap_one_line":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","linewrap::LineBreakCursor","linewrap::RewrapCtx","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","width_cache::WidthCache","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo","xi_unicode::LineBreakLeafIter"],"linewrap::VisualLine":["linewrap::VisualLine","std::marker::Sized","std::option::Option","xi_rope::Interval"],"linewrap::VisualLine::new":["linewrap::VisualLine","std::convert::Into","std::marker::Sized","std::option::Option","xi_rope::Interval"],"linewrap::VisualLines":["linewrap::MergedBreaks","linewrap::VisualLines","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"linewrap::WrapSummary":["linewrap::WrapSummary"],"linewrap::WrapWidth":["linewrap::WrapWidth"],"linewrap::WrapWidth::differs_in_kind":["linewrap::WrapWidth"],"linewrap::merged_line_of_offset":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"movement::Movement":["movement::Movement"],"movement::region_movement":["movement::Movement","selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"movement::scroll_height":[],"movement::selection_movement":["alloc::raw_vec::RawVec","movement::Movement","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"movement::selection_position":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"movement::vertical_motion":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"movement::vertical_motion_exact_pos":["selection::Affinity","selection::SelRegion","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"plugins::Plugin":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec"],"plugins::Plugin::close_view":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::Plugin::collect_trace":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec"],"plugins::Plugin::config_changed":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::Plugin","plugins::PluginPid","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::Plugin::did_save":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::Plugin::dispatch_command":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::Plugin","plugins::PluginPid","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::Plugin::get_hover":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::Plugin::initialize":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec"],"plugins::Plugin::language_changed":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::process::process_inner::Process","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"plugins::Plugin::new_buffer":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::Plugin","plugins::PluginPid","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::process::process_inner::Process","std::vec::Vec","syntax::LanguageId","tabs::BufferId"],"plugins::Plugin::shutdown":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec"],"plugins::Plugin::toggle_tracing":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec"],"plugins::Plugin::update":["alloc::raw_vec::RawVec","plugins::Plugin","plugins::PluginPid","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::process::process_inner::Process","std::vec::Vec","tabs::ViewId"],"plugins::PluginPid":["plugins::PluginPid"],"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor":["plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::_IMPL_SERIALIZE_FOR_PluginPid::<impl serde::Serialize for plugins::PluginPid>::serialize":["plugins::PluginPid","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::catalog::PluginCatalog":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"plugins::catalog::PluginCatalog::get_from_path":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::catalog::PluginCatalog::get_named":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"plugins::catalog::PluginCatalog::iter":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"plugins::catalog::PluginCatalog::iter_names":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"plugins::catalog::PluginCatalog::load_from_paths":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::catalog::PluginCatalog::make_languages_map":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"plugins::catalog::PluginCatalog::reload_from_paths":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::catalog::PluginCatalog::remove_named":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"plugins::catalog::PluginLoadError":["plugins::catalog::PluginLoadError","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","toml::de::Error"],"plugins::catalog::find_all_manifests":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::catalog::load_manifest":["std::ffi::OsStr","std::marker::Sized","std::path::Path","std::result::Result","std::sys::unix::os_str::Slice"],"plugins::manifest::ArgumentOption":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::ArgumentOption::new":["<rpc::MouseAction as serde::Serialize>::serialize::Helper","alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde::Serialize","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageId"],"plugins::manifest::ArgumentType":["plugins::manifest::ArgumentType"],"plugins::manifest::Command":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::Command::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::convert::AsRef","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageId"],"plugins::manifest::CommandArgument":["alloc::raw_vec::RawVec","plugins::manifest::ArgumentType","plugins::manifest::CommandArgument","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::CommandArgument::new":["alloc::raw_vec::RawVec","plugins::manifest::ArgumentType","plugins::manifest::CommandArgument","std::alloc::Allocator","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageId"],"plugins::manifest::PlaceholderRpc":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::PlaceholderRpc::is_request":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::PlaceholderRpc::method_ref":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::PlaceholderRpc::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::convert::AsRef","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageId"],"plugins::manifest::PlaceholderRpc::params_ref":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::PlaceholderRpc::params_ref_mut":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::manifest::PluginActivation":["plugins::manifest::PluginActivation","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"plugins::manifest::PluginDescription":["alloc::raw_vec::RawVec","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::manifest::PluginDescription::is_global":["alloc::raw_vec::RawVec","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::manifest::PluginScope":["plugins::manifest::PluginScope"],"plugins::manifest::RpcType":["plugins::manifest::RpcType"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor":["plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::manifest::_IMPL_SERIALIZE_FOR_ArgumentOption::<impl serde::Serialize for plugins::manifest::ArgumentOption>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::ArgumentOption","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::manifest::_IMPL_SERIALIZE_FOR_ArgumentType::<impl serde::Serialize for plugins::manifest::ArgumentType>::serialize":["plugins::manifest::ArgumentType","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_SERIALIZE_FOR_Command::<impl serde::Serialize for plugins::manifest::Command>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::Command","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::manifest::_IMPL_SERIALIZE_FOR_CommandArgument::<impl serde::Serialize for plugins::manifest::CommandArgument>::serialize":["alloc::raw_vec::RawVec","plugins::manifest::ArgumentType","plugins::manifest::CommandArgument","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::manifest::_IMPL_SERIALIZE_FOR_PlaceholderRpc::<impl serde::Serialize for plugins::manifest::PlaceholderRpc>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::manifest::_IMPL_SERIALIZE_FOR_PluginActivation::<impl serde::Serialize for plugins::manifest::PluginActivation>::serialize":["plugins::manifest::PluginActivation","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"plugins::manifest::_IMPL_SERIALIZE_FOR_PluginDescription::<impl serde::Serialize for plugins::manifest::PluginDescription>::serialize":["alloc::raw_vec::RawVec","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","serde::Serializer","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec"],"plugins::manifest::_IMPL_SERIALIZE_FOR_PluginScope::<impl serde::Serialize for plugins::manifest::PluginScope>::serialize":["plugins::manifest::PluginScope","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::manifest::_IMPL_SERIALIZE_FOR_RpcType::<impl serde::Serialize for plugins::manifest::RpcType>::serialize":["plugins::manifest::RpcType","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::manifest::platform_exec_path":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::ClientPluginInfo":["alloc::raw_vec::RawVec","plugins::rpc::ClientPluginInfo","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::rpc::DataSpan":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::DataSpan","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::rpc::EmptyStruct":["plugins::rpc::EmptyStruct"],"plugins::rpc::GetDataResponse":["alloc::raw_vec::RawVec","plugins::rpc::GetDataResponse","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::rpc::HostNotification":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::PluginPid","plugins::rpc::EmptyStruct","plugins::rpc::HostNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"plugins::rpc::HostRequest":["alloc::raw_vec::RawVec","plugins::rpc::EmptyStruct","plugins::rpc::HostRequest","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::Hover":["alloc::raw_vec::RawVec","plugins::rpc::Hover","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::rpc::PluginBufferInfo":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","syntax::LanguageId","tabs::BufferId"],"plugins::rpc::PluginBufferInfo::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::PluginBufferInfo","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"plugins::rpc::PluginCommand":["plugins::PluginPid","plugins::rpc::PluginCommand","std::marker::Sized","tabs::ViewId"],"plugins::rpc::PluginEdit":["alloc::raw_vec::RawVec","plugins::rpc::PluginEdit","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"plugins::rpc::PluginNotification":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"plugins::rpc::PluginRequest":["plugins::rpc::PluginRequest","plugins::rpc::TextUnit"],"plugins::rpc::PluginUpdate":["alloc::raw_vec::RawVec","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::PluginUpdate::new":["alloc::raw_vec::RawVec","plugins::rpc::PluginUpdate","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::Range":["plugins::rpc::Range"],"plugins::rpc::ScopeSpan":["plugins::rpc::ScopeSpan"],"plugins::rpc::TextUnit":["plugins::rpc::TextUnit"],"plugins::rpc::TextUnit::resolve_offset":["plugins::rpc::TextUnit","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor":["plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor","std::marker::PhantomData"],"plugins::rpc::_IMPL_SERIALIZE_FOR_ClientPluginInfo::<impl serde::Serialize for plugins::rpc::ClientPluginInfo>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::ClientPluginInfo","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::rpc::_IMPL_SERIALIZE_FOR_DataSpan::<impl serde::Serialize for plugins::rpc::DataSpan>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::DataSpan","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::rpc::_IMPL_SERIALIZE_FOR_EmptyStruct::<impl serde::Serialize for plugins::rpc::EmptyStruct>::serialize":["plugins::rpc::EmptyStruct","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_SERIALIZE_FOR_GetDataResponse::<impl serde::Serialize for plugins::rpc::GetDataResponse>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::GetDataResponse","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::PluginPid","plugins::rpc::EmptyStruct","plugins::rpc::HostNotification","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostRequest::<impl serde::Serialize for plugins::rpc::HostRequest>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::EmptyStruct","plugins::rpc::HostRequest","plugins::rpc::PluginUpdate","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::_IMPL_SERIALIZE_FOR_Hover::<impl serde::Serialize for plugins::rpc::Hover>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::Hover","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginBufferInfo::<impl serde::Serialize for plugins::rpc::PluginBufferInfo>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::rpc::PluginBufferInfo","serde::Serializer","serde_json::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::vec::Vec","syntax::LanguageId","tabs::BufferId"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginEdit::<impl serde::Serialize for plugins::rpc::PluginEdit>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::PluginEdit","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged":["alloc::raw_vec::RawVec","annotations::AnnotationType","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize":["plugins::rpc::PluginRequest","plugins::rpc::TextUnit","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged":["plugins::rpc::TextUnit","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged","std::marker::PhantomData"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginUpdate::<impl serde::Serialize for plugins::rpc::PluginUpdate>::serialize":["alloc::raw_vec::RawVec","plugins::rpc::PluginUpdate","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"plugins::rpc::_IMPL_SERIALIZE_FOR_Range::<impl serde::Serialize for plugins::rpc::Range>::serialize":["plugins::rpc::Range","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_SERIALIZE_FOR_ScopeSpan::<impl serde::Serialize for plugins::rpc::ScopeSpan>::serialize":["plugins::rpc::ScopeSpan","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::rpc::_IMPL_SERIALIZE_FOR_TextUnit::<impl serde::Serialize for plugins::rpc::TextUnit>::serialize":["plugins::rpc::TextUnit","serde::Serializer","std::marker::Sized","std::result::Result"],"plugins::start_plugin_process":["core::WeakXiCore","plugins::PluginPid","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","std::sync::Weak"],"recorder::Recorder":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recorder::clear":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recorder::is_recording":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recorder::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recorder::play":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recorder::record":["alloc::raw_vec::RawVec","annotations::AnnotationRange","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","movement::Movement","recorder::Recorder","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"recorder::Recorder::save_recording_buffer":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"recorder::Recorder::toggle_recording":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","recorder::Recorder","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recording":["alloc::raw_vec::RawVec","recorder::Recording","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recording::new":["alloc::raw_vec::RawVec","recorder::Recording","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"recorder::Recording::play":["alloc::raw_vec::RawVec","recorder::Recording","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"rpc::CoreNotification":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigDomainExternal","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::EditCommand","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"rpc::CoreRequest":["rpc::CoreRequest","rpc::EditCommand","std::marker::Sized","std::option::Option","tabs::ViewId"],"rpc::EditCommand":["rpc::EditCommand","std::marker::Sized","tabs::ViewId"],"rpc::EditNotification":["alloc::raw_vec::RawVec","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Size"],"rpc::EditRequest":["rpc::EditRequest"],"rpc::EmptyStruct":["rpc::EmptyStruct"],"rpc::FindQuery":["alloc::raw_vec::RawVec","rpc::FindQuery","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"rpc::GestureType":["rpc::GestureType","rpc::SelectionGranularity"],"rpc::LineRange":["rpc::LineRange"],"rpc::MouseAction":["rpc::MouseAction","std::marker::Sized","std::option::Option"],"rpc::PluginNotification":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","tabs::ViewId"],"rpc::Position":["rpc::Position"],"rpc::SelectionGranularity":["rpc::SelectionGranularity"],"rpc::SelectionModifier":["rpc::SelectionModifier"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor":["rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor","std::marker::PhantomData"],"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","config::ConfigDomainExternal","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::EditCommand","rpc::PluginNotification","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","tabs::ViewId"],"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged":["rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","tabs::ViewId"],"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize":["rpc::CoreRequest","rpc::EditCommand","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result","tabs::ViewId"],"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged":["rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged","std::marker::PhantomData","tabs::ViewId"],"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize":["alloc::raw_vec::RawVec","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Size"],"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged":["alloc::raw_vec::RawVec","rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"rpc::_IMPL_SERIALIZE_FOR_EditRequest::<impl serde::Serialize for rpc::EditRequest>::serialize":["rpc::EditRequest","serde::Serializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_SERIALIZE_FOR_EmptyStruct::<impl serde::Serialize for rpc::EmptyStruct>::serialize":["rpc::EmptyStruct","serde::Serializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_SERIALIZE_FOR_FindQuery::<impl serde::Serialize for rpc::FindQuery>::serialize":["alloc::raw_vec::RawVec","rpc::FindQuery","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"rpc::_IMPL_SERIALIZE_FOR_GestureType::<impl serde::Serialize for rpc::GestureType>::serialize":["rpc::GestureType","rpc::SelectionGranularity","serde::Serializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for rpc::PluginNotification>::serialize":["alloc::raw_vec::RawVec","annotations::AnnotationRange","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::PluginNotification","serde::Serializer","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","tabs::ViewId"],"rpc::_IMPL_SERIALIZE_FOR_Position::<impl serde::Serialize for rpc::Position>::serialize":["rpc::Position","serde::Serializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_SERIALIZE_FOR_SelectionGranularity::<impl serde::Serialize for rpc::SelectionGranularity>::serialize":["rpc::SelectionGranularity","serde::Serializer","std::marker::Sized","std::result::Result"],"rpc::_IMPL_SERIALIZE_FOR_SelectionModifier::<impl serde::Serialize for rpc::SelectionModifier>::serialize":["rpc::SelectionModifier","serde::Serializer","std::marker::Sized","std::result::Result"],"selection::<impl std::convert::From<&'a selection::SelRegion> for xi_rope::Interval>::from":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option","xi_rope::Interval"],"selection::Affinity":["selection::Affinity"],"selection::InsertDrift":["selection::InsertDrift"],"selection::SelRegion":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::caret":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::is_caret":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::is_upstream":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::max":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::merge_with":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::min":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::new":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::should_merge":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::with_affinity":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::SelRegion::with_horiz":["selection::Affinity","selection::SelRegion","std::marker::Sized","std::option::Option"],"selection::Selection":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::add_range_distinct":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::add_region":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::apply_delta":["alloc::raw_vec::RawVec","selection::InsertDrift","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"selection::Selection::clear":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::collapse":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::delete_range":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::new":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::new_simple":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::regions_in_range":["alloc::raw_vec::RawVec","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"selection::Selection::search":["alloc::raw_vec::RawVec","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"styles::Style":["std::marker::Sized","std::option::Option","styles::Style"],"styles::Style::default_for_theme":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","styles::Style","syntect::highlighting::Theme","syntect::highlighting::ThemeSettings"],"styles::Style::from_syntect_style_mod":["std::marker::Sized","std::option::Option","styles::Style","syntect::highlighting::StyleModifier"],"styles::Style::merge":["std::marker::Sized","std::option::Option","styles::Style"],"styles::Style::new":["std::convert::Into","std::marker::Sized","std::option::Option","styles::Style"],"styles::Style::rgba_from_syntect_color":["syntect::highlighting::Color"],"styles::Style::to_json":["alloc::raw_vec::RawVec","annotations::AnnotationRange","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style"],"styles::ThemeStyleMap":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::add":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::contains_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_default_style":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_dump_path":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_highlighter":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Highlighter","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_theme_name":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_theme_names":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::get_theme_settings":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::init_cache_dir":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::insert_to_map":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::load_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::load_theme_dir":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::load_theme_info_from_path":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::lookup":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::merge_with_default":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::remove_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::set_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::sync_dir":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::ThemeStyleMap::try_load_from_dump":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","styles::Style","styles::ThemeStyleMap","syntect::highlighting::Theme","syntect::highlighting::ThemeSet","syntect::highlighting::ThemeSettings"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":["styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor":["styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor":["std::marker::PhantomData","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor"],"styles::_IMPL_SERIALIZE_FOR_Style::<impl serde::Serialize for styles::Style>::serialize":["serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result","styles::Style"],"styles::validate_theme_file":["std::ffi::OsStr","std::marker::Sized","std::path::Path","std::result::Result","std::sys::unix::os_str::Slice"],"syntax::LanguageDefinition":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageDefinition","syntax::LanguageId"],"syntax::LanguageId":["std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId"],"syntax::Languages":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"syntax::Languages::difference":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","syntax::Languages"],"syntax::Languages::iter":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","syntax::Languages"],"syntax::Languages::language_for_name":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::sync::Arc","syntax::LanguageId","syntax::Languages"],"syntax::Languages::language_for_path":["annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::sys::unix::os_str::Slice","syntax::Languages"],"syntax::Languages::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageDefinition","syntax::LanguageId","syntax::Languages"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":["syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor":["syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor":["std::marker::PhantomData","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor":["std::marker::PhantomData","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor"],"syntax::_IMPL_SERIALIZE_FOR_LanguageDefinition::<impl serde::Serialize for syntax::LanguageDefinition>::serialize":["alloc::raw_vec::RawVec","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::vec::Vec","syntax::LanguageDefinition","syntax::LanguageId"],"syntax::_IMPL_SERIALIZE_FOR_LanguageId::<impl serde::Serialize for syntax::LanguageId>::serialize":["serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","syntax::LanguageId"],"tabs::<impl std::convert::From<tabs::ViewId> for usize>::from":["tabs::ViewId"],"tabs::BufferId":["tabs::BufferId"],"tabs::BufferId::new":["tabs::BufferId"],"tabs::CoreState":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::_test_open_editors":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::_test_open_views":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::after_stop_plugin":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::Plugin","plugins::PluginPid","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::process::Child","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::process::process_inner::Process","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::client_notification":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigDomainExternal","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::EditCommand","rpc::PluginNotification","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Buf","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::client_request":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","rpc::CoreRequest","rpc::EditCommand","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::detect_whitespace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_close_view":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","rpc::EditNotification","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","view::Size","watcher::FileWatcher"],"tabs::CoreState::do_edit_sync":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","rpc::EditRequest","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_get_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_get_contents":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_modify_user_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigDomainExternal","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_new_view":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::do_plugin_rpc":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_save":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_set_language":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_set_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::do_start_plugin":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::do_stop_plugin":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::finalize_new_views":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::finish_setup":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","core::WeakXiCore","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::Weak","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_config_changes":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_config_fs_event":["alloc::raw_vec::RawVec","annotations::AnnotationRange","anymap::Map","anymap::any::UncheckedAnyExt","anymap::raw::RawMap","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::Event","notify::EventKind","notify::INotifyWatcher","notify::event::AccessKind","notify::event::AccessMode","notify::event::CreateKind","notify::event::DataChange","notify::event::MetadataKind","notify::event::ModifyKind","notify::event::RemoveKind","notify::event::RenameMode","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_find_callback":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_fs_events":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_idle":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_open_file_fs_event":["alloc::raw_vec::RawVec","annotations::AnnotationRange","anymap::Map","anymap::any::UncheckedAnyExt","anymap::raw::RawMap","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::Event","notify::EventKind","notify::INotifyWatcher","notify::event::AccessKind","notify::event::AccessMode","notify::event::CreateKind","notify::event::DataChange","notify::event::MetadataKind","notify::event::ModifyKind","notify::event::RemoveKind","notify::event::RenameMode","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_plugin_fs_event":["alloc::raw_vec::RawVec","annotations::AnnotationRange","anymap::Map","anymap::any::UncheckedAnyExt","anymap::raw::RawMap","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::Event","notify::EventKind","notify::INotifyWatcher","notify::event::AccessKind","notify::event::AccessMode","notify::event::CreateKind","notify::event::DataChange","notify::event::MetadataKind","notify::event::ModifyKind","notify::event::RemoveKind","notify::event::RenameMode","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_render_timer":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_rewrap_callback":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::handle_themes_fs_event":["alloc::raw_vec::RawVec","annotations::AnnotationRange","anymap::Map","anymap::any::UncheckedAnyExt","anymap::raw::RawMap","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::Event","notify::EventKind","notify::INotifyWatcher","notify::event::AccessKind","notify::event::AccessMode","notify::event::CreateKind","notify::event::DataChange","notify::event::MetadataKind","notify::event::ModifyKind","notify::event::RemoveKind","notify::event::RenameMode","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::iter_groups":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::Iter","watcher::FileWatcher"],"tabs::CoreState::load_file_based_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::load_theme_file":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::make_context":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::next_buffer_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::BufferId","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::next_plugin_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::PluginPid","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::next_view_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::notify_client_and_update_views":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::plugin_connect":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::plugin_exit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::PluginPid","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::plugin_notification":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationType","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::PluginPid","plugins::catalog::PluginCatalog","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher","xi_rope::Delta","xi_rope::tree::NodeInfo","xi_rpc::RpcCtx"],"tabs::CoreState::plugin_request":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::PluginPid","plugins::catalog::PluginCatalog","plugins::rpc::PluginRequest","plugins::rpc::TextUnit","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher","xi_rpc::RpcCtx"],"tabs::CoreState::plugin_update":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::PluginPid","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::ViewId","watcher::FileWatcher"],"tabs::CoreState::remove_config_at_path":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::remove_theme":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::save_trace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::set_config":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigDomain","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::LanguageId","syntax::Languages","tabs::BufferId","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::CoreState::toggle_tracing":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","watcher::FileWatcher"],"tabs::Counter":["std::cell::Cell","std::cell::UnsafeCell","tabs::Counter"],"tabs::Counter::next":["std::cell::Cell","std::cell::UnsafeCell","tabs::Counter"],"tabs::Iter":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","config::ConfigManager","file::FileManager","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::set::HashSet","notify::INotifyWatcher","plugins::catalog::PluginCatalog","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::vec::Vec","syntax::Languages","tabs::CoreState","tabs::Counter","tabs::Iter","watcher::FileWatcher"],"tabs::ViewId":["tabs::ViewId"],"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor":["std::marker::PhantomData","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor"],"tabs::_IMPL_SERIALIZE_FOR_BufferId::<impl serde::Serialize for tabs::BufferId>::serialize":["serde::Serializer","std::marker::Sized","std::result::Result","tabs::BufferId"],"tabs::test_helpers::new_buffer_id":["tabs::BufferId"],"tabs::test_helpers::new_view_id":["tabs::ViewId"],"view::DragState":["alloc::raw_vec::RawVec","rpc::SelectionGranularity","selection::Selection","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","view::DragState"],"view::FindProgress":["std::marker::Sized","std::ops::Range","view::FindProgress"],"view::FindStatusChange":["view::FindStatusChange"],"view::Replace":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","view::Replace"],"view::Size":["view::Size"],"view::View":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::add_find":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::add_selection_by_movement":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","movement::Movement","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::after_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::InsertDrift","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","width_cache::WidthCache","xi_rope::Delta","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::collapse_selections":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::debug_force_rewrap_cols":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::deselect_at_offset":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_drag":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Affinity","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","edit_types::ViewEvent","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","movement::Movement","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_find":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_find_all":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_find_next":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionModifier","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_gesture":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::GestureType","rpc::SelectionGranularity","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_move":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","movement::Movement","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_selection_for_find":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_selection_for_replace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_set_replace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::do_split_selection_into_lines":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::encode_line":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::VisualLine","linewrap::WrapWidth","selection::Selection","serde_json::Map","serde_json::Number","serde_json::Value","serde_json::number::N","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::encode_styles":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::extend_selection":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionGranularity","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::find_in_progress":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::find_status":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_buffer_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_caret_offset":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_lines":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_or_def_style_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","styles::Style","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_replace":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::get_view_id":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::goto_line":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::has_pending_render":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::interval_of_visible_region":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::invalidate_selection":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::invalidate_styles":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::is_point_in_selection":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::needs_more_wrap":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::needs_wrap_in_visible_region":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::range_region":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionGranularity","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::render_if_dirty":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::request_lines":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::rewrap":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","width_cache::WidthCache","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::scroll_height":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::scroll_to_cursor":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::sel_regions":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Affinity","selection::SelRegion","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::select":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionGranularity","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::select_all":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::select_next_occurrence":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionModifier","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::send_update_for_plan":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","line_cache_shadow::RenderPlan","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_dirty":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_find":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_has_pending_render":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_scroll":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_selection":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_selection_for_edit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_selection_raw":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::set_size":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::unit":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","rpc::SelectionGranularity","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::update_annotations":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","annotations::AnnotationType","annotations::Annotations","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","plugins::PluginPid","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::Interval","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::View::update_wrap_settings":["alloc::raw_vec::RawVec","annotations::AnnotationRange","annotations::AnnotationStore","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","selection::Selection","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::vec::Vec","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Size","view::View","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":["view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor":["view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor":["std::marker::PhantomData","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":["view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor":["view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor":["std::marker::PhantomData","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor"],"view::_IMPL_SERIALIZE_FOR_Replace::<impl serde::Serialize for view::Replace>::serialize":["alloc::raw_vec::RawVec","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","view::Replace"],"view::_IMPL_SERIALIZE_FOR_Size::<impl serde::Serialize for view::Size>::serialize":["serde::Serializer","std::marker::Sized","std::result::Result","view::Size"],"view::clamp":[],"watcher::FileWatcher":["notify::INotifyWatcher","std::cell::UnsafeCell","std::marker::PhantomData","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher"],"watcher::FileWatcher::new":["notify::INotifyWatcher","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher","watcher::Notify","xi_rpc::RpcPeer"],"watcher::FileWatcher::take_events":["alloc::raw_vec::RawVec","notify::INotifyWatcher","std::alloc::Allocator","std::cell::UnsafeCell","std::collections::VecDeque","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","watcher::FileWatcher"],"watcher::FileWatcher::unwatch":["notify::INotifyWatcher","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","watcher::FileWatcher","watcher::WatchToken"],"watcher::FileWatcher::watch":["notify::INotifyWatcher","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","watcher::FileWatcher","watcher::WatchToken"],"watcher::FileWatcher::watch_filtered":["notify::INotifyWatcher","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::ops::Fn","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","watcher::FileWatcher","watcher::WatchToken"],"watcher::FileWatcher::watch_impl":["notify::INotifyWatcher","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::ptr::NonNull","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicU32","std::sync::poison::Flag","std::sys::unix::locks::futex_mutex::Mutex","std::sys::unix::os_str::Slice","watcher::FileWatcher","watcher::WatchToken"],"watcher::Notify::notify":[],"watcher::WatchToken":["watcher::WatchToken"],"watcher::Watchee":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec","watcher::WatchToken","watcher::Watchee"],"watcher::Watchee::applies_to_path":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsStr","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::Path","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::sys::unix::os_str::Slice","std::vec::Vec","watcher::WatchToken","watcher::Watchee"],"watcher::Watchee::wants_event":["alloc::raw_vec::RawVec","annotations::AnnotationRange","anymap::Map","anymap::any::UncheckedAnyExt","anymap::raw::RawMap","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","notify::Event","notify::EventKind","notify::event::AccessKind","notify::event::AccessMode","notify::event::CreateKind","notify::event::DataChange","notify::event::MetadataKind","notify::event::ModifyKind","notify::event::RemoveKind","notify::event::RenameMode","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec","watcher::WatchToken","watcher::Watchee"],"watcher::WatcherState":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::collections::VecDeque","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","watcher::WatcherState"],"watcher::mode_from_bool":["notify::RecursiveMode"],"whitespace::Indentation":["whitespace::Indentation"],"whitespace::Indentation::parse":["std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::Arc","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"whitespace::Indentation::parse_line":["std::marker::Sized","std::result::Result"],"whitespace::MixedIndentError":["whitespace::MixedIndentError"],"whitespace::extract_count":["annotations::AnnotationRange","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"whitespace::gcd":[],"width_cache::CodepointMono":["width_cache::CodepointMono"],"width_cache::WidthBatchReq":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthBatchReq","width_cache::WidthCache"],"width_cache::WidthBatchReq::<'a>::request":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthBatchReq","width_cache::WidthCache"],"width_cache::WidthBatchReq::<'a>::resolve_pending":["alloc::raw_vec::RawVec","annotations::AnnotationRange","client::Client","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::WidthBatchReq","width_cache::WidthCache","width_cache::WidthMeasure"],"width_cache::WidthCache":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthCache"],"width_cache::WidthCache::batch_req":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthBatchReq","width_cache::WidthCache"],"width_cache::WidthCache::len":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthCache"],"width_cache::WidthCache::new":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthCache"],"width_cache::WidthCache::resolve":["alloc::raw_vec::RawVec","annotations::AnnotationRange","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthCache"],"width_cache::WidthCacheKey":["std::borrow::Cow","std::borrow::ToOwned","width_cache::WidthCacheKey"],"width_cache::WidthMeasure::measure_width":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::WidthReq"],"width_cache::WidthReq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","width_cache::WidthReq"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":["width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor":["width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor":["std::marker::PhantomData","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor"],"width_cache::_IMPL_SERIALIZE_FOR_WidthReq::<impl serde::Serialize for width_cache::WidthReq>::serialize":["alloc::raw_vec::RawVec","serde::Serializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","width_cache::WidthReq"],"word_boundaries::WordBoundary":["word_boundaries::WordBoundary"],"word_boundaries::WordBoundary::is_boundary":["word_boundaries::WordBoundary"],"word_boundaries::WordBoundary::is_end":["word_boundaries::WordBoundary"],"word_boundaries::WordBoundary::is_start":["word_boundaries::WordBoundary"],"word_boundaries::WordCursor":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","word_boundaries::WordCursor","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"word_boundaries::WordCursor::<'a>::new":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","word_boundaries::WordCursor","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"word_boundaries::WordCursor::<'a>::next_boundary":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","word_boundaries::WordCursor","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"word_boundaries::WordCursor::<'a>::prev_boundary":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","word_boundaries::WordCursor","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"word_boundaries::WordCursor::<'a>::select_word":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::sync::Arc","word_boundaries::WordCursor","xi_rope::Cursor","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"word_boundaries::WordProperty":["word_boundaries::WordProperty"],"word_boundaries::classify_boundary":["word_boundaries::WordBoundary","word_boundaries::WordProperty"],"word_boundaries::classify_boundary_initial":["word_boundaries::WordBoundary","word_boundaries::WordProperty"],"word_boundaries::get_word_property":["word_boundaries::WordProperty"]},"glob_path_import":{},"self_to_fn":{"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor":["Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":["Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":["Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor":["Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor":["Deserialize"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":["Deserialize"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor":["Deserialize"],"<rpc::MouseAction as serde::Serialize>::serialize::Helper":["Serialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor":["Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor":["Deserialize"],"annotations::AnnotationRange":["Clone","Copy","Debug","Default","PartialEq","impl Serialize for AnnotationRange {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut seq = serializer.serialize_seq(Some(4))?;\n        seq.serialize_element(&self.start_line)?;\n        seq.serialize_element(&self.start_col)?;\n        seq.serialize_element(&self.end_line)?;\n        seq.serialize_element(&self.end_col)?;\n        seq.end()\n    }\n}","impl<'de> Deserialize<'de> for AnnotationRange {\n    fn deserialize<D>(deserializer: D) -> Result<AnnotationRange, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let mut range = AnnotationRange { ..Default::default() };\n        let seq = <[usize; 4]>::deserialize(deserializer)?;\n\n        range.start_line = seq[0];\n        range.start_col = seq[1];\n        range.end_line = seq[2];\n        range.end_col = seq[3];\n\n        Ok(range)\n    }\n}"],"annotations::AnnotationSlice":["Clone","Debug","Deserialize","Serialize","impl AnnotationSlice {\n    pub fn new(\n        annotation_type: AnnotationType,\n        ranges: Vec<AnnotationRange>,\n        payloads: Option<Vec<Value>>,\n    ) -> Self {\n        AnnotationSlice { annotation_type, ranges, payloads }\n    }\n\n    /// Returns json representation.\n    pub fn to_json(&self) -> Value {\n        json!({\n            \"type\": self.annotation_type.as_str(),\n            \"ranges\": self.ranges,\n            \"payloads\": self.payloads,\n            \"n\": self.ranges.len()\n        })\n    }\n}"],"annotations::AnnotationStore":["impl AnnotationStore {\n    pub fn new() -> Self {\n        AnnotationStore { store: HashMap::new() }\n    }\n\n    /// Invalidates and removes all annotations in the range of the interval.\n    pub fn invalidate(&mut self, interval: Interval) {\n        self.store\n            .values_mut()\n            .map(|v| v.iter_mut())\n            .flatten()\n            .for_each(|a| a.invalidate(interval));\n    }\n\n    /// Applies an update from a plugin to a set of annotations\n    pub fn update(&mut self, source: PluginId, interval: Interval, item: Annotations) {\n        if !self.store.contains_key(&source) {\n            self.store.insert(source, vec![item]);\n            return;\n        }\n\n        let entry = self.store.get_mut(&source).unwrap();\n        if let Some(annotation) =\n            entry.iter_mut().find(|a| a.annotation_type == item.annotation_type)\n        {\n            annotation.update(interval, item.items);\n        } else {\n            entry.push(item);\n        }\n    }\n\n    /// Returns an iterator which produces, for each type of annotation,\n    /// those annotations which intersect the given interval.\n    pub fn iter_range<'c>(\n        &'c self,\n        view: &'c View,\n        text: &'c Rope,\n        interval: Interval,\n    ) -> impl Iterator<Item = AnnotationSlice> + 'c {\n        self.store.iter().flat_map(move |(_plugin, value)| {\n            value.iter().map(move |annotation| {\n                // .filter() used instead of .subseq() because subseq() filters out spans with length 0\n                let payloads = annotation\n                    .items\n                    .iter()\n                    .filter(|(i, _p)| i.start() <= interval.end() && i.end() >= interval.start())\n                    .map(|(_i, p)| p.clone())\n                    .collect::<Vec<Value>>();\n\n                let ranges = annotation\n                    .items\n                    .iter()\n                    .filter(|(i, _p)| i.start() <= interval.end() && i.end() >= interval.start())\n                    .map(|(i, _p)| {\n                        let (start_line, start_col) = view.offset_to_line_col(text, i.start());\n                        let (end_line, end_col) = view.offset_to_line_col(text, i.end());\n\n                        AnnotationRange { start_line, start_col, end_line, end_col }\n                    })\n                    .collect::<Vec<AnnotationRange>>();\n\n                AnnotationSlice {\n                    annotation_type: annotation.annotation_type.clone(),\n                    ranges,\n                    payloads: Some(payloads),\n                }\n            })\n        })\n    }\n\n    /// Removes any annotations provided by this plugin\n    pub fn clear(&mut self, plugin: PluginId) {\n        self.store.remove(&plugin);\n    }\n}"],"annotations::AnnotationType":["Clone","Debug","Deserialize","PartialEq","Serialize","impl AnnotationType {\n    fn as_str(&self) -> &str {\n        match self {\n            AnnotationType::Find => \"find\",\n            AnnotationType::Selection => \"selection\",\n            AnnotationType::Other(ref s) => s,\n        }\n    }\n}"],"annotations::Annotations":["Clone","Debug","impl Annotations {\n    /// Update the annotations in `interval` with the provided `items`.\n    pub fn update(&mut self, interval: Interval, items: Spans<Value>) {\n        self.items.edit(interval, items);\n    }\n\n    /// Remove annotations intersecting `interval`.\n    pub fn invalidate(&mut self, interval: Interval) {\n        self.items.delete_after(interval);\n    }\n}"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":["Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor":["Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor":["Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":["Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor":["Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor":["Deserialize"],"backspace::offset_for_delete_backwards::State":["PartialEq"],"client::Client":["impl Client {\n    pub fn new(peer: RpcPeer) -> Self {\n        Client(peer)\n    }\n\n    pub fn update_view(&self, view_id: ViewId, update: &Update) {\n        self.0.send_rpc_notification(\n            \"update\",\n            &json!({\n                \"view_id\": view_id,\n                \"update\": update,\n            }),\n        );\n    }\n\n    pub fn scroll_to(&self, view_id: ViewId, line: usize, col: usize) {\n        self.0.send_rpc_notification(\n            \"scroll_to\",\n            &json!({\n                \"view_id\": view_id,\n                \"line\": line,\n                \"col\": col,\n            }),\n        );\n    }\n\n    pub fn config_changed(&self, view_id: ViewId, changes: &Table) {\n        self.0.send_rpc_notification(\n            \"config_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"changes\": changes,\n            }),\n        );\n    }\n\n    pub fn available_themes(&self, theme_names: Vec<String>) {\n        self.0.send_rpc_notification(\"available_themes\", &json!({ \"themes\": theme_names }))\n    }\n\n    pub fn available_languages(&self, languages: Vec<LanguageId>) {\n        self.0.send_rpc_notification(\"available_languages\", &json!({ \"languages\": languages }))\n    }\n\n    pub fn theme_changed(&self, name: &str, theme: &ThemeSettings) {\n        self.0.send_rpc_notification(\n            \"theme_changed\",\n            &json!({\n                \"name\": name,\n                \"theme\": theme,\n            }),\n        );\n    }\n\n    pub fn language_changed(&self, view_id: ViewId, new_lang: &LanguageId) {\n        self.0.send_rpc_notification(\n            \"language_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"language_id\": new_lang,\n            }),\n        );\n    }\n\n    /// Notify the client that a plugin has started.\n    pub fn plugin_started(&self, view_id: ViewId, plugin: &str) {\n        self.0.send_rpc_notification(\n            \"plugin_started\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n            }),\n        );\n    }\n\n    /// Notify the client that a plugin has stopped.\n    ///\n    /// `code` is not currently used; in the future may be used to\n    /// pass an exit code.\n    pub fn plugin_stopped(&self, view_id: ViewId, plugin: &str, code: i32) {\n        self.0.send_rpc_notification(\n            \"plugin_stopped\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n                \"code\": code,\n            }),\n        );\n    }\n\n    /// Notify the client of the available plugins.\n    pub fn available_plugins(&self, view_id: ViewId, plugins: &[ClientPluginInfo]) {\n        self.0.send_rpc_notification(\n            \"available_plugins\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugins\": plugins }),\n        );\n    }\n\n    pub fn update_cmds(&self, view_id: ViewId, plugin: &str, cmds: &[Command]) {\n        self.0.send_rpc_notification(\n            \"update_cmds\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n                \"cmds\": cmds,\n            }),\n        );\n    }\n\n    pub fn def_style(&self, style: &Value) {\n        self.0.send_rpc_notification(\"def_style\", &style)\n    }\n\n    pub fn find_status(&self, view_id: ViewId, queries: &Value) {\n        self.0.send_rpc_notification(\n            \"find_status\",\n            &json!({\n                \"view_id\": view_id,\n                \"queries\": queries,\n            }),\n        );\n    }\n\n    pub fn replace_status(&self, view_id: ViewId, replace: &Value) {\n        self.0.send_rpc_notification(\n            \"replace_status\",\n            &json!({\n                \"view_id\": view_id,\n                \"status\": replace,\n            }),\n        );\n    }\n\n    /// Ask front-end to measure widths of strings.\n    pub fn measure_width(&self, reqs: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error> {\n        let req_json = serde_json::to_value(reqs).expect(\"failed to serialize width req\");\n        let resp = self.0.send_rpc_request(\"measure_width\", &req_json)?;\n        Ok(serde_json::from_value(resp).expect(\"failed to deserialize width response\"))\n    }\n\n    pub fn alert<S: AsRef<str>>(&self, msg: S) {\n        self.0.send_rpc_notification(\"alert\", &json!({ \"msg\": msg.as_ref() }));\n    }\n\n    pub fn add_status_item(\n        &self,\n        view_id: ViewId,\n        source: &str,\n        key: &str,\n        value: &str,\n        alignment: &str,\n    ) {\n        self.0.send_rpc_notification(\n            \"add_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"source\": source,\n                \"key\": key,\n                \"value\": value,\n                \"alignment\": alignment\n            }),\n        );\n    }\n\n    pub fn update_status_item(&self, view_id: ViewId, key: &str, value: &str) {\n        self.0.send_rpc_notification(\n            \"update_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"key\": key,\n                \"value\": value,\n            }),\n        );\n    }\n\n    pub fn remove_status_item(&self, view_id: ViewId, key: &str) {\n        self.0.send_rpc_notification(\n            \"remove_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"key\": key,\n            }),\n        );\n    }\n\n    pub fn show_hover(&self, view_id: ViewId, request_id: usize, result: String) {\n        self.0.send_rpc_notification(\n            \"show_hover\",\n            &json!({\n                \"view_id\": view_id,\n                \"request_id\": request_id,\n                \"result\": result,\n            }),\n        )\n    }\n\n    pub fn schedule_idle(&self, token: usize) {\n        self.0.schedule_idle(token)\n    }\n\n    pub fn schedule_timer(&self, timeout: Instant, token: usize) {\n        self.0.schedule_timer(timeout, token);\n    }\n}","impl WidthMeasure for Client {\n    fn measure_width(&self, request: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error> {\n        Client::measure_width(self, request)\n    }\n}"],"client::OpType":["Clone","Debug","Serialize"],"client::Update":["Debug","Serialize"],"client::UpdateOp":["Debug","Serialize","impl UpdateOp {\n    pub(crate) fn invalidate(n: usize) -> Self {\n        UpdateOp { op: OpType::Invalidate, n, lines: None, first_line_number: None }\n    }\n\n    pub(crate) fn skip(n: usize) -> Self {\n        UpdateOp { op: OpType::Skip, n, lines: None, first_line_number: None }\n    }\n\n    pub(crate) fn copy(n: usize, line: usize) -> Self {\n        UpdateOp { op: OpType::Copy, n, lines: None, first_line_number: Some(line) }\n    }\n\n    pub(crate) fn insert(lines: Vec<Value>) -> Self {\n        UpdateOp { op: OpType::Insert, n: lines.len(), lines: Some(lines), first_line_number: None }\n    }\n\n    pub(crate) fn update(lines: Vec<Value>, line_opt: Option<usize>) -> Self {\n        UpdateOp {\n            op: OpType::Update,\n            n: lines.len(),\n            lines: Some(lines),\n            first_line_number: line_opt,\n        }\n    }\n}"],"config::BufferItems":["Clone","Debug","Deserialize","PartialEq","Serialize"],"config::Config":["Clone","Debug","Deserialize","Serialize","impl<'de, T: Deserialize<'de>> Config<T> {\n    /// Returns a `Table` of all the items in `self` which have different\n    /// values than in `other`.\n    pub fn changes_from(&self, other: Option<&Config<T>>) -> Option<Table> {\n        match other {\n            Some(other) => self.source.diff(&other.source),\n            None => self.source.collate().into(),\n        }\n    }\n}","impl<T: PartialEq> PartialEq for Config<T> {\n    fn eq(&self, other: &Config<T>) -> bool {\n        self.items == other.items\n    }\n}","impl<T> Config<T> {\n    pub fn to_table(&self) -> Table {\n        self.source.collate()\n    }\n}"],"config::ConfigDomain":["Clone","Debug","Deserialize","Eq","Hash","PartialEq","Serialize","impl ConfigDomain {\n    fn file_stem(&self) -> &str {\n        match self {\n            ConfigDomain::General => \"preferences\",\n            ConfigDomain::Language(lang) => lang.as_ref(),\n            ConfigDomain::UserOverride(_) | ConfigDomain::SysOverride(_) => \"we don't have files\",\n        }\n    }\n}","impl From<BufferId> for ConfigDomain {\n    fn from(src: BufferId) -> ConfigDomain {\n        ConfigDomain::UserOverride(src)\n    }\n}","impl From<LanguageId> for ConfigDomain {\n    fn from(src: LanguageId) -> ConfigDomain {\n        ConfigDomain::Language(src)\n    }\n}"],"config::ConfigDomainExternal":["Clone","Debug","Deserialize","Eq","Hash","PartialEq","Serialize"],"config::ConfigError":["Debug","impl Error for ConfigError {}","impl From<io::Error> for ConfigError {\n    fn from(src: io::Error) -> ConfigError {\n        ConfigError::Io(src)\n    }\n}","impl From<serde_json::Error> for ConfigError {\n    fn from(src: serde_json::Error) -> ConfigError {\n        ConfigError::UnexpectedItem(src)\n    }\n}","impl fmt::Display for ConfigError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::ConfigError::*;\n        match *self {\n            UnknownDomain(ref s) => write!(f, \"UnknownDomain: {}\", s),\n            Parse(ref p, ref e) => write!(f, \"Parse ({:?}), {}\", p, e),\n            Io(ref e) => write!(f, \"error loading config: {}\", e),\n            UnexpectedItem(ref e) => write!(f, \"{}\", e),\n        }\n    }\n}"],"config::ConfigManager":["Debug","impl ConfigManager {\n    pub fn new(config_dir: Option<PathBuf>, extras_dir: Option<PathBuf>) -> Self {\n        let base = load_base_config();\n        let mut defaults = HashMap::new();\n        defaults.insert(ConfigDomain::General, ConfigPair::with_base(base));\n        ConfigManager {\n            configs: defaults,\n            buffer_tags: HashMap::new(),\n            buffer_configs: HashMap::new(),\n            languages: Languages::default(),\n            config_dir,\n            extras_dir,\n        }\n    }\n\n    /// The path of the user's config file, if present.\n    pub(crate) fn base_config_file_path(&self) -> Option<PathBuf> {\n        let config_file = self.config_dir.as_ref().map(|p| p.join(\"preferences.xiconfig\"));\n        let exists = config_file.as_ref().map(|p| p.exists()).unwrap_or(false);\n        if exists {\n            config_file\n        } else {\n            None\n        }\n    }\n\n    pub(crate) fn get_plugin_paths(&self) -> Vec<PathBuf> {\n        let config_dir = self.config_dir.as_ref().map(|p| p.join(\"plugins\"));\n        [self.extras_dir.as_ref(), config_dir.as_ref()]\n            .iter()\n            .flat_map(|p| p.map(|p| p.to_owned()))\n            .filter(|p| p.exists())\n            .collect()\n    }\n\n    /// Adds a new buffer to the config manager, and returns the initial config\n    /// `Table` for that buffer. The `path` argument is used to determine\n    /// the buffer's default language.\n    ///\n    /// # Note: The caller is responsible for ensuring the config manager is\n    /// notified every time a buffer is added or removed.\n    ///\n    /// # Panics:\n    ///\n    /// Panics if `id` already exists.\n    pub(crate) fn add_buffer(&mut self, id: BufferId, path: Option<&Path>) -> Table {\n        let lang =\n            path.and_then(|p| self.language_for_path(p)).unwrap_or(LanguageId::from(\"Plain Text\"));\n        let lang_tag = LanguageTag::new(lang);\n        assert!(self.buffer_tags.insert(id, lang_tag).is_none());\n        self.update_buffer_config(id).expect(\"new buffer must always have config\")\n    }\n\n    /// Updates the default language for the given buffer.\n    ///\n    /// # Panics:\n    ///\n    /// Panics if `id` does not exist.\n    pub(crate) fn update_buffer_path(&mut self, id: BufferId, path: &Path) -> Option<Table> {\n        assert!(self.buffer_tags.contains_key(&id));\n        let lang = self.language_for_path(path).unwrap_or_default();\n        let has_changed = self.buffer_tags.get_mut(&id).map(|tag| tag.set_detected(lang)).unwrap();\n\n        if has_changed {\n            self.update_buffer_config(id)\n        } else {\n            None\n        }\n    }\n\n    /// Instructs the `ConfigManager` to stop tracking a given buffer.\n    ///\n    /// # Panics:\n    ///\n    /// Panics if `id` does not exist.\n    pub(crate) fn remove_buffer(&mut self, id: BufferId) {\n        self.buffer_tags.remove(&id).expect(\"remove key must exist\");\n        self.buffer_configs.remove(&id);\n        // TODO: remove any overrides\n    }\n\n    /// Sets a specific language for the given buffer. This is used if the\n    /// user selects a specific language in the frontend, for instance.\n    pub(crate) fn override_language(\n        &mut self,\n        id: BufferId,\n        new_lang: LanguageId,\n    ) -> Option<Table> {\n        let has_changed = self\n            .buffer_tags\n            .get_mut(&id)\n            .map(|tag| tag.set_user(Some(new_lang)))\n            .expect(\"buffer must exist\");\n        if has_changed {\n            self.update_buffer_config(id)\n        } else {\n            None\n        }\n    }\n\n    fn update_buffer_config(&mut self, id: BufferId) -> Option<Table> {\n        let new_config = self.generate_buffer_config(id);\n        let changes = new_config.changes_from(self.buffer_configs.get(&id));\n        self.buffer_configs.insert(id, new_config);\n        changes\n    }\n\n    fn update_all_buffer_configs(&mut self) -> Vec<(BufferId, Table)> {\n        self.buffer_configs\n            .keys()\n            .cloned()\n            .collect::<Vec<_>>()\n            .into_iter()\n            .flat_map(|k| self.update_buffer_config(k).map(|c| (k, c)))\n            .collect::<Vec<_>>()\n    }\n\n    fn generate_buffer_config(&mut self, id: BufferId) -> BufferConfig {\n        // it's possible for a buffer to be tagged with since-removed language\n        let lang = self\n            .buffer_tags\n            .get(&id)\n            .map(LanguageTag::resolve)\n            .and_then(|name| self.languages.language_for_name(name))\n            .map(|l| l.name.clone());\n        let mut configs = Vec::new();\n\n        configs.push(self.configs.get(&ConfigDomain::General));\n        if let Some(s) = lang {\n            configs.push(self.configs.get(&s.into()))\n        };\n        configs.push(self.configs.get(&ConfigDomain::SysOverride(id)));\n        configs.push(self.configs.get(&ConfigDomain::UserOverride(id)));\n\n        let configs = configs\n            .iter()\n            .flat_map(Option::iter)\n            .map(|c| c.cache.clone())\n            .rev()\n            .collect::<Vec<_>>();\n\n        let stack = TableStack(configs);\n        stack.into_config()\n    }\n\n    /// Returns a reference to the `BufferConfig` for this buffer.\n    ///\n    /// # Panics:\n    ///\n    /// Panics if `id` does not exist. The caller is responsible for ensuring\n    /// that the `ConfigManager` is kept up to date as buffers are added/removed.\n    pub(crate) fn get_buffer_config(&self, id: BufferId) -> &BufferConfig {\n        self.buffer_configs.get(&id).unwrap()\n    }\n\n    /// Returns the language associated with this buffer.\n    ///\n    /// # Panics:\n    ///\n    /// Panics if `id` does not exist.\n    pub(crate) fn get_buffer_language(&self, id: BufferId) -> LanguageId {\n        self.buffer_tags.get(&id).map(LanguageTag::resolve).unwrap()\n    }\n\n    /// Set the available `LanguageDefinition`s. Overrides any previous values.\n    pub fn set_languages(&mut self, languages: Languages) {\n        // remove base configs for any removed languages\n        self.languages.difference(&languages).iter().for_each(|lang| {\n            let domain: ConfigDomain = lang.name.clone().into();\n            if let Some(pair) = self.configs.get_mut(&domain) {\n                *pair = pair.new_with_base(None);\n            }\n        });\n\n        for language in languages.iter() {\n            let lang_id = language.name.clone();\n            let domain: ConfigDomain = lang_id.into();\n            let default_config = language.default_config.clone();\n            self.configs\n                .entry(domain.clone())\n                .and_modify(|c| *c = c.new_with_base(default_config.clone()))\n                .or_insert_with(|| ConfigPair::with_base(default_config));\n            if let Some(table) = self.load_user_config_file(&domain) {\n                // we can't report this error because we don't have a\n                // handle to the peer :|\n                let _ = self.set_user_config(domain, table);\n            }\n        }\n        //FIXME these changes are happening silently, which won't work once\n        //languages can by dynamically changed\n        self.languages = languages;\n        self.update_all_buffer_configs();\n    }\n\n    fn load_user_config_file(&self, domain: &ConfigDomain) -> Option<Table> {\n        let path = self\n            .config_dir\n            .as_ref()\n            .map(|p| p.join(domain.file_stem()).with_extension(\"xiconfig\"))?;\n\n        if !path.exists() {\n            return None;\n        }\n\n        match try_load_from_file(&path) {\n            Ok(t) => Some(t),\n            Err(e) => {\n                error!(\"Error loading config: {:?}\", e);\n                None\n            }\n        }\n    }\n\n    pub fn language_for_path(&self, path: &Path) -> Option<LanguageId> {\n        self.languages.language_for_path(path).map(|lang| lang.name.clone())\n    }\n\n    /// Sets the config for the given domain, removing any existing config.\n    /// Returns a `Vec` of individual buffer config changes that result from\n    /// this update, or a `ConfigError` if `config` is poorly formed.\n    pub fn set_user_config(\n        &mut self,\n        domain: ConfigDomain,\n        config: Table,\n    ) -> Result<Vec<(BufferId, Table)>, ConfigError> {\n        self.check_table(&config)?;\n        self.configs.entry(domain).or_insert_with(|| ConfigPair::with_base(None)).set_table(config);\n        Ok(self.update_all_buffer_configs())\n    }\n\n    /// Returns the `Table` produced by applying `changes` to the current user\n    /// config for the given `ConfigDomain`.\n    ///\n    /// # Note:\n    ///\n    /// When the user modifys a config _file_, the whole file is read,\n    /// and we can just overwrite any existing user config with the newly\n    /// loaded one.\n    ///\n    /// When the client modifies a config via the RPC mechanism, however,\n    /// this isn't the case. Instead of sending all config settings with\n    /// each update, the client just sends the keys/values they would like\n    /// to change. When they would like to remove a previously set key,\n    /// they send `Null` as the value for that key.\n    ///\n    /// This function creates a new table which is the product of updating\n    /// any existing table by applying the client's changes. This new table can\n    /// then be passed to `Self::set_user_config(..)`, as if it were loaded\n    /// from disk.\n    pub(crate) fn table_for_update(&mut self, domain: ConfigDomain, changes: Table) -> Table {\n        self.configs\n            .entry(domain)\n            .or_insert_with(|| ConfigPair::with_base(None))\n            .table_for_update(changes)\n    }\n\n    /// Returns the `ConfigDomain` relevant to a given file, if one exists.\n    pub fn domain_for_path(&self, path: &Path) -> Option<ConfigDomain> {\n        if path.extension().map(|e| e != \"xiconfig\").unwrap_or(true) {\n            return None;\n        }\n        match path.file_stem().and_then(|s| s.to_str()) {\n            Some(\"preferences\") => Some(ConfigDomain::General),\n            Some(name) if self.languages.language_for_name(&name).is_some() => {\n                let lang =\n                    self.languages.language_for_name(&name).map(|lang| lang.name.clone()).unwrap();\n                Some(ConfigDomain::Language(lang))\n            }\n            //TODO: plugin configs\n            _ => None,\n        }\n    }\n\n    fn check_table(&self, table: &Table) -> Result<(), ConfigError> {\n        let defaults = self\n            .configs\n            .get(&ConfigDomain::General)\n            .and_then(|pair| pair.base.clone())\n            .expect(\"general domain must have defaults\");\n        let mut defaults: Table = defaults.as_ref().clone();\n        for (k, v) in table.iter() {\n            // changes can include 'null', which means clear field\n            if v.is_null() {\n                continue;\n            }\n            defaults.insert(k.to_owned(), v.to_owned());\n        }\n        let _: BufferItems = serde_json::from_value(defaults.into())?;\n        Ok(())\n    }\n\n    /// Path to themes sub directory inside config directory.\n    /// Creates one if not present.\n    pub(crate) fn get_themes_dir(&self) -> Option<PathBuf> {\n        let themes_dir = self.config_dir.as_ref().map(|p| p.join(\"themes\"));\n\n        if let Some(p) = themes_dir {\n            if p.exists() {\n                return Some(p);\n            }\n            if fs::DirBuilder::new().create(&p).is_ok() {\n                return Some(p);\n            }\n        }\n        None\n    }\n\n    /// Path to plugins sub directory inside config directory.\n    /// Creates one if not present.\n    pub(crate) fn get_plugins_dir(&self) -> Option<PathBuf> {\n        let plugins_dir = self.config_dir.as_ref().map(|p| p.join(\"plugins\"));\n\n        if let Some(p) = plugins_dir {\n            if p.exists() {\n                return Some(p);\n            }\n            if fs::DirBuilder::new().create(&p).is_ok() {\n                return Some(p);\n            }\n        }\n        None\n    }\n}"],"config::ConfigPair":["Debug","impl ConfigPair {\n    /// Creates a new `ConfigPair` with the provided base config.\n    fn with_base<T: Into<Option<Table>>>(table: T) -> Self {\n        let base = table.into().map(Arc::new);\n        let cache = base.clone().unwrap_or_default();\n        ConfigPair { base, cache, user: None }\n    }\n\n    /// Returns a new `ConfigPair` with the provided base and the current\n    /// user config.\n    fn new_with_base<T: Into<Option<Table>>>(&self, table: T) -> Self {\n        let mut new_self = ConfigPair::with_base(table);\n        new_self.user = self.user.clone();\n        new_self.rebuild();\n        new_self\n    }\n\n    fn set_table(&mut self, user: Table) {\n        self.user = Some(Arc::new(user));\n        self.rebuild();\n    }\n\n    /// Returns the `Table` produced by updating `self.user` with the contents\n    /// of `user`, deleting null entries.\n    fn table_for_update(&self, user: Table) -> Table {\n        let mut new_user: Table =\n            self.user.as_ref().map(|arc| arc.as_ref().clone()).unwrap_or_default();\n        for (k, v) in user {\n            if v.is_null() {\n                new_user.remove(&k);\n            } else {\n                new_user.insert(k, v);\n            }\n        }\n        new_user\n    }\n\n    fn rebuild(&mut self) {\n        let mut cache = self.base.clone().unwrap_or_default();\n        if let Some(ref user) = self.user {\n            for (k, v) in user.iter() {\n                Arc::make_mut(&mut cache).insert(k.to_owned(), v.clone());\n            }\n        }\n        self.cache = cache;\n    }\n}"],"config::LanguageTag":["Clone","Debug","impl LanguageTag {\n    fn new(detected: LanguageId) -> Self {\n        LanguageTag { detected, user: None }\n    }\n\n    fn resolve(&self) -> LanguageId {\n        self.user.as_ref().unwrap_or(&self.detected).clone()\n    }\n\n    /// Set the detected language. Returns `true` if this changes the resolved\n    /// language.\n    fn set_detected(&mut self, detected: LanguageId) -> bool {\n        let before = self.resolve();\n        self.detected = detected;\n        before != self.resolve()\n    }\n\n    /// Set the user-specified language. Returns `true` if this changes\n    /// the resolved language.\n    #[allow(dead_code)]\n    fn set_user(&mut self, new_lang: Option<LanguageId>) -> bool {\n        let has_changed = self.user != new_lang;\n        self.user = new_lang;\n        has_changed\n    }\n}"],"config::TableStack":["Clone","Debug","Default","impl TableStack {\n    /// Create a single table representing the final config values.\n    fn collate(&self) -> Table {\n        // NOTE: This is fairly expensive; a future optimization would borrow\n        // from the underlying collections.\n        let mut out = Table::new();\n        for table in &self.0 {\n            for (k, v) in table.iter() {\n                if !out.contains_key(k) {\n                    // cloning these objects feels a bit gross, we could\n                    // improve this by implementing Deserialize for TableStack.\n                    out.insert(k.to_owned(), v.to_owned());\n                }\n            }\n        }\n        out\n    }\n\n    /// Converts the underlying tables into a static `Config` instance.\n    fn into_config<T>(self) -> Config<T>\n    where\n        for<'de> T: Deserialize<'de>,\n    {\n        let out = self.collate();\n        let items: T = serde_json::from_value(out.into()).unwrap();\n        let source = self;\n        Config { source, items }\n    }\n\n    /// Walks the tables in priority order, returning the first\n    /// occurance of `key`.\n    fn get<S: AsRef<str>>(&self, key: S) -> Option<&Value> {\n        for table in &self.0 {\n            if let Some(v) = table.get(key.as_ref()) {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    /// Returns a new `Table` containing only those keys and values in `self`\n    /// which have changed from `other`.\n    fn diff(&self, other: &TableStack) -> Option<Table> {\n        let mut out: Option<Table> = None;\n        let this = self.collate();\n        for (k, v) in this.iter() {\n            if other.get(k) != Some(v) {\n                let out: &mut Table = out.get_or_insert(Table::new());\n                out.insert(k.to_owned(), v.to_owned());\n            }\n        }\n        out\n    }\n}"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor":["Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor":["Deserialize"],"core::WeakXiCore":["Clone","impl Handler for WeakXiCore {\n    type Notification = PluginCommand<PluginNotification>;\n    type Request = PluginCommand<PluginRequest>;\n\n    fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification) {\n        let PluginCommand { view_id, plugin_id, cmd } = rpc;\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_notification(ctx, view_id, plugin_id, cmd)\n        }\n    }\n\n    fn handle_request(&mut self, ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError> {\n        let PluginCommand { view_id, plugin_id, cmd } = rpc;\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_request(ctx, view_id, plugin_id, cmd)\n        } else {\n            Err(RemoteError::custom(0, \"core is missing\", None))\n        }\n    }\n}","impl WeakXiCore {\n    /// Attempts to upgrade the weak reference. Essentially a wrapper\n    /// for `Arc::upgrade`.\n    fn upgrade(&self) -> Option<XiCore> {\n        self.0.upgrade().map(XiCore::Running)\n    }\n\n    /// Called immediately after attempting to start a plugin,\n    /// from the plugin's thread.\n    pub fn plugin_connect(&self, plugin: Result<Plugin, io::Error>) {\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_connect(plugin)\n        }\n    }\n\n    /// Called from a plugin runloop thread when the runloop exits.\n    pub fn plugin_exit(&self, plugin: PluginId, error: Result<(), ReadError>) {\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_exit(plugin, error)\n        }\n    }\n\n    /// Handles the result of an update sent to a plugin.\n    ///\n    /// All plugins must acknowledge when they are sent a new update, so that\n    /// core can track which revisions are still 'live', that is can still\n    /// be the base revision for a delta. Once a plugin has acknowledged a new\n    /// revision, it can no longer send deltas against any older revision.\n    pub fn handle_plugin_update(\n        &self,\n        plugin: PluginId,\n        view: ViewId,\n        response: Result<Value, RpcError>,\n    ) {\n        if let Some(core) = self.upgrade() {\n            let _t = xi_trace::trace_block(\"WeakXiCore::plugin_update\", &[\"core\"]);\n            core.inner().plugin_update(plugin, view, response);\n        }\n    }\n}"],"core::XiCore":["impl Handler for XiCore {\n    type Notification = CoreNotification;\n    type Request = CoreRequest;\n\n    fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification) {\n        use self::CoreNotification::*;\n\n        // We allow tracing to be enabled before event `client_started`\n        if let TracingConfig { enabled } = rpc {\n            match enabled {\n                true => xi_trace::enable_tracing(),\n                false => xi_trace::disable_tracing(),\n            }\n            info!(\"tracing in core = {:?}\", enabled);\n            if self.is_waiting() {\n                return;\n            }\n        }\n\n        // wait for client_started before setting up inner\n        if let ClientStarted { ref config_dir, ref client_extras_dir } = rpc {\n            assert!(self.is_waiting(), \"client_started can only be sent once\");\n            let state =\n                CoreState::new(ctx.get_peer(), config_dir.clone(), client_extras_dir.clone());\n            let state = Arc::new(Mutex::new(state));\n            *self = XiCore::Running(state);\n            let weak_self = self.weak_self().unwrap();\n            self.inner().finish_setup(weak_self);\n        }\n\n        self.inner().client_notification(rpc);\n    }\n\n    fn handle_request(&mut self, _ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError> {\n        self.inner().client_request(rpc)\n    }\n\n    fn idle(&mut self, _ctx: &RpcCtx, token: usize) {\n        self.inner().handle_idle(token);\n    }\n}","impl XiCore {\n    pub fn new() -> Self {\n        XiCore::Waiting\n    }\n\n    /// Returns `true` if the `client_started` has not been received.\n    fn is_waiting(&self) -> bool {\n        matches!(*self, XiCore::Waiting)\n    }\n\n    /// Returns a guard to the core state. A convenience around `Mutex::lock`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if core has not yet received the `client_started` message.\n    pub fn inner(&self) -> MutexGuard<CoreState> {\n        match self {\n            XiCore::Running(ref inner) => inner.lock().unwrap(),\n            XiCore::Waiting => panic!(\n                \"core does not start until client_started \\\n                 RPC is received\"\n            ),\n        }\n    }\n\n    /// Returns a new reference to the core state, if core is running.\n    fn weak_self(&self) -> Option<WeakXiCore> {\n        match self {\n            XiCore::Running(ref inner) => Some(WeakXiCore(Arc::downgrade(inner))),\n            XiCore::Waiting => None,\n        }\n    }\n}"],"edit_ops::IndentDirection":["Clone","Copy","Debug"],"edit_types::BufferEvent":["Clone","Debug","PartialEq"],"edit_types::EventDomain":["Clone","Debug","PartialEq","impl From<BufferEvent> for EventDomain {\n    fn from(src: BufferEvent) -> EventDomain {\n        EventDomain::Buffer(src)\n    }\n}","impl From<EditNotification> for EventDomain {\n    fn from(src: EditNotification) -> EventDomain {\n        use self::EditNotification::*;\n        match src {\n            Insert { chars } =>\n                BufferEvent::Insert(chars).into(),\n            Paste { chars } =>\n                BufferEvent::Paste(chars).into(),\n            DeleteForward =>\n                BufferEvent::Delete {\n                    movement: Movement::Right,\n                    kill: false\n                }.into(),\n            DeleteBackward =>\n                BufferEvent::Backspace.into(),\n            DeleteWordForward =>\n                BufferEvent::Delete {\n                    movement: Movement::RightWord,\n                    kill: false\n                }.into(),\n            DeleteWordBackward =>\n                BufferEvent::Delete {\n                    movement: Movement::LeftWord,\n                    kill: false\n                }.into(),\n            DeleteToEndOfParagraph =>\n                BufferEvent::Delete {\n                    movement: Movement::EndOfParagraphKill,\n                    kill: true\n                }.into(),\n            DeleteToBeginningOfLine =>\n                BufferEvent::Delete {\n                    movement: Movement::LeftOfLine,\n                    kill: false\n                }.into(),\n            InsertNewline =>\n                BufferEvent::InsertNewline.into(),\n            InsertTab =>\n                BufferEvent::InsertTab.into(),\n            MoveUp =>\n                ViewEvent::Move(Movement::Up).into(),\n            MoveUpAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Up).into(),\n            MoveDown =>\n                ViewEvent::Move(Movement::Down).into(),\n            MoveDownAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Down).into(),\n            MoveLeft | MoveBackward =>\n                ViewEvent::Move(Movement::Left).into(),\n            MoveLeftAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Left).into(),\n            MoveRight | MoveForward  =>\n                ViewEvent::Move(Movement::Right).into(),\n            MoveRightAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Right).into(),\n            MoveWordLeft =>\n                ViewEvent::Move(Movement::LeftWord).into(),\n            MoveWordLeftAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::LeftWord).into(),\n            MoveWordRight =>\n                ViewEvent::Move(Movement::RightWord).into(),\n            MoveWordRightAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::RightWord).into(),\n            MoveToBeginningOfParagraph =>\n                ViewEvent::Move(Movement::StartOfParagraph).into(),\n            MoveToBeginningOfParagraphAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::StartOfParagraph).into(),\n            MoveToEndOfParagraph =>\n                ViewEvent::Move(Movement::EndOfParagraph).into(),\n            MoveToEndOfParagraphAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::EndOfParagraph).into(),\n            MoveToLeftEndOfLine =>\n                ViewEvent::Move(Movement::LeftOfLine).into(),\n            MoveToLeftEndOfLineAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::LeftOfLine).into(),\n            MoveToRightEndOfLine =>\n                ViewEvent::Move(Movement::RightOfLine).into(),\n            MoveToRightEndOfLineAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::RightOfLine).into(),\n            MoveToBeginningOfDocument =>\n                ViewEvent::Move(Movement::StartOfDocument).into(),\n            MoveToBeginningOfDocumentAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::StartOfDocument).into(),\n            MoveToEndOfDocument =>\n                ViewEvent::Move(Movement::EndOfDocument).into(),\n            MoveToEndOfDocumentAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::EndOfDocument).into(),\n            ScrollPageUp =>\n                ViewEvent::Move(Movement::UpPage).into(),\n            PageUpAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::UpPage).into(),\n            ScrollPageDown =>\n                ViewEvent::Move(Movement::DownPage).into(),\n            PageDownAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::DownPage).into(),\n            SelectAll => ViewEvent::SelectAll.into(),\n            AddSelectionAbove => ViewEvent::AddSelectionAbove.into(),\n            AddSelectionBelow => ViewEvent::AddSelectionBelow.into(),\n            Scroll(range) => ViewEvent::Scroll(range).into(),\n            Resize(size) => SpecialEvent::Resize(size).into(),\n            GotoLine { line } => ViewEvent::GotoLine { line }.into(),\n            RequestLines(range) => SpecialEvent::RequestLines(range).into(),\n            Yank => BufferEvent::Yank.into(),\n            Transpose => BufferEvent::Transpose.into(),\n            Click(action) => ViewEvent::Click(action).into(),\n            Drag(action) => ViewEvent::Drag(action).into(),\n            Gesture { line, col,  ty } => {\n                // Translate deprecated gesture types into the new format\n                let new_ty = match ty {\n                    GestureType::PointSelect => {\n                        warn!(\"The point_select gesture is deprecated; use select instead\");\n                        GestureType::Select {granularity: SelectionGranularity::Point, multi: false}\n                    }\n                    GestureType::ToggleSel => {\n                        warn!(\"The toggle_sel gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Point, multi: true}\n                    }\n                    GestureType::WordSelect => {\n                        warn!(\"The word_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Word, multi: false}\n                    }\n                    GestureType::MultiWordSelect => {\n                        warn!(\"The multi_word_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Word, multi: true}\n                    }\n                    GestureType::LineSelect => {\n                        warn!(\"The line_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Line, multi: false}\n                    }\n                    GestureType::MultiLineSelect => {\n                        warn!(\"The multi_line_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Line, multi: true}\n                    }\n                    GestureType::RangeSelect => {\n                        warn!(\"The range_select gesture is deprecated; use select_extend instead\");\n                        GestureType::SelectExtend { granularity: SelectionGranularity::Point }\n                    }\n                    _ => ty\n                };\n                ViewEvent::Gesture { line, col, ty: new_ty }.into()\n            },\n            Undo => BufferEvent::Undo.into(),\n            Redo => BufferEvent::Redo.into(),\n            Find { chars, case_sensitive, regex, whole_words } =>\n                ViewEvent::Find { chars, case_sensitive, regex, whole_words }.into(),\n            MultiFind { queries } =>\n                ViewEvent::MultiFind { queries }.into(),\n            FindNext { wrap_around, allow_same, modify_selection } =>\n                ViewEvent::FindNext { wrap_around, allow_same, modify_selection }.into(),\n            FindPrevious { wrap_around, allow_same, modify_selection } =>\n                ViewEvent::FindPrevious { wrap_around, allow_same, modify_selection }.into(),\n            FindAll => ViewEvent::FindAll.into(),\n            DebugRewrap => SpecialEvent::DebugRewrap.into(),\n            DebugWrapWidth => SpecialEvent::DebugWrapWidth.into(),\n            DebugPrintSpans => SpecialEvent::DebugPrintSpans.into(),\n            Uppercase => BufferEvent::Uppercase.into(),\n            Lowercase => BufferEvent::Lowercase.into(),\n            Capitalize => BufferEvent::Capitalize.into(),\n            Indent => BufferEvent::Indent.into(),\n            Outdent => BufferEvent::Outdent.into(),\n            Reindent => SpecialEvent::Reindent.into(),\n            DebugToggleComment => SpecialEvent::DebugToggleComment.into(),\n            HighlightFind { visible } => ViewEvent::HighlightFind { visible }.into(),\n            SelectionForFind { case_sensitive } =>\n                ViewEvent::SelectionForFind { case_sensitive }.into(),\n            Replace { chars, preserve_case } =>\n                ViewEvent::Replace { chars, preserve_case }.into(),\n            ReplaceNext => BufferEvent::ReplaceNext.into(),\n            ReplaceAll => BufferEvent::ReplaceAll.into(),\n            SelectionForReplace => ViewEvent::SelectionForReplace.into(),\n            RequestHover { request_id, position } =>\n                SpecialEvent::RequestHover { request_id, position }.into(),\n            SelectionIntoLines => ViewEvent::SelectionIntoLines.into(),\n            DuplicateLine => BufferEvent::DuplicateLine.into(),\n            IncreaseNumber => BufferEvent::IncreaseNumber.into(),\n            DecreaseNumber => BufferEvent::DecreaseNumber.into(),\n            ToggleRecording { recording_name } => SpecialEvent::ToggleRecording(recording_name).into(),\n            PlayRecording { recording_name } => SpecialEvent::PlayRecording(recording_name).into(),\n            ClearRecording { recording_name } => SpecialEvent::ClearRecording(recording_name).into(),\n            CollapseSelections => ViewEvent::CollapseSelections.into(),\n        }\n    }\n}","impl From<SpecialEvent> for EventDomain {\n    fn from(src: SpecialEvent) -> EventDomain {\n        EventDomain::Special(src)\n    }\n}","impl From<ViewEvent> for EventDomain {\n    fn from(src: ViewEvent) -> EventDomain {\n        EventDomain::View(src)\n    }\n}"],"edit_types::SpecialEvent":["Clone","Debug","PartialEq"],"edit_types::ViewEvent":["Clone","Debug","PartialEq"],"editor::EditType":["Clone","Copy","Debug","Deserialize","Eq","PartialEq","Serialize","impl EditType {\n    /// Checks whether a new undo group should be created between two edits.\n    fn breaks_undo_group(self, previous: EditType) -> bool {\n        self == EditType::Other || self == EditType::Transpose || self != previous\n    }\n}"],"editor::Editor":["impl Editor {\n    /// Creates a new `Editor` with a new empty buffer.\n    pub fn new() -> Editor {\n        Self::with_text(\"\")\n    }\n\n    /// Creates a new `Editor`, loading text into a new buffer.\n    pub fn with_text<T: Into<Rope>>(text: T) -> Editor {\n        let engine = Engine::new(text.into());\n        let buffer = engine.get_head().clone();\n        let last_rev_id = engine.get_head_rev_id();\n\n        Editor {\n            text: buffer,\n            engine,\n            last_rev_id,\n            pristine_rev_id: last_rev_id,\n            undo_group_id: 1,\n            // GC only works on undone edits or prefixes of the visible edits,\n            // but initial file loading can create an edit with undo group 0,\n            // so we want to collect that as part of the prefix.\n            live_undos: vec![0],\n            cur_undo: 1,\n            undos: BTreeSet::new(),\n            gc_undos: BTreeSet::new(),\n            force_undo_group: false,\n            last_edit_type: EditType::Other,\n            this_edit_type: EditType::Other,\n            layers: Layers::default(),\n            revs_in_flight: 0,\n            sync_store: None,\n            last_synced_rev: last_rev_id,\n        }\n    }\n\n    pub(crate) fn get_buffer(&self) -> &Rope {\n        &self.text\n    }\n\n    pub(crate) fn get_layers(&self) -> &Layers {\n        &self.layers\n    }\n\n    pub(crate) fn get_layers_mut(&mut self) -> &mut Layers {\n        &mut self.layers\n    }\n\n    pub(crate) fn get_head_rev_token(&self) -> u64 {\n        self.engine.get_head_rev_id().token()\n    }\n\n    pub(crate) fn get_edit_type(&self) -> EditType {\n        self.this_edit_type\n    }\n\n    pub(crate) fn get_active_undo_group(&self) -> usize {\n        *self.live_undos.last().unwrap_or(&0)\n    }\n\n    pub(crate) fn update_edit_type(&mut self) {\n        self.last_edit_type = self.this_edit_type;\n        self.this_edit_type = EditType::Other\n    }\n\n    pub(crate) fn set_pristine(&mut self) {\n        self.pristine_rev_id = self.engine.get_head_rev_id();\n    }\n\n    pub(crate) fn is_pristine(&self) -> bool {\n        self.engine.is_equivalent_revision(self.pristine_rev_id, self.engine.get_head_rev_id())\n    }\n\n    /// Set whether or not edits are forced into the same undo group rather than being split by\n    /// their EditType.\n    ///\n    /// This is used for things such as recording playback, where you don't want the\n    /// individual events to be undoable, but instead the entire playback should be.\n    pub(crate) fn set_force_undo_group(&mut self, force_undo_group: bool) {\n        trace_payload(\"Editor::set_force_undo_group\", &[\"core\"], force_undo_group.to_string());\n        self.force_undo_group = force_undo_group;\n    }\n\n    /// Sets this Editor's contents to `text`, preserving undo state and cursor\n    /// position when possible.\n    pub fn reload(&mut self, text: Rope) {\n        let delta = LineHashDiff::compute_delta(self.get_buffer(), &text);\n        self.add_delta(delta);\n        self.set_pristine();\n    }\n\n    // each outstanding plugin edit represents a rev_in_flight.\n    pub fn increment_revs_in_flight(&mut self) {\n        self.revs_in_flight += 1;\n    }\n\n    // GC of CRDT engine is deferred until all plugins have acknowledged the new rev,\n    // so when the ack comes back, potentially trigger GC.\n    pub fn dec_revs_in_flight(&mut self) {\n        self.revs_in_flight -= 1;\n        self.gc_undos();\n    }\n\n    /// Applies a delta to the text, and updates undo state.\n    ///\n    /// Records the delta into the CRDT engine so that it can be undone. Also\n    /// contains the logic for merging edits into the same undo group. At call\n    /// time, self.this_edit_type should be set appropriately.\n    ///\n    /// This method can be called multiple times, accumulating deltas that will\n    /// be committed at once with `commit_delta`. Note that it does not update\n    /// the views. Thus, view-associated state such as the selection and line\n    /// breaks are to be considered invalid after this method, until the\n    /// `commit_delta` call.\n    fn add_delta(&mut self, delta: RopeDelta) {\n        let head_rev_id = self.engine.get_head_rev_id();\n        let undo_group = self.calculate_undo_group();\n        self.last_edit_type = self.this_edit_type;\n        let priority = 0x10000;\n        self.engine.edit_rev(priority, undo_group, head_rev_id.token(), delta);\n        self.text = self.engine.get_head().clone();\n    }\n\n    pub(crate) fn calculate_undo_group(&mut self) -> usize {\n        let has_undos = !self.live_undos.is_empty();\n        let force_undo_group = self.force_undo_group;\n        let is_unbroken_group = !self.this_edit_type.breaks_undo_group(self.last_edit_type);\n\n        if has_undos && (force_undo_group || is_unbroken_group) {\n            *self.live_undos.last().unwrap()\n        } else {\n            let undo_group = self.undo_group_id;\n            self.gc_undos.extend(&self.live_undos[self.cur_undo..]);\n            self.live_undos.truncate(self.cur_undo);\n            self.live_undos.push(undo_group);\n            if self.live_undos.len() <= MAX_UNDOS {\n                self.cur_undo += 1;\n            } else {\n                self.gc_undos.insert(self.live_undos.remove(0));\n            }\n            self.undo_group_id += 1;\n            undo_group\n        }\n    }\n\n    /// generates a delta from a plugin's response and applies it to the buffer.\n    pub fn apply_plugin_edit(&mut self, edit: PluginEdit) {\n        let _t = trace_block(\"Editor::apply_plugin_edit\", &[\"core\"]);\n        //TODO: get priority working, so that plugin edits don't necessarily move cursor\n        let PluginEdit { rev, delta, priority, undo_group, .. } = edit;\n        let priority = priority as usize;\n        let undo_group = undo_group.unwrap_or_else(|| self.calculate_undo_group());\n        match self.engine.try_edit_rev(priority, undo_group, rev, delta) {\n            Err(e) => error!(\"Error applying plugin edit: {}\", e),\n            Ok(_) => self.text = self.engine.get_head().clone(),\n        };\n    }\n\n    /// Commits the current delta. If the buffer has changed, returns\n    /// a 3-tuple containing the delta representing the changes, the previous\n    /// buffer, and an `InsertDrift` enum describing the correct selection update\n    /// behaviour.\n    pub(crate) fn commit_delta(&mut self) -> Option<(RopeDelta, Rope, InsertDrift)> {\n        let _t = trace_block(\"Editor::commit_delta\", &[\"core\"]);\n\n        if self.engine.get_head_rev_id() == self.last_rev_id {\n            return None;\n        }\n\n        let last_token = self.last_rev_id.token();\n        let delta = self.engine.try_delta_rev_head(last_token).expect(\"last_rev not found\");\n        // TODO (performance): it's probably quicker to stash last_text\n        // rather than resynthesize it.\n        let last_text = self.engine.get_rev(last_token).expect(\"last_rev not found\");\n\n        // Transpose can rotate characters inside of a selection; this is why it's an Inside edit.\n        // Surround adds characters on either side of a selection, that's why it's an Outside edit.\n        let drift = match self.this_edit_type {\n            EditType::Transpose => InsertDrift::Inside,\n            EditType::Surround => InsertDrift::Outside,\n            _ => InsertDrift::Default,\n        };\n        self.layers.update_all(&delta);\n\n        self.last_rev_id = self.engine.get_head_rev_id();\n        self.sync_state_changed();\n        Some((delta, last_text, drift))\n    }\n\n    /// Attempts to find the delta from head for the given `RevToken`. Returns\n    /// `None` if the revision is not found, so this result should be checked if\n    /// the revision is coming from a plugin.\n    pub(crate) fn delta_rev_head(&self, target_rev_id: RevToken) -> Option<RopeDelta> {\n        self.engine.try_delta_rev_head(target_rev_id).ok()\n    }\n\n    #[cfg(not(target_os = \"fuchsia\"))]\n    fn gc_undos(&mut self) {\n        if self.revs_in_flight == 0 && !self.gc_undos.is_empty() {\n            self.engine.gc(&self.gc_undos);\n            self.undos = &self.undos - &self.gc_undos;\n            self.gc_undos.clear();\n        }\n    }\n\n    #[cfg(target_os = \"fuchsia\")]\n    fn gc_undos(&mut self) {\n        // Never run GC on Fuchsia so that peers don't invalidate our\n        // last_rev_id and so that merge will work.\n    }\n\n    pub fn merge_new_state(&mut self, new_engine: Engine) {\n        self.engine.merge(&new_engine);\n        self.text = self.engine.get_head().clone();\n        // TODO: better undo semantics. This only implements separate undo\n        // histories for low concurrency.\n        self.undo_group_id = self.engine.max_undo_group_id() + 1;\n        self.last_synced_rev = self.engine.get_head_rev_id();\n        self.commit_delta();\n        //self.render();\n        //FIXME: render after fuchsia sync\n    }\n\n    /// See `Engine::set_session_id`. Only useful for Fuchsia sync.\n    pub fn set_session_id(&mut self, session: (u64, u32)) {\n        self.engine.set_session_id(session);\n    }\n\n    #[cfg(feature = \"ledger\")]\n    pub fn set_sync_store(&mut self, sync_store: SyncStore) {\n        self.sync_store = Some(sync_store);\n    }\n\n    #[cfg(not(feature = \"ledger\"))]\n    pub fn sync_state_changed(&mut self) {}\n\n    #[cfg(feature = \"ledger\")]\n    pub fn sync_state_changed(&mut self) {\n        if let Some(sync_store) = self.sync_store.as_mut() {\n            // we don't want to sync right after recieving a new merge\n            if self.last_synced_rev != self.engine.get_head_rev_id() {\n                self.last_synced_rev = self.engine.get_head_rev_id();\n                sync_store.state_changed();\n            }\n        }\n    }\n\n    #[cfg(feature = \"ledger\")]\n    pub fn transaction_ready(&mut self) {\n        if let Some(sync_store) = self.sync_store.as_mut() {\n            sync_store.commit_transaction(&self.engine);\n        }\n    }\n\n    fn do_insert(&mut self, view: &View, config: &BufferItems, chars: &str) {\n        let pair_search = config.surrounding_pairs.iter().find(|pair| pair.0 == chars);\n        let caret_exists = view.sel_regions().iter().any(|region| region.is_caret());\n        if let (Some(pair), false) = (pair_search, caret_exists) {\n            self.this_edit_type = EditType::Surround;\n            self.add_delta(edit_ops::surround(\n                &self.text,\n                view.sel_regions(),\n                pair.0.to_string(),\n                pair.1.to_string(),\n            ));\n        } else {\n            self.this_edit_type = EditType::InsertChars;\n            self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars));\n        }\n    }\n\n    fn do_paste(&mut self, view: &View, chars: &str) {\n        if view.sel_regions().len() == 1 || view.sel_regions().len() != count_lines(chars) {\n            self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars));\n        } else {\n            let mut builder = DeltaBuilder::new(self.text.len());\n            for (sel, line) in view.sel_regions().iter().zip(chars.lines()) {\n                let iv = Interval::new(sel.min(), sel.max());\n                builder.replace(iv, line.into());\n            }\n            self.add_delta(builder.build());\n        }\n    }\n\n    pub(crate) fn do_cut(&mut self, view: &mut View) -> Value {\n        let result = self.do_copy(view);\n        let delta = edit_ops::delete_sel_regions(&self.text, &view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n        result\n    }\n\n    pub(crate) fn do_copy(&self, view: &View) -> Value {\n        if let Some(val) = edit_ops::extract_sel_regions(&self.text, view.sel_regions()) {\n            Value::String(val.into_owned())\n        } else {\n            Value::Null\n        }\n    }\n\n    fn do_undo(&mut self) {\n        if self.cur_undo > 1 {\n            self.cur_undo -= 1;\n            assert!(self.undos.insert(self.live_undos[self.cur_undo]));\n            self.this_edit_type = EditType::Undo;\n            self.update_undos();\n        }\n    }\n\n    fn do_redo(&mut self) {\n        if self.cur_undo < self.live_undos.len() {\n            assert!(self.undos.remove(&self.live_undos[self.cur_undo]));\n            self.cur_undo += 1;\n            self.this_edit_type = EditType::Redo;\n            self.update_undos();\n        }\n    }\n\n    fn update_undos(&mut self) {\n        self.engine.undo(self.undos.clone());\n        self.text = self.engine.get_head().clone();\n    }\n\n    fn do_replace(&mut self, view: &mut View, replace_all: bool) {\n        if let Some(Replace { chars, .. }) = view.get_replace() {\n            // todo: implement preserve case\n            // store old selection because in case nothing is found the selection will be preserved\n            let mut old_selection = Selection::new();\n            for &region in view.sel_regions() {\n                old_selection.add_region(region);\n            }\n            view.collapse_selections(&self.text);\n\n            if replace_all {\n                view.do_find_all(&self.text);\n            } else {\n                view.do_find_next(&self.text, false, true, true, &SelectionModifier::Set);\n            }\n\n            match last_selection_region(view.sel_regions()) {\n                Some(_) => self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars)),\n                None => return,\n            };\n        }\n    }\n\n    fn do_delete_by_movement(\n        &mut self,\n        view: &View,\n        movement: Movement,\n        save: bool,\n        kill_ring: &mut Rope,\n    ) {\n        let (delta, rope) = edit_ops::delete_by_movement(\n            &self.text,\n            view.sel_regions(),\n            view.get_lines(),\n            movement,\n            view.scroll_height(),\n            save,\n        );\n        if let Some(rope) = rope {\n            *kill_ring = rope;\n        }\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n    }\n\n    fn do_delete_backward(&mut self, view: &View, config: &BufferItems) {\n        let delta = edit_ops::delete_backward(&self.text, view.sel_regions(), config);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n    }\n\n    fn do_transpose(&mut self, view: &View) {\n        let delta = edit_ops::transpose(&self.text, view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Transpose;\n            self.add_delta(delta);\n        }\n    }\n\n    fn do_transform_text<F: Fn(&str) -> String>(&mut self, view: &View, transform_function: F) {\n        let delta = edit_ops::transform_text(&self.text, view.sel_regions(), transform_function);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n    }\n\n    fn do_capitalize_text(&mut self, view: &mut View) {\n        let (delta, final_selection) = edit_ops::capitalize_text(&self.text, view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n\n        // at the end of the transformation carets are located at the end of the words that were\n        // transformed last in the selections\n        view.collapse_selections(&self.text);\n        view.set_selection(&self.text, final_selection);\n    }\n\n    fn do_modify_indent(&mut self, view: &View, config: &BufferItems, direction: IndentDirection) {\n        let delta = edit_ops::modify_indent(&self.text, view.sel_regions(), config, direction);\n        self.add_delta(delta);\n        self.this_edit_type = match direction {\n            IndentDirection::In => EditType::InsertChars,\n            IndentDirection::Out => EditType::Delete,\n        }\n    }\n\n    fn do_insert_newline(&mut self, view: &View, config: &BufferItems) {\n        let delta = edit_ops::insert_newline(&self.text, view.sel_regions(), config);\n        self.add_delta(delta);\n        self.this_edit_type = EditType::InsertNewline;\n    }\n\n    fn do_insert_tab(&mut self, view: &View, config: &BufferItems) {\n        let regions = view.sel_regions();\n        let delta = edit_ops::insert_tab(&self.text, regions, config);\n\n        // if we indent multiple regions or multiple lines,\n        // we treat this as an indentation adjustment; otherwise it is\n        // just inserting text.\n        let condition = regions\n            .first()\n            .map(|x| LogicalLines.get_line_range(&self.text, x).len() > 1)\n            .unwrap_or(false);\n\n        self.add_delta(delta);\n        self.this_edit_type =\n            if regions.len() > 1 || condition { EditType::Indent } else { EditType::InsertChars };\n    }\n\n    fn do_yank(&mut self, view: &View, kill_ring: &Rope) {\n        // TODO: if there are multiple cursors and the number of newlines\n        // is one less than the number of cursors, split and distribute one\n        // line per cursor.\n        let delta = edit_ops::insert(&self.text, view.sel_regions(), kill_ring.clone());\n        self.add_delta(delta);\n    }\n\n    fn do_duplicate_line(&mut self, view: &View, config: &BufferItems) {\n        let delta = edit_ops::duplicate_line(&self.text, view.sel_regions(), config);\n        self.add_delta(delta);\n        self.this_edit_type = EditType::Other;\n    }\n\n    fn do_change_number<F: Fn(i128) -> Option<i128>>(\n        &mut self,\n        view: &View,\n        transform_function: F,\n    ) {\n        let delta = edit_ops::change_number(&self.text, view.sel_regions(), transform_function);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n    }\n\n    pub(crate) fn do_edit(\n        &mut self,\n        view: &mut View,\n        kill_ring: &mut Rope,\n        config: &BufferItems,\n        cmd: BufferEvent,\n    ) {\n        use self::BufferEvent::*;\n        match cmd {\n            Delete { movement, kill } => {\n                self.do_delete_by_movement(view, movement, kill, kill_ring)\n            }\n            Backspace => self.do_delete_backward(view, config),\n            Transpose => self.do_transpose(view),\n            Undo => self.do_undo(),\n            Redo => self.do_redo(),\n            Uppercase => self.do_transform_text(view, |s| s.to_uppercase()),\n            Lowercase => self.do_transform_text(view, |s| s.to_lowercase()),\n            Capitalize => self.do_capitalize_text(view),\n            Indent => self.do_modify_indent(view, config, IndentDirection::In),\n            Outdent => self.do_modify_indent(view, config, IndentDirection::Out),\n            InsertNewline => self.do_insert_newline(view, config),\n            InsertTab => self.do_insert_tab(view, config),\n            Insert(chars) => self.do_insert(view, config, &chars),\n            Paste(chars) => self.do_paste(view, &chars),\n            Yank => self.do_yank(view, kill_ring),\n            ReplaceNext => self.do_replace(view, false),\n            ReplaceAll => self.do_replace(view, true),\n            DuplicateLine => self.do_duplicate_line(view, config),\n            IncreaseNumber => self.do_change_number(view, |s| s.checked_add(1)),\n            DecreaseNumber => self.do_change_number(view, |s| s.checked_sub(1)),\n        }\n    }\n\n    pub fn theme_changed(&mut self, style_map: &ThemeStyleMap) {\n        self.layers.theme_changed(style_map);\n    }\n\n    pub fn plugin_n_lines(&self) -> usize {\n        self.text.measure::<LinesMetric>() + 1\n    }\n\n    pub fn update_spans(\n        &mut self,\n        view: &mut View,\n        plugin: PluginId,\n        start: usize,\n        len: usize,\n        spans: Vec<ScopeSpan>,\n        rev: RevToken,\n    ) {\n        let _t = trace_block(\"Editor::update_spans\", &[\"core\"]);\n        // TODO: more protection against invalid input\n        let mut start = start;\n        let mut end_offset = start + len;\n        let mut sb = SpansBuilder::new(len);\n        for span in spans {\n            sb.add_span(Interval::new(span.start, span.end), span.scope_id);\n        }\n        let mut spans = sb.build();\n        if rev != self.engine.get_head_rev_id().token() {\n            if let Ok(delta) = self.engine.try_delta_rev_head(rev) {\n                let mut transformer = Transformer::new(&delta);\n                let new_start = transformer.transform(start, false);\n                if !transformer.interval_untouched(Interval::new(start, end_offset)) {\n                    spans = spans.transform(start, end_offset, &mut transformer);\n                }\n                start = new_start;\n                end_offset = transformer.transform(end_offset, true);\n            } else {\n                error!(\"Revision {} not found\", rev);\n            }\n        }\n        let iv = Interval::new(start, end_offset);\n        self.layers.update_layer(plugin, iv, spans);\n        view.invalidate_styles(&self.text, start, end_offset);\n    }\n\n    pub fn update_annotations(\n        &mut self,\n        view: &mut View,\n        plugin: PluginId,\n        start: usize,\n        len: usize,\n        annotation_spans: Vec<DataSpan>,\n        annotation_type: AnnotationType,\n        rev: RevToken,\n    ) {\n        let _t = trace_block(\"Editor::update_annotations\", &[\"core\"]);\n\n        let mut start = start;\n        let mut end_offset = start + len;\n        let mut sb = SpansBuilder::new(len);\n        for span in annotation_spans {\n            sb.add_span(Interval::new(span.start, span.end), span.data);\n        }\n        let mut spans = sb.build();\n        if rev != self.engine.get_head_rev_id().token() {\n            if let Ok(delta) = self.engine.try_delta_rev_head(rev) {\n                let mut transformer = Transformer::new(&delta);\n                let new_start = transformer.transform(start, false);\n                if !transformer.interval_untouched(Interval::new(start, end_offset)) {\n                    spans = spans.transform(start, end_offset, &mut transformer);\n                }\n                start = new_start;\n                end_offset = transformer.transform(end_offset, true);\n            } else {\n                error!(\"Revision {} not found\", rev);\n            }\n        }\n        let iv = Interval::new(start, end_offset);\n        view.update_annotations(plugin, iv, Annotations { items: spans, annotation_type });\n    }\n\n    pub(crate) fn get_rev(&self, rev: RevToken) -> Option<Cow<Rope>> {\n        let text_cow = if rev == self.engine.get_head_rev_id().token() {\n            Cow::Borrowed(&self.text)\n        } else {\n            match self.engine.get_rev(rev) {\n                None => return None,\n                Some(text) => Cow::Owned(text),\n            }\n        };\n\n        Some(text_cow)\n    }\n\n    pub fn plugin_get_data(\n        &self,\n        start: usize,\n        unit: TextUnit,\n        max_size: usize,\n        rev: RevToken,\n    ) -> Option<GetDataResponse> {\n        let _t = trace_block(\"Editor::plugin_get_data\", &[\"core\"]);\n        let text_cow = self.get_rev(rev)?;\n        let text = &text_cow;\n        // convert our offset into a valid byte offset\n        let offset = unit.resolve_offset(text.borrow(), start)?;\n\n        let max_size = min(max_size, MAX_SIZE_LIMIT);\n        let mut end_off = offset.saturating_add(max_size);\n        if end_off >= text.len() {\n            end_off = text.len();\n        } else {\n            // Snap end to codepoint boundary.\n            end_off = text.prev_codepoint_offset(end_off + 1).unwrap();\n        }\n\n        let chunk = text.slice_to_cow(offset..end_off).into_owned();\n        let first_line = text.line_of_offset(offset);\n        let first_line_offset = offset - text.offset_of_line(first_line);\n\n        Some(GetDataResponse { chunk, offset, first_line, first_line_offset })\n    }\n}"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":["Deserialize"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor":["Deserialize"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor":["Deserialize"],"event_context::EventContext":["impl<'a> EventContext<'a> {\n    /// Executes a closure with mutable references to the editor and the view,\n    /// common in edit actions that modify the text.\n    pub(crate) fn with_editor<R, F>(&mut self, f: F) -> R\n    where\n        F: FnOnce(&mut Editor, &mut View, &mut Rope, &BufferItems) -> R,\n    {\n        let mut editor = self.editor.borrow_mut();\n        let mut view = self.view.borrow_mut();\n        let mut kill_ring = self.kill_ring.borrow_mut();\n        f(&mut editor, &mut view, &mut kill_ring, &self.config)\n    }\n\n    /// Executes a closure with a mutable reference to the view and a reference\n    /// to the current text. This is common to most edits that just modify\n    /// selection or viewport state.\n    fn with_view<R, F>(&mut self, f: F) -> R\n    where\n        F: FnOnce(&mut View, &Rope) -> R,\n    {\n        let editor = self.editor.borrow();\n        let mut view = self.view.borrow_mut();\n        f(&mut view, editor.get_buffer())\n    }\n\n    fn with_each_plugin<F: FnMut(&&Plugin)>(&self, f: F) {\n        self.plugins.iter().for_each(f)\n    }\n\n    pub(crate) fn do_edit(&mut self, cmd: EditNotification) {\n        let event: EventDomain = cmd.into();\n\n        {\n            // Handle recording-- clone every non-toggle and play event into the recording buffer\n            let mut recorder = self.recorder.borrow_mut();\n            match (recorder.is_recording(), &event) {\n                (_, EventDomain::Special(SpecialEvent::ToggleRecording(recording_name))) => {\n                    recorder.toggle_recording(recording_name.clone());\n                }\n                // Don't save special events\n                (true, EventDomain::Special(_)) => {\n                    warn!(\"Special events cannot be recorded-- ignoring event {:?}\", event)\n                }\n                (true, event) => recorder.record(event.clone()),\n                _ => {}\n            }\n        }\n\n        self.dispatch_event(event);\n        self.after_edit(\"core\");\n        self.render_if_needed();\n    }\n\n    fn dispatch_event(&mut self, event: EventDomain) {\n        use self::EventDomain as E;\n        match event {\n            E::View(cmd) => {\n                self.with_view(|view, text| view.do_edit(text, cmd));\n                self.editor.borrow_mut().update_edit_type();\n                if self.with_view(|v, t| v.needs_wrap_in_visible_region(t)) {\n                    self.rewrap();\n                }\n                if self.with_view(|v, _| v.find_in_progress()) {\n                    self.do_incremental_find();\n                }\n            }\n            E::Buffer(cmd) => {\n                self.with_editor(|ed, view, k_ring, conf| ed.do_edit(view, k_ring, conf, cmd))\n            }\n            E::Special(cmd) => self.do_special(cmd),\n        }\n    }\n\n    fn do_special(&mut self, cmd: SpecialEvent) {\n        match cmd {\n            SpecialEvent::Resize(size) => {\n                self.with_view(|view, _| view.set_size(size));\n                if self.config.word_wrap {\n                    self.update_wrap_settings(false);\n                }\n            }\n            SpecialEvent::DebugRewrap | SpecialEvent::DebugWrapWidth => {\n                warn!(\"debug wrapping methods are removed, use the config system\")\n            }\n            SpecialEvent::DebugPrintSpans => self.with_editor(|ed, view, _, _| {\n                let sel = view.sel_regions().last().unwrap();\n                let iv = Interval::new(sel.min(), sel.max());\n                ed.get_layers().debug_print_spans(iv);\n            }),\n            SpecialEvent::RequestLines(LineRange { first, last }) => {\n                self.do_request_lines(first as usize, last as usize)\n            }\n            SpecialEvent::RequestHover { request_id, position } => {\n                self.do_request_hover(request_id, position)\n            }\n            SpecialEvent::DebugToggleComment => self.do_debug_toggle_comment(),\n            SpecialEvent::Reindent => self.do_reindent(),\n            SpecialEvent::ToggleRecording(_) => {}\n            SpecialEvent::PlayRecording(recording_name) => {\n                let recorder = self.recorder.borrow();\n\n                let starting_revision = self.editor.borrow_mut().get_head_rev_token();\n\n                // Don't group with the previous action\n                self.editor.borrow_mut().update_edit_type();\n                self.editor.borrow_mut().calculate_undo_group();\n\n                // No matter what, our entire block must belong to the same undo group\n                self.editor.borrow_mut().set_force_undo_group(true);\n                recorder.play(&recording_name, |event| {\n                    self.dispatch_event(event.clone());\n\n                    let mut editor = self.editor.borrow_mut();\n                    let (delta, last_text, drift) = match editor.commit_delta() {\n                        Some(edit_info) => edit_info,\n                        None => return,\n                    };\n                    self.update_views(&editor, &delta, &last_text, drift);\n                });\n                self.editor.borrow_mut().set_force_undo_group(false);\n\n                // The action that follows the block must belong to a separate undo group\n                self.editor.borrow_mut().update_edit_type();\n\n                let delta = self.editor.borrow_mut().delta_rev_head(starting_revision).unwrap();\n                self.update_plugins(&mut self.editor.borrow_mut(), delta, \"core\");\n            }\n            SpecialEvent::ClearRecording(recording_name) => {\n                let mut recorder = self.recorder.borrow_mut();\n                recorder.clear(&recording_name);\n            }\n        }\n    }\n\n    pub(crate) fn do_edit_sync(&mut self, cmd: EditRequest) -> Result<Value, RemoteError> {\n        use self::EditRequest::*;\n        let result = match cmd {\n            Cut => Ok(self.with_editor(|ed, view, _, _| ed.do_cut(view))),\n            Copy => Ok(self.with_editor(|ed, view, _, _| ed.do_copy(view))),\n        };\n        self.after_edit(\"core\");\n        self.render_if_needed();\n        result\n    }\n\n    pub(crate) fn do_plugin_cmd(&mut self, plugin: PluginId, cmd: PluginNotification) {\n        use self::PluginNotification::*;\n        match cmd {\n            AddScopes { scopes } => {\n                let mut ed = self.editor.borrow_mut();\n                let style_map = self.style_map.borrow();\n                ed.get_layers_mut().add_scopes(plugin, scopes, &style_map);\n            }\n            UpdateSpans { start, len, spans, rev } => self.with_editor(|ed, view, _, _| {\n                ed.update_spans(view, plugin, start, len, spans, rev)\n            }),\n            Edit { edit } => self.with_editor(|ed, _, _, _| ed.apply_plugin_edit(edit)),\n            Alert { msg } => self.client.alert(&msg),\n            AddStatusItem { key, value, alignment } => {\n                let plugin_name = &self.plugins.iter().find(|p| p.id == plugin).unwrap().name;\n                self.client.add_status_item(self.view_id, plugin_name, &key, &value, &alignment);\n            }\n            UpdateStatusItem { key, value } => {\n                self.client.update_status_item(self.view_id, &key, &value)\n            }\n            UpdateAnnotations { start, len, spans, annotation_type, rev } => {\n                self.with_editor(|ed, view, _, _| {\n                    ed.update_annotations(view, plugin, start, len, spans, annotation_type, rev)\n                })\n            }\n            RemoveStatusItem { key } => self.client.remove_status_item(self.view_id, &key),\n            ShowHover { request_id, result } => self.do_show_hover(request_id, result),\n        };\n        self.after_edit(&plugin.to_string());\n        self.render_if_needed();\n    }\n\n    pub(crate) fn do_plugin_cmd_sync(&mut self, _plugin: PluginId, cmd: PluginRequest) -> Value {\n        use self::PluginRequest::*;\n        match cmd {\n            LineCount => json!(self.editor.borrow().plugin_n_lines()),\n            GetData { start, unit, max_size, rev } => {\n                json!(self.editor.borrow().plugin_get_data(start, unit, max_size, rev))\n            }\n            GetSelections => json!(\"not implemented\"),\n        }\n    }\n\n    /// Commits any changes to the buffer, updating views and plugins as needed.\n    /// This only updates internal state; it does not update the client.\n    fn after_edit(&mut self, author: &str) {\n        let _t = trace_block(\"EventContext::after_edit\", &[\"core\"]);\n\n        let edit_info = self.editor.borrow_mut().commit_delta();\n        let (delta, last_text, drift) = match edit_info {\n            Some(edit_info) => edit_info,\n            None => return,\n        };\n\n        self.update_views(&self.editor.borrow(), &delta, &last_text, drift);\n        self.update_plugins(&mut self.editor.borrow_mut(), delta, author);\n\n        //if we have no plugins we always render immediately.\n        if !self.plugins.is_empty() {\n            let mut view = self.view.borrow_mut();\n            if !view.has_pending_render() {\n                let timeout = Instant::now() + RENDER_DELAY;\n                let view_id: usize = self.view_id.into();\n                let token = RENDER_VIEW_IDLE_MASK | view_id;\n                self.client.schedule_timer(timeout, token);\n                view.set_has_pending_render(true);\n            }\n        }\n    }\n\n    fn update_views(&self, ed: &Editor, delta: &RopeDelta, last_text: &Rope, drift: InsertDrift) {\n        let mut width_cache = self.width_cache.borrow_mut();\n        let iter_views = iter::once(&self.view).chain(self.siblings.iter());\n        iter_views.for_each(|view| {\n            view.borrow_mut().after_edit(\n                ed.get_buffer(),\n                last_text,\n                delta,\n                self.client,\n                &mut width_cache,\n                drift,\n            )\n        });\n    }\n\n    fn update_plugins(&self, ed: &mut Editor, delta: RopeDelta, author: &str) {\n        let new_len = delta.new_document_len();\n        let nb_lines = ed.get_buffer().measure::<LinesMetric>() + 1;\n        // don't send the actual delta if it is too large, by some heuristic\n        let approx_size = delta.inserts_len() + (delta.els.len() * 10);\n        let delta = if approx_size > MAX_SIZE_LIMIT { None } else { Some(delta) };\n\n        let undo_group = ed.get_active_undo_group();\n        //TODO: we want to just put EditType on the wire, but don't want\n        //to update the plugin lib quite yet.\n        let v: Value = serde_json::to_value(&ed.get_edit_type()).unwrap();\n        let edit_type_str = v.as_str().unwrap().to_string();\n\n        let update = PluginUpdate::new(\n            self.view_id,\n            ed.get_head_rev_token(),\n            delta,\n            new_len,\n            nb_lines,\n            Some(undo_group),\n            edit_type_str,\n            author.into(),\n        );\n\n        // we always increment and decrement regardless of whether we're\n        // sending plugins, to ensure that GC runs.\n        ed.increment_revs_in_flight();\n\n        self.plugins.iter().for_each(|plugin| {\n            ed.increment_revs_in_flight();\n            let weak_core = self.weak_core.clone();\n            let id = plugin.id;\n            let view_id = self.view_id;\n            plugin.update(&update, move |resp| {\n                weak_core.handle_plugin_update(id, view_id, resp);\n            });\n        });\n        ed.dec_revs_in_flight();\n        ed.update_edit_type();\n    }\n\n    /// Renders the view, if a render has not already been scheduled.\n    pub(crate) fn render_if_needed(&mut self) {\n        let needed = !self.view.borrow().has_pending_render();\n        if needed {\n            self.render()\n        }\n    }\n\n    pub(crate) fn _finish_delayed_render(&mut self) {\n        self.render();\n        self.view.borrow_mut().set_has_pending_render(false);\n    }\n\n    /// Flushes any changes in the views out to the frontend.\n    fn render(&mut self) {\n        let _t = trace_block(\"EventContext::render\", &[\"core\"]);\n        let ed = self.editor.borrow();\n        //TODO: render other views\n        self.view.borrow_mut().render_if_dirty(\n            ed.get_buffer(),\n            self.client,\n            self.style_map,\n            ed.get_layers().get_merged(),\n            ed.is_pristine(),\n        )\n    }\n}","impl<'a> EventContext<'a> {\n    pub(crate) fn view_init(&mut self) {\n        let wrap_width = self.config.wrap_width;\n        let word_wrap = self.config.word_wrap;\n\n        self.with_view(|view, text| view.update_wrap_settings(text, wrap_width, word_wrap));\n    }\n\n    pub(crate) fn finish_init(&mut self, config: &Table) {\n        if !self.plugins.is_empty() {\n            let info = self.plugin_info();\n\n            self.plugins.iter().for_each(|plugin| {\n                plugin.new_buffer(&info);\n                self.plugin_started(plugin);\n            });\n        }\n\n        let available_plugins = self\n            .plugins\n            .iter()\n            .map(|plugin| ClientPluginInfo { name: plugin.name.clone(), running: true })\n            .collect::<Vec<_>>();\n        self.client.available_plugins(self.view_id, &available_plugins);\n\n        self.client.config_changed(self.view_id, config);\n        self.client.language_changed(self.view_id, &self.language);\n\n        // Rewrap and request a render.\n        // This is largely similar to update_wrap_settings(), the only difference\n        // being that the view is expected to be already initialized.\n        self.rewrap();\n\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n\n        self.with_view(|view, text| view.set_dirty(text));\n        self.render()\n    }\n\n    pub(crate) fn after_save(&mut self, path: &Path) {\n        // notify plugins\n        self.plugins.iter().for_each(|plugin| plugin.did_save(self.view_id, path));\n\n        self.editor.borrow_mut().set_pristine();\n        self.with_view(|view, text| view.set_dirty(text));\n        self.render()\n    }\n\n    /// Returns `true` if this was the last view\n    pub(crate) fn close_view(&self) -> bool {\n        // we probably want to notify plugins _before_ we close the view\n        // TODO: determine what plugins we're stopping\n        self.plugins.iter().for_each(|plug| plug.close_view(self.view_id));\n        self.siblings.is_empty()\n    }\n\n    pub(crate) fn config_changed(&mut self, changes: &Table) {\n        if changes.contains_key(\"wrap_width\") || changes.contains_key(\"word_wrap\") {\n            // FIXME: if switching from measurement-based widths to columnar widths,\n            // we need to reset the cache, since we're using different coordinate spaces\n            // for the same IDs. The long-term solution would be to include font\n            // information in the width cache, and then use real width even in the column\n            // case, getting the unit width for a typeface and multiplying that by\n            // a string's unicode width.\n            if changes.contains_key(\"word_wrap\") {\n                debug!(\"clearing {} items from width cache\", self.width_cache.borrow().len());\n                self.width_cache.replace(WidthCache::new());\n            }\n            self.update_wrap_settings(true);\n        }\n\n        self.client.config_changed(self.view_id, &changes);\n        self.plugins.iter().for_each(|plug| plug.config_changed(self.view_id, &changes));\n        self.render()\n    }\n\n    pub(crate) fn language_changed(&mut self, new_language_id: &LanguageId) {\n        self.language = new_language_id.clone();\n        self.client.language_changed(self.view_id, new_language_id);\n        self.plugins.iter().for_each(|plug| plug.language_changed(self.view_id, new_language_id));\n    }\n\n    pub(crate) fn reload(&mut self, text: Rope) {\n        self.with_editor(|ed, _, _, _| ed.reload(text));\n        self.after_edit(\"core\");\n        self.render();\n    }\n\n    pub(crate) fn plugin_info(&mut self) -> PluginBufferInfo {\n        let ed = self.editor.borrow();\n        let nb_lines = ed.get_buffer().measure::<LinesMetric>() + 1;\n        let views: Vec<ViewId> = iter::once(&self.view)\n            .chain(self.siblings.iter())\n            .map(|v| v.borrow().get_view_id())\n            .collect();\n\n        let changes = serde_json::to_value(self.config).unwrap();\n        let path = self.info.map(|info| info.path.to_owned());\n        PluginBufferInfo::new(\n            self.buffer_id,\n            &views,\n            ed.get_head_rev_token(),\n            ed.get_buffer().len(),\n            nb_lines,\n            path,\n            self.language.clone(),\n            changes.as_object().unwrap().to_owned(),\n        )\n    }\n\n    pub(crate) fn plugin_started(&self, plugin: &Plugin) {\n        self.client.plugin_started(self.view_id, &plugin.name)\n    }\n\n    pub(crate) fn plugin_stopped(&mut self, plugin: &Plugin) {\n        self.client.plugin_stopped(self.view_id, &plugin.name, 0);\n        let needs_render = self.with_editor(|ed, view, _, _| {\n            if ed.get_layers_mut().remove_layer(plugin.id).is_some() {\n                view.set_dirty(ed.get_buffer());\n                true\n            } else {\n                false\n            }\n        });\n        if needs_render {\n            self.render();\n        }\n    }\n\n    pub(crate) fn do_plugin_update(&mut self, update: Result<Value, RpcError>) {\n        match update.map(serde_json::from_value::<u64>) {\n            Ok(Ok(_)) => (),\n            Ok(Err(err)) => error!(\"plugin response json err: {:?}\", err),\n            Err(err) => error!(\"plugin shutdown, do something {:?}\", err),\n        }\n        self.editor.borrow_mut().dec_revs_in_flight();\n    }\n\n    /// Returns the text to be saved, appending a newline if necessary.\n    pub(crate) fn text_for_save(&mut self) -> Rope {\n        let editor = self.editor.borrow();\n        let mut rope = editor.get_buffer().clone();\n        let rope_len = rope.len();\n\n        if rope_len < 1 || !self.config.save_with_newline {\n            return rope;\n        }\n\n        let cursor = Cursor::new(&rope, rope.len());\n        let has_newline_at_eof = match cursor.get_leaf() {\n            Some((last_chunk, _)) => last_chunk.ends_with(&self.config.line_ending),\n            // The rope can't be empty, since we would have returned earlier if it was\n            None => unreachable!(),\n        };\n\n        if !has_newline_at_eof {\n            let line_ending = &self.config.line_ending;\n            rope.edit(rope_len.., line_ending);\n            rope\n        } else {\n            rope\n        }\n    }\n\n    /// Called after anything changes that effects word wrap, such as the size of\n    /// the window or the user's wrap settings. `rewrap_immediately` should be `true`\n    /// except in the resize case; during live resize we want to delay recalculation\n    /// to avoid unnecessary work.\n    fn update_wrap_settings(&mut self, rewrap_immediately: bool) {\n        let wrap_width = self.config.wrap_width;\n        let word_wrap = self.config.word_wrap;\n        self.with_view(|view, text| view.update_wrap_settings(text, wrap_width, word_wrap));\n        if rewrap_immediately {\n            self.rewrap();\n            self.with_view(|view, text| view.set_dirty(text));\n        }\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n    }\n\n    /// Tells the view to rewrap a batch of lines, if needed. This guarantees that\n    /// the currently visible region will be correctly wrapped; the caller should\n    /// check if additional wrapping is necessary and schedule that if so.\n    fn rewrap(&mut self) {\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        let mut width_cache = self.width_cache.borrow_mut();\n        view.rewrap(ed.get_buffer(), &mut width_cache, self.client, ed.get_layers().get_merged());\n    }\n\n    /// Does incremental find.\n    pub(crate) fn do_incremental_find(&mut self) {\n        let _t = trace_block(\"EventContext::do_incremental_find\", &[\"find\"]);\n\n        self.find();\n        if self.view.borrow().find_in_progress() {\n            let ed = self.editor.borrow();\n            self.client.find_status(\n                self.view_id,\n                &json!(self.view.borrow().find_status(ed.get_buffer(), true)),\n            );\n            self.schedule_find();\n        }\n        self.render_if_needed();\n    }\n\n    fn schedule_find(&self) {\n        let view_id: usize = self.view_id.into();\n        let token = FIND_VIEW_IDLE_MASK | view_id;\n        self.client.schedule_idle(token);\n    }\n\n    /// Tells the view to execute find on a batch of lines, if needed.\n    fn find(&mut self) {\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        view.do_find(ed.get_buffer());\n    }\n\n    /// Does a rewrap batch, and schedules follow-up work if needed.\n    pub(crate) fn do_rewrap_batch(&mut self) {\n        self.rewrap();\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n        self.render_if_needed();\n    }\n\n    fn schedule_rewrap(&self) {\n        let view_id: usize = self.view_id.into();\n        let token = REWRAP_VIEW_IDLE_MASK | view_id;\n        self.client.schedule_idle(token);\n    }\n\n    fn do_request_lines(&mut self, first: usize, last: usize) {\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        view.request_lines(\n            ed.get_buffer(),\n            self.client,\n            self.style_map,\n            ed.get_layers().get_merged(),\n            first,\n            last,\n            ed.is_pristine(),\n        )\n    }\n\n    fn selected_line_ranges(&mut self) -> Vec<(usize, usize)> {\n        let ed = self.editor.borrow();\n        let mut prev_range: Option<Range<usize>> = None;\n        let mut line_ranges = Vec::new();\n        // we send selection state to syntect in the form of a vec of line ranges,\n        // so we combine overlapping selections to get the minimum set of ranges.\n        for region in self.view.borrow().sel_regions().iter() {\n            let start = ed.get_buffer().line_of_offset(region.min());\n            let end = ed.get_buffer().line_of_offset(region.max()) + 1;\n            let line_range = start..end;\n            let prev = prev_range.take();\n            match (prev, line_range) {\n                (None, range) => prev_range = Some(range),\n                (Some(ref prev), ref range) if range.start <= prev.end => {\n                    let combined =\n                        Range { start: prev.start.min(range.start), end: prev.end.max(range.end) };\n                    prev_range = Some(combined);\n                }\n                (Some(prev), range) => {\n                    line_ranges.push((prev.start, prev.end));\n                    prev_range = Some(range);\n                }\n            }\n        }\n\n        if let Some(prev) = prev_range {\n            line_ranges.push((prev.start, prev.end));\n        }\n\n        line_ranges\n    }\n\n    fn do_reindent(&mut self) {\n        let line_ranges = self.selected_line_ranges();\n        // this is handled by syntect only; this is definitely not the long-term solution.\n        if let Some(plug) = self.plugins.iter().find(|p| p.name == \"xi-syntect-plugin\") {\n            plug.dispatch_command(self.view_id, \"reindent\", &json!(line_ranges));\n        }\n    }\n\n    fn do_debug_toggle_comment(&mut self) {\n        let line_ranges = self.selected_line_ranges();\n\n        // this is handled by syntect only; this is definitely not the long-term solution.\n        if let Some(plug) = self.plugins.iter().find(|p| p.name == \"xi-syntect-plugin\") {\n            plug.dispatch_command(self.view_id, \"toggle_comment\", &json!(line_ranges));\n        }\n    }\n\n    fn do_request_hover(&mut self, request_id: usize, position: Option<ClientPosition>) {\n        if let Some(position) = self.get_resolved_position(position) {\n            self.with_each_plugin(|p| p.get_hover(self.view_id, request_id, position))\n        }\n    }\n\n    fn do_show_hover(&mut self, request_id: usize, hover: Result<Hover, RemoteError>) {\n        match hover {\n            Ok(hover) => {\n                // TODO: Get Range from hover here and use it to highlight text\n                self.client.show_hover(self.view_id, request_id, hover.content)\n            }\n            Err(err) => warn!(\"Hover Response from Client Error {:?}\", err),\n        }\n    }\n\n    /// Gives the requested position in UTF-8 offset format to be sent to plugin\n    /// If position is `None`, it tries to get the current Caret Position and use\n    /// that instead\n    fn get_resolved_position(&mut self, position: Option<ClientPosition>) -> Option<usize> {\n        position\n            .map(|p| self.with_view(|view, text| view.line_col_to_offset(text, p.line, p.column)))\n            .or_else(|| self.view.borrow().get_caret_offset())\n    }\n}"],"file::CharacterEncoding":["Clone","Copy","Debug","impl CharacterEncoding {\n    fn guess(s: &[u8]) -> Self {\n        if s.starts_with(UTF8_BOM.as_bytes()) {\n            CharacterEncoding::Utf8WithBom\n        } else {\n            CharacterEncoding::Utf8\n        }\n    }\n}"],"file::FileError":["impl FileError {\n    fn error_code(&self) -> i64 {\n        match self {\n            FileError::Io(_, _) => 5,\n            FileError::UnknownEncoding(_) => 6,\n            FileError::HasChanged(_) => 7,\n        }\n    }\n}","impl fmt::Display for FileError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            FileError::Io(ref e, ref p) => write!(f, \"{}. File path: {:?}\", e, p),\n            FileError::UnknownEncoding(ref p) => write!(f, \"Error decoding file: {:?}\", p),\n            FileError::HasChanged(ref p) => write!(\n                f,\n                \"File has changed on disk. \\\n                 Please save elsewhere and reload the file. File path: {:?}\",\n                p\n            ),\n        }\n    }\n}"],"file::FileInfo":["Debug"],"file::FileManager":["impl FileManager {\n    #[cfg(feature = \"notify\")]\n    pub fn new(watcher: FileWatcher) -> Self {\n        FileManager { open_files: HashMap::new(), file_info: HashMap::new(), watcher }\n    }\n\n    #[cfg(not(feature = \"notify\"))]\n    pub fn new() -> Self {\n        FileManager { open_files: HashMap::new(), file_info: HashMap::new() }\n    }\n\n    #[cfg(feature = \"notify\")]\n    pub fn watcher(&mut self) -> &mut FileWatcher {\n        &mut self.watcher\n    }\n\n    pub fn get_info(&self, id: BufferId) -> Option<&FileInfo> {\n        self.file_info.get(&id)\n    }\n\n    pub fn get_editor(&self, path: &Path) -> Option<BufferId> {\n        self.open_files.get(path).cloned()\n    }\n\n    /// Returns `true` if this file is open and has changed on disk.\n    /// This state is stashed.\n    pub fn check_file(&mut self, path: &Path, id: BufferId) -> bool {\n        if let Some(info) = self.file_info.get_mut(&id) {\n            let mod_t = get_mod_time(path);\n            if mod_t != info.mod_time {\n                info.has_changed = true\n            }\n            return info.has_changed;\n        }\n        false\n    }\n\n    pub fn open(&mut self, path: &Path, id: BufferId) -> Result<Rope, FileError> {\n        if !path.exists() {\n            return Ok(Rope::from(\"\"));\n        }\n\n        let (rope, info) = try_load_file(path)?;\n\n        self.open_files.insert(path.to_owned(), id);\n        if self.file_info.insert(id, info).is_none() {\n            #[cfg(feature = \"notify\")]\n            self.watcher.watch(path, false, OPEN_FILE_EVENT_TOKEN);\n        }\n        Ok(rope)\n    }\n\n    pub fn close(&mut self, id: BufferId) {\n        if let Some(info) = self.file_info.remove(&id) {\n            self.open_files.remove(&info.path);\n            #[cfg(feature = \"notify\")]\n            self.watcher.unwatch(&info.path, OPEN_FILE_EVENT_TOKEN);\n        }\n    }\n\n    pub fn save(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError> {\n        let is_existing = self.file_info.contains_key(&id);\n        if is_existing {\n            self.save_existing(path, text, id)\n        } else {\n            self.save_new(path, text, id)\n        }\n    }\n\n    fn save_new(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError> {\n        try_save(path, text, CharacterEncoding::Utf8, self.get_info(id))\n            .map_err(|e| FileError::Io(e, path.to_owned()))?;\n        let info = FileInfo {\n            encoding: CharacterEncoding::Utf8,\n            path: path.to_owned(),\n            mod_time: get_mod_time(path),\n            has_changed: false,\n            #[cfg(target_family = \"unix\")]\n            permissions: get_permissions(path),\n        };\n        self.open_files.insert(path.to_owned(), id);\n        self.file_info.insert(id, info);\n        #[cfg(feature = \"notify\")]\n        self.watcher.watch(path, false, OPEN_FILE_EVENT_TOKEN);\n        Ok(())\n    }\n\n    fn save_existing(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError> {\n        let prev_path = self.file_info[&id].path.clone();\n        if prev_path != path {\n            self.save_new(path, text, id)?;\n            self.open_files.remove(&prev_path);\n            #[cfg(feature = \"notify\")]\n            self.watcher.unwatch(&prev_path, OPEN_FILE_EVENT_TOKEN);\n        } else if self.file_info[&id].has_changed {\n            return Err(FileError::HasChanged(path.to_owned()));\n        } else {\n            let encoding = self.file_info[&id].encoding;\n            try_save(path, text, encoding, self.get_info(id))\n                .map_err(|e| FileError::Io(e, path.to_owned()))?;\n            self.file_info.get_mut(&id).unwrap().mod_time = get_mod_time(path);\n        }\n        Ok(())\n    }\n}"],"find::Find":["impl Find {\n    pub fn new(id: usize) -> Find {\n        Find {\n            id,\n            hls_dirty: true,\n            search_string: None,\n            case_matching: CaseMatching::CaseInsensitive,\n            regex: None,\n            whole_words: false,\n            occurrences: Selection::new(),\n        }\n    }\n\n    pub fn id(&self) -> usize {\n        self.id\n    }\n\n    pub fn occurrences(&self) -> &Selection {\n        &self.occurrences\n    }\n\n    pub fn hls_dirty(&self) -> bool {\n        self.hls_dirty\n    }\n\n    pub fn find_status(&self, view: &View, text: &Rope, matches_only: bool) -> FindStatus {\n        if matches_only {\n            FindStatus {\n                id: self.id,\n                chars: None,\n                case_sensitive: None,\n                is_regex: None,\n                whole_words: None,\n                matches: self.occurrences.len(),\n                lines: Vec::new(),\n            }\n        } else {\n            FindStatus {\n                id: self.id,\n                chars: self.search_string.clone(),\n                case_sensitive: Some(self.case_matching == CaseMatching::Exact),\n                is_regex: Some(self.regex.is_some()),\n                whole_words: Some(self.whole_words),\n                matches: self.occurrences.len(),\n                lines: self\n                    .occurrences\n                    .iter()\n                    .map(|o| view.offset_to_line_col(text, o.min()).0 + 1)\n                    .collect(),\n            }\n        }\n    }\n\n    pub fn set_hls_dirty(&mut self, is_dirty: bool) {\n        self.hls_dirty = is_dirty\n    }\n\n    pub fn update_highlights(&mut self, text: &Rope, delta: &RopeDelta) {\n        // update search highlights for changed regions\n        if self.search_string.is_some() {\n            // invalidate occurrences around deletion positions\n            for DeltaRegion { old_offset, len, .. } in delta.iter_deletions() {\n                self.occurrences.delete_range(old_offset, old_offset + len, false);\n            }\n\n            self.occurrences = self.occurrences.apply_delta(delta, false, InsertDrift::Default);\n\n            // invalidate occurrences around insert positions\n            for DeltaRegion { new_offset, len, .. } in delta.iter_inserts() {\n                // also invalidate previous occurrence since it might expand after insertion\n                // eg. for regex .* every insertion after match will be part of match\n                self.occurrences.delete_range(\n                    new_offset.saturating_sub(1),\n                    new_offset + len,\n                    false,\n                );\n            }\n\n            // update find for the whole delta and everything after\n            let (iv, new_len) = delta.summary();\n\n            // get last valid occurrence that was unaffected by the delta\n            let start = match self.occurrences.regions_in_range(0, iv.start()).last() {\n                Some(reg) => reg.end,\n                None => 0,\n            };\n\n            // invalidate all search results from the point of the last valid search result until ...\n            let is_multiline = LinesMetric::next(self.search_string.as_ref().unwrap(), 0).is_some();\n\n            if is_multiline || self.is_multiline_regex() {\n                // ... the end of the file\n                self.occurrences.delete_range(iv.start(), text.len(), false);\n                self.update_find(text, start, text.len(), false);\n            } else {\n                // ... the end of the line including line break\n                let mut cursor = Cursor::new(&text, iv.end() + new_len);\n\n                let end_of_line = match cursor.next::<LinesMetric>() {\n                    Some(end) => end,\n                    None if cursor.pos() == text.len() => cursor.pos(),\n                    _ => return,\n                };\n\n                self.occurrences.delete_range(iv.start(), end_of_line, false);\n                self.update_find(text, start, end_of_line, false);\n            }\n        }\n    }\n\n    /// Returns `true` if the search query is a multi-line regex.\n    pub(crate) fn is_multiline_regex(&self) -> bool {\n        self.regex.is_some() && is_multiline_regex(self.search_string.as_ref().unwrap())\n    }\n\n    /// Unsets the search and removes all highlights from the view.\n    pub fn unset(&mut self) {\n        self.search_string = None;\n        self.occurrences = Selection::new();\n        self.hls_dirty = true;\n    }\n\n    /// Sets find parameters and search query. Returns `true` if parameters have been updated.\n    /// Returns `false` to indicate that parameters haven't change.\n    pub(crate) fn set_find(\n        &mut self,\n        search_string: &str,\n        case_sensitive: bool,\n        is_regex: bool,\n        whole_words: bool,\n    ) -> bool {\n        if search_string.is_empty() {\n            self.unset();\n        }\n\n        let case_matching =\n            if case_sensitive { CaseMatching::Exact } else { CaseMatching::CaseInsensitive };\n\n        if let Some(ref s) = self.search_string {\n            if s == search_string\n                && case_matching == self.case_matching\n                && self.regex.is_some() == is_regex\n                && self.whole_words == whole_words\n            {\n                // search parameters did not change\n                return false;\n            }\n        }\n\n        self.unset();\n\n        self.search_string = Some(search_string.to_string());\n        self.case_matching = case_matching;\n        self.whole_words = whole_words;\n\n        // create regex from untrusted input\n        self.regex = match is_regex {\n            false => None,\n            true => RegexBuilder::new(search_string)\n                .size_limit(REGEX_SIZE_LIMIT)\n                .case_insensitive(case_matching == CaseMatching::CaseInsensitive)\n                .build()\n                .ok(),\n        };\n\n        true\n    }\n\n    /// Execute the search on the provided text in the range provided by `start` and `end`.\n    pub fn update_find(&mut self, text: &Rope, start: usize, end: usize, include_slop: bool) {\n        if self.search_string.is_none() {\n            return;\n        }\n\n        // extend the search by twice the string length (twice, because case matching may increase\n        // the length of an occurrence)\n        let slop = if include_slop { self.search_string.as_ref().unwrap().len() * 2 } else { 0 };\n\n        let search_string = self.search_string.as_ref().unwrap();\n\n        // expand region to be able to find occurrences around the region's edges\n        let expanded_start = max(start, slop) - slop;\n        let expanded_end = min(end + slop, text.len());\n        let from = text.at_or_prev_codepoint_boundary(expanded_start).unwrap_or(0);\n        let to = text.at_or_next_codepoint_boundary(expanded_end).unwrap_or(text.len());\n        let mut to_cursor = Cursor::new(&text, to);\n        let _ = to_cursor.next_leaf();\n\n        let sub_text = text.subseq(Interval::new(0, to_cursor.pos()));\n        let mut find_cursor = Cursor::new(&sub_text, from);\n\n        let mut raw_lines = text.lines_raw(from..to);\n\n        while let Some(start) = find(\n            &mut find_cursor,\n            &mut raw_lines,\n            self.case_matching,\n            &search_string,\n            self.regex.as_ref(),\n        ) {\n            let end = find_cursor.pos();\n\n            if self.whole_words && !self.is_matching_whole_words(text, start, end) {\n                raw_lines = text.lines_raw(find_cursor.pos()..to);\n                continue;\n            }\n\n            let region = SelRegion::new(start, end);\n            let (_, e) = self.occurrences.add_range_distinct(region);\n            // in case of ambiguous search results (e.g. search \"aba\" in \"ababa\"),\n            // the search result closer to the beginning of the file wins\n            if e != end {\n                // Skip the search result and keep the occurrence that is closer to\n                // the beginning of the file. Re-align the cursor to the kept\n                // occurrence\n                find_cursor.set(e);\n                raw_lines = text.lines_raw(find_cursor.pos()..to);\n                continue;\n            }\n\n            // in case current cursor matches search result (for example query a* matches)\n            // all cursor positions, then cursor needs to be increased so that search\n            // continues at next position. Otherwise, search will result in overflow since\n            // search will always repeat at current cursor position.\n            if start == end {\n                // determine whether end of text is reached and stop search or increase\n                // cursor manually\n                if end + 1 >= text.len() {\n                    break;\n                } else {\n                    find_cursor.set(end + 1);\n                }\n            }\n\n            // update line iterator so that line starts at current cursor position\n            raw_lines = text.lines_raw(find_cursor.pos()..to);\n        }\n\n        self.hls_dirty = true;\n    }\n\n    /// Return the occurrence closest to the provided selection `sel`. If searched is reversed then\n    /// the occurrence closest to the start of the selection is returned. `wrapped` indicates that\n    /// if the end of the text is reached the search continues from the start.\n    pub fn next_occurrence(\n        &self,\n        text: &Rope,\n        reverse: bool,\n        wrapped: bool,\n        sel: &Selection,\n    ) -> Option<SelRegion> {\n        if self.occurrences.len() == 0 {\n            return None;\n        }\n\n        let (sel_start, sel_end) = match sel.last() {\n            Some(last) if last.is_caret() =>\n            // if last selection is caret then allow the current position to be part of the occurrence\n            {\n                (last.min(), last.max())\n            }\n            Some(last) if !last.is_caret() =>\n            // if the last selection is not a caret then continue searching after the caret\n            {\n                (last.min(), last.max() + 1)\n            }\n            _ => (0, 0),\n        };\n\n        if reverse {\n            let next_occurrence = match sel_start.checked_sub(1) {\n                Some(search_end) => self.occurrences.regions_in_range(0, search_end).last(),\n                None => None,\n            };\n\n            if next_occurrence.is_none() && !wrapped {\n                // get previous unselected occurrence\n                return self\n                    .occurrences\n                    .regions_in_range(0, text.len())\n                    .iter()\n                    .cloned()\n                    .filter(|o| sel.regions_in_range(o.min(), o.max()).is_empty())\n                    .collect::<Vec<SelRegion>>()\n                    .last()\n                    .cloned();\n            }\n\n            next_occurrence.cloned()\n        } else {\n            let next_occurrence = self.occurrences.regions_in_range(sel_end, text.len()).first();\n\n            if next_occurrence.is_none() && !wrapped {\n                // get next unselected occurrence\n                return self\n                    .occurrences\n                    .regions_in_range(0, text.len())\n                    .iter()\n                    .cloned()\n                    .filter(|o| sel.regions_in_range(o.min(), o.max()).is_empty())\n                    .collect::<Vec<SelRegion>>()\n                    .first()\n                    .cloned();\n            }\n\n            next_occurrence.cloned()\n        }\n    }\n\n    /// Checks if the start and end of a match is matching whole words.\n    fn is_matching_whole_words(&self, text: &Rope, start: usize, end: usize) -> bool {\n        let mut word_end_cursor = WordCursor::new(text, end - 1);\n        let mut word_start_cursor = WordCursor::new(text, start + 1);\n\n        if let Some(start_boundary) = word_start_cursor.prev_boundary() {\n            if start_boundary != start {\n                return false;\n            }\n        }\n\n        if let Some(end_boundary) = word_end_cursor.next_boundary() {\n            if end_boundary != end {\n                return false;\n            }\n        }\n\n        true\n    }\n}","impl ToAnnotation for Find {\n    fn get_annotations(&self, interval: Interval, view: &View, text: &Rope) -> AnnotationSlice {\n        let regions = self.occurrences.regions_in_range(interval.start(), interval.end());\n        let ranges = regions\n            .iter()\n            .map(|region| {\n                let (start_line, start_col) = view.offset_to_line_col(text, region.min());\n                let (end_line, end_col) = view.offset_to_line_col(text, region.max());\n\n                AnnotationRange { start_line, start_col, end_line, end_col }\n            })\n            .collect::<Vec<AnnotationRange>>();\n\n        let payload = iter::repeat(json!({\"id\": self.id})).take(ranges.len()).collect::<Vec<_>>();\n\n        AnnotationSlice::new(AnnotationType::Find, ranges, Some(payload))\n    }\n}"],"find::FindStatus":["Debug","Deserialize","Serialize"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":["Deserialize"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor":["Deserialize"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor":["Deserialize"],"index_set::IndexSet":["impl IndexSet {\n    /// Create a new, empty set.\n    pub fn new() -> IndexSet {\n        IndexSet { ranges: Vec::new() }\n    }\n\n    /// Clear the set.\n    pub fn clear(&mut self) {\n        self.ranges.clear();\n    }\n\n    /// Add the range start..end to the set.\n    pub fn union_one_range(&mut self, start: usize, end: usize) {\n        for i in 0..self.ranges.len() {\n            let (istart, iend) = self.ranges[i];\n            if start > iend {\n                continue;\n            } else if end < istart {\n                self.ranges.insert(i, (start, end));\n                return;\n            } else {\n                self.ranges[i].0 = min(start, istart);\n                let mut j = i;\n                while j + 1 < self.ranges.len() && end >= self.ranges[j + 1].0 {\n                    j += 1;\n                }\n                self.ranges[i].1 = max(end, self.ranges[j].1);\n                remove_n_at(&mut self.ranges, i + 1, j - i);\n                return;\n            }\n        }\n        self.ranges.push((start, end));\n    }\n\n    /// Deletes the given range from the set.\n    pub fn delete_range(&mut self, start: usize, end: usize) {\n        let mut ix = match self.ranges.binary_search_by(|r| r.1.cmp(&start)) {\n            Ok(ix) => ix,\n            Err(ix) => ix,\n        };\n\n        let mut del_from = None;\n        let mut del_len = 0;\n        while ix < self.ranges.len() {\n            if self.ranges[ix].0 >= end {\n                break;\n            }\n\n            if self.ranges[ix].0 < start {\n                if self.ranges[ix].1 > end {\n                    let range = (end, self.ranges[ix].1);\n                    self.ranges.insert(ix + 1, range);\n                }\n                self.ranges[ix].1 = start;\n            } else if self.ranges[ix].1 > end {\n                self.ranges[ix].0 = end;\n            } else {\n                if del_from.is_none() {\n                    del_from = Some(ix);\n                }\n                del_len += 1;\n            }\n\n            ix += 1;\n        }\n\n        if let Some(del_from) = del_from {\n            remove_n_at(&mut self.ranges, del_from, del_len);\n        }\n    }\n\n    /// Return an iterator that yields start..end minus the coverage in this set.\n    pub fn minus_one_range(&self, start: usize, end: usize) -> MinusIter {\n        let mut ranges = &self.ranges[..];\n        while !ranges.is_empty() && start >= ranges[0].1 {\n            ranges = &ranges[1..];\n        }\n        MinusIter { ranges, start, end }\n    }\n\n    /// Computes a new set based on applying a delta to the old set. Collapsed regions are removed\n    /// and contiguous regions are combined.\n    pub fn apply_delta(&self, delta: &RopeDelta) -> IndexSet {\n        let mut ranges: Vec<(usize, usize)> = Vec::new();\n        let mut transformer = Transformer::new(delta);\n        for &(start, end) in &self.ranges {\n            let new_range =\n                (transformer.transform(start, false), transformer.transform(end, false));\n            if new_range.0 == new_range.1 {\n                continue; // remove collapsed regions\n            }\n            if !ranges.is_empty() {\n                let ix = ranges.len() - 1;\n                if ranges[ix].1 == new_range.0 {\n                    ranges[ix] = (ranges[ix].0, new_range.1);\n                    continue;\n                }\n            }\n            ranges.push(new_range);\n        }\n        IndexSet { ranges }\n    }\n\n    #[cfg(test)]\n    fn get_ranges(&self) -> &[(usize, usize)] {\n        &self.ranges\n    }\n}"],"index_set::MinusIter":["impl<'a> DoubleEndedIterator for MinusIter<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while self.start < self.end {\n            if self.ranges.is_empty() || self.ranges[self.ranges.len() - 1].1 <= self.start {\n                let result = (self.start, self.end);\n                self.start = self.end;\n                return Some(result);\n            }\n            let last_ix = self.ranges.len() - 1;\n            let result = (self.ranges[last_ix].1, self.end);\n            self.end = self.ranges[last_ix].0;\n            self.ranges = &self.ranges[..last_ix];\n            if result.1 > result.0 {\n                return Some(result);\n            }\n        }\n        None\n    }\n}","impl<'a> Iterator for MinusIter<'a> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        while self.start < self.end {\n            if self.ranges.is_empty() || self.end <= self.ranges[0].0 {\n                let result = (self.start, self.end);\n                self.start = self.end;\n                return Some(result);\n            }\n            let result = (self.start, self.ranges[0].0);\n            self.start = self.ranges[0].1;\n            self.ranges = &self.ranges[1..];\n            if result.1 > result.0 {\n                return Some(result);\n            }\n        }\n        None\n    }\n}"],"layers::Layers":["Default","impl Layers {\n    pub fn get_merged(&self) -> &Spans<Style> {\n        &self.merged\n    }\n\n    /// Adds the provided scopes to the layer's lookup table.\n    pub fn add_scopes(\n        &mut self,\n        layer: PluginPid,\n        scopes: Vec<Vec<String>>,\n        style_map: &ThemeStyleMap,\n    ) {\n        let _t = trace_block(\"Layers::AddScopes\", &[\"core\"]);\n        if self.create_if_missing(layer).is_err() {\n            return;\n        }\n        self.layers.get_mut(&layer).unwrap().add_scopes(scopes, style_map);\n    }\n\n    /// Applies the delta to all layers, inserting empty intervals\n    /// for any regions inserted in the delta.\n    ///\n    /// This is useful for clearing spans, and for updating spans\n    /// as edits occur.\n    pub fn update_all(&mut self, delta: &RopeDelta) {\n        self.merged.apply_shape(delta);\n\n        for layer in self.layers.values_mut() {\n            layer.blank_scopes(delta);\n        }\n        let (iv, _len) = delta.summary();\n        self.resolve_styles(iv);\n    }\n\n    /// Updates the scope spans for a given layer.\n    pub fn update_layer(&mut self, layer: PluginPid, iv: Interval, spans: Spans<u32>) {\n        if self.create_if_missing(layer).is_err() {\n            return;\n        }\n        self.layers.get_mut(&layer).unwrap().update_scopes(iv, &spans);\n        self.resolve_styles(iv);\n    }\n\n    /// Removes a given layer. This will remove all styles derived from\n    /// that layer's scopes.\n    pub fn remove_layer(&mut self, layer: PluginPid) -> Option<ScopeLayer> {\n        self.deleted.insert(layer);\n        let layer = self.layers.remove(&layer);\n        if layer.is_some() {\n            let iv_all = Interval::new(0, self.merged.len());\n            //TODO: should Spans<T> have a clear() method?\n            self.merged = SpansBuilder::new(self.merged.len()).build();\n            self.resolve_styles(iv_all);\n        }\n        layer\n    }\n\n    pub fn theme_changed(&mut self, style_map: &ThemeStyleMap) {\n        for layer in self.layers.values_mut() {\n            layer.theme_changed(style_map);\n        }\n        self.merged = SpansBuilder::new(self.merged.len()).build();\n        let iv_all = Interval::new(0, self.merged.len());\n        self.resolve_styles(iv_all);\n    }\n\n    /// Resolves styles from all layers for the given interval, updating\n    /// the master style spans.\n    fn resolve_styles(&mut self, iv: Interval) {\n        if self.layers.is_empty() {\n            return;\n        }\n        let mut layer_iter = self.layers.values();\n        let mut resolved = layer_iter.next().unwrap().style_spans.subseq(iv);\n\n        for other in layer_iter {\n            let spans = other.style_spans.subseq(iv);\n            assert_eq!(resolved.len(), spans.len());\n            resolved = resolved.merge(&spans, |a, b| match b {\n                Some(b) => a.merge(b),\n                None => a.to_owned(),\n            });\n        }\n        self.merged.edit(iv, resolved);\n    }\n\n    /// Prints scopes and style information for the given `Interval`.\n    pub fn debug_print_spans(&self, iv: Interval) {\n        for (id, layer) in &self.layers {\n            let spans = layer.scope_spans.subseq(iv);\n            let styles = layer.style_spans.subseq(iv);\n            if spans.iter().next().is_some() {\n                info!(\"scopes for layer {:?}:\", id);\n                for (iv, val) in spans.iter() {\n                    info!(\"{}: {:?}\", iv, layer.stack_lookup[*val as usize]);\n                }\n                info!(\"styles:\");\n                for (iv, val) in styles.iter() {\n                    info!(\"{}: {:?}\", iv, val);\n                }\n            }\n        }\n    }\n\n    /// Returns an `Err` if this layer has been deleted; the caller should return.\n    fn create_if_missing(&mut self, layer_id: PluginPid) -> Result<(), ()> {\n        if self.deleted.contains(&layer_id) {\n            return Err(());\n        }\n        if !self.layers.contains_key(&layer_id) {\n            self.layers.insert(layer_id, ScopeLayer::new(self.merged.len()));\n        }\n        Ok(())\n    }\n}"],"layers::ScopeLayer":["impl Default for ScopeLayer {\n    fn default() -> Self {\n        ScopeLayer {\n            stack_lookup: Vec::new(),\n            style_lookup: Vec::new(),\n            style_cache: HashMap::new(),\n            scope_spans: Spans::default(),\n            style_spans: Spans::default(),\n        }\n    }\n}","impl ScopeLayer {\n    pub fn new(len: usize) -> Self {\n        ScopeLayer {\n            stack_lookup: Vec::new(),\n            style_lookup: Vec::new(),\n            style_cache: HashMap::new(),\n            scope_spans: SpansBuilder::new(len).build(),\n            style_spans: SpansBuilder::new(len).build(),\n        }\n    }\n\n    fn theme_changed(&mut self, style_map: &ThemeStyleMap) {\n        // recompute styles with the new theme\n        let cur_stacks = self.stack_lookup.clone();\n        self.style_lookup = self.styles_for_stacks(&cur_stacks, style_map);\n        let iv_all = Interval::new(0, self.style_spans.len());\n        self.style_spans = SpansBuilder::new(self.style_spans.len()).build();\n        // this feels unnecessary but we can't pass in a reference to self\n        // and I don't want to get fancy unless there's an actual perf problem\n        let scopes = self.scope_spans.clone();\n        self.update_styles(iv_all, &scopes)\n    }\n\n    fn add_scopes(&mut self, scopes: Vec<Vec<String>>, style_map: &ThemeStyleMap) {\n        let mut stacks = Vec::with_capacity(scopes.len());\n        for stack in scopes {\n            let scopes = stack\n                .iter()\n                .map(|s| Scope::new(&s))\n                .filter(|result| match *result {\n                    Err(ref err) => {\n                        warn!(\"failed to resolve scope {}\\nErr: {:?}\", &stack.join(\" \"), err);\n                        false\n                    }\n                    _ => true,\n                })\n                .map(|s| s.unwrap())\n                .collect::<Vec<_>>();\n            stacks.push(scopes);\n        }\n\n        let mut new_styles = self.styles_for_stacks(stacks.as_slice(), style_map);\n        self.stack_lookup.append(&mut stacks);\n        self.style_lookup.append(&mut new_styles);\n    }\n\n    fn styles_for_stacks(\n        &mut self,\n        stacks: &[Vec<Scope>],\n        style_map: &ThemeStyleMap,\n    ) -> Vec<Style> {\n        //let style_map = style_map.borrow();\n        let highlighter = style_map.get_highlighter();\n        let mut new_styles = Vec::new();\n\n        for stack in stacks {\n            let mut last_style: Option<StyleModifier> = None;\n            let mut upper_bound_of_last = stack.len() as usize;\n\n            // walk backwards through stack to see if we have an existing\n            // style for any child stacks.\n            for i in 0..stack.len() - 1 {\n                let prev_range = 0..stack.len() - (i + 1);\n                if let Some(s) = self.style_cache.get(&stack[prev_range]) {\n                    last_style = Some(*s);\n                    upper_bound_of_last = stack.len() - (i + 1);\n                    break;\n                }\n            }\n            let mut base_style_mod = last_style.unwrap_or_default();\n\n            // apply the stack, generating children as needed.\n            for i in upper_bound_of_last..stack.len() {\n                let style_mod = highlighter.style_mod_for_stack(&stack[0..=i]);\n                base_style_mod = base_style_mod.apply(style_mod);\n            }\n\n            let style = Style::from_syntect_style_mod(&base_style_mod);\n            self.style_cache.insert(stack.clone(), base_style_mod);\n\n            new_styles.push(style);\n        }\n        new_styles\n    }\n\n    fn update_scopes(&mut self, iv: Interval, spans: &Spans<u32>) {\n        self.scope_spans.edit(iv, spans.to_owned());\n        self.update_styles(iv, spans);\n    }\n\n    /// Applies `delta`, which is presumed to contain empty spans.\n    /// This is only used when we receive an edit, to adjust current span\n    /// positions.\n    fn blank_scopes(&mut self, delta: &RopeDelta) {\n        self.style_spans.apply_shape(delta);\n        self.scope_spans.apply_shape(delta);\n    }\n\n    /// Updates `self.style_spans`, mapping scopes to styles and combining\n    /// adjacent and equal spans.\n    fn update_styles(&mut self, iv: Interval, spans: &Spans<u32>) {\n        // NOTE: This is a tradeoff. Keeping both u32 and Style spans for each\n        // layer makes debugging simpler and reduces the total number of spans\n        // on the wire (because we combine spans that resolve to the same style)\n        // but it does require additional computation + memory up front.\n        let mut sb = SpansBuilder::new(spans.len());\n        let mut spans_iter = spans.iter();\n        let mut prev = spans_iter.next();\n        {\n            // distinct adjacent scopes can often resolve to the same style,\n            // so we combine them when building the styles.\n            let style_eq = |i1: &u32, i2: &u32| {\n                self.style_lookup[*i1 as usize] == self.style_lookup[*i2 as usize]\n            };\n\n            while let Some((p_iv, p_val)) = prev {\n                match spans_iter.next() {\n                    Some((n_iv, n_val)) if n_iv.start() == p_iv.end() && style_eq(p_val, n_val) => {\n                        prev = Some((p_iv.union(n_iv), p_val));\n                    }\n                    other => {\n                        sb.add_span(p_iv, self.style_lookup[*p_val as usize].to_owned());\n                        prev = other;\n                    }\n                }\n            }\n        }\n        self.style_spans.edit(iv, sb.build());\n    }\n}"],"line_cache_shadow::Builder":["impl Builder {\n    pub fn new() -> Builder {\n        Builder { spans: Vec::new(), dirty: false }\n    }\n\n    pub fn build(self) -> LineCacheShadow {\n        LineCacheShadow { spans: self.spans, dirty: self.dirty }\n    }\n\n    pub fn add_span(&mut self, n: usize, start_line_num: usize, validity: Validity) {\n        if n > 0 {\n            if let Some(last) = self.spans.last_mut() {\n                if last.validity == validity\n                    && (validity == INVALID || last.start_line_num + last.n == start_line_num)\n                {\n                    last.n += n;\n                    return;\n                }\n            }\n            self.spans.push(Span { n, start_line_num, validity });\n        }\n    }\n\n    pub fn set_dirty(&mut self, dirty: bool) {\n        self.dirty = dirty;\n    }\n}"],"line_cache_shadow::LineCacheShadow":["Debug","impl Default for LineCacheShadow {\n    fn default() -> LineCacheShadow {\n        Builder::new().build()\n    }\n}","impl LineCacheShadow {\n    pub fn edit(&mut self, start: usize, end: usize, replace: usize) {\n        let mut b = Builder::new();\n        let mut line_num = 0;\n        let mut i = 0;\n        while i < self.spans.len() {\n            let span = &self.spans[i];\n            if line_num + span.n <= start {\n                b.add_span(span.n, span.start_line_num, span.validity);\n                line_num += span.n;\n                i += 1;\n            } else {\n                b.add_span(start - line_num, span.start_line_num, span.validity);\n                break;\n            }\n        }\n        b.add_span(replace, 0, INVALID);\n        for span in &self.spans[i..] {\n            if line_num + span.n > end {\n                let offset = end.saturating_sub(line_num);\n                b.add_span(span.n - offset, span.start_line_num + offset, span.validity);\n            }\n            line_num += span.n;\n        }\n        b.set_dirty(true);\n        *self = b.build();\n    }\n\n    pub fn partial_invalidate(&mut self, start: usize, end: usize, invalid: Validity) {\n        let mut clean = true;\n        let mut line_num = 0;\n        for span in &self.spans {\n            if start < line_num + span.n && end > line_num && (span.validity & invalid) != 0 {\n                clean = false;\n                break;\n            }\n            line_num += span.n;\n        }\n        if clean {\n            return;\n        }\n\n        let mut b = Builder::new();\n        let mut line_num = 0;\n        for span in &self.spans {\n            if start > line_num {\n                b.add_span(min(span.n, start - line_num), span.start_line_num, span.validity);\n            }\n            let invalid_start = max(start, line_num);\n            let invalid_end = min(end, line_num + span.n);\n            if invalid_end > invalid_start {\n                b.add_span(\n                    invalid_end - invalid_start,\n                    span.start_line_num + (invalid_start - line_num),\n                    span.validity & !invalid,\n                );\n            }\n            if line_num + span.n > end {\n                let offset = end.saturating_sub(line_num);\n                b.add_span(span.n - offset, span.start_line_num + offset, span.validity);\n            }\n            line_num += span.n;\n        }\n        b.set_dirty(true);\n        *self = b.build();\n    }\n\n    pub fn needs_render(&self, plan: &RenderPlan) -> bool {\n        self.dirty\n            || self\n                .iter_with_plan(plan)\n                .any(|seg| seg.tactic == RenderTactic::Render && seg.validity != ALL_VALID)\n    }\n\n    pub fn spans(&self) -> &[Span] {\n        &self.spans\n    }\n\n    pub fn iter_with_plan<'a>(&'a self, plan: &'a RenderPlan) -> PlanIterator<'a> {\n        PlanIterator {\n            lc_shadow: self,\n            plan,\n            shadow_ix: 0,\n            shadow_line_num: 0,\n            plan_ix: 0,\n            plan_line_num: 0,\n        }\n    }\n}"],"line_cache_shadow::PlanIterator":["impl<'a> Iterator for PlanIterator<'a> {\n    type Item = PlanSegment;\n\n    fn next(&mut self) -> Option<PlanSegment> {\n        if self.shadow_ix == self.lc_shadow.spans.len() || self.plan_ix == self.plan.spans.len() {\n            return None;\n        }\n        let shadow_span = &self.lc_shadow.spans[self.shadow_ix];\n        let plan_span = &self.plan.spans[self.plan_ix];\n        let start = max(self.shadow_line_num, self.plan_line_num);\n        let end = min(self.shadow_line_num + shadow_span.n, self.plan_line_num + plan_span.0);\n        let result = PlanSegment {\n            our_line_num: start,\n            their_line_num: shadow_span.start_line_num + (start - self.shadow_line_num),\n            n: end - start,\n            validity: shadow_span.validity,\n            tactic: plan_span.1,\n        };\n\n        if end == self.shadow_line_num + shadow_span.n {\n            self.shadow_line_num = end;\n            self.shadow_ix += 1;\n        }\n        if end == self.plan_line_num + plan_span.0 {\n            self.plan_line_num = end;\n            self.plan_ix += 1;\n        }\n        Some(result)\n    }\n}"],"line_cache_shadow::RenderPlan":["impl RenderPlan {\n    /// This function implements the policy of what to discard, what to preserve, and\n    /// what to render.\n    pub fn create(total_height: usize, first_line: usize, height: usize) -> RenderPlan {\n        let mut spans = Vec::new();\n        let mut last = 0;\n        let first_line = min(first_line, total_height);\n        if first_line > PRESERVE_EXTENT {\n            last = first_line - PRESERVE_EXTENT;\n            spans.push((last, RenderTactic::Discard));\n        }\n        if first_line > SCROLL_SLOP {\n            let n = first_line - SCROLL_SLOP - last;\n            spans.push((n, RenderTactic::Preserve));\n            last += n;\n        }\n        let render_end = min(first_line + height + SCROLL_SLOP, total_height);\n        spans.push((render_end - last, RenderTactic::Render));\n        last = render_end;\n        let preserve_end = min(first_line + height + PRESERVE_EXTENT, total_height);\n        if preserve_end > last {\n            spans.push((preserve_end - last, RenderTactic::Preserve));\n            last = preserve_end;\n        }\n        if total_height > last {\n            spans.push((total_height - last, RenderTactic::Discard));\n        }\n        RenderPlan { spans }\n    }\n\n    /// Upgrade a range of lines to the \"Render\" tactic.\n    pub fn request_lines(&mut self, start: usize, end: usize) {\n        let mut spans: Vec<(usize, RenderTactic)> = Vec::new();\n        let mut i = 0;\n        let mut line_num = 0;\n        while i < self.spans.len() {\n            let span = &self.spans[i];\n            if line_num + span.0 <= start {\n                spans.push(*span);\n                line_num += span.0;\n                i += 1;\n            } else {\n                if line_num < start {\n                    spans.push((start - line_num, span.1));\n                }\n                break;\n            }\n        }\n        spans.push((end - start, RenderTactic::Render));\n        for span in &self.spans[i..] {\n            if line_num + span.0 > end {\n                let offset = end.saturating_sub(line_num);\n                spans.push((span.0 - offset, span.1));\n            }\n            line_num += span.0;\n        }\n        self.spans = spans;\n    }\n}"],"line_cache_shadow::RenderTactic":["Clone","Copy","PartialEq"],"line_cache_shadow::Span":["impl fmt::Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let validity = match self.validity {\n            TEXT_VALID => \"text\",\n            ALL_VALID => \"all\",\n            _other => \"mixed\",\n        };\n        if self.validity == INVALID {\n            write!(f, \"({} invalid)\", self.n)?;\n        } else {\n            write!(f, \"({}: {}, {})\", self.start_line_num, self.n, validity)?;\n        }\n        Ok(())\n    }\n}"],"line_ending::LineEnding":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl LineEnding {\n    /// Breaks a rope down into chunks, and checks each chunk for line endings\n    pub fn parse(rope: &Rope) -> Result<Option<Self>, MixedLineEndingError> {\n        let mut crlf = false;\n        let mut lf = false;\n\n        for chunk in rope.iter_chunks(..) {\n            match LineEnding::parse_chunk(&chunk) {\n                Ok(Some(LineEnding::CrLf)) => crlf = true,\n                Ok(Some(LineEnding::Lf)) => lf = true,\n                Ok(None) => (),\n                Err(e) => return Err(e),\n            }\n        }\n\n        match (crlf, lf) {\n            (true, false) => Ok(Some(LineEnding::CrLf)),\n            (false, true) => Ok(Some(LineEnding::Lf)),\n            (false, false) => Ok(None),\n            _ => Err(MixedLineEndingError),\n        }\n    }\n\n    /// Checks a chunk for line endings, assuming \\n or \\r\\n\n    pub fn parse_chunk(chunk: &str) -> Result<Option<Self>, MixedLineEndingError> {\n        let bytes = chunk.as_bytes();\n        let newline = memchr2(b'\\n', b'\\r', bytes);\n        match newline {\n            Some(x) if bytes[x] == b'\\r' && bytes.len() > x + 1 && bytes[x + 1] == b'\\n' => {\n                Ok(Some(LineEnding::CrLf))\n            }\n            Some(x) if bytes[x] == b'\\n' => Ok(Some(LineEnding::Lf)),\n            Some(_) => Err(MixedLineEndingError),\n            _ => Ok(None),\n        }\n    }\n}"],"line_ending::MixedLineEndingError":["Debug"],"line_offset::LogicalLines":["impl LineOffset for LogicalLines {}"],"linewrap::LineBreakCursor":["impl<'a> LineBreakCursor<'a> {\n    fn new(text: &'a Rope, pos: usize) -> LineBreakCursor<'a> {\n        let inner = Cursor::new(text, pos);\n        let lb_iter = match inner.get_leaf() {\n            Some((s, offset)) => LineBreakLeafIter::new(s.as_str(), offset),\n            _ => LineBreakLeafIter::default(),\n        };\n        LineBreakCursor { inner, lb_iter, last_byte: 0 }\n    }\n\n    // position and whether break is hard; up to caller to stop calling after EOT\n    fn next(&mut self) -> (usize, bool) {\n        let mut leaf = self.inner.get_leaf();\n        loop {\n            match leaf {\n                Some((s, offset)) => {\n                    let (next, hard) = self.lb_iter.next(s.as_str());\n                    if next < s.len() {\n                        return (self.inner.pos() - offset + next, hard);\n                    }\n                    if !s.is_empty() {\n                        self.last_byte = s.as_bytes()[s.len() - 1];\n                    }\n                    leaf = self.inner.next_leaf();\n                }\n                // A little hacky but only reports last break as hard if final newline\n                None => return (self.inner.pos(), self.last_byte == b'\\n'),\n            }\n        }\n    }\n}"],"linewrap::Lines":["Default","impl LineOffset for Lines {\n    fn offset_of_line(&self, text: &Rope, line: usize) -> usize {\n        self.offset_of_visual_line(text, line)\n    }\n\n    fn line_of_offset(&self, text: &Rope, offset: usize) -> usize {\n        self.visual_line_of_offset(text, offset)\n    }\n}","impl Lines {\n    pub(crate) fn set_wrap_width(&mut self, text: &Rope, wrap: WrapWidth) {\n        self.work.clear();\n        self.add_task(0..text.len());\n        if self.breaks.is_empty() || self.wrap.differs_in_kind(wrap) {\n            // we keep breaks while resizing, for more efficient invalidation\n            self.breaks = Breaks::new_no_break(text.len());\n        }\n        self.wrap = wrap;\n    }\n\n    fn add_task<T: Into<Interval>>(&mut self, iv: T) {\n        let iv = iv.into();\n        if iv.is_empty() {\n            return;\n        }\n\n        // keep everything that doesn't intersect. merge things that do.\n        let split_idx = match self.work.iter().position(|&t| !t.intersect(iv).is_empty()) {\n            Some(idx) => idx,\n            None => {\n                self.work.push(iv);\n                return;\n            }\n        };\n\n        let to_update = self.work.split_off(split_idx);\n        let mut new_task = Some(iv);\n\n        for t in &to_update {\n            match new_task.take() {\n                Some(new) if !t.intersect(new).is_empty() => new_task = Some(t.union(new)),\n                Some(new) => {\n                    self.work.push(new);\n                    self.work.push(*t);\n                }\n                None => self.work.push(*t),\n            }\n        }\n        if let Some(end) = new_task.take() {\n            self.work.push(end);\n        }\n    }\n\n    pub(crate) fn is_converged(&self) -> bool {\n        self.wrap == WrapWidth::None || self.work.is_empty()\n    }\n\n    /// Returns `true` if this interval is part of an incomplete task.\n    pub(crate) fn interval_needs_wrap(&self, iv: Interval) -> bool {\n        self.work.iter().any(|t| !t.intersect(iv).is_empty())\n    }\n\n    pub(crate) fn visual_line_of_offset(&self, text: &Rope, offset: usize) -> usize {\n        let mut line = text.line_of_offset(offset);\n        if self.wrap != WrapWidth::None {\n            line += self.breaks.count::<BreaksMetric>(offset)\n        }\n        line\n    }\n\n    /// Returns the byte offset corresponding to the line `line`.\n    pub(crate) fn offset_of_visual_line(&self, text: &Rope, line: usize) -> usize {\n        match self.wrap {\n            WrapWidth::None => {\n                // sanitize input\n                let line = line.min(text.measure::<LinesMetric>() + 1);\n                text.offset_of_line(line)\n            }\n            _ => {\n                let mut cursor = MergedBreaks::new(text, &self.breaks);\n                cursor.offset_of_line(line)\n            }\n        }\n    }\n\n    /// Returns an iterator over [`VisualLine`]s, starting at (and including)\n    /// `start_line`.\n    pub(crate) fn iter_lines<'a>(\n        &'a self,\n        text: &'a Rope,\n        start_line: usize,\n    ) -> impl Iterator<Item = VisualLine> + 'a {\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let offset = cursor.offset_of_line(start_line);\n        let logical_line = text.line_of_offset(offset) + 1;\n        cursor.set_offset(offset);\n        VisualLines { offset, cursor, len: text.len(), logical_line, eof: false }\n    }\n\n    /// Returns the next task, prioritizing the currently visible region.\n    /// Does not modify the task list; this is done after the task runs.\n    fn get_next_task(&self, visible_offset: usize) -> Option<Task> {\n        // the first task t where t.end > visible_offset is the only task\n        // that might contain the visible region.\n        self.work\n            .iter()\n            .find(|t| t.end > visible_offset)\n            .map(|t| Task::new(t.start.max(visible_offset), t.end))\n            .or(self.work.last().cloned())\n    }\n\n    fn update_tasks_after_wrap<T: Into<Interval>>(&mut self, wrapped_iv: T) {\n        if self.work.is_empty() {\n            return;\n        }\n        let wrapped_iv = wrapped_iv.into();\n\n        let mut work = Vec::new();\n        for task in &self.work {\n            if task.is_before(wrapped_iv.start) || task.is_after(wrapped_iv.end) {\n                work.push(*task);\n                continue;\n            }\n            if wrapped_iv.start > task.start {\n                work.push(task.prefix(wrapped_iv));\n            }\n            if wrapped_iv.end < task.end {\n                work.push(task.suffix(wrapped_iv));\n            }\n        }\n        self.work = work;\n    }\n\n    /// Adjust offsets for any tasks after an edit.\n    fn patchup_tasks<T: Into<Interval>>(&mut self, iv: T, new_len: usize) {\n        let iv = iv.into();\n        let mut new_work = Vec::new();\n\n        for task in &self.work {\n            if task.is_before(iv.start) {\n                new_work.push(*task);\n            } else if task.contains(iv.start) {\n                let head = task.prefix(iv);\n                let tail_end = iv.start.max((task.end + new_len).saturating_sub(iv.size()));\n                let tail = Interval::new(iv.start, tail_end);\n                new_work.push(head);\n                new_work.push(tail);\n            } else {\n                // take task - our edit interval, then translate it (- old_size, + new_size)\n                let tail = task.suffix(iv).translate(new_len).translate_neg(iv.size());\n                new_work.push(tail);\n            }\n        }\n        new_work.retain(|iv| !iv.is_empty());\n        self.work.clear();\n        for task in new_work {\n            if let Some(prev) = self.work.last_mut() {\n                if prev.end >= task.start {\n                    *prev = prev.union(task);\n                    continue;\n                }\n            }\n            self.work.push(task);\n        }\n    }\n\n    /// Do a chunk of wrap work, if any exists.\n    pub(crate) fn rewrap_chunk(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        _spans: &Spans<Style>,\n        visible_lines: Range<usize>,\n    ) -> Option<InvalLines> {\n        if self.is_converged() {\n            None\n        } else {\n            let summary = self.do_wrap_task(text, width_cache, client, visible_lines, None);\n            let WrapSummary { start_line, inval_count, new_count, .. } = summary;\n            Some(InvalLines { start_line, inval_count, new_count })\n        }\n    }\n\n    /// Updates breaks after an edit. Returns `InvalLines`, for minimal invalidation,\n    /// when possible.\n    pub(crate) fn after_edit(\n        &mut self,\n        text: &Rope,\n        old_text: &Rope,\n        delta: &RopeDelta,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        visible_lines: Range<usize>,\n    ) -> Option<InvalLines> {\n        let (iv, newlen) = delta.summary();\n\n        let logical_start_line = text.line_of_offset(iv.start);\n        let old_logical_end_line = old_text.line_of_offset(iv.end) + 1;\n        let new_logical_end_line = text.line_of_offset(iv.start + newlen) + 1;\n        let old_logical_end_offset = old_text.offset_of_line(old_logical_end_line);\n        let old_hard_count = old_logical_end_line - logical_start_line;\n        let new_hard_count = new_logical_end_line - logical_start_line;\n\n        //TODO: we should be able to avoid wrapping the whole para in most cases,\n        // but the logic is trickier.\n        let prev_break = text.offset_of_line(logical_start_line);\n        let next_hard_break = text.offset_of_line(new_logical_end_line);\n\n        // count the soft breaks in the region we will rewrap, before we update them.\n        let inval_soft = self.breaks.count::<BreaksMetric>(old_logical_end_offset)\n            - self.breaks.count::<BreaksMetric>(prev_break);\n\n        // update soft breaks, adding empty spans in the edited region\n        let mut builder = BreakBuilder::new();\n        builder.add_no_break(newlen);\n        self.breaks.edit(iv, builder.build());\n        self.patchup_tasks(iv, newlen);\n\n        if self.wrap == WrapWidth::None {\n            return Some(InvalLines {\n                start_line: logical_start_line,\n                inval_count: old_hard_count,\n                new_count: new_hard_count,\n            });\n        }\n\n        let new_task = prev_break..next_hard_break;\n        self.add_task(new_task);\n\n        // possible if the whole buffer is deleted, e.g\n        if !self.work.is_empty() {\n            let summary = self.do_wrap_task(text, width_cache, client, visible_lines, None);\n            let WrapSummary { start_line, new_soft, .. } = summary;\n            // if we haven't converged after this update we can't do minimal invalidation\n            // because we don't have complete knowledge of the new breaks state.\n            if self.is_converged() {\n                let inval_count = old_hard_count + inval_soft;\n                let new_count = new_hard_count + new_soft;\n                Some(InvalLines { start_line, new_count, inval_count })\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    fn do_wrap_task(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        visible_lines: Range<usize>,\n        max_lines: Option<usize>,\n    ) -> WrapSummary {\n        use self::WrapWidth::*;\n        let _t = trace_block(\"Lines::do_wrap_task\", &[\"core\"]);\n        // 'line' is a poor unit here; could do some fancy Duration thing?\n        const MAX_LINES_PER_BATCH: usize = 500;\n\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let visible_off = cursor.offset_of_line(visible_lines.start);\n        let logical_off = text.offset_of_line(text.line_of_offset(visible_off));\n\n        // task.start is a hard break; task.end is a boundary or EOF.\n        let task = self.get_next_task(logical_off).unwrap();\n        cursor.set_offset(task.start);\n        debug_assert_eq!(cursor.offset, task.start, \"task_start must be valid offset\");\n\n        let mut ctx = match self.wrap {\n            Bytes(b) => RewrapCtx::new(text, &CodepointMono, b as f64, width_cache, task.start),\n            Width(w) => RewrapCtx::new(text, client, w, width_cache, task.start),\n            None => unreachable!(),\n        };\n\n        let start_line = cursor.cur_line;\n        let max_lines = max_lines.unwrap_or(MAX_LINES_PER_BATCH);\n        // always wrap at least a screen worth of lines (unless we converge earlier)\n        let batch_size = max_lines.max(visible_lines.end - visible_lines.start);\n\n        let mut builder = BreakBuilder::new();\n        let mut lines_wrapped = 0;\n        let mut pos = task.start;\n        let mut old_next_maybe = cursor.next();\n\n        loop {\n            if let Some(new_next) = ctx.wrap_one_line(pos) {\n                while let Some(old_next) = old_next_maybe {\n                    if old_next >= new_next {\n                        break; // just advance old cursor and continue\n                    }\n                    old_next_maybe = cursor.next();\n                }\n\n                let is_hard = cursor.offset == new_next && cursor.is_hard_break();\n                if is_hard {\n                    builder.add_no_break(new_next - pos);\n                } else {\n                    builder.add_break(new_next - pos);\n                }\n                lines_wrapped += 1;\n                pos = new_next;\n                if pos == task.end || (lines_wrapped > batch_size && is_hard) {\n                    break;\n                }\n            } else {\n                // EOF\n                builder.add_no_break(text.len() - pos);\n                break;\n            }\n        }\n\n        let breaks = builder.build();\n        let end = task.start + breaks.len();\n\n        // this is correct *only* when an edit has not occured.\n        let inval_soft =\n            self.breaks.count::<BreaksMetric>(end) - self.breaks.count::<BreaksMetric>(task.start);\n\n        let hard_count = 1 + text.line_of_offset(end) - text.line_of_offset(task.start);\n\n        let inval_count = inval_soft + hard_count;\n        let new_soft = breaks.measure::<BreaksMetric>();\n        let new_count = new_soft + hard_count;\n\n        let iv = Interval::new(task.start, end);\n        self.breaks.edit(iv, breaks);\n        self.update_tasks_after_wrap(iv);\n\n        WrapSummary { start_line, inval_count, new_count, new_soft }\n    }\n\n    pub fn logical_line_range(&self, text: &Rope, line: usize) -> (usize, usize) {\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let offset = cursor.offset_of_line(line);\n        let logical_line = text.line_of_offset(offset);\n        let start_logical_line_offset = text.offset_of_line(logical_line);\n        let end_logical_line_offset = text.offset_of_line(logical_line + 1);\n        (start_logical_line_offset, end_logical_line_offset)\n    }\n\n    #[cfg(test)]\n    fn for_testing(text: &Rope, wrap: WrapWidth) -> Lines {\n        let mut lines = Lines::default();\n        lines.set_wrap_width(text, wrap);\n        lines\n    }\n\n    #[cfg(test)]\n    fn rewrap_all(&mut self, text: &Rope, client: &Client, width_cache: &mut WidthCache) {\n        if !self.is_converged() {\n            self.do_wrap_task(text, width_cache, client, 0..10, Some(usize::max_value()));\n        }\n    }\n}"],"linewrap::MergedBreaks":["impl<'a> Iterator for MergedBreaks<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        if self.text.pos() == self.offset && !self.at_eof() {\n            // don't iterate past EOF, or we can't get the leaf and check for \\n\n            self.text.next::<LinesMetric>();\n        }\n        if self.soft.pos() == self.offset {\n            self.soft.next::<BreaksMetric>();\n        }\n        let prev_off = self.offset;\n        self.offset = self.text.pos().min(self.soft.pos());\n\n        let eof_without_newline = self.offset > 0 && self.at_eof() && self.eof_without_newline();\n        if self.offset == prev_off || eof_without_newline {\n            None\n        } else {\n            self.cur_line += 1;\n            Some(self.offset)\n        }\n    }\n}","impl<'a> MergedBreaks<'a> {\n    fn new(text: &'a Rope, breaks: &'a Breaks) -> Self {\n        debug_assert_eq!(text.len(), breaks.len());\n        let text = Cursor::new(text, 0);\n        let soft = Cursor::new(breaks, 0);\n        let total_lines =\n            text.root().measure::<LinesMetric>() + soft.root().measure::<BreaksMetric>() + 1;\n        let len = text.total_len();\n        MergedBreaks { text, soft, offset: 0, cur_line: 0, total_lines, len }\n    }\n\n    /// Sets the `self.offset` to the first valid break immediately at or preceding `offset`,\n    /// and restores invariants.\n    fn set_offset(&mut self, offset: usize) {\n        self.text.set(offset);\n        self.soft.set(offset);\n        if offset > 0 {\n            if self.text.at_or_prev::<LinesMetric>().is_none() {\n                self.text.set(0);\n            }\n            if self.soft.at_or_prev::<BreaksMetric>().is_none() {\n                self.soft.set(0);\n            }\n        }\n\n        // self.offset should be at the first valid break immediately preceding `offset`, or 0.\n        // the position of the non-break cursor should be > than that of the break cursor, or EOF.\n        match self.text.pos().cmp(&self.soft.pos()) {\n            Ordering::Less => {\n                self.text.next::<LinesMetric>();\n            }\n            Ordering::Greater => {\n                self.soft.next::<BreaksMetric>();\n            }\n            Ordering::Equal => assert!(self.text.pos() == 0),\n        }\n\n        self.offset = self.text.pos().min(self.soft.pos());\n        self.cur_line = merged_line_of_offset(self.text.root(), self.soft.root(), self.offset);\n    }\n\n    fn offset_of_line(&mut self, line: usize) -> usize {\n        match line {\n            0 => 0,\n            l if l >= self.total_lines => self.text.total_len(),\n            l if l == self.cur_line => self.offset,\n            l if l > self.cur_line && l - self.cur_line < MAX_LINEAR_DIST => {\n                self.offset_of_line_linear(l)\n            }\n            other => self.offset_of_line_bsearch(other),\n        }\n    }\n\n    fn offset_of_line_linear(&mut self, line: usize) -> usize {\n        assert!(line > self.cur_line);\n        let dist = line - self.cur_line;\n        self.nth(dist - 1).unwrap_or(self.len)\n    }\n\n    fn offset_of_line_bsearch(&mut self, line: usize) -> usize {\n        let mut range = 0..self.len;\n        loop {\n            let pivot = range.start + (range.end - range.start) / 2;\n            self.set_offset(pivot);\n\n            match self.cur_line {\n                l if l == line => break self.offset,\n                l if l > line => range = range.start..pivot,\n                l if line - l > MAX_LINEAR_DIST => range = pivot..range.end,\n                _else => break self.offset_of_line_linear(line),\n            }\n        }\n    }\n\n    fn is_hard_break(&self) -> bool {\n        self.offset == self.text.pos()\n    }\n\n    fn at_eof(&self) -> bool {\n        self.offset == self.len\n    }\n\n    fn eof_without_newline(&mut self) -> bool {\n        debug_assert!(self.at_eof());\n        self.text.set(self.len);\n        self.text.get_leaf().map(|(l, _)| l.as_bytes().last() != Some(&b'\\n')).unwrap()\n    }\n}"],"linewrap::RewrapCtx":["impl<'a> RewrapCtx<'a> {\n    fn new(\n        text: &'a Rope,\n        //_style_spans: &Spans<Style>,  client: &'a T,\n        client: &'a dyn WidthMeasure,\n        max_width: f64,\n        width_cache: &'a mut WidthCache,\n        start: usize,\n    ) -> RewrapCtx<'a> {\n        let lb_cursor_pos = start;\n        let lb_cursor = LineBreakCursor::new(text, start);\n        RewrapCtx {\n            text,\n            lb_cursor,\n            lb_cursor_pos,\n            width_cache,\n            client,\n            pot_breaks: Vec::new(),\n            pot_break_ix: 0,\n            max_width,\n        }\n    }\n\n    fn refill_pot_breaks(&mut self) {\n        let mut req = self.width_cache.batch_req();\n\n        self.pot_breaks.clear();\n        self.pot_break_ix = 0;\n        let mut pos = self.lb_cursor_pos;\n        while pos < self.text.len() && self.pot_breaks.len() < MAX_POT_BREAKS {\n            let (next, hard) = self.lb_cursor.next();\n            let word = self.text.slice_to_cow(pos..next);\n            let tok = req.request(N_RESERVED_STYLES, &word);\n            pos = next;\n            self.pot_breaks.push(PotentialBreak { pos, tok, hard });\n        }\n        req.resolve_pending(self.client).unwrap();\n        self.lb_cursor_pos = pos;\n    }\n\n    /// Compute the next break, assuming `start` is a valid break.\n    ///\n    /// Invariant: `start` corresponds to the start of the word referenced by `pot_break_ix`.\n    fn wrap_one_line(&mut self, start: usize) -> Option<usize> {\n        let mut line_width = 0.0;\n        let mut pos = start;\n        while pos < self.text.len() {\n            if self.pot_break_ix >= self.pot_breaks.len() {\n                self.refill_pot_breaks();\n            }\n            let pot_break = &self.pot_breaks[self.pot_break_ix];\n            let width = self.width_cache.resolve(pot_break.tok);\n            if !pot_break.hard {\n                if line_width == 0.0 && width >= self.max_width {\n                    // we don't care about soft breaks at EOF\n                    if pot_break.pos == self.text.len() {\n                        return None;\n                    }\n                    self.pot_break_ix += 1;\n                    return Some(pot_break.pos);\n                }\n                line_width += width;\n                if line_width > self.max_width {\n                    return Some(pos);\n                }\n                self.pot_break_ix += 1;\n                pos = pot_break.pos;\n            } else if line_width != 0. && width + line_width > self.max_width {\n                // if this is a hard break but we would have broken at the previous\n                // pos otherwise, we still break at the previous pos.\n                return Some(pos);\n            } else {\n                self.pot_break_ix += 1;\n                return Some(pot_break.pos);\n            }\n        }\n        None\n    }\n}"],"linewrap::VisualLine":["impl VisualLine {\n    fn new<I: Into<Interval>, L: Into<Option<usize>>>(iv: I, line: L) -> Self {\n        VisualLine { interval: iv.into(), line_num: line.into() }\n    }\n}"],"linewrap::VisualLines":["impl<'a> Iterator for VisualLines<'a> {\n    type Item = VisualLine;\n\n    fn next(&mut self) -> Option<VisualLine> {\n        let line_num = if self.cursor.is_hard_break() { Some(self.logical_line) } else { None };\n        let next_end_bound = match self.cursor.next() {\n            Some(b) => b,\n            None if self.eof => return None,\n            _else => {\n                self.eof = true;\n                self.len\n            }\n        };\n        let result = VisualLine::new(self.offset..next_end_bound, line_num);\n        if self.cursor.is_hard_break() {\n            self.logical_line += 1;\n        }\n        self.offset = next_end_bound;\n        Some(result)\n    }\n}"],"linewrap::WrapWidth":["Clone","Copy","Debug","PartialEq","impl Default for WrapWidth {\n    fn default() -> Self {\n        WrapWidth::None\n    }\n}","impl WrapWidth {\n    fn differs_in_kind(self, other: WrapWidth) -> bool {\n        use self::WrapWidth::*;\n        match (self, other) {\n            (None, None) | (Bytes(_), Bytes(_)) | (Width(_), Width(_)) => false,\n            _else => true,\n        }\n    }\n}"],"movement::Movement":["Clone","Copy","Debug","PartialEq"],"plugins::Plugin":["impl Plugin {\n    //TODO: initialize should be sent automatically during launch,\n    //and should only send the plugin_id. We can just use the existing 'new_buffer'\n    // RPC for adding views\n    pub fn initialize(&self, info: Vec<PluginBufferInfo>) {\n        self.peer.send_rpc_notification(\n            \"initialize\",\n            &json!({\n                \"plugin_id\": self.id,\n                \"buffer_info\": info,\n            }),\n        )\n    }\n\n    pub fn shutdown(&self) {\n        self.peer.send_rpc_notification(\"shutdown\", &json!({}));\n    }\n\n    // TODO: rethink naming, does this need to be a vec?\n    pub fn new_buffer(&self, info: &PluginBufferInfo) {\n        self.peer.send_rpc_notification(\"new_buffer\", &json!({ \"buffer_info\": [info] }))\n    }\n\n    pub fn close_view(&self, view_id: ViewId) {\n        self.peer.send_rpc_notification(\"did_close\", &json!({ \"view_id\": view_id }))\n    }\n\n    pub fn did_save(&self, view_id: ViewId, path: &Path) {\n        self.peer.send_rpc_notification(\n            \"did_save\",\n            &json!({\n                \"view_id\": view_id,\n                \"path\": path,\n            }),\n        )\n    }\n\n    pub fn update<F>(&self, update: &PluginUpdate, callback: F)\n    where\n        F: FnOnce(Result<Value, xi_rpc::Error>) + Send + 'static,\n    {\n        self.peer.send_rpc_request_async(\"update\", &json!(update), Box::new(callback))\n    }\n\n    pub fn toggle_tracing(&self, enabled: bool) {\n        self.peer.send_rpc_notification(\"tracing_config\", &json!({ \"enabled\": enabled }))\n    }\n\n    pub fn collect_trace(&self) -> Result<Value, xi_rpc::Error> {\n        self.peer.send_rpc_request(\"collect_trace\", &json!({}))\n    }\n\n    pub fn config_changed(&self, view_id: ViewId, changes: &Table) {\n        self.peer.send_rpc_notification(\n            \"config_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"changes\": changes,\n            }),\n        )\n    }\n\n    pub fn language_changed(&self, view_id: ViewId, new_lang: &LanguageId) {\n        self.peer.send_rpc_notification(\n            \"language_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"new_lang\": new_lang,\n            }),\n        )\n    }\n\n    pub fn get_hover(&self, view_id: ViewId, request_id: usize, position: usize) {\n        self.peer.send_rpc_notification(\n            \"get_hover\",\n            &json!({\n                \"view_id\": view_id,\n                \"request_id\": request_id,\n                \"position\": position,\n            }),\n        )\n    }\n\n    pub fn dispatch_command(&self, view_id: ViewId, method: &str, params: &Value) {\n        self.peer.send_rpc_notification(\n            \"custom_command\",\n            &json!({\n                \"view_id\": view_id,\n                \"method\": method,\n                \"params\": params,\n            }),\n        )\n    }\n}"],"plugins::PluginPid":["Clone","Copy","Debug","Default","Deserialize","Eq","Hash","Ord","PartialEq","PartialOrd","Serialize","impl fmt::Display for PluginPid {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(f, \"plugin-{}\", self.0)\n    }\n}"],"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor":["Deserialize"],"plugins::catalog::PluginCatalog":["Clone","Debug","Default","impl<'a> PluginCatalog {\n    /// Loads any plugins discovered in these paths, replacing any existing\n    /// plugins.\n    pub fn reload_from_paths(&mut self, paths: &[PathBuf]) {\n        self.items.clear();\n        self.locations.clear();\n        self.load_from_paths(paths);\n    }\n\n    /// Loads plugins from paths and adds them to existing plugins.\n    pub fn load_from_paths(&mut self, paths: &[PathBuf]) {\n        let all_manifests = find_all_manifests(paths);\n        for manifest_path in &all_manifests {\n            match load_manifest(manifest_path) {\n                Err(e) => warn!(\"error loading plugin {:?}\", e),\n                Ok(manifest) => {\n                    info!(\"loaded {}\", manifest.name);\n                    let manifest = Arc::new(manifest);\n                    self.items.insert(manifest.name.clone(), manifest.clone());\n                    self.locations.insert(manifest_path.clone(), manifest);\n                }\n            }\n        }\n    }\n\n    pub fn make_languages_map(&self) -> Languages {\n        let all_langs =\n            self.items.values().flat_map(|plug| plug.languages.iter().cloned()).collect::<Vec<_>>();\n        Languages::new(all_langs.as_slice())\n    }\n\n    /// Returns an iterator over all plugins in the catalog, in arbitrary order.\n    pub fn iter(&'a self) -> impl Iterator<Item = Arc<PluginDescription>> + 'a {\n        self.items.values().cloned()\n    }\n\n    /// Returns an iterator over all plugin names in the catalog,\n    /// in arbitrary order.\n    pub fn iter_names(&'a self) -> impl Iterator<Item = &'a PluginName> {\n        self.items.keys()\n    }\n\n    /// Returns the plugin located at the provided file path.\n    pub fn get_from_path(&self, path: &PathBuf) -> Option<Arc<PluginDescription>> {\n        self.items\n            .values()\n            .find(|&v| v.exec_path.to_str().unwrap().contains(path.to_str().unwrap()))\n            .cloned()\n    }\n\n    /// Returns a reference to the named plugin if it exists in the catalog.\n    pub fn get_named(&self, plugin_name: &str) -> Option<Arc<PluginDescription>> {\n        self.items.get(plugin_name).map(Arc::clone)\n    }\n\n    /// Removes the named plugin.\n    pub fn remove_named(&mut self, plugin_name: &str) {\n        self.items.remove(plugin_name);\n    }\n}"],"plugins::catalog::PluginLoadError":["Debug","impl From<io::Error> for PluginLoadError {\n    fn from(err: io::Error) -> PluginLoadError {\n        PluginLoadError::Io(err)\n    }\n}","impl From<toml::de::Error> for PluginLoadError {\n    fn from(err: toml::de::Error) -> PluginLoadError {\n        PluginLoadError::Parse(err)\n    }\n}"],"plugins::manifest::ArgumentOption":["Clone","Debug","Deserialize","PartialEq","Serialize","impl ArgumentOption {\n    pub fn new<S: AsRef<str>, V: Serialize>(title: S, value: V) -> Self {\n        let title = title.as_ref().to_owned();\n        let value = serde_json::to_value(value).unwrap();\n        ArgumentOption { title, value }\n    }\n}"],"plugins::manifest::ArgumentType":["Clone","Debug","Deserialize","PartialEq","Serialize"],"plugins::manifest::Command":["Clone","Debug","Deserialize","Serialize","impl Command {\n    pub fn new<S, V>(title: S, description: S, rpc_cmd: PlaceholderRpc, args: V) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Vec<CommandArgument>>>,\n    {\n        let title = title.as_ref().to_owned();\n        let description = description.as_ref().to_owned();\n        let args = args.into().unwrap_or_else(Vec::new);\n        Command { title, description, rpc_cmd, args }\n    }\n}"],"plugins::manifest::CommandArgument":["Clone","Debug","Deserialize","Serialize","impl CommandArgument {\n    pub fn new<S: AsRef<str>>(\n        title: S,\n        description: S,\n        key: S,\n        arg_type: ArgumentType,\n        options: Option<Vec<ArgumentOption>>,\n    ) -> Self {\n        let key = key.as_ref().to_owned();\n        let title = title.as_ref().to_owned();\n        let description = description.as_ref().to_owned();\n        if arg_type == ArgumentType::Choice {\n            assert!(options.is_some())\n        }\n        CommandArgument { title, description, key, arg_type, options }\n    }\n}"],"plugins::manifest::PlaceholderRpc":["Clone","Debug","Deserialize","PartialEq","Serialize","impl PlaceholderRpc {\n    pub fn new<S, V>(method: S, params: V, request: bool) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Value>>,\n    {\n        let method = method.as_ref().to_owned();\n        let params = params.into().unwrap_or(json!({}));\n        let rpc_type = if request { RpcType::Request } else { RpcType::Notification };\n\n        PlaceholderRpc { method, params, rpc_type }\n    }\n\n    pub fn is_request(&self) -> bool {\n        self.rpc_type == RpcType::Request\n    }\n\n    /// Returns a reference to the placeholder's params.\n    pub fn params_ref(&self) -> &Value {\n        &self.params\n    }\n\n    /// Returns a mutable reference to the placeholder's params.\n    pub fn params_ref_mut(&mut self) -> &mut Value {\n        &mut self.params\n    }\n\n    /// Returns a reference to the placeholder's method.\n    pub fn method_ref(&self) -> &str {\n        &self.method\n    }\n}"],"plugins::manifest::PluginActivation":["Clone","Debug","Deserialize","Serialize"],"plugins::manifest::PluginDescription":["Clone","Debug","Deserialize","Serialize","impl PluginDescription {\n    /// Returns `true` if this plugin is globally scoped, else `false`.\n    pub fn is_global(&self) -> bool {\n        matches!(self.scope, PluginScope::Global)\n    }\n}"],"plugins::manifest::PluginScope":["Clone","Debug","Deserialize","Serialize","impl Default for PluginScope {\n    fn default() -> Self {\n        PluginScope::BufferLocal\n    }\n}"],"plugins::manifest::RpcType":["Clone","Debug","Deserialize","PartialEq","Serialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor":["Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::ClientPluginInfo":["Debug","Deserialize","Serialize"],"plugins::rpc::DataSpan":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::EmptyStruct":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::GetDataResponse":["Debug","Deserialize","Serialize"],"plugins::rpc::HostNotification":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::HostRequest":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::Hover":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::PluginBufferInfo":["Clone","Debug","Deserialize","Serialize","impl PluginBufferInfo {\n    pub fn new(\n        buffer_id: BufferIdentifier,\n        views: &[ViewId],\n        rev: u64,\n        buf_size: usize,\n        nb_lines: usize,\n        path: Option<PathBuf>,\n        syntax: LanguageId,\n        config: Table,\n    ) -> Self {\n        //TODO: do make any current assertions about paths being valid utf-8? do we want to?\n        let path = path.map(|p| p.to_str().unwrap().to_owned());\n        let views = views.to_owned();\n        PluginBufferInfo { buffer_id, views, rev, buf_size, nb_lines, path, syntax, config }\n    }\n}"],"plugins::rpc::PluginCommand":["impl<'de, T: Deserialize<'de>> Deserialize<'de> for PluginCommand<T> {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        #[derive(Deserialize)]\n        struct InnerIds {\n            view_id: ViewId,\n            plugin_id: PluginPid,\n        }\n        #[derive(Deserialize)]\n        struct IdsWrapper {\n            params: InnerIds,\n        }\n\n        let v = Value::deserialize(deserializer)?;\n        let helper = IdsWrapper::deserialize(&v).map_err(de::Error::custom)?;\n        let InnerIds { view_id, plugin_id } = helper.params;\n        let cmd = T::deserialize(v).map_err(de::Error::custom)?;\n        Ok(PluginCommand { view_id, plugin_id, cmd })\n    }\n}","impl<T: Serialize> Serialize for PluginCommand<T> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut v = serde_json::to_value(&self.cmd).map_err(ser::Error::custom)?;\n        v[\"params\"][\"view_id\"] = json!(self.view_id);\n        v[\"params\"][\"plugin_id\"] = json!(self.plugin_id);\n        v.serialize(serializer)\n    }\n}"],"plugins::rpc::PluginEdit":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::PluginNotification":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::PluginRequest":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::PluginUpdate":["Clone","Debug","Deserialize","Serialize","impl PluginUpdate {\n    pub fn new<D>(\n        view_id: ViewId,\n        rev: u64,\n        delta: D,\n        new_len: usize,\n        new_line_count: usize,\n        undo_group: Option<usize>,\n        edit_type: String,\n        author: String,\n    ) -> Self\n    where\n        D: Into<Option<RopeDelta>>,\n    {\n        let delta = delta.into();\n        PluginUpdate { view_id, delta, new_len, new_line_count, rev, undo_group, edit_type, author }\n    }\n}"],"plugins::rpc::Range":["Clone","Debug","Deserialize","Serialize"],"plugins::rpc::ScopeSpan":["Clone","Copy","Debug","Deserialize","Serialize"],"plugins::rpc::TextUnit":["Clone","Copy","Debug","Deserialize","Serialize","impl TextUnit {\n    /// Converts an offset in some unit to a concrete byte offset. Returns\n    /// `None` if the input offset is out of bounds in its unit space.\n    pub fn resolve_offset<T: Borrow<Rope>>(self, text: T, offset: usize) -> Option<usize> {\n        let text = text.borrow();\n        match self {\n            TextUnit::Utf8 => {\n                if offset > text.len() {\n                    None\n                } else {\n                    text.at_or_prev_codepoint_boundary(offset)\n                }\n            }\n            TextUnit::Line => {\n                let max_line_number = text.measure::<LinesMetric>() + 1;\n                if offset > max_line_number {\n                    None\n                } else {\n                    text.offset_of_line(offset).into()\n                }\n            }\n        }\n    }\n}"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor":["Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor":["Deserialize"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged":["Serialize"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged":["Serialize"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged":["Serialize"],"recorder::Recorder":["impl Recorder {\n    pub(crate) fn new() -> Recorder {\n        Recorder {\n            active_recording: None,\n            recording_buffer: Vec::new(),\n            recordings: HashMap::new(),\n        }\n    }\n\n    pub(crate) fn is_recording(&self) -> bool {\n        self.active_recording.is_some()\n    }\n\n    /// Starts or stops the specified recording.\n    ///\n    ///\n    /// There are three outcome behaviors:\n    /// - If the current recording name is specified, the active recording is saved\n    /// - If no recording name is specified, the currently active recording is saved\n    /// - If a recording name other than the active recording is specified,\n    /// the current recording will be thrown out and will be switched to the new name\n    ///\n    /// In addition to the above:\n    /// - If the recording was saved, there is no active recording\n    /// - If the recording was switched, there will be a new active recording\n    pub(crate) fn toggle_recording(&mut self, recording_name: Option<String>) {\n        let is_recording = self.is_recording();\n        let last_recording = self.active_recording.take();\n\n        match (is_recording, &last_recording, &recording_name) {\n            (true, Some(last_recording), None) => {\n                self.save_recording_buffer(last_recording.clone())\n            }\n            (true, Some(last_recording), Some(recording_name)) => {\n                if last_recording != recording_name {\n                    self.recording_buffer.clear();\n                } else {\n                    self.save_recording_buffer(last_recording.clone());\n                    return;\n                }\n            }\n            _ => {}\n        }\n\n        self.active_recording = recording_name;\n    }\n\n    /// Saves an event into the currently active recording.\n    ///\n    /// Every sequential `BufferEvent::Insert` event will be merged together to cut down the number of\n    /// `Editor::commit_delta` calls we need to make when playing back.\n    pub(crate) fn record(&mut self, current_event: EventDomain) {\n        assert!(self.is_recording());\n\n        let recording_buffer = &mut self.recording_buffer;\n\n        if recording_buffer.last().is_none() {\n            recording_buffer.push(current_event);\n            return;\n        }\n\n        {\n            let last_event = recording_buffer.last_mut().unwrap();\n            if let (\n                EventDomain::Buffer(BufferEvent::Insert(old_characters)),\n                EventDomain::Buffer(BufferEvent::Insert(new_characters)),\n            ) = (last_event, &current_event)\n            {\n                old_characters.push_str(new_characters);\n                return;\n            }\n        }\n\n        recording_buffer.push(current_event);\n    }\n\n    /// Iterates over a specified recording's buffer and runs the specified action\n    /// on each event.\n    pub(crate) fn play<F>(&self, recording_name: &str, action: F)\n    where\n        F: FnMut(&EventDomain),\n    {\n        let is_current_recording: bool = self\n            .active_recording\n            .as_ref()\n            .map_or(false, |current_recording| current_recording == recording_name);\n\n        if is_current_recording {\n            warn!(\"Cannot play recording while it's currently active!\");\n            return;\n        }\n\n        if let Some(recording) = self.recordings.get(recording_name) {\n            recording.play(action);\n        }\n    }\n\n    /// Completely removes the specified recording from the Recorder\n    pub(crate) fn clear(&mut self, recording_name: &str) {\n        self.recordings.remove(recording_name);\n    }\n\n    /// Cleans the recording buffer by filtering out any undo or redo events and then saving it\n    /// with the specified name.\n    ///\n    /// A recording should not store any undos or redos--\n    /// call this once a recording is 'finalized.'\n    fn save_recording_buffer(&mut self, recording_name: String) {\n        let mut saw_undo = false;\n        let mut saw_redo = false;\n\n        // Walk the recording backwards and remove any undo / redo events\n        let filtered: Vec<EventDomain> = self\n            .recording_buffer\n            .clone()\n            .into_iter()\n            .rev()\n            .filter(|event| {\n                if let EventDomain::Buffer(event) = event {\n                    return match event {\n                        BufferEvent::Undo => {\n                            saw_undo = !saw_redo;\n                            saw_redo = false;\n                            false\n                        }\n                        BufferEvent::Redo => {\n                            saw_redo = !saw_undo;\n                            saw_undo = false;\n                            false\n                        }\n                        _ => {\n                            let ret = !saw_undo;\n                            saw_undo = false;\n                            saw_redo = false;\n                            ret\n                        }\n                    };\n                }\n\n                true\n            })\n            .collect::<Vec<EventDomain>>()\n            .into_iter()\n            .rev()\n            .collect();\n\n        let current_recording = Recording::new(filtered);\n        self.recordings.insert(recording_name, current_recording);\n        self.recording_buffer.clear();\n    }\n}"],"recorder::Recording":["impl Recording {\n    fn new(events: Vec<EventDomain>) -> Recording {\n        Recording { events }\n    }\n\n    /// Iterates over the recording buffer and runs the specified action\n    /// on each event.\n    fn play<F>(&self, action: F)\n    where\n        F: FnMut(&EventDomain),\n    {\n        let _guard = trace_block(\"Recording::play\", &[\"core\", \"recording\"]);\n        self.events.iter().for_each(action)\n    }\n}"],"rpc::CoreNotification":["Debug","Deserialize","PartialEq","Serialize"],"rpc::CoreRequest":["Debug","Deserialize","PartialEq","Serialize"],"rpc::EditCommand":["Clone","Debug","PartialEq","impl<'de, T: Deserialize<'de>> Deserialize<'de> for EditCommand<T> {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        #[derive(Deserialize)]\n        struct InnerId {\n            view_id: ViewId,\n        }\n\n        let mut v = Value::deserialize(deserializer)?;\n        let helper = InnerId::deserialize(&v).map_err(de::Error::custom)?;\n        let InnerId { view_id } = helper;\n\n        // if params are empty, remove them\n        let remove_params = match v.get(\"params\") {\n            Some(&Value::Object(ref obj)) => obj.is_empty() && T::deserialize(v.clone()).is_err(),\n            Some(&Value::Array(ref arr)) => arr.is_empty() && T::deserialize(v.clone()).is_err(),\n            Some(_) => {\n                return Err(de::Error::custom(\n                    \"'params' field, if present, must be object or array.\",\n                ));\n            }\n            None => false,\n        };\n\n        if remove_params {\n            v.as_object_mut().map(|v| v.remove(\"params\"));\n        }\n\n        let cmd = T::deserialize(v).map_err(de::Error::custom)?;\n        Ok(EditCommand { view_id, cmd })\n    }\n}","impl<T: Serialize> Serialize for EditCommand<T> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut v = serde_json::to_value(&self.cmd).map_err(ser::Error::custom)?;\n        v[\"view_id\"] = json!(self.view_id);\n        v.serialize(serializer)\n    }\n}"],"rpc::EditNotification":["Debug","Deserialize","PartialEq","Serialize"],"rpc::EditRequest":["Debug","Deserialize","PartialEq","Serialize"],"rpc::EmptyStruct":["Debug","Deserialize","PartialEq","Serialize"],"rpc::FindQuery":["Clone","Debug","Deserialize","Eq","PartialEq","Serialize"],"rpc::GestureType":["Clone","Copy","Debug","Deserialize","Eq","PartialEq","Serialize"],"rpc::LineRange":["Clone","Debug","Eq","PartialEq","impl Serialize for LineRange {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let as_tup = (self.first, self.last);\n        as_tup.serialize(serializer)\n    }\n}","impl<'de> Deserialize<'de> for LineRange {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        #[derive(Deserialize)]\n        struct TwoTuple(i64, i64);\n\n        let tup = TwoTuple::deserialize(deserializer)?;\n        Ok(LineRange { first: tup.0, last: tup.1 })\n    }\n}"],"rpc::MouseAction":["Clone","Debug","Eq","PartialEq","impl Serialize for MouseAction {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        #[derive(Serialize)]\n        struct Helper(u64, u64, u64, Option<u64>);\n\n        let as_tup = Helper(self.line, self.column, self.flags, self.click_count);\n        as_tup.serialize(serializer)\n    }\n}","impl<'de> Deserialize<'de> for MouseAction {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let v: Vec<u64> = Vec::deserialize(deserializer)?;\n        let click_count = if v.len() == 4 { Some(v[3]) } else { None };\n        Ok(MouseAction { line: v[0], column: v[1], flags: v[2], click_count })\n    }\n}"],"rpc::PluginNotification":["Debug","Deserialize","PartialEq","Serialize"],"rpc::Position":["Clone","Debug","Deserialize","Eq","PartialEq","Serialize"],"rpc::SelectionGranularity":["Clone","Copy","Debug","Deserialize","Eq","PartialEq","Serialize"],"rpc::SelectionModifier":["Clone","Debug","Deserialize","Eq","PartialEq","Serialize","impl Default for SelectionModifier {\n    fn default() -> SelectionModifier {\n        SelectionModifier::Set\n    }\n}"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor":["Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor":["Deserialize"],"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged":["Serialize"],"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged":["Serialize"],"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged":["Serialize"],"selection::Affinity":["Clone","Copy","Debug","Eq","PartialEq","impl Default for Affinity {\n    fn default() -> Affinity {\n        Affinity::Downstream\n    }\n}"],"selection::InsertDrift":["Clone","Copy"],"selection::SelRegion":["Clone","Copy","Debug","Eq","PartialEq","impl From<Interval> for SelRegion {\n    fn from(src: Interval) -> SelRegion {\n        SelRegion::new(src.start, src.end)\n    }\n}","impl SelRegion {\n    /// Returns a new region.\n    pub fn new(start: usize, end: usize) -> Self {\n        Self { start, end, horiz: None, affinity: Affinity::default() }\n    }\n\n    /// Returns a new caret region (`start == end`).\n    pub fn caret(pos: usize) -> Self {\n        Self { start: pos, end: pos, horiz: None, affinity: Affinity::default() }\n    }\n\n    /// Returns a region with the given horizontal position.\n    pub fn with_horiz(self, horiz: Option<HorizPos>) -> Self {\n        Self { horiz, ..self }\n    }\n\n    /// Returns a region with the given affinity.\n    pub fn with_affinity(self, affinity: Affinity) -> Self {\n        Self { affinity, ..self }\n    }\n\n    /// Gets the earliest offset within the region, ie the minimum of both edges.\n    pub fn min(self) -> usize {\n        min(self.start, self.end)\n    }\n\n    /// Gets the latest offset within the region, ie the maximum of both edges.\n    pub fn max(self) -> usize {\n        max(self.start, self.end)\n    }\n\n    /// Determines whether the region is a caret (ie has an empty interior).\n    pub fn is_caret(self) -> bool {\n        self.start == self.end\n    }\n\n    /// Determines whether the region's affinity is upstream.\n    pub fn is_upstream(self) -> bool {\n        self.affinity == Affinity::Upstream\n    }\n\n    // Indicate whether this region should merge with the next.\n    // Assumption: regions are sorted (self.min() <= other.min())\n    fn should_merge(self, other: SelRegion) -> bool {\n        other.min() < self.max()\n            || ((self.is_caret() || other.is_caret()) && other.min() == self.max())\n    }\n\n    // Merge self with an overlapping region.\n    // Retains direction of self.\n    fn merge_with(self, other: SelRegion) -> SelRegion {\n        let is_forward = self.end >= self.start;\n        let new_min = min(self.min(), other.min());\n        let new_max = max(self.max(), other.max());\n        let (start, end) = if is_forward { (new_min, new_max) } else { (new_max, new_min) };\n        // Could try to preserve horiz/affinity from one of the\n        // sources, but very likely not worth it.\n        SelRegion::new(start, end)\n    }\n}","impl fmt::Display for SelRegion {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.is_caret() {\n            write!(f, \"{}|\", self.start)?;\n        } else if self.start < self.end {\n            write!(f, \"{}..{}|\", self.start, self.end)?;\n        } else {\n            write!(f, \"|{}..{}\", self.end, self.start)?;\n        }\n        Ok(())\n    }\n}"],"selection::Selection":["Clone","Debug","Default","impl Deref for Selection {\n    type Target = [SelRegion];\n\n    fn deref(&self) -> &[SelRegion] {\n        &self.regions\n    }\n}","impl From<SelRegion> for Selection {\n    fn from(region: SelRegion) -> Self {\n        Self::new_simple(region)\n    }\n}","impl Selection {\n    /// Creates a new empty selection.\n    pub fn new() -> Selection {\n        Selection::default()\n    }\n\n    /// Creates a selection with a single region.\n    pub fn new_simple(region: SelRegion) -> Selection {\n        Selection { regions: vec![region] }\n    }\n\n    /// Clear the selection.\n    pub fn clear(&mut self) {\n        self.regions.clear();\n    }\n\n    /// Collapse all selections into a single caret.\n    pub fn collapse(&mut self) {\n        self.regions.truncate(1);\n        self.regions[0].start = self.regions[0].end;\n    }\n\n    // The smallest index so that offset > region.max() for all preceding\n    // regions.\n    pub fn search(&self, offset: usize) -> usize {\n        if self.regions.is_empty() || offset > self.regions.last().unwrap().max() {\n            return self.regions.len();\n        }\n        match self.regions.binary_search_by(|r| r.max().cmp(&offset)) {\n            Ok(ix) => ix,\n            Err(ix) => ix,\n        }\n    }\n\n    /// Add a region to the selection. This method implements merging logic.\n    ///\n    /// Two non-caret regions merge if their interiors intersect; merely\n    /// touching at the edges does not cause a merge. A caret merges with\n    /// a non-caret if it is in the interior or on either edge. Two carets\n    /// merge if they are the same offset.\n    ///\n    /// Performance note: should be O(1) if the new region strictly comes\n    /// after all the others in the selection, otherwise O(n).\n    pub fn add_region(&mut self, region: SelRegion) {\n        let mut ix = self.search(region.min());\n        if ix == self.regions.len() {\n            self.regions.push(region);\n            return;\n        }\n        let mut region = region;\n        let mut end_ix = ix;\n        if self.regions[ix].min() <= region.min() {\n            if self.regions[ix].should_merge(region) {\n                region = region.merge_with(self.regions[ix]);\n            } else {\n                ix += 1;\n            }\n            end_ix += 1;\n        }\n        while end_ix < self.regions.len() && region.should_merge(self.regions[end_ix]) {\n            region = region.merge_with(self.regions[end_ix]);\n            end_ix += 1;\n        }\n        if ix == end_ix {\n            self.regions.insert(ix, region);\n        } else {\n            self.regions[ix] = region;\n            remove_n_at(&mut self.regions, ix + 1, end_ix - ix - 1);\n        }\n    }\n\n    /// Gets a slice of regions that intersect the given range. Regions that\n    /// merely touch the range at the edges are also included, so it is the\n    /// caller's responsibility to further trim them, in particular to only\n    /// display one caret in the upstream/downstream cases.\n    ///\n    /// Performance note: O(log n).\n    pub fn regions_in_range(&self, start: usize, end: usize) -> &[SelRegion] {\n        let first = self.search(start);\n        let mut last = self.search(end);\n        if last < self.regions.len() && self.regions[last].min() <= end {\n            last += 1;\n        }\n        &self.regions[first..last]\n    }\n\n    /// Deletes all the regions that intersect or (if delete_adjacent = true) touch the given range.\n    pub fn delete_range(&mut self, start: usize, end: usize, delete_adjacent: bool) {\n        let mut first = self.search(start);\n        let mut last = self.search(end);\n        if first >= self.regions.len() {\n            return;\n        }\n        if !delete_adjacent && self.regions[first].max() == start {\n            first += 1;\n        }\n        if last < self.regions.len()\n            && ((delete_adjacent && self.regions[last].min() <= end)\n                || (!delete_adjacent && self.regions[last].min() < end))\n        {\n            last += 1;\n        }\n        remove_n_at(&mut self.regions, first, last - first);\n    }\n\n    /// Add a region to the selection. This method does not merge regions and does not allow\n    /// ambiguous regions (regions that overlap).\n    ///\n    /// On ambiguous regions, the region with the lower start position wins. That is, in such a\n    /// case, the new region is either not added at all, because there is an ambiguous region with\n    /// a lower start position, or existing regions that intersect with the new region but do\n    /// not start before the new region, are deleted.\n    pub fn add_range_distinct(&mut self, region: SelRegion) -> (usize, usize) {\n        let mut ix = self.search(region.min());\n\n        if ix < self.regions.len() && self.regions[ix].max() == region.min() {\n            ix += 1;\n        }\n\n        if ix < self.regions.len() {\n            // in case of ambiguous regions the region closer to the left wins\n            let occ = &self.regions[ix];\n            let is_eq = occ.min() == region.min() && occ.max() == region.max();\n            let is_intersect_before = region.min() >= occ.min() && occ.max() > region.min();\n            if is_eq || is_intersect_before {\n                return (occ.min(), occ.max());\n            }\n        }\n\n        // delete ambiguous regions to the right\n        let mut last = self.search(region.max());\n        if last < self.regions.len() && self.regions[last].min() < region.max() {\n            last += 1;\n        }\n        remove_n_at(&mut self.regions, ix, last - ix);\n\n        if ix == self.regions.len() {\n            self.regions.push(region);\n        } else {\n            self.regions.insert(ix, region);\n        }\n\n        (self.regions[ix].min(), self.regions[ix].max())\n    }\n\n    /// Computes a new selection based on applying a delta to the old selection.\n    ///\n    /// When new text is inserted at a caret, the new caret can be either before\n    /// or after the inserted text, depending on the `after` parameter.\n    ///\n    /// Whether or not the preceding selections are restored depends on the keep_selections\n    /// value (only set to true on transpose).\n    pub fn apply_delta(&self, delta: &RopeDelta, after: bool, drift: InsertDrift) -> Selection {\n        let mut result = Selection::new();\n        let mut transformer = Transformer::new(delta);\n        for region in self.iter() {\n            let is_caret = region.start == region.end;\n            let is_region_forward = region.start < region.end;\n\n            let (start_after, end_after) = match (drift, is_caret) {\n                (InsertDrift::Inside, false) => (!is_region_forward, is_region_forward),\n                (InsertDrift::Outside, false) => (is_region_forward, !is_region_forward),\n                _ => (after, after),\n            };\n\n            let new_region = SelRegion::new(\n                transformer.transform(region.start, start_after),\n                transformer.transform(region.end, end_after),\n            )\n            .with_affinity(region.affinity);\n            result.add_region(new_region);\n        }\n        result\n    }\n}","impl ToAnnotation for Selection {\n    fn get_annotations(&self, interval: Interval, view: &View, text: &Rope) -> AnnotationSlice {\n        let regions = self.regions_in_range(interval.start(), interval.end());\n        let ranges = regions\n            .iter()\n            .map(|region| {\n                let (start_line, start_col) = view.offset_to_line_col(text, region.min());\n                let (end_line, end_col) = view.offset_to_line_col(text, region.max());\n\n                AnnotationRange { start_line, start_col, end_line, end_col }\n            })\n            .collect::<Vec<AnnotationRange>>();\n        AnnotationSlice::new(AnnotationType::Selection, ranges, None)\n    }\n}","impl fmt::Display for Selection {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.regions.len() == 1 {\n            self.regions[0].fmt(f)?;\n        } else {\n            write!(f, \"[ {}\", &self.regions[0])?;\n            for region in &self.regions[1..] {\n                write!(f, \", {}\", region)?;\n            }\n            write!(f, \" ]\")?;\n        }\n        Ok(())\n    }\n}"],"styles::Style":["Clone","Default","Deserialize","Eq","Hash","PartialEq","Serialize","impl Style {\n    /// Creates a new `Style` by converting from a `Syntect::StyleModifier`.\n    pub fn from_syntect_style_mod(style: &SynStyleModifier) -> Self {\n        let font_style = style.font_style.map(|s| s.bits()).unwrap_or_default();\n        let weight = if (font_style & 1) != 0 { Some(700) } else { None };\n        let underline = if (font_style & 2) != 0 { Some(true) } else { None };\n        let italic = if (font_style & 4) != 0 { Some(true) } else { None };\n\n        Self::new(\n            SYNTAX_PRIORITY_DEFAULT,\n            style.foreground.map(Self::rgba_from_syntect_color),\n            style.background.map(Self::rgba_from_syntect_color),\n            weight,\n            underline,\n            italic,\n        )\n    }\n\n    pub fn new<O32, O16, OB>(\n        priority: u16,\n        fg_color: O32,\n        bg_color: O32,\n        weight: O16,\n        underline: OB,\n        italic: OB,\n    ) -> Self\n    where\n        O32: Into<Option<u32>>,\n        O16: Into<Option<u16>>,\n        OB: Into<Option<bool>>,\n    {\n        assert!(priority <= 1000);\n        Style {\n            priority,\n            fg_color: fg_color.into(),\n            bg_color: bg_color.into(),\n            weight: weight.into(),\n            underline: underline.into(),\n            italic: italic.into(),\n        }\n    }\n\n    /// Returns the default style for the given `Theme`.\n    pub fn default_for_theme(theme: &Theme) -> Self {\n        let fg = theme.settings.foreground.unwrap_or(Color::BLACK);\n        Style::new(\n            SYNTAX_PRIORITY_LOWEST,\n            Some(Self::rgba_from_syntect_color(fg)),\n            None,\n            None,\n            None,\n            None,\n        )\n    }\n\n    /// Creates a new style by combining attributes of `self` and `other`.\n    /// If both styles define an attribute, the highest priority wins; `other`\n    /// wins in the case of a tie.\n    ///\n    /// Note: when merging multiple styles, apply them in increasing priority.\n    pub fn merge(&self, other: &Style) -> Style {\n        let (p1, p2) = if self.priority > other.priority { (self, other) } else { (other, self) };\n\n        Style::new(\n            p1.priority,\n            p1.fg_color.or(p2.fg_color),\n            p1.bg_color.or(p2.bg_color),\n            p1.weight.or(p2.weight),\n            p1.underline.or(p2.underline),\n            p1.italic.or(p2.italic),\n        )\n    }\n\n    /// Encode this `Style`, setting the `id` property.\n    ///\n    /// Note: this should only be used when sending the `def_style` RPC.\n    pub fn to_json(&self, id: usize) -> Value {\n        let mut as_val = serde_json::to_value(self).expect(\"failed to encode style\");\n        as_val[\"id\"] = id.into();\n        as_val\n    }\n\n    fn rgba_from_syntect_color(color: Color) -> u32 {\n        let Color { r, g, b, a } = color;\n        ((a as u32) << 24) | ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)\n    }\n}","impl fmt::Debug for Style {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fn fmt_color(f: &mut fmt::Formatter, c: Option<u32>) -> fmt::Result {\n            if let Some(c) = c {\n                write!(f, \"#{:X}\", c)\n            } else {\n                write!(f, \"None\")\n            }\n        }\n\n        write!(f, \"Style( P{}, fg: \", self.priority)?;\n        fmt_color(f, self.fg_color)?;\n        write!(f, \" bg: \")?;\n        fmt_color(f, self.bg_color)?;\n\n        if let Some(w) = self.weight {\n            write!(f, \" weight {}\", w)?;\n        }\n        if let Some(i) = self.italic {\n            write!(f, \" ital: {}\", i)?;\n        }\n        if let Some(u) = self.underline {\n            write!(f, \" uline: {}\", u)?;\n        }\n        write!(f, \" )\")\n    }\n}"],"styles::ThemeStyleMap":["impl ThemeStyleMap {\n    pub fn new(themes_dir: Option<PathBuf>) -> ThemeStyleMap {\n        let themes = ThemeSet::load_defaults();\n        let theme_name = DEFAULT_THEME.to_owned();\n        let theme = themes.themes.get(&theme_name).expect(\"missing theme\").to_owned();\n        let default_themes = themes.themes.keys().cloned().collect();\n        let default_style = Style::default_for_theme(&theme);\n        let cache_dir = None;\n        let caching_enabled = true;\n\n        ThemeStyleMap {\n            themes,\n            theme_name,\n            theme,\n            default_themes,\n            default_style,\n            map: HashMap::new(),\n            path_map: BTreeMap::new(),\n            styles: Vec::new(),\n            themes_dir,\n            cache_dir,\n            caching_enabled,\n        }\n    }\n\n    pub fn get_default_style(&self) -> &Style {\n        &self.default_style\n    }\n\n    pub fn get_highlighter(&self) -> Highlighter {\n        Highlighter::new(&self.theme)\n    }\n\n    pub fn get_theme_name(&self) -> &str {\n        &self.theme_name\n    }\n\n    pub fn get_theme_settings(&self) -> &ThemeSettings {\n        &self.theme.settings\n    }\n\n    pub fn get_theme_names(&self) -> Vec<String> {\n        self.path_map.keys().chain(self.default_themes.iter()).cloned().collect()\n    }\n\n    pub fn contains_theme(&self, k: &str) -> bool {\n        self.themes.themes.contains_key(k)\n    }\n\n    pub fn set_theme(&mut self, theme_name: &str) -> Result<(), &'static str> {\n        match self.load_theme(theme_name) {\n            Ok(()) => {\n                if let Some(new_theme) = self.themes.themes.get(theme_name) {\n                    self.theme = new_theme.to_owned();\n                    self.theme_name = theme_name.to_owned();\n                    self.default_style = Style::default_for_theme(&self.theme);\n                    self.map = HashMap::new();\n                    self.styles = Vec::new();\n                    Ok(())\n                } else {\n                    Err(\"unknown theme\")\n                }\n            }\n            Err(e) => {\n                error!(\"Encountered error {:?} while trying to load {:?}\", e, theme_name);\n                Err(\"could not load theme\")\n            }\n        }\n    }\n\n    pub fn merge_with_default(&self, style: &Style) -> Style {\n        self.default_style.merge(style)\n    }\n\n    pub fn lookup(&self, style: &Style) -> Option<usize> {\n        self.map.get(style).cloned()\n    }\n\n    pub fn add(&mut self, style: &Style) -> usize {\n        let result = self.styles.len() + N_RESERVED_STYLES;\n        self.map.insert(style.clone(), result);\n        self.styles.push(style.clone());\n        result\n    }\n\n    /// Delete key and the corresponding dump file from the themes map.\n    pub(crate) fn remove_theme(&mut self, path: &Path) -> Option<String> {\n        validate_theme_file(path).ok()?;\n\n        let theme_name = path.file_stem().and_then(OsStr::to_str)?;\n        self.themes.themes.remove(theme_name);\n        self.path_map.remove(theme_name);\n\n        let dump_p = self.get_dump_path(theme_name)?;\n        if dump_p.exists() {\n            let _ = fs::remove_file(dump_p);\n        }\n\n        Some(theme_name.to_string())\n    }\n\n    /// Cache all themes names and their paths inside the given directory.\n    pub(crate) fn load_theme_dir(&mut self) {\n        if let Some(themes_dir) = self.themes_dir.clone() {\n            match ThemeSet::discover_theme_paths(themes_dir) {\n                Ok(themes) => {\n                    self.caching_enabled = self.caching_enabled && self.init_cache_dir();\n                    // We look through the theme folder here and cache their names/paths to a\n                    // path hashmap.\n                    for theme_p in &themes {\n                        match self.load_theme_info_from_path(theme_p) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"Encountered error {:?} loading theme at {:?}\", e, theme_p)\n                            }\n                        }\n                    }\n                }\n                Err(e) => error!(\"Error loading themes dir: {:?}\", e),\n            }\n        }\n    }\n\n    /// A wrapper around `from_dump_file`\n    /// to validate the state of dump file.\n    /// Invalidates if mod time of dump is less\n    /// than the original one.\n    fn try_load_from_dump(&self, theme_p: &Path) -> Option<(String, Theme)> {\n        if !self.caching_enabled {\n            return None;\n        }\n\n        let theme_name = theme_p.file_stem().and_then(OsStr::to_str)?;\n\n        let dump_p = self.get_dump_path(theme_name)?;\n\n        if !&dump_p.exists() {\n            return None;\n        }\n\n        //NOTE: `try_load_from_dump` will return `None` if the file at\n        //`dump_p` or `theme_p` is deleted before the execution of this fn.\n        let mod_t = fs::metadata(&dump_p).and_then(|md| md.modified()).ok()?;\n        let mod_t_orig = fs::metadata(theme_p).and_then(|md| md.modified()).ok()?;\n\n        if mod_t >= mod_t_orig {\n            from_dump_file(&dump_p).ok().map(|t| (theme_name.to_owned(), t))\n        } else {\n            // Delete dump file\n            let _ = fs::remove_file(&dump_p);\n            None\n        }\n    }\n\n    /// Loads a theme's name and its respective path into the theme path map.\n    pub(crate) fn load_theme_info_from_path(\n        &mut self,\n        theme_p: &Path,\n    ) -> Result<String, LoadingError> {\n        validate_theme_file(theme_p)?;\n        let theme_name =\n            theme_p.file_stem().and_then(OsStr::to_str).ok_or(LoadingError::BadPath)?;\n\n        self.path_map.insert(theme_name.to_string(), theme_p.to_path_buf());\n\n        Ok(theme_name.to_owned())\n    }\n\n    /// Loads theme using syntect's `get_theme` fn to our `theme` path map.\n    /// Stores binary dump in a file with `tmdump` extension, only if\n    /// caching is enabled.\n    fn load_theme(&mut self, theme_name: &str) -> Result<(), LoadingError> {\n        // If it is the current theme (the user has edited it), we load it again.\n        // Otherwise, if it's a default theme or the theme has already been loaded, we can move on.\n        if self.contains_theme(theme_name) && self.get_theme_name() != theme_name {\n            return Ok(());\n        }\n        // If we haven't loaded the theme before, we try to load it from the dump if a dump\n        // exists or load it from the theme file itself.\n        let theme_p = &self.path_map.get(theme_name).cloned();\n        if let Some(theme_p) = theme_p {\n            match self.try_load_from_dump(theme_p) {\n                Some((dump_theme_name, dump_theme_data)) => {\n                    self.insert_to_map(dump_theme_name, dump_theme_data);\n                }\n                None => {\n                    let theme = ThemeSet::get_theme(theme_p)?;\n                    if self.caching_enabled {\n                        if let Some(dump_p) = self.get_dump_path(theme_name) {\n                            let _ = dump_to_file(&theme, dump_p);\n                        }\n                    }\n                    self.insert_to_map(theme_name.to_owned(), theme);\n                }\n            }\n            Ok(())\n        } else {\n            Err(LoadingError::BadPath)\n        }\n    }\n\n    fn insert_to_map(&mut self, k: String, v: Theme) {\n        self.themes.themes.insert(k, v);\n    }\n\n    /// Returns dump's path corresponding to the given theme name.\n    fn get_dump_path(&self, theme_name: &str) -> Option<PathBuf> {\n        self.cache_dir.as_ref().map(|p| p.join(theme_name).with_extension(\"tmdump\"))\n    }\n\n    /// Compare the stored file paths in `self.state`\n    /// to the present ones.\n    pub(crate) fn sync_dir(&mut self, dir: Option<&Path>) {\n        if let Some(themes_dir) = dir {\n            if let Ok(paths) = ThemeSet::discover_theme_paths(themes_dir) {\n                let current_state: HashSet<PathBuf> = HashSet::from_iter(paths.into_iter());\n                let maintained_state: HashSet<PathBuf> =\n                    HashSet::from_iter(self.path_map.values().cloned());\n\n                let to_insert = current_state.difference(&maintained_state);\n                for path in to_insert {\n                    let _ = self.load_theme_info_from_path(path);\n                }\n                let to_remove = maintained_state.difference(&current_state);\n                for path in to_remove {\n                    self.remove_theme(path);\n                }\n            }\n        }\n    }\n    /// Creates the cache dir returns true\n    /// if it is successfully initialized or\n    /// already exists.\n    fn init_cache_dir(&mut self) -> bool {\n        self.cache_dir = self.themes_dir.clone().map(|p| p.join(\"cache\"));\n\n        if let Some(ref p) = self.cache_dir {\n            if p.exists() {\n                return true;\n            }\n            fs::DirBuilder::new().create(&p).is_ok()\n        } else {\n            false\n        }\n    }\n}"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":["Deserialize"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor":["Deserialize"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor":["Deserialize"],"syntax::LanguageDefinition":["Clone","Debug","Deserialize","Serialize"],"syntax::LanguageId":["Clone","Debug","Default","Deserialize","Eq","Hash","Ord","PartialEq","PartialOrd","Serialize","impl AsRef<str> for LanguageId {\n    fn as_ref(&self) -> &str {\n        self.0.as_ref()\n    }\n}","impl Borrow<str> for LanguageId {\n    fn borrow(&self) -> &str {\n        &self.0.as_ref()\n    }\n}","impl<'a> From<&'a str> for LanguageId {\n    fn from(src: &'a str) -> LanguageId {\n        LanguageId(Arc::new(src.into()))\n    }\n}"],"syntax::Languages":["Debug","Default","impl Languages {\n    pub fn new(language_defs: &[LanguageDefinition]) -> Self {\n        let mut named = BTreeMap::new();\n        let mut extensions = HashMap::new();\n        for lang in language_defs.iter() {\n            let lang_arc = Arc::new(lang.clone());\n            named.insert(lang.name.clone(), lang_arc.clone());\n            for ext in &lang.extensions {\n                extensions.insert(ext.clone(), lang_arc.clone());\n            }\n        }\n        Languages { named, extensions }\n    }\n\n    pub fn language_for_path(&self, path: &Path) -> Option<Arc<LanguageDefinition>> {\n        path.extension()\n            .or_else(|| path.file_name())\n            .and_then(|ext| self.extensions.get(ext.to_str().unwrap_or_default()))\n            .map(Arc::clone)\n    }\n\n    pub fn language_for_name<S>(&self, name: S) -> Option<Arc<LanguageDefinition>>\n    where\n        S: AsRef<str>,\n    {\n        self.named.get(name.as_ref()).map(Arc::clone)\n    }\n\n    /// Returns a Vec of any `LanguageDefinition`s which exist\n    /// in `self` but not `other`.\n    pub fn difference(&self, other: &Languages) -> Vec<Arc<LanguageDefinition>> {\n        self.named\n            .iter()\n            .filter(|(k, _)| !other.named.contains_key(*k))\n            .map(|(_, v)| v.clone())\n            .collect()\n    }\n\n    pub fn iter(&self) -> impl Iterator<Item = &Arc<LanguageDefinition>> {\n        self.named.values()\n    }\n}"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":["Deserialize"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor":["Deserialize"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor":["Deserialize"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor":["Deserialize"],"tabs::BufferId":["Clone","Copy","Debug","Deserialize","Eq","Hash","Ord","PartialEq","PartialOrd","Serialize","impl BufferId {\n    pub fn new(val: usize) -> Self {\n        BufferId(val)\n    }\n}","impl fmt::Display for BufferId {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"buffer-id-{}\", self.0)\n    }\n}"],"tabs::CoreState":["impl CoreState {\n    /// Called from a plugin's thread after trying to start the plugin.\n    pub(crate) fn plugin_connect(&mut self, plugin: Result<Plugin, io::Error>) {\n        match plugin {\n            Ok(plugin) => {\n                let init_info =\n                    self.iter_groups().map(|mut ctx| ctx.plugin_info()).collect::<Vec<_>>();\n                plugin.initialize(init_info);\n                self.running_plugins.push(plugin);\n            }\n            Err(e) => error!(\"failed to start plugin {:?}\", e),\n        }\n    }\n\n    pub(crate) fn plugin_exit(&mut self, id: PluginId, error: Result<(), ReadError>) {\n        warn!(\"plugin {:?} exited with result {:?}\", id, error);\n        let running_idx = self.running_plugins.iter().position(|p| p.id == id);\n        if let Some(idx) = running_idx {\n            let plugin = self.running_plugins.remove(idx);\n            self.after_stop_plugin(&plugin);\n        }\n    }\n\n    /// Handles the response to a sync update sent to a plugin.\n    pub(crate) fn plugin_update(\n        &mut self,\n        _plugin_id: PluginId,\n        view_id: ViewId,\n        response: Result<Value, xi_rpc::Error>,\n    ) {\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_plugin_update(response);\n        }\n    }\n\n    pub(crate) fn plugin_notification(\n        &mut self,\n        _ctx: &RpcCtx,\n        view_id: ViewId,\n        plugin_id: PluginId,\n        cmd: PluginNotification,\n    ) {\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_plugin_cmd(plugin_id, cmd)\n        }\n    }\n\n    pub(crate) fn plugin_request(\n        &mut self,\n        _ctx: &RpcCtx,\n        view_id: ViewId,\n        plugin_id: PluginId,\n        cmd: PluginRequest,\n    ) -> Result<Value, RemoteError> {\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            Ok(edit_ctx.do_plugin_cmd_sync(plugin_id, cmd))\n        } else {\n            Err(RemoteError::custom(404, \"missing view\", None))\n        }\n    }\n}","impl CoreState {\n    /// Creates an `EventContext` for the provided `ViewId`. This context\n    /// holds references to the `Editor` and `View` backing this `ViewId`,\n    /// as well as to sibling views, plugins, and other state necessary\n    /// for handling most events.\n    pub(crate) fn make_context(&self, view_id: ViewId) -> Option<EventContext> {\n        self.views.get(&view_id).map(|view| {\n            let buffer_id = view.borrow().get_buffer_id();\n\n            let editor = &self.editors[&buffer_id];\n            let info = self.file_manager.get_info(buffer_id);\n            let plugins = self.running_plugins.iter().collect::<Vec<_>>();\n            let config = self.config_manager.get_buffer_config(buffer_id);\n            let language = self.config_manager.get_buffer_language(buffer_id);\n\n            EventContext {\n                view_id,\n                buffer_id,\n                view,\n                editor,\n                config: &config.items,\n                recorder: &self.recorder,\n                language,\n                info,\n                siblings: Vec::new(),\n                plugins,\n                client: &self.peer,\n                style_map: &self.style_map,\n                width_cache: &self.width_cache,\n                kill_ring: &self.kill_ring,\n                weak_core: self.self_ref.as_ref().unwrap(),\n            }\n        })\n    }\n\n    /// Produces an iterator over all event contexts, with each view appearing\n    /// exactly once.\n    fn iter_groups<'a>(&'a self) -> Iter<'a, Box<dyn Iterator<Item = &ViewId> + 'a>> {\n        Iter { views: Box::new(self.views.keys()), seen: HashSet::new(), inner: self }\n    }\n\n    pub(crate) fn client_notification(&mut self, cmd: CoreNotification) {\n        use self::CoreNotification::*;\n        use self::CorePluginNotification as PN;\n        match cmd {\n            Edit(crate::rpc::EditCommand { view_id, cmd }) => self.do_edit(view_id, cmd),\n            Save { view_id, file_path } => self.do_save(view_id, file_path),\n            CloseView { view_id } => self.do_close_view(view_id),\n            ModifyUserConfig { domain, changes } => self.do_modify_user_config(domain, changes),\n            SetTheme { theme_name } => self.do_set_theme(&theme_name),\n            SaveTrace { destination, frontend_samples } => {\n                self.save_trace(&destination, frontend_samples)\n            }\n            Plugin(cmd) => match cmd {\n                PN::Start { view_id, plugin_name } => self.do_start_plugin(view_id, &plugin_name),\n                PN::Stop { view_id, plugin_name } => self.do_stop_plugin(view_id, &plugin_name),\n                PN::PluginRpc { view_id, receiver, rpc } => {\n                    self.do_plugin_rpc(view_id, &receiver, &rpc.method, &rpc.params)\n                }\n            },\n            TracingConfig { enabled } => self.toggle_tracing(enabled),\n            // handled at the top level\n            ClientStarted { .. } => (),\n            SetLanguage { view_id, language_id } => self.do_set_language(view_id, language_id),\n        }\n    }\n\n    pub(crate) fn client_request(&mut self, cmd: CoreRequest) -> Result<Value, RemoteError> {\n        use self::CoreRequest::*;\n        match cmd {\n            //TODO: make file_path be an Option<PathBuf>\n            //TODO: make this a notification\n            NewView { file_path } => self.do_new_view(file_path.map(PathBuf::from)),\n            Edit(crate::rpc::EditCommand { view_id, cmd }) => self.do_edit_sync(view_id, cmd),\n            //TODO: why is this a request?? make a notification?\n            GetConfig { view_id } => self.do_get_config(view_id).map(|c| json!(c)),\n            DebugGetContents { view_id } => self.do_get_contents(view_id).map(|c| json!(c)),\n        }\n    }\n\n    fn do_edit(&mut self, view_id: ViewId, cmd: EditNotification) {\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_edit(cmd);\n        }\n    }\n\n    fn do_edit_sync(&mut self, view_id: ViewId, cmd: EditRequest) -> Result<Value, RemoteError> {\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_edit_sync(cmd)\n        } else {\n            // TODO: some custom error tpye that can Into<RemoteError>\n            Err(RemoteError::custom(404, format!(\"missing view {:?}\", view_id), None))\n        }\n    }\n\n    fn do_new_view(&mut self, path: Option<PathBuf>) -> Result<Value, RemoteError> {\n        let view_id = self.next_view_id();\n        let buffer_id = self.next_buffer_id();\n\n        let rope = match path.as_ref() {\n            Some(p) => self.file_manager.open(p, buffer_id)?,\n            None => Rope::from(\"\"),\n        };\n\n        let editor = RefCell::new(Editor::with_text(rope));\n        let view = RefCell::new(View::new(view_id, buffer_id));\n\n        self.editors.insert(buffer_id, editor);\n        self.views.insert(view_id, view);\n\n        let config = self.config_manager.add_buffer(buffer_id, path.as_deref());\n\n        // NOTE: because this is a synchronous call, we have to initialize the\n        // view and return the view_id before we can send any events to this\n        // view. We call view_init(), mark the view as pending and schedule the\n        // idle handler so that we can finish setting up this view on the next\n        // runloop pass, in finalize_new_views.\n\n        let mut edit_ctx = self.make_context(view_id).unwrap();\n        edit_ctx.view_init();\n\n        self.pending_views.push((view_id, config));\n        self.peer.schedule_idle(NEW_VIEW_IDLE_TOKEN);\n\n        Ok(json!(view_id))\n    }\n\n    fn do_save<P>(&mut self, view_id: ViewId, path: P)\n    where\n        P: AsRef<Path>,\n    {\n        let _t = trace_block(\"CoreState::do_save\", &[\"core\"]);\n        let path = path.as_ref();\n        let buffer_id = self.views.get(&view_id).map(|v| v.borrow().get_buffer_id());\n        let buffer_id = match buffer_id {\n            Some(id) => id,\n            None => return,\n        };\n\n        let mut save_ctx = self.make_context(view_id).unwrap();\n        let fin_text = save_ctx.text_for_save();\n\n        if let Err(e) = self.file_manager.save(path, &fin_text, buffer_id) {\n            let error_message = e.to_string();\n            error!(\"File error: {:?}\", error_message);\n            self.peer.alert(error_message);\n            return;\n        }\n\n        let changes = self.config_manager.update_buffer_path(buffer_id, path);\n        let language = self.config_manager.get_buffer_language(buffer_id);\n\n        self.make_context(view_id).unwrap().after_save(path);\n        self.make_context(view_id).unwrap().language_changed(&language);\n\n        // update the config _after_ sending save related events\n        if let Some(changes) = changes {\n            self.make_context(view_id).unwrap().config_changed(&changes);\n        }\n    }\n\n    fn do_close_view(&mut self, view_id: ViewId) {\n        let close_buffer = self.make_context(view_id).map(|ctx| ctx.close_view()).unwrap_or(true);\n\n        let buffer_id = self.views.remove(&view_id).map(|v| v.borrow().get_buffer_id());\n\n        if let Some(buffer_id) = buffer_id {\n            if close_buffer {\n                self.editors.remove(&buffer_id);\n                self.file_manager.close(buffer_id);\n                self.config_manager.remove_buffer(buffer_id);\n            }\n        }\n    }\n\n    fn do_set_theme(&self, theme_name: &str) {\n        //Set only if requested theme is different from the\n        //current one.\n        if theme_name != self.style_map.borrow().get_theme_name() {\n            if let Err(e) = self.style_map.borrow_mut().set_theme(&theme_name) {\n                error!(\"error setting theme: {:?}, {:?}\", theme_name, e);\n                return;\n            }\n        }\n        self.notify_client_and_update_views();\n    }\n\n    fn notify_client_and_update_views(&self) {\n        {\n            let style_map = self.style_map.borrow();\n            self.peer.theme_changed(style_map.get_theme_name(), style_map.get_theme_settings());\n        }\n\n        self.iter_groups().for_each(|mut edit_ctx| {\n            edit_ctx.with_editor(|ed, view, _, _| {\n                ed.theme_changed(&self.style_map.borrow());\n                view.set_dirty(ed.get_buffer());\n            });\n            edit_ctx.render_if_needed();\n        });\n    }\n\n    /// Updates the config for a given domain.\n    fn do_modify_user_config(&mut self, domain: ConfigDomainExternal, changes: Table) {\n        // the client sends ViewId but we need BufferId so we do a dance\n        let domain: ConfigDomain = match domain {\n            ConfigDomainExternal::General => ConfigDomain::General,\n            ConfigDomainExternal::Syntax(id) => ConfigDomain::Language(id),\n            ConfigDomainExternal::Language(id) => ConfigDomain::Language(id),\n            ConfigDomainExternal::UserOverride(view_id) => match self.views.get(&view_id) {\n                Some(v) => ConfigDomain::UserOverride(v.borrow().get_buffer_id()),\n                None => return,\n            },\n        };\n        let new_config = self.config_manager.table_for_update(domain.clone(), changes);\n        self.set_config(domain, new_config);\n    }\n\n    fn do_get_config(&self, view_id: ViewId) -> Result<Table, RemoteError> {\n        let _t = trace_block(\"CoreState::get_config\", &[\"core\"]);\n        self.views\n            .get(&view_id)\n            .map(|v| v.borrow().get_buffer_id())\n            .map(|id| self.config_manager.get_buffer_config(id).to_table())\n            .ok_or(RemoteError::custom(404, format!(\"missing {}\", view_id), None))\n    }\n\n    fn do_get_contents(&self, view_id: ViewId) -> Result<Rope, RemoteError> {\n        self.make_context(view_id)\n            .map(|ctx| ctx.editor.borrow().get_buffer().to_owned())\n            .ok_or_else(|| RemoteError::custom(404, format!(\"No view for id {}\", view_id), None))\n    }\n\n    fn do_set_language(&mut self, view_id: ViewId, language_id: LanguageId) {\n        if let Some(view) = self.views.get(&view_id) {\n            let buffer_id = view.borrow().get_buffer_id();\n            let changes = self.config_manager.override_language(buffer_id, language_id.clone());\n\n            let mut context = self.make_context(view_id).unwrap();\n            context.language_changed(&language_id);\n            if let Some(changes) = changes {\n                context.config_changed(&changes);\n            }\n        }\n    }\n\n    fn do_start_plugin(&mut self, _view_id: ViewId, plugin: &str) {\n        if self.running_plugins.iter().any(|p| p.name == plugin) {\n            info!(\"plugin {} already running\", plugin);\n            return;\n        }\n\n        if let Some(manifest) = self.plugins.get_named(plugin) {\n            //TODO: lots of races possible here, we need to keep track of\n            //pending launches.\n            start_plugin_process(\n                manifest,\n                self.next_plugin_id(),\n                self.self_ref.as_ref().unwrap().clone(),\n            );\n        } else {\n            warn!(\"no plugin found with name '{}'\", plugin);\n        }\n    }\n\n    fn do_stop_plugin(&mut self, _view_id: ViewId, plugin: &str) {\n        if let Some(p) = self\n            .running_plugins\n            .iter()\n            .position(|p| p.name == plugin)\n            .map(|ix| self.running_plugins.remove(ix))\n        {\n            //TODO: verify shutdown; kill if necessary\n            p.shutdown();\n            self.after_stop_plugin(&p);\n        }\n    }\n\n    fn do_plugin_rpc(&self, view_id: ViewId, receiver: &str, method: &str, params: &Value) {\n        self.running_plugins\n            .iter()\n            .filter(|p| p.name == receiver)\n            .for_each(|p| p.dispatch_command(view_id, method, params))\n    }\n\n    fn after_stop_plugin(&mut self, plugin: &Plugin) {\n        self.iter_groups().for_each(|mut cx| cx.plugin_stopped(plugin));\n    }\n}","impl CoreState {\n    pub fn _test_open_editors(&self) -> Vec<BufferId> {\n        self.editors.keys().cloned().collect()\n    }\n\n    pub fn _test_open_views(&self) -> Vec<ViewId> {\n        self.views.keys().cloned().collect()\n    }\n}","impl CoreState {\n    pub(crate) fn handle_idle(&mut self, token: usize) {\n        match token {\n            NEW_VIEW_IDLE_TOKEN => self.finalize_new_views(),\n            WATCH_IDLE_TOKEN => self.handle_fs_events(),\n            other if (other & RENDER_VIEW_IDLE_MASK) != 0 => {\n                self.handle_render_timer(other ^ RENDER_VIEW_IDLE_MASK)\n            }\n            other if (other & REWRAP_VIEW_IDLE_MASK) != 0 => {\n                self.handle_rewrap_callback(other ^ REWRAP_VIEW_IDLE_MASK)\n            }\n            other if (other & FIND_VIEW_IDLE_MASK) != 0 => {\n                self.handle_find_callback(other ^ FIND_VIEW_IDLE_MASK)\n            }\n            other => panic!(\"unexpected idle token {}\", other),\n        };\n    }\n\n    fn finalize_new_views(&mut self) {\n        let to_start = mem::replace(&mut self.pending_views, Vec::new());\n\n        to_start.iter().for_each(|(id, config)| {\n            let modified = self.detect_whitespace(*id, config);\n            let config = modified.as_ref().unwrap_or(config);\n            let mut edit_ctx = self.make_context(*id).unwrap();\n            edit_ctx.finish_init(&config);\n        });\n    }\n\n    // Detects whitespace settings from the file and merges them with the config\n    fn detect_whitespace(&mut self, id: ViewId, config: &Table) -> Option<Table> {\n        let buffer_id = self.views.get(&id).map(|v| v.borrow().get_buffer_id())?;\n        let editor = self\n            .editors\n            .get(&buffer_id)\n            .expect(\"existing buffer_id must have corresponding editor\");\n\n        if editor.borrow().get_buffer().is_empty() {\n            return None;\n        }\n\n        let autodetect_whitespace =\n            self.config_manager.get_buffer_config(buffer_id).items.autodetect_whitespace;\n        if !autodetect_whitespace {\n            return None;\n        }\n\n        let mut changes = Table::new();\n        let indentation = Indentation::parse(editor.borrow().get_buffer());\n        match indentation {\n            Ok(Some(Indentation::Tabs)) => {\n                changes.insert(\"translate_tabs_to_spaces\".into(), false.into());\n            }\n            Ok(Some(Indentation::Spaces(n))) => {\n                changes.insert(\"translate_tabs_to_spaces\".into(), true.into());\n                changes.insert(\"tab_size\".into(), n.into());\n            }\n            Err(_) => info!(\"detected mixed indentation\"),\n            Ok(None) => info!(\"file contains no indentation\"),\n        }\n\n        let line_ending = LineEnding::parse(editor.borrow().get_buffer());\n        match line_ending {\n            Ok(Some(LineEnding::CrLf)) => {\n                changes.insert(\"line_ending\".into(), \"\\r\\n\".into());\n            }\n            Ok(Some(LineEnding::Lf)) => {\n                changes.insert(\"line_ending\".into(), \"\\n\".into());\n            }\n            Err(_) => info!(\"detected mixed line endings\"),\n            Ok(None) => info!(\"file contains no supported line endings\"),\n        }\n\n        let config_delta =\n            self.config_manager.table_for_update(ConfigDomain::SysOverride(buffer_id), changes);\n        match self\n            .config_manager\n            .set_user_config(ConfigDomain::SysOverride(buffer_id), config_delta)\n        {\n            Ok(ref mut items) if !items.is_empty() => {\n                assert!(\n                    items.len() == 1,\n                    \"whitespace overrides can only update a single buffer's config\\n{:?}\",\n                    items\n                );\n                let table = items.remove(0).1;\n                let mut config = config.clone();\n                config.extend(table);\n                Some(config)\n            }\n            Ok(_) => {\n                warn!(\"set_user_config failed to update config, no tables were returned\");\n                None\n            }\n            Err(err) => {\n                warn!(\"detect_whitespace failed to update config: {:?}\", err);\n                None\n            }\n        }\n    }\n\n    fn handle_render_timer(&mut self, token: usize) {\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx._finish_delayed_render();\n        }\n    }\n\n    /// Callback for doing word wrap on a view\n    fn handle_rewrap_callback(&mut self, token: usize) {\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx.do_rewrap_batch();\n        }\n    }\n\n    /// Callback for doing incremental find in a view\n    fn handle_find_callback(&mut self, token: usize) {\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx.do_incremental_find();\n        }\n    }\n\n    #[cfg(feature = \"notify\")]\n    fn handle_fs_events(&mut self) {\n        let _t = trace_block(\"CoreState::handle_fs_events\", &[\"core\"]);\n        let mut events = self.file_manager.watcher().take_events();\n\n        for (token, event) in events.drain(..) {\n            match token {\n                OPEN_FILE_EVENT_TOKEN => self.handle_open_file_fs_event(event),\n                CONFIG_EVENT_TOKEN => self.handle_config_fs_event(event),\n                THEME_FILE_EVENT_TOKEN => self.handle_themes_fs_event(event),\n                PLUGIN_EVENT_TOKEN => self.handle_plugin_fs_event(event),\n                _ => warn!(\"unexpected fs event token {:?}\", token),\n            }\n        }\n    }\n\n    #[cfg(not(feature = \"notify\"))]\n    fn handle_fs_events(&mut self) {}\n\n    /// Handles a file system event related to a currently open file\n    #[cfg(feature = \"notify\")]\n    fn handle_open_file_fs_event(&mut self, event: Event) {\n        use notify::event::*;\n        let path = match event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Modify(ModifyKind::Any) => &event.paths[0],\n            other => {\n                debug!(\"Ignoring event in open file {:?}\", other);\n                return;\n            }\n        };\n\n        let buffer_id = match self.file_manager.get_editor(path) {\n            Some(id) => id,\n            None => return,\n        };\n\n        let has_changes = self.file_manager.check_file(path, buffer_id);\n        let is_pristine = self.editors.get(&buffer_id).map(|ed| ed.borrow().is_pristine()).unwrap();\n        //TODO: currently we only use the file's modification time when\n        // determining if a file has been changed by another process.\n        // A more robust solution would also hash the file's contents.\n\n        if has_changes && is_pristine {\n            if let Ok(text) = self.file_manager.open(path, buffer_id) {\n                // this is ugly; we don't map buffer_id -> view_id anywhere\n                // but we know we must have a view.\n                let view_id = self\n                    .views\n                    .values()\n                    .find(|v| v.borrow().get_buffer_id() == buffer_id)\n                    .map(|v| v.borrow().get_view_id())\n                    .unwrap();\n                self.make_context(view_id).unwrap().reload(text);\n            }\n        }\n    }\n\n    /// Handles a config related file system event.\n    #[cfg(feature = \"notify\")]\n    fn handle_config_fs_event(&mut self, event: Event) {\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Modify(ModifyKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any)) => {\n                self.load_file_based_config(&event.paths[0])\n            }\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                self.remove_config_at_path(&event.paths[0])\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                self.remove_config_at_path(&event.paths[0]);\n                self.load_file_based_config(&event.paths[1]);\n            }\n            _ => (),\n        }\n    }\n\n    fn remove_config_at_path(&mut self, path: &Path) {\n        if let Some(domain) = self.config_manager.domain_for_path(path) {\n            self.set_config(domain, Table::default());\n        }\n    }\n\n    /// Handles changes in plugin files.\n    #[cfg(feature = \"notify\")]\n    fn handle_plugin_fs_event(&mut self, event: Event) {\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any) | EventKind::Modify(ModifyKind::Any) => {\n                self.plugins.load_from_paths(&[event.paths[0].clone()]);\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_start_plugin(ViewId(0), &plugin.name);\n                }\n            }\n            // the way FSEvents on macOS work, we want to verify that this path\n            // has actually be removed before we do anything.\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_stop_plugin(ViewId(0), &plugin.name);\n                    self.plugins.remove_named(&plugin.name);\n                }\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                let old = &event.paths[0];\n                let new = &event.paths[1];\n                if let Some(old_plugin) = self.plugins.get_from_path(old) {\n                    self.do_stop_plugin(ViewId(0), &old_plugin.name);\n                    self.plugins.remove_named(&old_plugin.name);\n                }\n\n                self.plugins.load_from_paths(&[new.clone()]);\n                if let Some(new_plugin) = self.plugins.get_from_path(new) {\n                    self.do_start_plugin(ViewId(0), &new_plugin.name);\n                }\n            }\n            EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Remove(RemoveKind::Any) => {\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_stop_plugin(ViewId(0), &plugin.name);\n                    self.do_start_plugin(ViewId(0), &plugin.name);\n                }\n            }\n            _ => (),\n        }\n\n        self.views.keys().for_each(|view_id| {\n            let available_plugins = self\n                .plugins\n                .iter()\n                .map(|plugin| ClientPluginInfo { name: plugin.name.clone(), running: true })\n                .collect::<Vec<_>>();\n            self.peer.available_plugins(*view_id, &available_plugins);\n        });\n    }\n\n    /// Handles changes in theme files.\n    #[cfg(feature = \"notify\")]\n    fn handle_themes_fs_event(&mut self, event: Event) {\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any) | EventKind::Modify(ModifyKind::Any) => {\n                self.load_theme_file(&event.paths[0])\n            }\n            // the way FSEvents on macOS work, we want to verify that this path\n            // has actually be removed before we do anything.\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                self.remove_theme(&event.paths[0]);\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                let old = &event.paths[0];\n                let new = &event.paths[1];\n                self.remove_theme(old);\n                self.load_theme_file(new);\n            }\n            EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Remove(RemoveKind::Any) => {\n                self.style_map.borrow_mut().sync_dir(event.paths[0].parent())\n            }\n            _ => (),\n        }\n        let theme_names = self.style_map.borrow().get_theme_names();\n        self.peer.available_themes(theme_names);\n    }\n\n    /// Load a single theme file. Updates if already present.\n    fn load_theme_file(&mut self, path: &Path) {\n        let _t = trace_block(\"CoreState::load_theme_file\", &[\"core\"]);\n\n        let result = self.style_map.borrow_mut().load_theme_info_from_path(path);\n        match result {\n            Ok(theme_name) => {\n                if theme_name == self.style_map.borrow().get_theme_name() {\n                    if self.style_map.borrow_mut().set_theme(&theme_name).is_ok() {\n                        self.notify_client_and_update_views();\n                    }\n                }\n            }\n            Err(e) => error!(\"Error loading theme file: {:?}, {:?}\", path, e),\n        }\n    }\n\n    fn remove_theme(&mut self, path: &Path) {\n        let result = self.style_map.borrow_mut().remove_theme(path);\n\n        // Set default theme if the removed theme was the\n        // current one.\n        if let Some(theme_name) = result {\n            if theme_name == self.style_map.borrow().get_theme_name() {\n                self.do_set_theme(DEFAULT_THEME);\n            }\n        }\n    }\n\n    fn toggle_tracing(&self, enabled: bool) {\n        self.running_plugins.iter().for_each(|plugin| plugin.toggle_tracing(enabled))\n    }\n\n    fn save_trace<P>(&self, path: P, frontend_samples: Value)\n    where\n        P: AsRef<Path>,\n    {\n        use xi_trace::chrome_trace_dump;\n        let mut all_traces = xi_trace::samples_cloned_unsorted();\n        if let Ok(mut traces) = chrome_trace_dump::decode(frontend_samples) {\n            all_traces.append(&mut traces);\n        }\n\n        for plugin in &self.running_plugins {\n            match plugin.collect_trace() {\n                Ok(json) => {\n                    let mut trace = chrome_trace_dump::decode(json).unwrap();\n                    all_traces.append(&mut trace);\n                }\n                Err(e) => error!(\"trace error {:?}\", e),\n            }\n        }\n\n        all_traces.sort_unstable();\n\n        let mut trace_file = match File::create(path.as_ref()) {\n            Ok(f) => f,\n            Err(e) => {\n                error!(\"error saving trace {:?}\", e);\n                return;\n            }\n        };\n\n        if let Err(e) = chrome_trace_dump::serialize(&all_traces, &mut trace_file) {\n            error!(\"error saving trace {:?}\", e);\n        }\n    }\n}","impl CoreState {\n    pub(crate) fn new(\n        peer: &RpcPeer,\n        config_dir: Option<PathBuf>,\n        extras_dir: Option<PathBuf>,\n    ) -> Self {\n        #[cfg(feature = \"notify\")]\n        let mut watcher = FileWatcher::new(peer.clone());\n\n        if let Some(p) = config_dir.as_ref() {\n            if !p.exists() {\n                if let Err(e) = config::init_config_dir(p) {\n                    //TODO: report this error?\n                    error!(\"error initing file based configs: {:?}\", e);\n                }\n            }\n\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, CONFIG_EVENT_TOKEN, |p| {\n                p.extension().and_then(OsStr::to_str).unwrap_or(\"\") == \"xiconfig\"\n            });\n        }\n\n        let config_manager = ConfigManager::new(config_dir, extras_dir);\n\n        let themes_dir = config_manager.get_themes_dir();\n        if let Some(p) = themes_dir.as_ref() {\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, THEME_FILE_EVENT_TOKEN, |p| {\n                p.extension().and_then(OsStr::to_str).unwrap_or(\"\") == \"tmTheme\"\n            });\n        }\n\n        let plugins_dir = config_manager.get_plugins_dir();\n        if let Some(p) = plugins_dir.as_ref() {\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, PLUGIN_EVENT_TOKEN, |p| p.is_dir() || !p.exists());\n        }\n\n        CoreState {\n            views: BTreeMap::new(),\n            editors: BTreeMap::new(),\n            #[cfg(feature = \"notify\")]\n            file_manager: FileManager::new(watcher),\n            #[cfg(not(feature = \"notify\"))]\n            file_manager: FileManager::new(),\n            kill_ring: RefCell::new(Rope::from(\"\")),\n            style_map: RefCell::new(ThemeStyleMap::new(themes_dir)),\n            width_cache: RefCell::new(WidthCache::new()),\n            config_manager,\n            recorder: RefCell::new(Recorder::new()),\n            self_ref: None,\n            pending_views: Vec::new(),\n            peer: Client::new(peer.clone()),\n            id_counter: Counter::default(),\n            plugins: PluginCatalog::default(),\n            running_plugins: Vec::new(),\n        }\n    }\n\n    fn next_view_id(&self) -> ViewId {\n        ViewId(self.id_counter.next())\n    }\n\n    fn next_buffer_id(&self) -> BufferId {\n        BufferId(self.id_counter.next())\n    }\n\n    fn next_plugin_id(&self) -> PluginId {\n        PluginPid(self.id_counter.next())\n    }\n\n    pub(crate) fn finish_setup(&mut self, self_ref: WeakXiCore) {\n        self.self_ref = Some(self_ref);\n\n        if let Some(path) = self.config_manager.base_config_file_path() {\n            self.load_file_based_config(&path);\n        }\n\n        // Load the custom theme files.\n        self.style_map.borrow_mut().load_theme_dir();\n\n        // instead of having to do this here, config should just own\n        // the plugin catalog and reload automatically\n        let plugin_paths = self.config_manager.get_plugin_paths();\n        self.plugins.reload_from_paths(&plugin_paths);\n        let languages = self.plugins.make_languages_map();\n        let languages_ids = languages.iter().map(|l| l.name.clone()).collect::<Vec<_>>();\n        self.peer.available_languages(languages_ids);\n        self.config_manager.set_languages(languages);\n        let theme_names = self.style_map.borrow().get_theme_names();\n        self.peer.available_themes(theme_names);\n\n        // FIXME: temporary: we just launch every plugin we find at startup\n        for manifest in self.plugins.iter() {\n            start_plugin_process(\n                manifest.clone(),\n                self.next_plugin_id(),\n                self.self_ref.as_ref().unwrap().clone(),\n            );\n        }\n    }\n\n    /// Attempt to load a config file.\n    fn load_file_based_config(&mut self, path: &Path) {\n        let _t = trace_block(\"CoreState::load_config_file\", &[\"core\"]);\n        if let Some(domain) = self.config_manager.domain_for_path(path) {\n            match config::try_load_from_file(&path) {\n                Ok(table) => self.set_config(domain, table),\n                Err(e) => self.peer.alert(e.to_string()),\n            }\n        } else {\n            self.peer.alert(format!(\"Unexpected config file {:?}\", path));\n        }\n    }\n\n    /// Sets (overwriting) the config for a given domain.\n    fn set_config(&mut self, domain: ConfigDomain, table: Table) {\n        match self.config_manager.set_user_config(domain, table) {\n            Err(e) => self.peer.alert(format!(\"{}\", &e)),\n            Ok(changes) => self.handle_config_changes(changes),\n        }\n    }\n\n    /// Notify editors/views/plugins of config changes.\n    fn handle_config_changes(&self, changes: Vec<(BufferId, Table)>) {\n        for (id, table) in changes {\n            let view_id = self\n                .views\n                .values()\n                .find(|v| v.borrow().get_buffer_id() == id)\n                .map(|v| v.borrow().get_view_id())\n                .unwrap();\n\n            self.make_context(view_id).unwrap().config_changed(&table)\n        }\n    }\n}"],"tabs::Counter":["Debug","Default","impl Counter {\n    pub(crate) fn next(&self) -> usize {\n        let n = self.0.get();\n        self.0.set(n + 1);\n        n + 1\n    }\n}"],"tabs::Iter":["impl<'a, I> Iterator for Iter<'a, I>\nwhere\n    I: Iterator<Item = &'a ViewId>,\n{\n    type Item = EventContext<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let &mut Iter { ref mut views, ref mut seen, ref inner } = self;\n        loop {\n            let next_view = match views.next() {\n                None => return None,\n                Some(v) if seen.contains(v) => continue,\n                Some(v) => v,\n            };\n            let context = inner.make_context(*next_view).unwrap();\n            context.siblings.iter().for_each(|sibl| {\n                let _ = seen.insert(sibl.borrow().get_view_id());\n            });\n            return Some(context);\n        }\n    }\n}"],"tabs::ViewId":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<usize> for ViewId {\n    fn from(src: usize) -> ViewId {\n        ViewId(src)\n    }\n}","impl Serialize for ViewId {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(&self.to_string())\n    }\n}","impl fmt::Display for ViewId {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"view-id-{}\", self.0)\n    }\n}","impl<'de> Deserialize<'de> for ViewId {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let s = String::deserialize(deserializer)?;\n        let ord = s.trim_start_matches(\"view-id-\");\n        match usize::from_str_radix(ord, 10) {\n            Ok(id) => Ok(ViewId(id)),\n            Err(_) => Err(de::Error::invalid_value(Unexpected::Str(&s), &\"view id\")),\n        }\n    }\n}"],"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor":["Deserialize"],"view::FindProgress":["Clone","Debug","PartialEq"],"view::FindStatusChange":["Debug","PartialEq"],"view::Replace":["Clone","Debug","Default","Deserialize","PartialEq","Serialize"],"view::Size":["Clone","Debug","Default","Deserialize","PartialEq","Serialize"],"view::View":["impl LineOffset for View {\n    fn offset_of_line(&self, text: &Rope, line: usize) -> usize {\n        self.lines.offset_of_visual_line(text, line)\n    }\n\n    fn line_of_offset(&self, text: &Rope, offset: usize) -> usize {\n        self.lines.visual_line_of_offset(text, offset)\n    }\n}","impl View {\n    /// Exposed for benchmarking\n    #[doc(hidden)]\n    pub fn debug_force_rewrap_cols(&mut self, text: &Rope, cols: usize) {\n        use xi_rpc::test_utils::DummyPeer;\n\n        let spans: Spans<Style> = Spans::default();\n        let mut width_cache = WidthCache::new();\n        let client = Client::new(Box::new(DummyPeer));\n        self.update_wrap_settings(text, cols, false);\n        self.rewrap(text, &mut width_cache, &client, &spans);\n    }\n}","impl View {\n    pub fn new(view_id: ViewId, buffer_id: BufferId) -> View {\n        View {\n            view_id,\n            buffer_id,\n            pending_render: false,\n            selection: SelRegion::caret(0).into(),\n            scroll_to: Some(0),\n            size: Size::default(),\n            drag_state: None,\n            first_line: 0,\n            height: 10,\n            lines: Lines::default(),\n            lc_shadow: LineCacheShadow::default(),\n            find: Vec::new(),\n            find_id_counter: Counter::default(),\n            find_changed: FindStatusChange::None,\n            find_progress: FindProgress::Ready,\n            highlight_find: false,\n            replace: None,\n            replace_changed: false,\n            annotations: AnnotationStore::new(),\n        }\n    }\n\n    pub(crate) fn get_buffer_id(&self) -> BufferId {\n        self.buffer_id\n    }\n\n    pub(crate) fn get_view_id(&self) -> ViewId {\n        self.view_id\n    }\n\n    pub(crate) fn get_lines(&self) -> &Lines {\n        &self.lines\n    }\n\n    pub(crate) fn get_replace(&self) -> Option<Replace> {\n        self.replace.clone()\n    }\n\n    pub(crate) fn set_has_pending_render(&mut self, pending: bool) {\n        self.pending_render = pending\n    }\n\n    pub(crate) fn has_pending_render(&self) -> bool {\n        self.pending_render\n    }\n\n    pub(crate) fn update_wrap_settings(&mut self, text: &Rope, wrap_cols: usize, word_wrap: bool) {\n        let wrap_width = match (word_wrap, wrap_cols) {\n            (true, _) => WrapWidth::Width(self.size.width),\n            (false, 0) => WrapWidth::None,\n            (false, cols) => WrapWidth::Bytes(cols),\n        };\n        self.lines.set_wrap_width(text, wrap_width);\n    }\n\n    pub(crate) fn needs_more_wrap(&self) -> bool {\n        !self.lines.is_converged()\n    }\n\n    pub(crate) fn needs_wrap_in_visible_region(&self, text: &Rope) -> bool {\n        if self.lines.is_converged() {\n            false\n        } else {\n            let visible_region = self.interval_of_visible_region(text);\n            self.lines.interval_needs_wrap(visible_region)\n        }\n    }\n\n    pub(crate) fn find_in_progress(&self) -> bool {\n        match self.find_progress {\n            FindProgress::InProgress(_) => true,\n            FindProgress::Started => true,\n            _ => false,\n        }\n    }\n\n    pub(crate) fn do_edit(&mut self, text: &Rope, cmd: ViewEvent) {\n        use self::ViewEvent::*;\n        match cmd {\n            Move(movement) => self.do_move(text, movement, false),\n            ModifySelection(movement) => self.do_move(text, movement, true),\n            SelectAll => self.select_all(text),\n            Scroll(range) => self.set_scroll(range.first, range.last),\n            AddSelectionAbove => self.add_selection_by_movement(text, Movement::UpExactPosition),\n            AddSelectionBelow => self.add_selection_by_movement(text, Movement::DownExactPosition),\n            Gesture { line, col, ty } => self.do_gesture(text, line, col, ty),\n            GotoLine { line } => self.goto_line(text, line),\n            Find { chars, case_sensitive, regex, whole_words } => {\n                let id = self.find.first().map(|q| q.id());\n                let query_changes = FindQuery { id, chars, case_sensitive, regex, whole_words };\n                self.set_find(text, [query_changes].to_vec())\n            }\n            MultiFind { queries } => self.set_find(text, queries),\n            FindNext { wrap_around, allow_same, modify_selection } => {\n                self.do_find_next(text, false, wrap_around, allow_same, &modify_selection)\n            }\n            FindPrevious { wrap_around, allow_same, modify_selection } => {\n                self.do_find_next(text, true, wrap_around, allow_same, &modify_selection)\n            }\n            FindAll => self.do_find_all(text),\n            Click(MouseAction { line, column, flags, click_count }) => {\n                // Deprecated (kept for client compatibility):\n                // should be removed in favor of do_gesture\n                warn!(\"Usage of click is deprecated; use do_gesture\");\n                if (flags & FLAG_SELECT) != 0 {\n                    self.do_gesture(\n                        text,\n                        line,\n                        column,\n                        GestureType::SelectExtend { granularity: SelectionGranularity::Point },\n                    )\n                } else if click_count == Some(2) {\n                    self.do_gesture(text, line, column, GestureType::WordSelect)\n                } else if click_count == Some(3) {\n                    self.do_gesture(text, line, column, GestureType::LineSelect)\n                } else {\n                    self.do_gesture(text, line, column, GestureType::PointSelect)\n                }\n            }\n            Drag(MouseAction { line, column, .. }) => {\n                warn!(\"Usage of drag is deprecated; use gesture instead\");\n                self.do_gesture(text, line, column, GestureType::Drag)\n            }\n            CollapseSelections => self.collapse_selections(text),\n            HighlightFind { visible } => {\n                self.highlight_find = visible;\n                self.find_changed = FindStatusChange::All;\n                self.set_dirty(text);\n            }\n            SelectionForFind { case_sensitive } => self.do_selection_for_find(text, case_sensitive),\n            Replace { chars, preserve_case } => self.do_set_replace(chars, preserve_case),\n            SelectionForReplace => self.do_selection_for_replace(text),\n            SelectionIntoLines => self.do_split_selection_into_lines(text),\n        }\n    }\n\n    fn do_gesture(&mut self, text: &Rope, line: u64, col: u64, ty: GestureType) {\n        let line = line as usize;\n        let col = col as usize;\n        let offset = self.line_col_to_offset(text, line, col);\n        match ty {\n            GestureType::Select { granularity, multi } => {\n                self.select(text, offset, granularity, multi)\n            }\n            GestureType::SelectExtend { granularity } => {\n                self.extend_selection(text, offset, granularity)\n            }\n            GestureType::Drag => self.do_drag(text, offset, Affinity::default()),\n\n            _ => {\n                warn!(\"Deprecated gesture type sent to do_gesture method\");\n            }\n        }\n    }\n\n    fn goto_line(&mut self, text: &Rope, line: u64) {\n        let offset = self.line_col_to_offset(text, line as usize, 0);\n        self.set_selection(text, SelRegion::caret(offset));\n    }\n\n    pub fn set_size(&mut self, size: Size) {\n        self.size = size;\n    }\n\n    pub fn set_scroll(&mut self, first: i64, last: i64) {\n        let first = max(first, 0) as usize;\n        let last = max(last, 0) as usize;\n        self.first_line = first;\n        self.height = last - first;\n    }\n\n    pub fn scroll_height(&self) -> usize {\n        self.height\n    }\n\n    fn scroll_to_cursor(&mut self, text: &Rope) {\n        let end = self.sel_regions().last().unwrap().end;\n        let line = self.line_of_offset(text, end);\n        if line < self.first_line {\n            self.first_line = line;\n        } else if self.first_line + self.height <= line {\n            self.first_line = line - (self.height - 1);\n        }\n        // We somewhat arbitrarily choose the last region for setting the old-style\n        // selection state, and for scrolling it into view if needed. This choice can\n        // likely be improved.\n        self.scroll_to = Some(end);\n    }\n\n    /// Removes any selection present at the given offset.\n    /// Returns true if a selection was removed, false otherwise.\n    pub fn deselect_at_offset(&mut self, text: &Rope, offset: usize) -> bool {\n        if !self.selection.regions_in_range(offset, offset).is_empty() {\n            let mut sel = self.selection.clone();\n            sel.delete_range(offset, offset, true);\n            if !sel.is_empty() {\n                self.drag_state = None;\n                self.set_selection_raw(text, sel);\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Move the selection by the given movement. Return value is the offset of\n    /// a point that should be scrolled into view.\n    ///\n    /// If `modify` is `true`, the selections are modified, otherwise the results\n    /// of individual region movements become carets.\n    pub fn do_move(&mut self, text: &Rope, movement: Movement, modify: bool) {\n        self.drag_state = None;\n        let new_sel =\n            selection_movement(movement, &self.selection, self, self.scroll_height(), text, modify);\n        self.set_selection(text, new_sel);\n    }\n\n    /// Set the selection to a new value.\n    pub fn set_selection<S: Into<Selection>>(&mut self, text: &Rope, sel: S) {\n        self.set_selection_raw(text, sel.into());\n        self.scroll_to_cursor(text);\n    }\n\n    /// Sets the selection to a new value, without invalidating.\n    fn set_selection_for_edit(&mut self, text: &Rope, sel: Selection) {\n        self.selection = sel;\n        self.scroll_to_cursor(text);\n    }\n\n    /// Sets the selection to a new value, invalidating the line cache as needed.\n    /// This function does not perform any scrolling.\n    fn set_selection_raw(&mut self, text: &Rope, sel: Selection) {\n        self.invalidate_selection(text);\n        self.selection = sel;\n        self.invalidate_selection(text);\n    }\n\n    /// Invalidate the current selection. Note that we could be even more\n    /// fine-grained in the case of multiple cursors, but we also want this\n    /// method to be fast even when the selection is large.\n    fn invalidate_selection(&mut self, text: &Rope) {\n        // TODO: refine for upstream (caret appears on prev line)\n        let first_line = self.line_of_offset(text, self.selection.first().unwrap().min());\n        let last_line = self.line_of_offset(text, self.selection.last().unwrap().max()) + 1;\n        let all_caret = self.selection.iter().all(|region| region.is_caret());\n        let invalid = if all_caret {\n            line_cache_shadow::CURSOR_VALID\n        } else {\n            line_cache_shadow::CURSOR_VALID | line_cache_shadow::STYLES_VALID\n        };\n        self.lc_shadow.partial_invalidate(first_line, last_line, invalid);\n    }\n\n    fn add_selection_by_movement(&mut self, text: &Rope, movement: Movement) {\n        let mut sel = Selection::new();\n        for &region in self.sel_regions() {\n            sel.add_region(region);\n            let new_region =\n                region_movement(movement, region, self, self.scroll_height(), &text, false);\n            sel.add_region(new_region);\n        }\n        self.set_selection(text, sel);\n    }\n\n    // TODO: insert from keyboard or input method shouldn't break undo group,\n    /// Invalidates the styles of the given range (start and end are offsets within\n    /// the text).\n    pub fn invalidate_styles(&mut self, text: &Rope, start: usize, end: usize) {\n        let first_line = self.line_of_offset(text, start);\n        let (mut last_line, last_col) = self.offset_to_line_col(text, end);\n        last_line += if last_col > 0 { 1 } else { 0 };\n        self.lc_shadow.partial_invalidate(first_line, last_line, line_cache_shadow::STYLES_VALID);\n    }\n\n    pub fn update_annotations(\n        &mut self,\n        plugin: PluginId,\n        interval: Interval,\n        annotations: Annotations,\n    ) {\n        self.annotations.update(plugin, interval, annotations)\n    }\n\n    /// Select entire buffer.\n    ///\n    /// Note: unlike movement based selection, this does not scroll.\n    pub fn select_all(&mut self, text: &Rope) {\n        let selection = SelRegion::new(0, text.len()).into();\n        self.set_selection_raw(text, selection);\n    }\n\n    /// Finds the unit of text containing the given offset.\n    fn unit(&self, text: &Rope, offset: usize, granularity: SelectionGranularity) -> Interval {\n        match granularity {\n            SelectionGranularity::Point => Interval::new(offset, offset),\n            SelectionGranularity::Word => {\n                let mut word_cursor = WordCursor::new(text, offset);\n                let (start, end) = word_cursor.select_word();\n                Interval::new(start, end)\n            }\n            SelectionGranularity::Line => {\n                let (line, _) = self.offset_to_line_col(text, offset);\n                let (start, end) = self.lines.logical_line_range(text, line);\n                Interval::new(start, end)\n            }\n        }\n    }\n\n    /// Selects text with a certain granularity and supports multi_selection\n    fn select(\n        &mut self,\n        text: &Rope,\n        offset: usize,\n        granularity: SelectionGranularity,\n        multi: bool,\n    ) {\n        // If multi-select is enabled, toggle existing regions\n        if multi\n            && granularity == SelectionGranularity::Point\n            && self.deselect_at_offset(text, offset)\n        {\n            return;\n        }\n\n        let region = self.unit(text, offset, granularity).into();\n\n        let base_sel = match multi {\n            true => self.selection.clone(),\n            false => Selection::new(),\n        };\n        let mut selection = base_sel.clone();\n        selection.add_region(region);\n        self.set_selection(text, selection);\n\n        self.drag_state =\n            Some(DragState { base_sel, min: region.start, max: region.end, granularity });\n    }\n\n    /// Extends an existing selection (eg. when the user performs SHIFT + click).\n    pub fn extend_selection(\n        &mut self,\n        text: &Rope,\n        offset: usize,\n        granularity: SelectionGranularity,\n    ) {\n        if self.sel_regions().is_empty() {\n            return;\n        }\n\n        let (base_sel, last) = {\n            let mut base = Selection::new();\n            let (last, rest) = self.sel_regions().split_last().unwrap();\n            for &region in rest {\n                base.add_region(region);\n            }\n            (base, *last)\n        };\n\n        let mut sel = base_sel.clone();\n        self.drag_state =\n            Some(DragState { base_sel, min: last.start, max: last.start, granularity });\n\n        let start = (last.start, last.start);\n        let new_region = self.range_region(text, start, offset, granularity);\n\n        // TODO: small nit, merged region should be backward if end < start.\n        // This could be done by explicitly overriding, or by tweaking the\n        // merge logic.\n        sel.add_region(new_region);\n        self.set_selection(text, sel);\n    }\n\n    /// Splits current selections into lines.\n    fn do_split_selection_into_lines(&mut self, text: &Rope) {\n        let mut selection = Selection::new();\n\n        for region in self.selection.iter() {\n            if region.is_caret() {\n                selection.add_region(SelRegion::caret(region.max()));\n            } else {\n                let mut cursor = Cursor::new(&text, region.min());\n\n                while cursor.pos() < region.max() {\n                    let sel_start = cursor.pos();\n                    let end_of_line = match cursor.next::<LinesMetric>() {\n                        Some(end) if end >= region.max() => max(0, region.max() - 1),\n                        Some(end) => max(0, end - 1),\n                        None if cursor.pos() == text.len() => cursor.pos(),\n                        _ => break,\n                    };\n\n                    selection.add_region(SelRegion::new(sel_start, end_of_line));\n                }\n            }\n        }\n\n        self.set_selection_raw(text, selection);\n    }\n\n    /// Does a drag gesture, setting the selection from a combination of the drag\n    /// state and new offset.\n    fn do_drag(&mut self, text: &Rope, offset: usize, affinity: Affinity) {\n        let new_sel = self.drag_state.as_ref().map(|drag_state| {\n            let mut sel = drag_state.base_sel.clone();\n            let start = (drag_state.min, drag_state.max);\n            let new_region = self.range_region(text, start, offset, drag_state.granularity);\n            sel.add_region(new_region.with_horiz(None).with_affinity(affinity));\n            sel\n        });\n\n        if let Some(sel) = new_sel {\n            self.set_selection(text, sel);\n        }\n    }\n\n    /// Creates a `SelRegion` for range select or drag operations.\n    pub fn range_region(\n        &self,\n        text: &Rope,\n        start: (usize, usize),\n        offset: usize,\n        granularity: SelectionGranularity,\n    ) -> SelRegion {\n        let (min_start, max_start) = start;\n        let end = self.unit(text, offset, granularity);\n        let (min_end, max_end) = (end.start, end.end);\n        if offset >= min_start {\n            SelRegion::new(min_start, max_end)\n        } else {\n            SelRegion::new(max_start, min_end)\n        }\n    }\n\n    /// Returns the regions of the current selection.\n    pub fn sel_regions(&self) -> &[SelRegion] {\n        &self.selection\n    }\n\n    /// Collapse all selections in this view into a single caret\n    pub fn collapse_selections(&mut self, text: &Rope) {\n        let mut sel = self.selection.clone();\n        sel.collapse();\n        self.set_selection(text, sel);\n    }\n\n    /// Determines whether the offset is in any selection (counting carets and\n    /// selection edges).\n    pub fn is_point_in_selection(&self, offset: usize) -> bool {\n        !self.selection.regions_in_range(offset, offset).is_empty()\n    }\n\n    // Encode a single line with its styles and cursors in JSON.\n    // If \"text\" is not specified, don't add \"text\" to the output.\n    // If \"style_spans\" are not specified, don't add \"styles\" to the output.\n    fn encode_line(\n        &self,\n        client: &Client,\n        styles: &StyleMap,\n        line: VisualLine,\n        text: Option<&Rope>,\n        style_spans: Option<&Spans<Style>>,\n        last_pos: usize,\n    ) -> Value {\n        let start_pos = line.interval.start;\n        let pos = line.interval.end;\n        let mut cursors = Vec::new();\n        let mut selections = Vec::new();\n        for region in self.selection.regions_in_range(start_pos, pos) {\n            // cursor\n            let c = region.end;\n\n            if (c > start_pos && c < pos)\n                || (!region.is_upstream() && c == start_pos)\n                || (region.is_upstream() && c == pos)\n                || (c == pos && c == last_pos)\n            {\n                cursors.push(c - start_pos);\n            }\n\n            // selection with interior\n            let sel_start_ix = clamp(region.min(), start_pos, pos) - start_pos;\n            let sel_end_ix = clamp(region.max(), start_pos, pos) - start_pos;\n            if sel_end_ix > sel_start_ix {\n                selections.push((sel_start_ix, sel_end_ix));\n            }\n        }\n\n        let mut hls = Vec::new();\n\n        if self.highlight_find {\n            for find in &self.find {\n                let mut cur_hls = Vec::new();\n                for region in find.occurrences().regions_in_range(start_pos, pos) {\n                    let sel_start_ix = clamp(region.min(), start_pos, pos) - start_pos;\n                    let sel_end_ix = clamp(region.max(), start_pos, pos) - start_pos;\n                    if sel_end_ix > sel_start_ix {\n                        cur_hls.push((sel_start_ix, sel_end_ix));\n                    }\n                }\n                hls.push(cur_hls);\n            }\n        }\n\n        let mut result = json!({});\n\n        if let Some(text) = text {\n            result[\"text\"] = json!(text.slice_to_cow(start_pos..pos));\n        }\n        if let Some(style_spans) = style_spans {\n            result[\"styles\"] = json!(self.encode_styles(\n                client,\n                styles,\n                start_pos,\n                pos,\n                &selections,\n                &hls,\n                style_spans\n            ));\n        }\n        if !cursors.is_empty() {\n            result[\"cursor\"] = json!(cursors);\n        }\n        if let Some(line_num) = line.line_num {\n            result[\"ln\"] = json!(line_num);\n        }\n        result\n    }\n\n    pub fn encode_styles(\n        &self,\n        client: &Client,\n        styles: &StyleMap,\n        start: usize,\n        end: usize,\n        sel: &[(usize, usize)],\n        hls: &Vec<Vec<(usize, usize)>>,\n        style_spans: &Spans<Style>,\n    ) -> Vec<isize> {\n        let mut encoded_styles = Vec::new();\n        assert!(start <= end, \"{} {}\", start, end);\n        let style_spans = style_spans.subseq(Interval::new(start, end));\n\n        let mut ix = 0;\n        // we add the special find highlights (1 to N) and selection (0) styles first.\n        // We add selection after find because we want it to be preferred if the\n        // same span exists in both sets (as when there is an active selection)\n        for (index, cur_find_hls) in hls.iter().enumerate() {\n            for &(sel_start, sel_end) in cur_find_hls {\n                encoded_styles.push((sel_start as isize) - ix);\n                encoded_styles.push(sel_end as isize - sel_start as isize);\n                encoded_styles.push(index as isize + 1);\n                ix = sel_end as isize;\n            }\n        }\n        for &(sel_start, sel_end) in sel {\n            encoded_styles.push((sel_start as isize) - ix);\n            encoded_styles.push(sel_end as isize - sel_start as isize);\n            encoded_styles.push(0);\n            ix = sel_end as isize;\n        }\n        for (iv, style) in style_spans.iter() {\n            let style_id = self.get_or_def_style_id(client, styles, &style);\n            encoded_styles.push((iv.start() as isize) - ix);\n            encoded_styles.push(iv.end() as isize - iv.start() as isize);\n            encoded_styles.push(style_id as isize);\n            ix = iv.end() as isize;\n        }\n        encoded_styles\n    }\n\n    fn get_or_def_style_id(&self, client: &Client, style_map: &StyleMap, style: &Style) -> usize {\n        let mut style_map = style_map.borrow_mut();\n        if let Some(ix) = style_map.lookup(style) {\n            return ix;\n        }\n        let ix = style_map.add(style);\n        let style = style_map.merge_with_default(style);\n        client.def_style(&style.to_json(ix));\n        ix\n    }\n\n    fn send_update_for_plan(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        plan: &RenderPlan,\n        pristine: bool,\n    ) {\n        // every time current visible range changes, annotations are sent to frontend\n        let start_off = self.offset_of_line(text, self.first_line);\n        let end_off = self.offset_of_line(text, self.first_line + self.height + 2);\n        let visible_range = Interval::new(start_off, end_off);\n        let selection_annotations =\n            self.selection.get_annotations(visible_range, &self, text).to_json();\n        let find_annotations =\n            self.find.iter().map(|ref f| f.get_annotations(visible_range, &self, text).to_json());\n        let plugin_annotations =\n            self.annotations.iter_range(&self, text, visible_range).map(|a| a.to_json());\n\n        let annotations = iter::once(selection_annotations)\n            .chain(find_annotations)\n            .chain(plugin_annotations)\n            .collect::<Vec<_>>();\n\n        if !self.lc_shadow.needs_render(plan) {\n            let total_lines = self.line_of_offset(text, text.len()) + 1;\n            let update =\n                Update { ops: vec![UpdateOp::copy(total_lines, 1)], pristine, annotations };\n            client.update_view(self.view_id, &update);\n            return;\n        }\n\n        // send updated find status only if there have been changes\n        if self.find_changed != FindStatusChange::None {\n            let matches_only = self.find_changed == FindStatusChange::Matches;\n            client.find_status(self.view_id, &json!(self.find_status(text, matches_only)));\n            self.find_changed = FindStatusChange::None;\n        }\n\n        // send updated replace status if changed\n        if self.replace_changed {\n            if let Some(replace) = self.get_replace() {\n                client.replace_status(self.view_id, &json!(replace))\n            }\n        }\n\n        let mut b = line_cache_shadow::Builder::new();\n        let mut ops = Vec::new();\n        let mut line_num = 0; // tracks old line cache\n\n        for seg in self.lc_shadow.iter_with_plan(plan) {\n            match seg.tactic {\n                RenderTactic::Discard => {\n                    ops.push(UpdateOp::invalidate(seg.n));\n                    b.add_span(seg.n, 0, 0);\n                }\n                RenderTactic::Preserve | RenderTactic::Render => {\n                    // Depending on the state of TEXT_VALID, STYLES_VALID and\n                    // CURSOR_VALID, perform one of the following actions:\n                    //\n                    //   - All the three are valid => send the \"copy\" op\n                    //     (+leading \"skip\" to catch up with \"ln\" to update);\n                    //\n                    //   - Text and styles are valid, cursors are not => same,\n                    //     but send an \"update\" op instead of \"copy\" to move\n                    //     the cursors;\n                    //\n                    //   - Text or styles are invalid:\n                    //     => send \"invalidate\" if RenderTactic is \"Preserve\";\n                    //     => send \"skip\"+\"insert\" (recreate the lines) if\n                    //        RenderTactic is \"Render\".\n                    if (seg.validity & line_cache_shadow::TEXT_VALID) != 0\n                        && (seg.validity & line_cache_shadow::STYLES_VALID) != 0\n                    {\n                        let n_skip = seg.their_line_num - line_num;\n                        if n_skip > 0 {\n                            ops.push(UpdateOp::skip(n_skip));\n                        }\n                        let line_offset = self.offset_of_line(text, seg.our_line_num);\n                        let logical_line = text.line_of_offset(line_offset);\n                        if (seg.validity & line_cache_shadow::CURSOR_VALID) != 0 {\n                            // ALL_VALID; copy lines as-is\n                            ops.push(UpdateOp::copy(seg.n, logical_line + 1));\n                        } else {\n                            // !CURSOR_VALID; update cursors\n                            let start_line = seg.our_line_num;\n\n                            let encoded_lines = self\n                                .lines\n                                .iter_lines(text, start_line)\n                                .take(seg.n)\n                                .map(|l| {\n                                    self.encode_line(\n                                        client,\n                                        styles,\n                                        l,\n                                        /* text = */ None,\n                                        /* style_spans = */ None,\n                                        text.len(),\n                                    )\n                                })\n                                .collect::<Vec<_>>();\n\n                            let logical_line_opt =\n                                if logical_line == 0 { None } else { Some(logical_line + 1) };\n                            ops.push(UpdateOp::update(encoded_lines, logical_line_opt));\n                        }\n                        b.add_span(seg.n, seg.our_line_num, seg.validity);\n                        line_num = seg.their_line_num + seg.n;\n                    } else {\n                        if seg.tactic == RenderTactic::Preserve {\n                            ops.push(UpdateOp::invalidate(seg.n));\n                            b.add_span(seg.n, 0, 0);\n                        } else if seg.tactic == RenderTactic::Render {\n                            let start_line = seg.our_line_num;\n                            let encoded_lines = self\n                                .lines\n                                .iter_lines(text, start_line)\n                                .take(seg.n)\n                                .map(|l| {\n                                    self.encode_line(\n                                        client,\n                                        styles,\n                                        l,\n                                        Some(text),\n                                        Some(style_spans),\n                                        text.len(),\n                                    )\n                                })\n                                .collect::<Vec<_>>();\n                            debug_assert_eq!(encoded_lines.len(), seg.n);\n                            ops.push(UpdateOp::insert(encoded_lines));\n                            b.add_span(seg.n, seg.our_line_num, line_cache_shadow::ALL_VALID);\n                        }\n                    }\n                }\n            }\n        }\n\n        self.lc_shadow = b.build();\n        for find in &mut self.find {\n            find.set_hls_dirty(false)\n        }\n\n        let update = Update { ops, pristine, annotations };\n        client.update_view(self.view_id, &update);\n    }\n\n    /// Determines the current number of find results and search parameters to send them to\n    /// the frontend.\n    pub fn find_status(&self, text: &Rope, matches_only: bool) -> Vec<FindStatus> {\n        self.find\n            .iter()\n            .map(|find| find.find_status(&self, text, matches_only))\n            .collect::<Vec<FindStatus>>()\n    }\n\n    /// Update front-end with any changes to view since the last time sent.\n    /// The `pristine` argument indicates whether or not the buffer has\n    /// unsaved changes.\n    pub fn render_if_dirty(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        pristine: bool,\n    ) {\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let plan = RenderPlan::create(height, self.first_line, self.height);\n        self.send_update_for_plan(text, client, styles, style_spans, &plan, pristine);\n        if let Some(new_scroll_pos) = self.scroll_to.take() {\n            let (line, col) = self.offset_to_line_col(text, new_scroll_pos);\n            client.scroll_to(self.view_id, line, col);\n        }\n    }\n\n    // Send the requested lines even if they're outside the current scroll region.\n    pub fn request_lines(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        first_line: usize,\n        last_line: usize,\n        pristine: bool,\n    ) {\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let mut plan = RenderPlan::create(height, self.first_line, self.height);\n        plan.request_lines(first_line, last_line);\n        self.send_update_for_plan(text, client, styles, style_spans, &plan, pristine);\n    }\n\n    /// Invalidates front-end's entire line cache, forcing a full render at the next\n    /// update cycle. This should be a last resort, updates should generally cause\n    /// finer grain invalidation.\n    pub fn set_dirty(&mut self, text: &Rope) {\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let mut b = line_cache_shadow::Builder::new();\n        b.add_span(height, 0, 0);\n        b.set_dirty(true);\n        self.lc_shadow = b.build();\n    }\n\n    /// Returns the byte range of the currently visible lines.\n    fn interval_of_visible_region(&self, text: &Rope) -> Interval {\n        let start = self.offset_of_line(text, self.first_line);\n        let end = self.offset_of_line(text, self.first_line + self.height + 1);\n        Interval::new(start, end)\n    }\n\n    /// Generate line breaks, based on current settings. Currently batch-mode,\n    /// and currently in a debugging state.\n    pub(crate) fn rewrap(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        spans: &Spans<Style>,\n    ) {\n        let _t = trace_block(\"View::rewrap\", &[\"core\"]);\n        let visible = self.first_line..self.first_line + self.height;\n        let inval = self.lines.rewrap_chunk(text, width_cache, client, spans, visible);\n        if let Some(InvalLines { start_line, inval_count, new_count }) = inval {\n            self.lc_shadow.edit(start_line, start_line + inval_count, new_count);\n        }\n    }\n\n    /// Updates the view after the text has been modified by the given `delta`.\n    /// This method is responsible for updating the cursors, and also for\n    /// recomputing line wraps.\n    pub fn after_edit(\n        &mut self,\n        text: &Rope,\n        last_text: &Rope,\n        delta: &RopeDelta,\n        client: &Client,\n        width_cache: &mut WidthCache,\n        drift: InsertDrift,\n    ) {\n        let visible = self.first_line..self.first_line + self.height;\n        match self.lines.after_edit(text, last_text, delta, width_cache, client, visible) {\n            Some(InvalLines { start_line, inval_count, new_count }) => {\n                self.lc_shadow.edit(start_line, start_line + inval_count, new_count);\n            }\n            None => self.set_dirty(text),\n        }\n\n        // Any edit cancels a drag. This is good behavior for edits initiated through\n        // the front-end, but perhaps not for async edits.\n        self.drag_state = None;\n\n        // all annotations that come after the edit need to be invalidated\n        let (iv, _) = delta.summary();\n        self.annotations.invalidate(iv);\n\n        // update only find highlights affected by change\n        for find in &mut self.find {\n            find.update_highlights(text, delta);\n            self.find_changed = FindStatusChange::All;\n        }\n\n        // Note: for committing plugin edits, we probably want to know the priority\n        // of the delta so we can set the cursor before or after the edit, as needed.\n        let new_sel = self.selection.apply_delta(delta, true, drift);\n        self.set_selection_for_edit(text, new_sel);\n    }\n\n    fn do_selection_for_find(&mut self, text: &Rope, case_sensitive: bool) {\n        // set last selection or word under current cursor as search query\n        let search_query = match self.selection.last() {\n            Some(region) => {\n                if !region.is_caret() {\n                    text.slice_to_cow(region)\n                } else {\n                    let (start, end) = {\n                        let mut word_cursor = WordCursor::new(text, region.max());\n                        word_cursor.select_word()\n                    };\n                    text.slice_to_cow(start..end)\n                }\n            }\n            _ => return,\n        };\n\n        self.set_dirty(text);\n\n        // set selection as search query for first find if no additional search queries are used\n        // otherwise add new find with selection as search query\n        if self.find.len() != 1 {\n            self.add_find();\n        }\n\n        self.find.last_mut().unwrap().set_find(&search_query, case_sensitive, false, true);\n        self.find_progress = FindProgress::Started;\n    }\n\n    fn add_find(&mut self) {\n        let id = self.find_id_counter.next();\n        self.find.push(Find::new(id));\n    }\n\n    fn set_find(&mut self, text: &Rope, queries: Vec<FindQuery>) {\n        // checks if at least query has been changed, otherwise we don't need to rerun find\n        let mut find_changed = queries.len() != self.find.len();\n\n        // remove deleted queries\n        self.find.retain(|f| queries.iter().any(|q| q.id == Some(f.id())));\n\n        for query in &queries {\n            let pos = match query.id {\n                Some(id) => {\n                    // update existing query\n                    match self.find.iter().position(|f| f.id() == id) {\n                        Some(p) => p,\n                        None => return,\n                    }\n                }\n                None => {\n                    // add new query\n                    self.add_find();\n                    self.find.len() - 1\n                }\n            };\n\n            if self.find[pos].set_find(\n                &query.chars.clone(),\n                query.case_sensitive,\n                query.regex,\n                query.whole_words,\n            ) {\n                find_changed = true;\n            }\n        }\n\n        if find_changed {\n            self.set_dirty(text);\n            self.find_progress = FindProgress::Started;\n        }\n    }\n\n    pub fn do_find(&mut self, text: &Rope) {\n        let search_range = match &self.find_progress.clone() {\n            FindProgress::Started => {\n                // start incremental find on visible region\n                let start = self.offset_of_line(text, self.first_line);\n                let end = min(text.len(), start + FIND_BATCH_SIZE);\n                self.find_changed = FindStatusChange::Matches;\n                self.find_progress = FindProgress::InProgress(Range { start, end });\n                Some((start, end))\n            }\n            FindProgress::InProgress(searched_range) => {\n                if searched_range.start == 0 && searched_range.end >= text.len() {\n                    // the entire text has been searched\n                    // end find by executing multi-line regex queries on entire text\n                    // stop incremental find\n                    self.find_progress = FindProgress::Ready;\n                    self.find_changed = FindStatusChange::All;\n                    Some((0, text.len()))\n                } else {\n                    self.find_changed = FindStatusChange::Matches;\n                    // expand find to un-searched regions\n                    let start_off = self.offset_of_line(text, self.first_line);\n\n                    // If there is unsearched text before the visible region, we want to include it in this search operation\n                    let search_preceding_range = start_off.saturating_sub(searched_range.start)\n                        < searched_range.end.saturating_sub(start_off)\n                        && searched_range.start > 0;\n\n                    if search_preceding_range || searched_range.end >= text.len() {\n                        let start = searched_range.start.saturating_sub(FIND_BATCH_SIZE);\n                        self.find_progress =\n                            FindProgress::InProgress(Range { start, end: searched_range.end });\n                        Some((start, searched_range.start))\n                    } else if searched_range.end < text.len() {\n                        let end = min(text.len(), searched_range.end + FIND_BATCH_SIZE);\n                        self.find_progress =\n                            FindProgress::InProgress(Range { start: searched_range.start, end });\n                        Some((searched_range.end, end))\n                    } else {\n                        self.find_changed = FindStatusChange::All;\n                        None\n                    }\n                }\n            }\n            _ => {\n                self.find_changed = FindStatusChange::None;\n                None\n            }\n        };\n\n        if let Some((search_range_start, search_range_end)) = search_range {\n            for query in &mut self.find {\n                if !query.is_multiline_regex() {\n                    query.update_find(text, search_range_start, search_range_end, true);\n                } else {\n                    // only execute multi-line regex queries if we are searching the entire text (last step)\n                    if search_range_start == 0 && search_range_end == text.len() {\n                        query.update_find(text, search_range_start, search_range_end, true);\n                    }\n                }\n            }\n        }\n    }\n\n    /// Selects the next find match.\n    pub fn do_find_next(\n        &mut self,\n        text: &Rope,\n        reverse: bool,\n        wrap: bool,\n        allow_same: bool,\n        modify_selection: &SelectionModifier,\n    ) {\n        self.select_next_occurrence(text, reverse, false, allow_same, modify_selection);\n        if self.scroll_to.is_none() && wrap {\n            self.select_next_occurrence(text, reverse, true, allow_same, modify_selection);\n        }\n    }\n\n    /// Selects all find matches.\n    pub fn do_find_all(&mut self, text: &Rope) {\n        let mut selection = Selection::new();\n        for find in &self.find {\n            for &occurrence in find.occurrences().iter() {\n                selection.add_region(occurrence);\n            }\n        }\n\n        if !selection.is_empty() {\n            // todo: invalidate so that nothing selected accidentally replaced\n            self.set_selection(text, selection);\n        }\n    }\n\n    /// Select the next occurrence relative to the last cursor. `reverse` determines whether the\n    /// next occurrence before (`true`) or after (`false`) the last cursor is selected. `wrapped`\n    /// indicates a search for the next occurrence past the end of the file.\n    pub fn select_next_occurrence(\n        &mut self,\n        text: &Rope,\n        reverse: bool,\n        wrapped: bool,\n        _allow_same: bool,\n        modify_selection: &SelectionModifier,\n    ) {\n        let (cur_start, cur_end) = match self.selection.last() {\n            Some(sel) => (sel.min(), sel.max()),\n            _ => (0, 0),\n        };\n\n        // multiple queries; select closest occurrence\n        let closest_occurrence = self\n            .find\n            .iter()\n            .flat_map(|x| x.next_occurrence(text, reverse, wrapped, &self.selection))\n            .min_by_key(|x| match reverse {\n                true if x.end > cur_end => 2 * text.len() - x.end,\n                true => cur_end - x.end,\n                false if x.start < cur_start => x.start + text.len(),\n                false => x.start - cur_start,\n            });\n\n        if let Some(occ) = closest_occurrence {\n            match modify_selection {\n                SelectionModifier::Set => self.set_selection(text, occ),\n                SelectionModifier::Add => {\n                    let mut selection = self.selection.clone();\n                    selection.add_region(occ);\n                    self.set_selection(text, selection);\n                }\n                SelectionModifier::AddRemovingCurrent => {\n                    let mut selection = self.selection.clone();\n\n                    if let Some(last_selection) = self.selection.last() {\n                        if !last_selection.is_caret() {\n                            selection.delete_range(\n                                last_selection.min(),\n                                last_selection.max(),\n                                false,\n                            );\n                        }\n                    }\n\n                    selection.add_region(occ);\n                    self.set_selection(text, selection);\n                }\n                _ => {}\n            }\n        }\n    }\n\n    fn do_set_replace(&mut self, chars: String, preserve_case: bool) {\n        self.replace = Some(Replace { chars, preserve_case });\n        self.replace_changed = true;\n    }\n\n    fn do_selection_for_replace(&mut self, text: &Rope) {\n        // set last selection or word under current cursor as replacement string\n        let replacement = match self.selection.last() {\n            Some(region) => {\n                if !region.is_caret() {\n                    text.slice_to_cow(region)\n                } else {\n                    let (start, end) = {\n                        let mut word_cursor = WordCursor::new(text, region.max());\n                        word_cursor.select_word()\n                    };\n                    text.slice_to_cow(start..end)\n                }\n            }\n            _ => return,\n        };\n\n        self.set_dirty(text);\n        self.do_set_replace(replacement.into_owned(), false);\n    }\n\n    pub fn get_caret_offset(&self) -> Option<usize> {\n        match self.selection.len() {\n            1 if self.selection[0].is_caret() => {\n                let offset = self.selection[0].start;\n                Some(offset)\n            }\n            _ => None,\n        }\n    }\n}"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":["Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor":["Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor":["Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":["Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor":["Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor":["Deserialize"],"watcher::FileWatcher":["impl FileWatcher {\n    pub fn new<T: Notify + 'static>(peer: T) -> Self {\n        let (tx_event, rx_event) = unbounded();\n\n        let state = Arc::new(Mutex::new(WatcherState::default()));\n        let state_clone = state.clone();\n\n        let inner = watcher(tx_event, Duration::from_millis(100)).expect(\"watcher should spawn\");\n\n        thread::spawn(move || {\n            while let Ok(Ok(event)) = rx_event.recv() {\n                let mut state = state_clone.lock().unwrap();\n                let WatcherState { ref mut events, ref mut watchees } = *state;\n\n                watchees\n                    .iter()\n                    .filter(|w| w.wants_event(&event))\n                    .map(|w| w.token)\n                    .for_each(|t| events.push_back((t, event.clone())));\n\n                peer.notify();\n            }\n        });\n\n        FileWatcher { inner, state }\n    }\n\n    /// Begin watching `path`. As `Event`s (documented in the\n    /// [notify](https://docs.rs/notify) crate) arrive, they are stored\n    /// with the associated `token` and a task is added to the runloop's\n    /// idle queue.\n    ///\n    /// Delivery of events then requires that the runloop's handler\n    /// correctly forward the `handle_idle` call to the interested party.\n    pub fn watch(&mut self, path: &Path, recursive: bool, token: WatchToken) {\n        self.watch_impl(path, recursive, token, None);\n    }\n\n    /// Like `watch`, but taking a predicate function that filters delivery\n    /// of events based on their path.\n    pub fn watch_filtered<F>(&mut self, path: &Path, recursive: bool, token: WatchToken, filter: F)\n    where\n        F: Fn(&Path) -> bool + Send + 'static,\n    {\n        let filter = Box::new(filter) as Box<PathFilter>;\n        self.watch_impl(path, recursive, token, Some(filter));\n    }\n\n    fn watch_impl(\n        &mut self,\n        path: &Path,\n        recursive: bool,\n        token: WatchToken,\n        filter: Option<Box<PathFilter>>,\n    ) {\n        let path = match path.canonicalize() {\n            Ok(ref p) => p.to_owned(),\n            Err(e) => {\n                warn!(\"error watching {:?}: {:?}\", path, e);\n                return;\n            }\n        };\n\n        let mut state = self.state.lock().unwrap();\n\n        let w = Watchee { path, recursive, token, filter };\n        let mode = mode_from_bool(w.recursive);\n\n        if !state.watchees.iter().any(|w2| w.path == w2.path) {\n            if let Err(e) = self.inner.watch(&w.path, mode) {\n                warn!(\"watching error {:?}\", e);\n            }\n        }\n\n        state.watchees.push(w);\n    }\n\n    /// Removes the provided token/path pair from the watch list.\n    /// Does not stop watching this path, if it is associated with\n    /// other tokens.\n    pub fn unwatch(&mut self, path: &Path, token: WatchToken) {\n        let mut state = self.state.lock().unwrap();\n\n        let idx = state.watchees.iter().position(|w| w.token == token && w.path == path);\n\n        if let Some(idx) = idx {\n            let removed = state.watchees.remove(idx);\n            if !state.watchees.iter().any(|w| w.path == removed.path) {\n                if let Err(e) = self.inner.unwatch(&removed.path) {\n                    warn!(\"unwatching error {:?}\", e);\n                }\n            }\n            //TODO: Ideally we would be tracking what paths we're watching with\n            // some prefix-tree-like structure, which would let us keep track\n            // of when some child path might need to be reregistered. How this\n            // works and when registration would be required is dependent on\n            // the underlying notification mechanism, however. There's an\n            // in-progress rewrite of the Notify crate which use under the\n            // hood, and a component of that rewrite is adding this\n            // functionality; so until that lands we're using a fairly coarse\n            // heuristic to determine if we need to re-watch subpaths.\n\n            // if this was recursive, check if any child paths need to be\n            // manually re-added\n            if removed.recursive {\n                // do this in two steps because we've borrowed mutably up top\n                let to_add = state\n                    .watchees\n                    .iter()\n                    .filter(|w| w.path.starts_with(&removed.path))\n                    .map(|w| (w.path.to_owned(), mode_from_bool(w.recursive)))\n                    .collect::<Vec<_>>();\n\n                for (path, mode) in to_add {\n                    if let Err(e) = self.inner.watch(&path, mode) {\n                        warn!(\"watching error {:?}\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    /// Takes ownership of this `Watcher`'s current event queue.\n    pub fn take_events(&mut self) -> VecDeque<(WatchToken, Event)> {\n        let mut state = self.state.lock().unwrap();\n        let WatcherState { ref mut events, .. } = *state;\n        mem::replace(events, VecDeque::new())\n    }\n}"],"watcher::WatchToken":["Clone","Copy","Debug","Eq","PartialEq"],"watcher::Watchee":["impl Watchee {\n    fn wants_event(&self, event: &Event) -> bool {\n        match &event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Remove(RemoveKind::Any)\n            | EventKind::Modify(ModifyKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any)) => {\n                if event.paths.len() == 1 {\n                    self.applies_to_path(&event.paths[0])\n                } else {\n                    info!(\n                        \"Rejecting event {:?} with incorrect paths. Expected 1 found {}.\",\n                        event,\n                        event.paths.len()\n                    );\n                    false\n                }\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                if event.paths.len() == 2 {\n                    //There will be two paths. First is \"from\" and other is \"to\".\n                    self.applies_to_path(&event.paths[0]) || self.applies_to_path(&event.paths[1])\n                } else {\n                    info!(\n                        \"Rejecting event {:?} with incorrect paths. Expected 2 found {}.\",\n                        event,\n                        event.paths.len()\n                    );\n                    false\n                }\n            }\n            _ => false,\n        }\n    }\n\n    fn applies_to_path(&self, path: &Path) -> bool {\n        let general_case = if path.starts_with(&self.path) {\n            (self.recursive || self.path == path) || path.parent() == Some(&self.path)\n        } else {\n            false\n        };\n\n        if let Some(ref filter) = self.filter {\n            general_case && filter(path)\n        } else {\n            general_case\n        }\n    }\n}","impl fmt::Debug for Watchee {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Watchee path: {:?}, r {}, t {} f {}\",\n            self.path,\n            self.recursive,\n            self.token.0,\n            self.filter.is_some()\n        )\n    }\n}"],"watcher::WatcherState":["Debug","Default"],"whitespace::Indentation":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Indentation {\n    /// Parses a rope for indentation settings.\n    pub fn parse(rope: &Rope) -> Result<Option<Self>, MixedIndentError> {\n        let lines = rope.lines_raw(..);\n        let mut tabs = false;\n        let mut spaces: BTreeMap<usize, usize> = BTreeMap::new();\n\n        for line in lines {\n            match Indentation::parse_line(&line) {\n                Ok(Some(Indentation::Spaces(size))) => {\n                    let counter = spaces.entry(size).or_insert(0);\n                    *counter += 1;\n                }\n                Ok(Some(Indentation::Tabs)) => tabs = true,\n                Ok(None) => continue,\n                Err(e) => return Err(e),\n            }\n        }\n\n        match (tabs, !spaces.is_empty()) {\n            (true, true) => Err(MixedIndentError),\n            (true, false) => Ok(Some(Indentation::Tabs)),\n            (false, true) => {\n                let tab_size = extract_count(spaces);\n                if tab_size > 0 {\n                    Ok(Some(Indentation::Spaces(tab_size)))\n                } else {\n                    Ok(None)\n                }\n            }\n            _ => Ok(None),\n        }\n    }\n\n    /// Detects the indentation on a specific line.\n    /// Parses whitespace until first occurrence of something else\n    pub fn parse_line(line: &str) -> Result<Option<Self>, MixedIndentError> {\n        let mut spaces = 0;\n\n        for char in line.as_bytes() {\n            match char {\n                b' ' => spaces += 1,\n                b'\\t' if spaces > 0 => return Err(MixedIndentError),\n                b'\\t' => return Ok(Some(Indentation::Tabs)),\n                _ => break,\n            }\n        }\n\n        if spaces > 0 {\n            Ok(Some(Indentation::Spaces(spaces)))\n        } else {\n            Ok(None)\n        }\n    }\n}"],"whitespace::MixedIndentError":["Debug"],"width_cache::CodepointMono":["impl WidthMeasure for CodepointMono {\n    /// In which each codepoint has width == 1.\n    fn measure_width(&self, request: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error> {\n        Ok(request\n            .iter()\n            .map(|r| r.strings.iter().map(|s| s.chars().count() as f64).collect())\n            .collect())\n    }\n}"],"width_cache::WidthBatchReq":["impl<'a> WidthBatchReq<'a> {\n    /// Request measurement of one string/style pair within the batch.\n    pub fn request(&mut self, id: StyleId, s: &str) -> Token {\n        let key = WidthCacheKey { id, s: Cow::Borrowed(s) };\n        if let Some(tok) = self.cache.m.get(&key) {\n            return *tok;\n        }\n        // cache miss, add the request\n        let key = WidthCacheKey { id, s: Cow::Owned(s.to_owned()) };\n        let req = &mut self.req;\n        let req_toks = &mut self.req_toks;\n        let id_off = *self.req_ids.entry(id).or_insert_with(|| {\n            let id_off = req.len();\n            req.push(WidthReq { id, strings: Vec::new() });\n            req_toks.push(Vec::new());\n            id_off\n        });\n        // To avoid this second clone, we could potentially do a tricky thing where\n        // we extract the strings from the WidthReq. Probably not worth it though.\n        req[id_off].strings.push(s.to_owned());\n        let tok = self.pending_tok;\n        self.cache.m.insert(key, tok);\n        self.pending_tok += 1;\n        req_toks[id_off].push(tok);\n        tok\n    }\n\n    /// Resolves pending measurements to concrete widths using the provided [`WidthMeasure`].\n    /// On success, the tokens given by `request` will resolve in the cache.\n    pub fn resolve_pending<T: WidthMeasure + ?Sized>(\n        &mut self,\n        handler: &T,\n    ) -> Result<(), xi_rpc::Error> {\n        // The 0.0 values should all get replaced with actual widths, assuming the\n        // shape of the response from the front-end matches that of the request.\n        if self.pending_tok > self.cache.widths.len() {\n            self.cache.widths.resize(self.pending_tok, 0.0);\n            let widths = handler.measure_width(&self.req)?;\n            for (w, t) in widths.iter().zip(self.req_toks.iter()) {\n                for (width, tok) in w.iter().zip(t.iter()) {\n                    self.cache.widths[*tok] = *width;\n                }\n            }\n        }\n        Ok(())\n    }\n}"],"width_cache::WidthCache":["impl WidthCache {\n    pub fn new() -> WidthCache {\n        WidthCache { m: HashMap::new(), widths: Vec::new() }\n    }\n\n    /// Returns the number of items currently in the cache.\n    pub(crate) fn len(&self) -> usize {\n        self.m.len()\n    }\n\n    /// Resolve a previously obtained token into a width value.\n    pub fn resolve(&self, tok: Token) -> Width {\n        self.widths[tok]\n    }\n\n    /// Create a new batch of requests.\n    pub fn batch_req(self: &mut WidthCache) -> WidthBatchReq {\n        let pending_tok = self.widths.len();\n        WidthBatchReq {\n            cache: self,\n            pending_tok,\n            req: Vec::new(),\n            req_toks: Vec::new(),\n            req_ids: BTreeMap::new(),\n        }\n    }\n}"],"width_cache::WidthCacheKey":["Eq","Hash","PartialEq"],"width_cache::WidthReq":["Deserialize","Serialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":["Deserialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor":["Deserialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor":["Deserialize"],"word_boundaries::WordBoundary":["Eq","PartialEq","impl WordBoundary {\n    fn is_start(&self) -> bool {\n        *self == WordBoundary::Start || *self == WordBoundary::Both\n    }\n\n    fn is_end(&self) -> bool {\n        *self == WordBoundary::End || *self == WordBoundary::Both\n    }\n\n    fn is_boundary(&self) -> bool {\n        *self != WordBoundary::Interior\n    }\n}"],"word_boundaries::WordCursor":["impl<'a> WordCursor<'a> {\n    pub fn new(text: &'a Rope, pos: usize) -> WordCursor<'a> {\n        let inner = Cursor::new(text, pos);\n        WordCursor { inner }\n    }\n\n    /// Get previous boundary, and set the cursor at the boundary found.\n    pub fn prev_boundary(&mut self) -> Option<usize> {\n        if let Some(ch) = self.inner.prev_codepoint() {\n            let mut prop = get_word_property(ch);\n            let mut candidate = self.inner.pos();\n            while let Some(prev) = self.inner.prev_codepoint() {\n                let prop_prev = get_word_property(prev);\n                if classify_boundary(prop_prev, prop).is_start() {\n                    break;\n                }\n                prop = prop_prev;\n                candidate = self.inner.pos();\n            }\n            self.inner.set(candidate);\n            return Some(candidate);\n        }\n        None\n    }\n\n    /// Get next boundary, and set the cursor at the boundary found.\n    pub fn next_boundary(&mut self) -> Option<usize> {\n        if let Some(ch) = self.inner.next_codepoint() {\n            let mut prop = get_word_property(ch);\n            let mut candidate = self.inner.pos();\n            while let Some(next) = self.inner.next_codepoint() {\n                let prop_next = get_word_property(next);\n                if classify_boundary(prop, prop_next).is_end() {\n                    break;\n                }\n                prop = prop_next;\n                candidate = self.inner.pos();\n            }\n            self.inner.set(candidate);\n            return Some(candidate);\n        }\n        None\n    }\n\n    /// Return the selection for the word containing the current cursor. The\n    /// cursor is moved to the end of that selection.\n    pub fn select_word(&mut self) -> (usize, usize) {\n        let initial = self.inner.pos();\n        let init_prop_after = self.inner.next_codepoint().map(get_word_property);\n        self.inner.set(initial);\n        let init_prop_before = self.inner.prev_codepoint().map(get_word_property);\n        let mut start = initial;\n        let init_boundary = if let (Some(pb), Some(pa)) = (init_prop_before, init_prop_after) {\n            classify_boundary_initial(pb, pa)\n        } else {\n            WordBoundary::Both\n        };\n        let mut prop_after = init_prop_after;\n        let mut prop_before = init_prop_before;\n        if prop_after.is_none() {\n            start = self.inner.pos();\n            prop_after = prop_before;\n            prop_before = self.inner.prev_codepoint().map(get_word_property);\n        }\n        while let (Some(pb), Some(pa)) = (prop_before, prop_after) {\n            if start == initial {\n                if init_boundary.is_start() {\n                    break;\n                }\n            } else if !init_boundary.is_boundary() {\n                if classify_boundary(pb, pa).is_boundary() {\n                    break;\n                }\n            } else if classify_boundary(pb, pa).is_start() {\n                break;\n            }\n            start = self.inner.pos();\n            prop_after = prop_before;\n            prop_before = self.inner.prev_codepoint().map(get_word_property);\n        }\n        self.inner.set(initial);\n        let mut end = initial;\n        prop_after = init_prop_after;\n        prop_before = init_prop_before;\n        if prop_before.is_none() {\n            prop_before = self.inner.next_codepoint().map(get_word_property);\n            end = self.inner.pos();\n            prop_after = self.inner.next_codepoint().map(get_word_property);\n        }\n        while let (Some(pb), Some(pa)) = (prop_before, prop_after) {\n            if end == initial {\n                if init_boundary.is_end() {\n                    break;\n                }\n            } else if !init_boundary.is_boundary() {\n                if classify_boundary(pb, pa).is_boundary() {\n                    break;\n                }\n            } else if classify_boundary(pb, pa).is_end() {\n                break;\n            }\n            end = self.inner.pos();\n            prop_before = prop_after;\n            prop_after = self.inner.next_codepoint().map(get_word_property);\n        }\n        self.inner.set(end);\n        (start, end)\n    }\n}"],"word_boundaries::WordProperty":["Clone","Copy"],"xi_rope::Interval":["impl<'a> From<&'a SelRegion> for Interval {\n    fn from(src: &'a SelRegion) -> Interval {\n        Interval::new(src.min(), src.max())\n    }\n}"],"xi_rope::breaks::Breaks":["impl LineOffset for xi_rope::breaks::Breaks {\n    fn offset_of_line(&self, _text: &Rope, line: usize) -> usize {\n        self.count_base_units::<xi_rope::breaks::BreaksMetric>(line)\n    }\n\n    fn line_of_offset(&self, text: &Rope, offset: usize) -> usize {\n        let offset = offset.min(text.len());\n        self.count::<xi_rope::breaks::BreaksMetric>(offset)\n    }\n}"],"xi_rpc::RemoteError":["impl From<FileError> for RemoteError {\n    fn from(src: FileError) -> RemoteError {\n        //TODO: when we migrate to using the failure crate for error handling,\n        // this should return a better message\n        let code = src.error_code();\n        let message = src.to_string();\n        RemoteError::custom(code, message, None)\n    }\n}"],"xi_rpc::RpcPeer":["impl Notify for RpcPeer {\n    fn notify(&self) {\n        self.schedule_idle(crate::tabs::WATCH_IDLE_TOKEN);\n    }\n}"]},"single_path_import":{"config::BufferItems":"BufferItems","config::Table":"Table","core::WeakXiCore":"WeakXiCore","core::XiCore":"XiCore","editor::EditType":"EditType","plugins::PluginPid":"PluginPid","plugins::manifest":"manifest","plugins::manifest::Command":"plugins::Command","plugins::manifest::PlaceholderRpc":"plugins::PlaceholderRpc","plugins::manifest::PluginDescription":"plugins::PluginDescription","plugins::rpc":"rpc","syntax::LanguageDefinition":"LanguageDefinition","syntax::LanguageId":"LanguageId","syntect::highlighting::ThemeSettings":"styles::ThemeSettings","tabs::BufferId":"BufferId","tabs::BufferIdentifier":"BufferIdentifier","tabs::ViewId":"ViewId","tabs::test_helpers":"test_helpers"},"srcs":{"<annotations::AnnotationRange as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<AnnotationRange, D::Error>\n    where\n        D: Deserializer<'de>,{\n        let mut range = AnnotationRange { ..Default::default() };\n        let seq = <[usize; 4]>::deserialize(deserializer)?;\n\n        range.start_line = seq[0];\n        range.start_col = seq[1];\n        range.end_line = seq[2];\n        range.end_col = seq[3];\n\n        Ok(range)\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"<annotations::AnnotationRange as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        let mut seq = serializer.serialize_seq(Some(4))?;\n        seq.serialize_element(&self.start_line)?;\n        seq.serialize_element(&self.start_col)?;\n        seq.serialize_element(&self.end_line)?;\n        seq.serialize_element(&self.end_col)?;\n        seq.end()\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"<client::Client as width_cache::WidthMeasure>::measure_width":["fn measure_width(&self, request: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error>{\n        Client::measure_width(self, request)\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"<config::Config<T> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Config<T>) -> bool{\n        self.items == other.items\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::ConfigDomain as std::convert::From<syntax::LanguageId>>::from":["fn from(src: LanguageId) -> ConfigDomain{\n        ConfigDomain::Language(src)\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::ConfigDomain as std::convert::From<tabs::BufferId>>::from":["fn from(src: BufferId) -> ConfigDomain{\n        ConfigDomain::UserOverride(src)\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::ConfigError as std::convert::From<serde_json::Error>>::from":["fn from(src: serde_json::Error) -> ConfigError{\n        ConfigError::UnexpectedItem(src)\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::ConfigError as std::convert::From<std::io::Error>>::from":["fn from(src: io::Error) -> ConfigError{\n        ConfigError::Io(src)\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::ConfigError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::ConfigError::*;\n        match *self {\n            UnknownDomain(ref s) => write!(f, \"UnknownDomain: {}\", s),\n            Parse(ref p, ref e) => write!(f, \"Parse ({:?}), {}\", p, e),\n            Io(ref e) => write!(f, \"error loading config: {}\", e),\n            UnexpectedItem(ref e) => write!(f, \"{}\", e),\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"<core::WeakXiCore as xi_rpc::Handler>::handle_notification":["fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification){\n        let PluginCommand { view_id, plugin_id, cmd } = rpc;\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_notification(ctx, view_id, plugin_id, cmd)\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"<core::WeakXiCore as xi_rpc::Handler>::handle_request":["fn handle_request(&mut self, ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError>{\n        let PluginCommand { view_id, plugin_id, cmd } = rpc;\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_request(ctx, view_id, plugin_id, cmd)\n        } else {\n            Err(RemoteError::custom(0, \"core is missing\", None))\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"<core::XiCore as xi_rpc::Handler>::handle_notification":["fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification){\n        use self::CoreNotification::*;\n\n        // We allow tracing to be enabled before event `client_started`\n        if let TracingConfig { enabled } = rpc {\n            match enabled {\n                true => xi_trace::enable_tracing(),\n                false => xi_trace::disable_tracing(),\n            }\n            info!(\"tracing in core = {:?}\", enabled);\n            if self.is_waiting() {\n                return;\n            }\n        }\n\n        // wait for client_started before setting up inner\n        if let ClientStarted { ref config_dir, ref client_extras_dir } = rpc {\n            assert!(self.is_waiting(), \"client_started can only be sent once\");\n            let state =\n                CoreState::new(ctx.get_peer(), config_dir.clone(), client_extras_dir.clone());\n            let state = Arc::new(Mutex::new(state));\n            *self = XiCore::Running(state);\n            let weak_self = self.weak_self().unwrap();\n            self.inner().finish_setup(weak_self);\n        }\n\n        self.inner().client_notification(rpc);\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"<core::XiCore as xi_rpc::Handler>::handle_request":["fn handle_request(&mut self, _ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError>{\n        self.inner().client_request(rpc)\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"<core::XiCore as xi_rpc::Handler>::idle":["fn idle(&mut self, _ctx: &RpcCtx, token: usize){\n        self.inner().handle_idle(token);\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"<edit_types::EventDomain as std::convert::From<edit_types::BufferEvent>>::from":["fn from(src: BufferEvent) -> EventDomain{\n        EventDomain::Buffer(src)\n    }","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"<edit_types::EventDomain as std::convert::From<edit_types::SpecialEvent>>::from":["fn from(src: SpecialEvent) -> EventDomain{\n        EventDomain::Special(src)\n    }","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"<edit_types::EventDomain as std::convert::From<edit_types::ViewEvent>>::from":["fn from(src: ViewEvent) -> EventDomain{\n        EventDomain::View(src)\n    }","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"<edit_types::EventDomain as std::convert::From<rpc::EditNotification>>::from":["fn from(src: EditNotification) -> EventDomain{\n        use self::EditNotification::*;\n        match src {\n            Insert { chars } =>\n                BufferEvent::Insert(chars).into(),\n            Paste { chars } =>\n                BufferEvent::Paste(chars).into(),\n            DeleteForward =>\n                BufferEvent::Delete {\n                    movement: Movement::Right,\n                    kill: false\n                }.into(),\n            DeleteBackward =>\n                BufferEvent::Backspace.into(),\n            DeleteWordForward =>\n                BufferEvent::Delete {\n                    movement: Movement::RightWord,\n                    kill: false\n                }.into(),\n            DeleteWordBackward =>\n                BufferEvent::Delete {\n                    movement: Movement::LeftWord,\n                    kill: false\n                }.into(),\n            DeleteToEndOfParagraph =>\n                BufferEvent::Delete {\n                    movement: Movement::EndOfParagraphKill,\n                    kill: true\n                }.into(),\n            DeleteToBeginningOfLine =>\n                BufferEvent::Delete {\n                    movement: Movement::LeftOfLine,\n                    kill: false\n                }.into(),\n            InsertNewline =>\n                BufferEvent::InsertNewline.into(),\n            InsertTab =>\n                BufferEvent::InsertTab.into(),\n            MoveUp =>\n                ViewEvent::Move(Movement::Up).into(),\n            MoveUpAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Up).into(),\n            MoveDown =>\n                ViewEvent::Move(Movement::Down).into(),\n            MoveDownAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Down).into(),\n            MoveLeft | MoveBackward =>\n                ViewEvent::Move(Movement::Left).into(),\n            MoveLeftAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Left).into(),\n            MoveRight | MoveForward  =>\n                ViewEvent::Move(Movement::Right).into(),\n            MoveRightAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::Right).into(),\n            MoveWordLeft =>\n                ViewEvent::Move(Movement::LeftWord).into(),\n            MoveWordLeftAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::LeftWord).into(),\n            MoveWordRight =>\n                ViewEvent::Move(Movement::RightWord).into(),\n            MoveWordRightAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::RightWord).into(),\n            MoveToBeginningOfParagraph =>\n                ViewEvent::Move(Movement::StartOfParagraph).into(),\n            MoveToBeginningOfParagraphAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::StartOfParagraph).into(),\n            MoveToEndOfParagraph =>\n                ViewEvent::Move(Movement::EndOfParagraph).into(),\n            MoveToEndOfParagraphAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::EndOfParagraph).into(),\n            MoveToLeftEndOfLine =>\n                ViewEvent::Move(Movement::LeftOfLine).into(),\n            MoveToLeftEndOfLineAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::LeftOfLine).into(),\n            MoveToRightEndOfLine =>\n                ViewEvent::Move(Movement::RightOfLine).into(),\n            MoveToRightEndOfLineAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::RightOfLine).into(),\n            MoveToBeginningOfDocument =>\n                ViewEvent::Move(Movement::StartOfDocument).into(),\n            MoveToBeginningOfDocumentAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::StartOfDocument).into(),\n            MoveToEndOfDocument =>\n                ViewEvent::Move(Movement::EndOfDocument).into(),\n            MoveToEndOfDocumentAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::EndOfDocument).into(),\n            ScrollPageUp =>\n                ViewEvent::Move(Movement::UpPage).into(),\n            PageUpAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::UpPage).into(),\n            ScrollPageDown =>\n                ViewEvent::Move(Movement::DownPage).into(),\n            PageDownAndModifySelection =>\n                ViewEvent::ModifySelection(Movement::DownPage).into(),\n            SelectAll => ViewEvent::SelectAll.into(),\n            AddSelectionAbove => ViewEvent::AddSelectionAbove.into(),\n            AddSelectionBelow => ViewEvent::AddSelectionBelow.into(),\n            Scroll(range) => ViewEvent::Scroll(range).into(),\n            Resize(size) => SpecialEvent::Resize(size).into(),\n            GotoLine { line } => ViewEvent::GotoLine { line }.into(),\n            RequestLines(range) => SpecialEvent::RequestLines(range).into(),\n            Yank => BufferEvent::Yank.into(),\n            Transpose => BufferEvent::Transpose.into(),\n            Click(action) => ViewEvent::Click(action).into(),\n            Drag(action) => ViewEvent::Drag(action).into(),\n            Gesture { line, col,  ty } => {\n                // Translate deprecated gesture types into the new format\n                let new_ty = match ty {\n                    GestureType::PointSelect => {\n                        warn!(\"The point_select gesture is deprecated; use select instead\");\n                        GestureType::Select {granularity: SelectionGranularity::Point, multi: false}\n                    }\n                    GestureType::ToggleSel => {\n                        warn!(\"The toggle_sel gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Point, multi: true}\n                    }\n                    GestureType::WordSelect => {\n                        warn!(\"The word_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Word, multi: false}\n                    }\n                    GestureType::MultiWordSelect => {\n                        warn!(\"The multi_word_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Word, multi: true}\n                    }\n                    GestureType::LineSelect => {\n                        warn!(\"The line_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Line, multi: false}\n                    }\n                    GestureType::MultiLineSelect => {\n                        warn!(\"The multi_line_select gesture is deprecated; use select instead\");\n                        GestureType::Select { granularity: SelectionGranularity::Line, multi: true}\n                    }\n                    GestureType::RangeSelect => {\n                        warn!(\"The range_select gesture is deprecated; use select_extend instead\");\n                        GestureType::SelectExtend { granularity: SelectionGranularity::Point }\n                    }\n                    _ => ty\n                };\n                ViewEvent::Gesture { line, col, ty: new_ty }.into()\n            },\n            Undo => BufferEvent::Undo.into(),\n            Redo => BufferEvent::Redo.into(),\n            Find { chars, case_sensitive, regex, whole_words } =>\n                ViewEvent::Find { chars, case_sensitive, regex, whole_words }.into(),\n            MultiFind { queries } =>\n                ViewEvent::MultiFind { queries }.into(),\n            FindNext { wrap_around, allow_same, modify_selection } =>\n                ViewEvent::FindNext { wrap_around, allow_same, modify_selection }.into(),\n            FindPrevious { wrap_around, allow_same, modify_selection } =>\n                ViewEvent::FindPrevious { wrap_around, allow_same, modify_selection }.into(),\n            FindAll => ViewEvent::FindAll.into(),\n            DebugRewrap => SpecialEvent::DebugRewrap.into(),\n            DebugWrapWidth => SpecialEvent::DebugWrapWidth.into(),\n            DebugPrintSpans => SpecialEvent::DebugPrintSpans.into(),\n            Uppercase => BufferEvent::Uppercase.into(),\n            Lowercase => BufferEvent::Lowercase.into(),\n            Capitalize => BufferEvent::Capitalize.into(),\n            Indent => BufferEvent::Indent.into(),\n            Outdent => BufferEvent::Outdent.into(),\n            Reindent => SpecialEvent::Reindent.into(),\n            DebugToggleComment => SpecialEvent::DebugToggleComment.into(),\n            HighlightFind { visible } => ViewEvent::HighlightFind { visible }.into(),\n            SelectionForFind { case_sensitive } =>\n                ViewEvent::SelectionForFind { case_sensitive }.into(),\n            Replace { chars, preserve_case } =>\n                ViewEvent::Replace { chars, preserve_case }.into(),\n            ReplaceNext => BufferEvent::ReplaceNext.into(),\n            ReplaceAll => BufferEvent::ReplaceAll.into(),\n            SelectionForReplace => ViewEvent::SelectionForReplace.into(),\n            RequestHover { request_id, position } =>\n                SpecialEvent::RequestHover { request_id, position }.into(),\n            SelectionIntoLines => ViewEvent::SelectionIntoLines.into(),\n            DuplicateLine => BufferEvent::DuplicateLine.into(),\n            IncreaseNumber => BufferEvent::IncreaseNumber.into(),\n            DecreaseNumber => BufferEvent::DecreaseNumber.into(),\n            ToggleRecording { recording_name } => SpecialEvent::ToggleRecording(recording_name).into(),\n            PlayRecording { recording_name } => SpecialEvent::PlayRecording(recording_name).into(),\n            ClearRecording { recording_name } => SpecialEvent::ClearRecording(recording_name).into(),\n            CollapseSelections => ViewEvent::CollapseSelections.into(),\n        }\n    }","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"<file::FileError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            FileError::Io(ref e, ref p) => write!(f, \"{}. File path: {:?}\", e, p),\n            FileError::UnknownEncoding(ref p) => write!(f, \"Error decoding file: {:?}\", p),\n            FileError::HasChanged(ref p) => write!(\n                f,\n                \"File has changed on disk. \\\n                 Please save elsewhere and reload the file. File path: {:?}\",\n                p\n            ),\n        }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"<find::Find as annotations::ToAnnotation>::get_annotations":["fn get_annotations(&self, interval: Interval, view: &View, text: &Rope) -> AnnotationSlice{\n        let regions = self.occurrences.regions_in_range(interval.start(), interval.end());\n        let ranges = regions\n            .iter()\n            .map(|region| {\n                let (start_line, start_col) = view.offset_to_line_col(text, region.min());\n                let (end_line, end_col) = view.offset_to_line_col(text, region.max());\n\n                AnnotationRange { start_line, start_col, end_line, end_col }\n            })\n            .collect::<Vec<AnnotationRange>>();\n\n        let payload = iter::repeat(json!({\"id\": self.id})).take(ranges.len()).collect::<Vec<_>>();\n\n        AnnotationSlice::new(AnnotationType::Find, ranges, Some(payload))\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"<index_set::MinusIter<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        while self.start < self.end {\n            if self.ranges.is_empty() || self.ranges[self.ranges.len() - 1].1 <= self.start {\n                let result = (self.start, self.end);\n                self.start = self.end;\n                return Some(result);\n            }\n            let last_ix = self.ranges.len() - 1;\n            let result = (self.ranges[last_ix].1, self.end);\n            self.end = self.ranges[last_ix].0;\n            self.ranges = &self.ranges[..last_ix];\n            if result.1 > result.0 {\n                return Some(result);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"<index_set::MinusIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, usize)>{\n        while self.start < self.end {\n            if self.ranges.is_empty() || self.end <= self.ranges[0].0 {\n                let result = (self.start, self.end);\n                self.start = self.end;\n                return Some(result);\n            }\n            let result = (self.start, self.ranges[0].0);\n            self.start = self.ranges[0].1;\n            self.ranges = &self.ranges[1..];\n            if result.1 > result.0 {\n                return Some(result);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"<layers::ScopeLayer as std::default::Default>::default":["fn default() -> Self{\n        ScopeLayer {\n            stack_lookup: Vec::new(),\n            style_lookup: Vec::new(),\n            style_cache: HashMap::new(),\n            scope_spans: Spans::default(),\n            style_spans: Spans::default(),\n        }\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"<line_cache_shadow::LineCacheShadow as std::default::Default>::default":["fn default() -> LineCacheShadow{\n        Builder::new().build()\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"<line_cache_shadow::PlanIterator<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<PlanSegment>{\n        if self.shadow_ix == self.lc_shadow.spans.len() || self.plan_ix == self.plan.spans.len() {\n            return None;\n        }\n        let shadow_span = &self.lc_shadow.spans[self.shadow_ix];\n        let plan_span = &self.plan.spans[self.plan_ix];\n        let start = max(self.shadow_line_num, self.plan_line_num);\n        let end = min(self.shadow_line_num + shadow_span.n, self.plan_line_num + plan_span.0);\n        let result = PlanSegment {\n            our_line_num: start,\n            their_line_num: shadow_span.start_line_num + (start - self.shadow_line_num),\n            n: end - start,\n            validity: shadow_span.validity,\n            tactic: plan_span.1,\n        };\n\n        if end == self.shadow_line_num + shadow_span.n {\n            self.shadow_line_num = end;\n            self.shadow_ix += 1;\n        }\n        if end == self.plan_line_num + plan_span.0 {\n            self.plan_line_num = end;\n            self.plan_ix += 1;\n        }\n        Some(result)\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"<line_cache_shadow::Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let validity = match self.validity {\n            TEXT_VALID => \"text\",\n            ALL_VALID => \"all\",\n            _other => \"mixed\",\n        };\n        if self.validity == INVALID {\n            write!(f, \"({} invalid)\", self.n)?;\n        } else {\n            write!(f, \"({}: {}, {})\", self.start_line_num, self.n, validity)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"<linewrap::Lines as line_offset::LineOffset>::line_of_offset":["fn line_of_offset(&self, text: &Rope, offset: usize) -> usize{\n        self.visual_line_of_offset(text, offset)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"<linewrap::Lines as line_offset::LineOffset>::offset_of_line":["fn offset_of_line(&self, text: &Rope, line: usize) -> usize{\n        self.offset_of_visual_line(text, line)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"<linewrap::MergedBreaks<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        if self.text.pos() == self.offset && !self.at_eof() {\n            // don't iterate past EOF, or we can't get the leaf and check for \\n\n            self.text.next::<LinesMetric>();\n        }\n        if self.soft.pos() == self.offset {\n            self.soft.next::<BreaksMetric>();\n        }\n        let prev_off = self.offset;\n        self.offset = self.text.pos().min(self.soft.pos());\n\n        let eof_without_newline = self.offset > 0 && self.at_eof() && self.eof_without_newline();\n        if self.offset == prev_off || eof_without_newline {\n            None\n        } else {\n            self.cur_line += 1;\n            Some(self.offset)\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"<linewrap::VisualLines<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<VisualLine>{\n        let line_num = if self.cursor.is_hard_break() { Some(self.logical_line) } else { None };\n        let next_end_bound = match self.cursor.next() {\n            Some(b) => b,\n            None if self.eof => return None,\n            _else => {\n                self.eof = true;\n                self.len\n            }\n        };\n        let result = VisualLine::new(self.offset..next_end_bound, line_num);\n        if self.cursor.is_hard_break() {\n            self.logical_line += 1;\n        }\n        self.offset = next_end_bound;\n        Some(result)\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"<linewrap::WrapWidth as std::default::Default>::default":["fn default() -> Self{\n        WrapWidth::None\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"<plugins::PluginPid as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        write!(f, \"plugin-{}\", self.0)\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"<plugins::catalog::PluginLoadError as std::convert::From<std::io::Error>>::from":["fn from(err: io::Error) -> PluginLoadError{\n        PluginLoadError::Io(err)\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"<plugins::catalog::PluginLoadError as std::convert::From<toml::de::Error>>::from":["fn from(err: toml::de::Error) -> PluginLoadError{\n        PluginLoadError::Parse(err)\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"<plugins::manifest::PluginScope as std::default::Default>::default":["fn default() -> Self{\n        PluginScope::BufferLocal\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        #[derive(Deserialize)]\n        struct InnerIds {\n            view_id: ViewId,\n            plugin_id: PluginPid,\n        }\n        #[derive(Deserialize)]\n        struct IdsWrapper {\n            params: InnerIds,\n        }\n\n        let v = Value::deserialize(deserializer)?;\n        let helper = IdsWrapper::deserialize(&v).map_err(de::Error::custom)?;\n        let InnerIds { view_id, plugin_id } = helper.params;\n        let cmd = T::deserialize(v).map_err(de::Error::custom)?;\n        Ok(PluginCommand { view_id, plugin_id, cmd })\n    }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":["struct IdsWrapper {\n            params: InnerIds,\n        }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":["struct InnerIds {\n            view_id: ViewId,\n            plugin_id: PluginPid,\n        }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::PluginCommand<T> as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        let mut v = serde_json::to_value(&self.cmd).map_err(ser::Error::custom)?;\n        v[\"params\"][\"view_id\"] = json!(self.view_id);\n        v[\"params\"][\"plugin_id\"] = json!(self.plugin_id);\n        v.serialize(serializer)\n    }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        #[derive(Deserialize)]\n        struct InnerId {\n            view_id: ViewId,\n        }\n\n        let mut v = Value::deserialize(deserializer)?;\n        let helper = InnerId::deserialize(&v).map_err(de::Error::custom)?;\n        let InnerId { view_id } = helper;\n\n        // if params are empty, remove them\n        let remove_params = match v.get(\"params\") {\n            Some(&Value::Object(ref obj)) => obj.is_empty() && T::deserialize(v.clone()).is_err(),\n            Some(&Value::Array(ref arr)) => arr.is_empty() && T::deserialize(v.clone()).is_err(),\n            Some(_) => {\n                return Err(de::Error::custom(\n                    \"'params' field, if present, must be object or array.\",\n                ));\n            }\n            None => false,\n        };\n\n        if remove_params {\n            v.as_object_mut().map(|v| v.remove(\"params\"));\n        }\n\n        let cmd = T::deserialize(v).map_err(de::Error::custom)?;\n        Ok(EditCommand { view_id, cmd })\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":["struct InnerId {\n            view_id: ViewId,\n        }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::EditCommand<T> as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        let mut v = serde_json::to_value(&self.cmd).map_err(ser::Error::custom)?;\n        v[\"view_id\"] = json!(self.view_id);\n        v.serialize(serializer)\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        #[derive(Deserialize)]\n        struct TwoTuple(i64, i64);\n\n        let tup = TwoTuple::deserialize(deserializer)?;\n        Ok(LineRange { first: tup.0, last: tup.1 })\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":["struct TwoTuple(i64, i64);","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::LineRange as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        let as_tup = (self.first, self.last);\n        as_tup.serialize(serializer)\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::MouseAction as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        let v: Vec<u64> = Vec::deserialize(deserializer)?;\n        let click_count = if v.len() == 4 { Some(v[3]) } else { None };\n        Ok(MouseAction { line: v[0], column: v[1], flags: v[2], click_count })\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::MouseAction as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        #[derive(Serialize)]\n        struct Helper(u64, u64, u64, Option<u64>);\n\n        let as_tup = Helper(self.line, self.column, self.flags, self.click_count);\n        as_tup.serialize(serializer)\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::MouseAction as serde::Serialize>::serialize::Helper":["struct Helper(u64, u64, u64, Option<u64>);","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::SelectionModifier as std::default::Default>::default":["fn default() -> SelectionModifier{\n        SelectionModifier::Set\n    }","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"<selection::Affinity as std::default::Default>::default":["fn default() -> Affinity{\n        Affinity::Downstream\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::SelRegion as std::convert::From<xi_rope::Interval>>::from":["fn from(src: Interval) -> SelRegion{\n        SelRegion::new(src.start, src.end)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::SelRegion as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.is_caret() {\n            write!(f, \"{}|\", self.start)?;\n        } else if self.start < self.end {\n            write!(f, \"{}..{}|\", self.start, self.end)?;\n        } else {\n            write!(f, \"|{}..{}\", self.end, self.start)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::Selection as annotations::ToAnnotation>::get_annotations":["fn get_annotations(&self, interval: Interval, view: &View, text: &Rope) -> AnnotationSlice{\n        let regions = self.regions_in_range(interval.start(), interval.end());\n        let ranges = regions\n            .iter()\n            .map(|region| {\n                let (start_line, start_col) = view.offset_to_line_col(text, region.min());\n                let (end_line, end_col) = view.offset_to_line_col(text, region.max());\n\n                AnnotationRange { start_line, start_col, end_line, end_col }\n            })\n            .collect::<Vec<AnnotationRange>>();\n        AnnotationSlice::new(AnnotationType::Selection, ranges, None)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::Selection as std::convert::From<selection::SelRegion>>::from":["fn from(region: SelRegion) -> Self{\n        Self::new_simple(region)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::Selection as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.regions.len() == 1 {\n            self.regions[0].fmt(f)?;\n        } else {\n            write!(f, \"[ {}\", &self.regions[0])?;\n            for region in &self.regions[1..] {\n                write!(f, \", {}\", region)?;\n            }\n            write!(f, \" ]\")?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<selection::Selection as std::ops::Deref>::deref":["fn deref(&self) -> &[SelRegion]{\n        &self.regions\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"<std::boxed::Box<(dyn xi_rpc::Peer + 'static)> as watcher::Notify>::notify":["fn notify(&self){\n        self.schedule_idle(crate::tabs::WATCH_IDLE_TOKEN);\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"<styles::Style as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fn fmt_color(f: &mut fmt::Formatter, c: Option<u32>) -> fmt::Result {\n            if let Some(c) = c {\n                write!(f, \"#{:X}\", c)\n            } else {\n                write!(f, \"None\")\n            }\n        }\n\n        write!(f, \"Style( P{}, fg: \", self.priority)?;\n        fmt_color(f, self.fg_color)?;\n        write!(f, \" bg: \")?;\n        fmt_color(f, self.bg_color)?;\n\n        if let Some(w) = self.weight {\n            write!(f, \" weight {}\", w)?;\n        }\n        if let Some(i) = self.italic {\n            write!(f, \" ital: {}\", i)?;\n        }\n        if let Some(u) = self.underline {\n            write!(f, \" uline: {}\", u)?;\n        }\n        write!(f, \" )\")\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"<styles::Style as std::fmt::Debug>::fmt::fmt_color":["fn fmt_color(f: &mut fmt::Formatter, c: Option<u32>) -> fmt::Result{\n            if let Some(c) = c {\n                write!(f, \"#{:X}\", c)\n            } else {\n                write!(f, \"None\")\n            }\n        }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"<syntax::LanguageId as std::borrow::Borrow<str>>::borrow":["fn borrow(&self) -> &str{\n        &self.0.as_ref()\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"<syntax::LanguageId as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        self.0.as_ref()\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"<syntax::LanguageId as std::convert::From<&'a str>>::from":["fn from(src: &'a str) -> LanguageId{\n        LanguageId(Arc::new(src.into()))\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"<tabs::BufferId as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"buffer-id-{}\", self.0)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<tabs::Iter<'a, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let &mut Iter { ref mut views, ref mut seen, ref inner } = self;\n        loop {\n            let next_view = match views.next() {\n                None => return None,\n                Some(v) if seen.contains(v) => continue,\n                Some(v) => v,\n            };\n            let context = inner.make_context(*next_view).unwrap();\n            context.siblings.iter().for_each(|sibl| {\n                let _ = seen.insert(sibl.borrow().get_view_id());\n            });\n            return Some(context);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<tabs::ViewId as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        let s = String::deserialize(deserializer)?;\n        let ord = s.trim_start_matches(\"view-id-\");\n        match usize::from_str_radix(ord, 10) {\n            Ok(id) => Ok(ViewId(id)),\n            Err(_) => Err(de::Error::invalid_value(Unexpected::Str(&s), &\"view id\")),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<tabs::ViewId as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        serializer.serialize_str(&self.to_string())\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<tabs::ViewId as std::convert::From<usize>>::from":["fn from(src: usize) -> ViewId{\n        ViewId(src)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<tabs::ViewId as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"view-id-{}\", self.0)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"<view::View as line_offset::LineOffset>::line_of_offset":["fn line_of_offset(&self, text: &Rope, offset: usize) -> usize{\n        self.lines.visual_line_of_offset(text, offset)\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"<view::View as line_offset::LineOffset>::offset_of_line":["fn offset_of_line(&self, text: &Rope, line: usize) -> usize{\n        self.lines.offset_of_visual_line(text, line)\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"<watcher::Watchee as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Watchee path: {:?}, r {}, t {} f {}\",\n            self.path,\n            self.recursive,\n            self.token.0,\n            self.filter.is_some()\n        )\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"<width_cache::CodepointMono as width_cache::WidthMeasure>::measure_width":["/// In which each codepoint has width == 1.\nfn measure_width(&self, request: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error>{\n        Ok(request\n            .iter()\n            .map(|r| r.strings.iter().map(|s| s.chars().count() as f64).collect())\n            .collect())\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::line_of_offset":["fn line_of_offset(&self, text: &Rope, offset: usize) -> usize{\n        let offset = offset.min(text.len());\n        self.count::<xi_rope::breaks::BreaksMetric>(offset)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::offset_of_line":["fn offset_of_line(&self, _text: &Rope, line: usize) -> usize{\n        self.count_base_units::<xi_rope::breaks::BreaksMetric>(line)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"annotations::AnnotationRange":["/// Location and range of an annotation ([start_line, start_col, end_line, end_col]).\n/// Location and range of an annotation\npub struct AnnotationRange {\n    pub start_line: usize,\n    pub start_col: usize,\n    pub end_line: usize,\n    pub end_col: usize,\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationSlice":["/// A region of an `Annotation`.\npub struct AnnotationSlice {\n    annotation_type: AnnotationType,\n    /// Annotation occurrences, guaranteed non-descending start order.\n    ranges: Vec<AnnotationRange>,\n    /// If present, one payload per range.\n    payloads: Option<Vec<Value>>,\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationSlice::new":["pub fn new(\n        annotation_type: AnnotationType,\n        ranges: Vec<AnnotationRange>,\n        payloads: Option<Vec<Value>>,\n    ) -> Self{\n        AnnotationSlice { annotation_type, ranges, payloads }\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationSlice::to_json":["/// Returns json representation.\npub fn to_json(&self) -> Value{\n        json!({\n            \"type\": self.annotation_type.as_str(),\n            \"ranges\": self.ranges,\n            \"payloads\": self.payloads,\n            \"n\": self.ranges.len()\n        })\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore":["/// All the annotations for a given view\npub struct AnnotationStore {\n    store: HashMap<PluginId, Vec<Annotations>>,\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore::clear":["/// Removes any annotations provided by this plugin\npub fn clear(&mut self, plugin: PluginId){\n        self.store.remove(&plugin);\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore::invalidate":["/// Invalidates and removes all annotations in the range of the interval.\npub fn invalidate(&mut self, interval: Interval){\n        self.store\n            .values_mut()\n            .map(|v| v.iter_mut())\n            .flatten()\n            .for_each(|a| a.invalidate(interval));\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore::iter_range":["/// Returns an iterator which produces, for each type of annotation,\n/// those annotations which intersect the given interval.\npub fn iter_range<'c>(\n        &'c self,\n        view: &'c View,\n        text: &'c Rope,\n        interval: Interval,\n    ) -> impl Iterator<Item = AnnotationSlice> + 'c{\n        self.store.iter().flat_map(move |(_plugin, value)| {\n            value.iter().map(move |annotation| {\n                // .filter() used instead of .subseq() because subseq() filters out spans with length 0\n                let payloads = annotation\n                    .items\n                    .iter()\n                    .filter(|(i, _p)| i.start() <= interval.end() && i.end() >= interval.start())\n                    .map(|(_i, p)| p.clone())\n                    .collect::<Vec<Value>>();\n\n                let ranges = annotation\n                    .items\n                    .iter()\n                    .filter(|(i, _p)| i.start() <= interval.end() && i.end() >= interval.start())\n                    .map(|(i, _p)| {\n                        let (start_line, start_col) = view.offset_to_line_col(text, i.start());\n                        let (end_line, end_col) = view.offset_to_line_col(text, i.end());\n\n                        AnnotationRange { start_line, start_col, end_line, end_col }\n                    })\n                    .collect::<Vec<AnnotationRange>>();\n\n                AnnotationSlice {\n                    annotation_type: annotation.annotation_type.clone(),\n                    ranges,\n                    payloads: Some(payloads),\n                }\n            })\n        })\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore::new":["pub fn new() -> Self{\n        AnnotationStore { store: HashMap::new() }\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationStore::update":["/// Applies an update from a plugin to a set of annotations\npub fn update(&mut self, source: PluginId, interval: Interval, item: Annotations){\n        if !self.store.contains_key(&source) {\n            self.store.insert(source, vec![item]);\n            return;\n        }\n\n        let entry = self.store.get_mut(&source).unwrap();\n        if let Some(annotation) =\n            entry.iter_mut().find(|a| a.annotation_type == item.annotation_type)\n        {\n            annotation.update(interval, item.items);\n        } else {\n            entry.push(item);\n        }\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationType":["pub enum AnnotationType {\n    Selection,\n    Find,\n    Other(String),\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::AnnotationType::as_str":["fn as_str(&self) -> &str{\n        match self {\n            AnnotationType::Find => \"find\",\n            AnnotationType::Selection => \"selection\",\n            AnnotationType::Other(ref s) => s,\n        }\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::Annotations":["/// A set of annotations of a given type.\npub struct Annotations {\n    pub items: Spans<Value>,\n    pub annotation_type: AnnotationType,\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::Annotations::invalidate":["/// Remove annotations intersecting `interval`.\npub fn invalidate(&mut self, interval: Interval){\n        self.items.delete_after(interval);\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::Annotations::update":["/// Update the annotations in `interval` with the provided `items`.\npub fn update(&mut self, interval: Interval, items: Spans<Value>){\n        self.items.edit(interval, items);\n    }","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::ToAnnotation":["/// A trait for types (like `Selection`) that have a distinct representation\n/// in core but are presented to the frontend as annotations.\npub trait ToAnnotation {\n    /// Returns annotations that overlap the provided interval.\n    fn get_annotations(&self, interval: Interval, view: &View, text: &Rope) -> AnnotationSlice;\n}","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))"],"backspace::offset_for_delete_backwards":["#[allow(clippy::cognitive_complexity)]\npub fn offset_for_delete_backwards(region: &SelRegion, text: &Rope, config: &BufferItems) -> usize{\n    if !region.is_caret() {\n        region.min()\n    } else {\n        // backspace deletes max(1, tab_size) contiguous spaces\n        let (_, c) = LogicalLines.offset_to_line_col(&text, region.start);\n\n        let tab_off = c % config.tab_size;\n        let tab_size = config.tab_size;\n        let tab_size = if tab_off == 0 { tab_size } else { tab_off };\n        let tab_start = region.start.saturating_sub(tab_size);\n        let preceded_by_spaces =\n            region.start > 0 && (tab_start..region.start).all(|i| text.byte_at(i) == b' ');\n        if preceded_by_spaces && config.translate_tabs_to_spaces && config.use_tab_stops {\n            tab_start\n        } else {\n            #[derive(PartialEq)]\n            enum State {\n                Start,\n                Lf,\n                BeforeKeycap,\n                BeforeVsAndKeycap,\n                BeforeEmojiModifier,\n                BeforeVSAndEmojiModifier,\n                BeforeVS,\n                BeforeEmoji,\n                BeforeZwj,\n                BeforeVSAndZWJ,\n                OddNumberedRIS,\n                EvenNumberedRIS,\n                InTagSequence,\n                Finished,\n            };\n            let mut state = State::Start;\n            let mut tmp_offset = region.end;\n\n            let mut delete_code_point_count = 0;\n            let mut last_seen_vs_code_point_count = 0;\n\n            while state != State::Finished && tmp_offset > 0 {\n                let mut cursor = Cursor::new(&text, tmp_offset);\n                let code_point = cursor.prev_codepoint().unwrap_or('0');\n\n                tmp_offset = text.prev_codepoint_offset(tmp_offset).unwrap_or(0);\n\n                match state {\n                    State::Start => {\n                        delete_code_point_count = 1;\n                        if code_point == '\\n' {\n                            state = State::Lf;\n                        } else if is_variation_selector(code_point) {\n                            state = State::BeforeVS;\n                        } else if code_point.is_regional_indicator_symbol() {\n                            state = State::OddNumberedRIS;\n                        } else if code_point.is_emoji_modifier() {\n                            state = State::BeforeEmojiModifier;\n                        } else if code_point.is_emoji_combining_enclosing_keycap() {\n                            state = State::BeforeKeycap;\n                        } else if code_point.is_emoji() {\n                            state = State::BeforeEmoji;\n                        } else if code_point.is_emoji_cancel_tag() {\n                            state = State::InTagSequence;\n                        } else {\n                            state = State::Finished;\n                        }\n                    }\n                    State::Lf => {\n                        if code_point == '\\r' {\n                            delete_code_point_count += 1;\n                        }\n                        state = State::Finished;\n                    }\n                    State::OddNumberedRIS => {\n                        if code_point.is_regional_indicator_symbol() {\n                            delete_code_point_count += 1;\n                            state = State::EvenNumberedRIS\n                        } else {\n                            state = State::Finished\n                        }\n                    }\n                    State::EvenNumberedRIS => {\n                        if code_point.is_regional_indicator_symbol() {\n                            delete_code_point_count -= 1;\n                            state = State::OddNumberedRIS;\n                        } else {\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeKeycap => {\n                        if is_variation_selector(code_point) {\n                            last_seen_vs_code_point_count = 1;\n                            state = State::BeforeVsAndKeycap;\n                        } else {\n                            if is_keycap_base(code_point) {\n                                delete_code_point_count += 1;\n                            }\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeVsAndKeycap => {\n                        if is_keycap_base(code_point) {\n                            delete_code_point_count += last_seen_vs_code_point_count + 1;\n                        }\n                        state = State::Finished;\n                    }\n                    State::BeforeEmojiModifier => {\n                        if is_variation_selector(code_point) {\n                            last_seen_vs_code_point_count = 1;\n                            state = State::BeforeVSAndEmojiModifier;\n                        } else {\n                            if code_point.is_emoji_modifier_base() {\n                                delete_code_point_count += 1;\n                            }\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeVSAndEmojiModifier => {\n                        if code_point.is_emoji_modifier_base() {\n                            delete_code_point_count += last_seen_vs_code_point_count + 1;\n                        }\n                        state = State::Finished;\n                    }\n                    State::BeforeVS => {\n                        if code_point.is_emoji() {\n                            delete_code_point_count += 1;\n                            state = State::BeforeEmoji;\n                        } else {\n                            if !is_variation_selector(code_point) {\n                                //TODO: UCharacter.getCombiningClass(codePoint) == 0\n                                delete_code_point_count += 1;\n                            }\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeEmoji => {\n                        if code_point.is_zwj() {\n                            state = State::BeforeZwj;\n                        } else {\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeZwj => {\n                        if code_point.is_emoji() {\n                            delete_code_point_count += 2;\n                            state = if code_point.is_emoji_modifier() {\n                                State::BeforeEmojiModifier\n                            } else {\n                                State::BeforeEmoji\n                            };\n                        } else if is_variation_selector(code_point) {\n                            last_seen_vs_code_point_count = 1;\n                            state = State::BeforeVSAndZWJ;\n                        } else {\n                            state = State::Finished;\n                        }\n                    }\n                    State::BeforeVSAndZWJ => {\n                        if code_point.is_emoji() {\n                            delete_code_point_count += last_seen_vs_code_point_count + 2;\n                            last_seen_vs_code_point_count = 0;\n                            state = State::BeforeEmoji;\n                        } else {\n                            state = State::Finished;\n                        }\n                    }\n                    State::InTagSequence => {\n                        if code_point.is_tag_spec_char() {\n                            delete_code_point_count += 1;\n                        } else if code_point.is_emoji() {\n                            delete_code_point_count += 1;\n                            state = State::Finished;\n                        } else {\n                            delete_code_point_count = 1;\n                            state = State::Finished;\n                        }\n                    }\n                    State::Finished => {\n                        break;\n                    }\n                }\n            }\n\n            let mut start = region.end;\n            while delete_code_point_count > 0 {\n                start = text.prev_codepoint_offset(start).unwrap_or(0);\n                delete_code_point_count -= 1;\n            }\n            start\n        }\n    }\n}","Real(LocalPath(\"core-lib/src/backspace.rs\"))"],"backspace::offset_for_delete_backwards::State":["enum State {\n                Start,\n                Lf,\n                BeforeKeycap,\n                BeforeVsAndKeycap,\n                BeforeEmojiModifier,\n                BeforeVSAndEmojiModifier,\n                BeforeVS,\n                BeforeEmoji,\n                BeforeZwj,\n                BeforeVSAndZWJ,\n                OddNumberedRIS,\n                EvenNumberedRIS,\n                InTagSequence,\n                Finished,\n            }","Real(LocalPath(\"core-lib/src/backspace.rs\"))"],"client::Client":["/// An interface to the frontend.\npub struct Client(RpcPeer);","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::add_status_item":["pub fn add_status_item(\n        &self,\n        view_id: ViewId,\n        source: &str,\n        key: &str,\n        value: &str,\n        alignment: &str,\n    ){\n        self.0.send_rpc_notification(\n            \"add_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"source\": source,\n                \"key\": key,\n                \"value\": value,\n                \"alignment\": alignment\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::alert":["pub fn alert<S: AsRef<str>>(&self, msg: S){\n        self.0.send_rpc_notification(\"alert\", &json!({ \"msg\": msg.as_ref() }));\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::available_languages":["pub fn available_languages(&self, languages: Vec<LanguageId>){\n        self.0.send_rpc_notification(\"available_languages\", &json!({ \"languages\": languages }))\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::available_plugins":["/// Notify the client of the available plugins.\npub fn available_plugins(&self, view_id: ViewId, plugins: &[ClientPluginInfo]){\n        self.0.send_rpc_notification(\n            \"available_plugins\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugins\": plugins }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::available_themes":["pub fn available_themes(&self, theme_names: Vec<String>){\n        self.0.send_rpc_notification(\"available_themes\", &json!({ \"themes\": theme_names }))\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::config_changed":["pub fn config_changed(&self, view_id: ViewId, changes: &Table){\n        self.0.send_rpc_notification(\n            \"config_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"changes\": changes,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::def_style":["pub fn def_style(&self, style: &Value){\n        self.0.send_rpc_notification(\"def_style\", &style)\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::find_status":["pub fn find_status(&self, view_id: ViewId, queries: &Value){\n        self.0.send_rpc_notification(\n            \"find_status\",\n            &json!({\n                \"view_id\": view_id,\n                \"queries\": queries,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::language_changed":["pub fn language_changed(&self, view_id: ViewId, new_lang: &LanguageId){\n        self.0.send_rpc_notification(\n            \"language_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"language_id\": new_lang,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::measure_width":["/// Ask front-end to measure widths of strings.\npub fn measure_width(&self, reqs: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error>{\n        let req_json = serde_json::to_value(reqs).expect(\"failed to serialize width req\");\n        let resp = self.0.send_rpc_request(\"measure_width\", &req_json)?;\n        Ok(serde_json::from_value(resp).expect(\"failed to deserialize width response\"))\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::new":["pub fn new(peer: RpcPeer) -> Self{\n        Client(peer)\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::plugin_started":["/// Notify the client that a plugin has started.\npub fn plugin_started(&self, view_id: ViewId, plugin: &str){\n        self.0.send_rpc_notification(\n            \"plugin_started\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::plugin_stopped":["/// Notify the client that a plugin has stopped.\n///\n/// `code` is not currently used; in the future may be used to\n/// pass an exit code.\npub fn plugin_stopped(&self, view_id: ViewId, plugin: &str, code: i32){\n        self.0.send_rpc_notification(\n            \"plugin_stopped\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n                \"code\": code,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::remove_status_item":["pub fn remove_status_item(&self, view_id: ViewId, key: &str){\n        self.0.send_rpc_notification(\n            \"remove_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"key\": key,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::replace_status":["pub fn replace_status(&self, view_id: ViewId, replace: &Value){\n        self.0.send_rpc_notification(\n            \"replace_status\",\n            &json!({\n                \"view_id\": view_id,\n                \"status\": replace,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::schedule_idle":["pub fn schedule_idle(&self, token: usize){\n        self.0.schedule_idle(token)\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::schedule_timer":["pub fn schedule_timer(&self, timeout: Instant, token: usize){\n        self.0.schedule_timer(timeout, token);\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::scroll_to":["pub fn scroll_to(&self, view_id: ViewId, line: usize, col: usize){\n        self.0.send_rpc_notification(\n            \"scroll_to\",\n            &json!({\n                \"view_id\": view_id,\n                \"line\": line,\n                \"col\": col,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::show_hover":["pub fn show_hover(&self, view_id: ViewId, request_id: usize, result: String){\n        self.0.send_rpc_notification(\n            \"show_hover\",\n            &json!({\n                \"view_id\": view_id,\n                \"request_id\": request_id,\n                \"result\": result,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::theme_changed":["pub fn theme_changed(&self, name: &str, theme: &ThemeSettings){\n        self.0.send_rpc_notification(\n            \"theme_changed\",\n            &json!({\n                \"name\": name,\n                \"theme\": theme,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::update_cmds":["pub fn update_cmds(&self, view_id: ViewId, plugin: &str, cmds: &[Command]){\n        self.0.send_rpc_notification(\n            \"update_cmds\",\n            &json!({\n                \"view_id\": view_id,\n                \"plugin\": plugin,\n                \"cmds\": cmds,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::update_status_item":["pub fn update_status_item(&self, view_id: ViewId, key: &str, value: &str){\n        self.0.send_rpc_notification(\n            \"update_status_item\",\n            &json!({\n                \"view_id\": view_id,\n                \"key\": key,\n                \"value\": value,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Client::update_view":["pub fn update_view(&self, view_id: ViewId, update: &Update){\n        self.0.send_rpc_notification(\n            \"update\",\n            &json!({\n                \"view_id\": view_id,\n                \"update\": update,\n            }),\n        );\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::OpType":["#[serde(rename_all = \"lowercase\")]\nenum OpType {\n    #[serde(rename = \"ins\")]\n    Insert,\n    Skip,\n    Invalidate,\n    Copy,\n    Update,\n}","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::Update":["pub struct Update {\n    pub(crate) ops: Vec<UpdateOp>,\n    pub(crate) pristine: bool,\n    pub(crate) annotations: Vec<Value>,\n}","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp":["pub(crate) struct UpdateOp {\n    op: OpType,\n    n: usize,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    lines: Option<Vec<Value>>,\n    #[serde(rename = \"ln\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    first_line_number: Option<usize>,\n}","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp::copy":["pub(crate) fn copy(n: usize, line: usize) -> Self{\n        UpdateOp { op: OpType::Copy, n, lines: None, first_line_number: Some(line) }\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp::insert":["pub(crate) fn insert(lines: Vec<Value>) -> Self{\n        UpdateOp { op: OpType::Insert, n: lines.len(), lines: Some(lines), first_line_number: None }\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp::invalidate":["pub(crate) fn invalidate(n: usize) -> Self{\n        UpdateOp { op: OpType::Invalidate, n, lines: None, first_line_number: None }\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp::skip":["pub(crate) fn skip(n: usize) -> Self{\n        UpdateOp { op: OpType::Skip, n, lines: None, first_line_number: None }\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"client::UpdateOp::update":["pub(crate) fn update(lines: Vec<Value>, line_opt: Option<usize>) -> Self{\n        UpdateOp {\n            op: OpType::Update,\n            n: lines.len(),\n            lines: Some(lines),\n            first_line_number: line_opt,\n        }\n    }","Real(LocalPath(\"core-lib/src/client.rs\"))"],"config::BufferItems":["/// The concrete type for buffer-related settings.\npub struct BufferItems {\n    pub line_ending: String,\n    #[serde(deserialize_with = \"deserialize_tab_size\")]\n    pub tab_size: usize,\n    pub translate_tabs_to_spaces: bool,\n    pub use_tab_stops: bool,\n    pub font_face: String,\n    pub font_size: f32,\n    pub auto_indent: bool,\n    pub scroll_past_end: bool,\n    pub wrap_width: usize,\n    pub word_wrap: bool,\n    pub autodetect_whitespace: bool,\n    pub surrounding_pairs: Vec<(String, String)>,\n    pub save_with_newline: bool,\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::Config":["/// A frozen collection of settings, and their sources.\npub struct Config<T> {\n    /// The underlying set of config tables that contributed to this\n    /// `Config` instance. Used for diffing.\n    #[serde(skip)]\n    source: TableStack,\n    /// The settings themselves, deserialized into some concrete type.\n    pub items: T,\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::Config::<T>::changes_from":["/// Returns a `Table` of all the items in `self` which have different\n/// values than in `other`.\npub fn changes_from(&self, other: Option<&Config<T>>) -> Option<Table>{\n        match other {\n            Some(other) => self.source.diff(&other.source),\n            None => self.source.collate().into(),\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::Config::<T>::to_table":["pub fn to_table(&self) -> Table{\n        self.source.collate()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigDomain":["/// A `ConfigDomain` describes a level or category of user settings.\n#[serde(rename_all = \"snake_case\")]\npub enum ConfigDomain {\n    /// The general user preferences\n    General,\n    /// The overrides for a particular syntax.\n    Language(LanguageId),\n    /// The user overrides for a particular buffer\n    UserOverride(BufferId),\n    /// The system's overrides for a particular buffer. Only used internally.\n    #[serde(skip_deserializing)]\n    SysOverride(BufferId),\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigDomain::file_stem":["fn file_stem(&self) -> &str{\n        match self {\n            ConfigDomain::General => \"preferences\",\n            ConfigDomain::Language(lang) => lang.as_ref(),\n            ConfigDomain::UserOverride(_) | ConfigDomain::SysOverride(_) => \"we don't have files\",\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigDomainExternal":["/// The external RPC sends `ViewId`s, which we convert to `BufferId`s\n/// internally.\n#[serde(rename_all = \"snake_case\")]\npub enum ConfigDomainExternal {\n    General,\n    //TODO: remove this old name\n    Syntax(LanguageId),\n    Language(LanguageId),\n    UserOverride(ViewId),\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigError":["/// The errors that can occur when managing configs.\npub enum ConfigError {\n    /// The config domain was not recognized.\n    UnknownDomain(String),\n    /// A file-based config could not be loaded or parsed.\n    Parse(PathBuf, toml::de::Error),\n    /// The config table contained unexpected values\n    UnexpectedItem(serde_json::Error),\n    /// An Io Error\n    Io(io::Error),\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager":["pub struct ConfigManager {\n    /// A map of `ConfigPairs` (defaults + overrides) for all in-use domains.\n    configs: HashMap<ConfigDomain, ConfigPair>,\n    /// The currently loaded `Languages`.\n    languages: Languages,\n    /// The language assigned to each buffer.\n    buffer_tags: HashMap<BufferId, LanguageTag>,\n    /// The configs for any open buffers\n    buffer_configs: HashMap<BufferId, BufferConfig>,\n    /// If using file-based config, this is the base config directory\n    /// (perhaps `$HOME/.config/xi`, by default).\n    config_dir: Option<PathBuf>,\n    /// An optional client-provided path for bundled resources, such\n    /// as plugins and themes.\n    extras_dir: Option<PathBuf>,\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::add_buffer":["/// Adds a new buffer to the config manager, and returns the initial config\n/// `Table` for that buffer. The `path` argument is used to determine\n/// the buffer's default language.\n///\n/// # Note: The caller is responsible for ensuring the config manager is\n/// notified every time a buffer is added or removed.\n///\n/// # Panics:\n///\n/// Panics if `id` already exists.\npub(crate) fn add_buffer(&mut self, id: BufferId, path: Option<&Path>) -> Table{\n        let lang =\n            path.and_then(|p| self.language_for_path(p)).unwrap_or(LanguageId::from(\"Plain Text\"));\n        let lang_tag = LanguageTag::new(lang);\n        assert!(self.buffer_tags.insert(id, lang_tag).is_none());\n        self.update_buffer_config(id).expect(\"new buffer must always have config\")\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::base_config_file_path":["/// The path of the user's config file, if present.\npub(crate) fn base_config_file_path(&self) -> Option<PathBuf>{\n        let config_file = self.config_dir.as_ref().map(|p| p.join(\"preferences.xiconfig\"));\n        let exists = config_file.as_ref().map(|p| p.exists()).unwrap_or(false);\n        if exists {\n            config_file\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::check_table":["fn check_table(&self, table: &Table) -> Result<(), ConfigError>{\n        let defaults = self\n            .configs\n            .get(&ConfigDomain::General)\n            .and_then(|pair| pair.base.clone())\n            .expect(\"general domain must have defaults\");\n        let mut defaults: Table = defaults.as_ref().clone();\n        for (k, v) in table.iter() {\n            // changes can include 'null', which means clear field\n            if v.is_null() {\n                continue;\n            }\n            defaults.insert(k.to_owned(), v.to_owned());\n        }\n        let _: BufferItems = serde_json::from_value(defaults.into())?;\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::domain_for_path":["/// Returns the `ConfigDomain` relevant to a given file, if one exists.\npub fn domain_for_path(&self, path: &Path) -> Option<ConfigDomain>{\n        if path.extension().map(|e| e != \"xiconfig\").unwrap_or(true) {\n            return None;\n        }\n        match path.file_stem().and_then(|s| s.to_str()) {\n            Some(\"preferences\") => Some(ConfigDomain::General),\n            Some(name) if self.languages.language_for_name(&name).is_some() => {\n                let lang =\n                    self.languages.language_for_name(&name).map(|lang| lang.name.clone()).unwrap();\n                Some(ConfigDomain::Language(lang))\n            }\n            //TODO: plugin configs\n            _ => None,\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::generate_buffer_config":["fn generate_buffer_config(&mut self, id: BufferId) -> BufferConfig{\n        // it's possible for a buffer to be tagged with since-removed language\n        let lang = self\n            .buffer_tags\n            .get(&id)\n            .map(LanguageTag::resolve)\n            .and_then(|name| self.languages.language_for_name(name))\n            .map(|l| l.name.clone());\n        let mut configs = Vec::new();\n\n        configs.push(self.configs.get(&ConfigDomain::General));\n        if let Some(s) = lang {\n            configs.push(self.configs.get(&s.into()))\n        };\n        configs.push(self.configs.get(&ConfigDomain::SysOverride(id)));\n        configs.push(self.configs.get(&ConfigDomain::UserOverride(id)));\n\n        let configs = configs\n            .iter()\n            .flat_map(Option::iter)\n            .map(|c| c.cache.clone())\n            .rev()\n            .collect::<Vec<_>>();\n\n        let stack = TableStack(configs);\n        stack.into_config()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::get_buffer_config":["/// Returns a reference to the `BufferConfig` for this buffer.\n///\n/// # Panics:\n///\n/// Panics if `id` does not exist. The caller is responsible for ensuring\n/// that the `ConfigManager` is kept up to date as buffers are added/removed.\npub(crate) fn get_buffer_config(&self, id: BufferId) -> &BufferConfig{\n        self.buffer_configs.get(&id).unwrap()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::get_buffer_language":["/// Returns the language associated with this buffer.\n///\n/// # Panics:\n///\n/// Panics if `id` does not exist.\npub(crate) fn get_buffer_language(&self, id: BufferId) -> LanguageId{\n        self.buffer_tags.get(&id).map(LanguageTag::resolve).unwrap()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::get_plugin_paths":["pub(crate) fn get_plugin_paths(&self) -> Vec<PathBuf>{\n        let config_dir = self.config_dir.as_ref().map(|p| p.join(\"plugins\"));\n        [self.extras_dir.as_ref(), config_dir.as_ref()]\n            .iter()\n            .flat_map(|p| p.map(|p| p.to_owned()))\n            .filter(|p| p.exists())\n            .collect()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::get_plugins_dir":["/// Path to plugins sub directory inside config directory.\n/// Creates one if not present.\npub(crate) fn get_plugins_dir(&self) -> Option<PathBuf>{\n        let plugins_dir = self.config_dir.as_ref().map(|p| p.join(\"plugins\"));\n\n        if let Some(p) = plugins_dir {\n            if p.exists() {\n                return Some(p);\n            }\n            if fs::DirBuilder::new().create(&p).is_ok() {\n                return Some(p);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::get_themes_dir":["/// Path to themes sub directory inside config directory.\n/// Creates one if not present.\npub(crate) fn get_themes_dir(&self) -> Option<PathBuf>{\n        let themes_dir = self.config_dir.as_ref().map(|p| p.join(\"themes\"));\n\n        if let Some(p) = themes_dir {\n            if p.exists() {\n                return Some(p);\n            }\n            if fs::DirBuilder::new().create(&p).is_ok() {\n                return Some(p);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::language_for_path":["pub fn language_for_path(&self, path: &Path) -> Option<LanguageId>{\n        self.languages.language_for_path(path).map(|lang| lang.name.clone())\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::load_user_config_file":["fn load_user_config_file(&self, domain: &ConfigDomain) -> Option<Table>{\n        let path = self\n            .config_dir\n            .as_ref()\n            .map(|p| p.join(domain.file_stem()).with_extension(\"xiconfig\"))?;\n\n        if !path.exists() {\n            return None;\n        }\n\n        match try_load_from_file(&path) {\n            Ok(t) => Some(t),\n            Err(e) => {\n                error!(\"Error loading config: {:?}\", e);\n                None\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::new":["pub fn new(config_dir: Option<PathBuf>, extras_dir: Option<PathBuf>) -> Self{\n        let base = load_base_config();\n        let mut defaults = HashMap::new();\n        defaults.insert(ConfigDomain::General, ConfigPair::with_base(base));\n        ConfigManager {\n            configs: defaults,\n            buffer_tags: HashMap::new(),\n            buffer_configs: HashMap::new(),\n            languages: Languages::default(),\n            config_dir,\n            extras_dir,\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::override_language":["/// Sets a specific language for the given buffer. This is used if the\n/// user selects a specific language in the frontend, for instance.\npub(crate) fn override_language(\n        &mut self,\n        id: BufferId,\n        new_lang: LanguageId,\n    ) -> Option<Table>{\n        let has_changed = self\n            .buffer_tags\n            .get_mut(&id)\n            .map(|tag| tag.set_user(Some(new_lang)))\n            .expect(\"buffer must exist\");\n        if has_changed {\n            self.update_buffer_config(id)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::remove_buffer":["/// Instructs the `ConfigManager` to stop tracking a given buffer.\n///\n/// # Panics:\n///\n/// Panics if `id` does not exist.\npub(crate) fn remove_buffer(&mut self, id: BufferId){\n        self.buffer_tags.remove(&id).expect(\"remove key must exist\");\n        self.buffer_configs.remove(&id);\n        // TODO: remove any overrides\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::set_languages":["/// Set the available `LanguageDefinition`s. Overrides any previous values.\npub fn set_languages(&mut self, languages: Languages){\n        // remove base configs for any removed languages\n        self.languages.difference(&languages).iter().for_each(|lang| {\n            let domain: ConfigDomain = lang.name.clone().into();\n            if let Some(pair) = self.configs.get_mut(&domain) {\n                *pair = pair.new_with_base(None);\n            }\n        });\n\n        for language in languages.iter() {\n            let lang_id = language.name.clone();\n            let domain: ConfigDomain = lang_id.into();\n            let default_config = language.default_config.clone();\n            self.configs\n                .entry(domain.clone())\n                .and_modify(|c| *c = c.new_with_base(default_config.clone()))\n                .or_insert_with(|| ConfigPair::with_base(default_config));\n            if let Some(table) = self.load_user_config_file(&domain) {\n                // we can't report this error because we don't have a\n                // handle to the peer :|\n                let _ = self.set_user_config(domain, table);\n            }\n        }\n        //FIXME these changes are happening silently, which won't work once\n        //languages can by dynamically changed\n        self.languages = languages;\n        self.update_all_buffer_configs();\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::set_user_config":["/// Sets the config for the given domain, removing any existing config.\n/// Returns a `Vec` of individual buffer config changes that result from\n/// this update, or a `ConfigError` if `config` is poorly formed.\npub fn set_user_config(\n        &mut self,\n        domain: ConfigDomain,\n        config: Table,\n    ) -> Result<Vec<(BufferId, Table)>, ConfigError>{\n        self.check_table(&config)?;\n        self.configs.entry(domain).or_insert_with(|| ConfigPair::with_base(None)).set_table(config);\n        Ok(self.update_all_buffer_configs())\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::table_for_update":["/// Returns the `Table` produced by applying `changes` to the current user\n/// config for the given `ConfigDomain`.\n///\n/// # Note:\n///\n/// When the user modifys a config _file_, the whole file is read,\n/// and we can just overwrite any existing user config with the newly\n/// loaded one.\n///\n/// When the client modifies a config via the RPC mechanism, however,\n/// this isn't the case. Instead of sending all config settings with\n/// each update, the client just sends the keys/values they would like\n/// to change. When they would like to remove a previously set key,\n/// they send `Null` as the value for that key.\n///\n/// This function creates a new table which is the product of updating\n/// any existing table by applying the client's changes. This new table can\n/// then be passed to `Self::set_user_config(..)`, as if it were loaded\n/// from disk.\npub(crate) fn table_for_update(&mut self, domain: ConfigDomain, changes: Table) -> Table{\n        self.configs\n            .entry(domain)\n            .or_insert_with(|| ConfigPair::with_base(None))\n            .table_for_update(changes)\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::update_all_buffer_configs":["fn update_all_buffer_configs(&mut self) -> Vec<(BufferId, Table)>{\n        self.buffer_configs\n            .keys()\n            .cloned()\n            .collect::<Vec<_>>()\n            .into_iter()\n            .flat_map(|k| self.update_buffer_config(k).map(|c| (k, c)))\n            .collect::<Vec<_>>()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::update_buffer_config":["fn update_buffer_config(&mut self, id: BufferId) -> Option<Table>{\n        let new_config = self.generate_buffer_config(id);\n        let changes = new_config.changes_from(self.buffer_configs.get(&id));\n        self.buffer_configs.insert(id, new_config);\n        changes\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigManager::update_buffer_path":["/// Updates the default language for the given buffer.\n///\n/// # Panics:\n///\n/// Panics if `id` does not exist.\npub(crate) fn update_buffer_path(&mut self, id: BufferId, path: &Path) -> Option<Table>{\n        assert!(self.buffer_tags.contains_key(&id));\n        let lang = self.language_for_path(path).unwrap_or_default();\n        let has_changed = self.buffer_tags.get_mut(&id).map(|tag| tag.set_detected(lang)).unwrap();\n\n        if has_changed {\n            self.update_buffer_config(id)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair":["/// Represents the common pattern of default settings masked by\n/// user settings.\npub struct ConfigPair {\n    /// A static default configuration, which will never change.\n    base: Option<Arc<Table>>,\n    /// A variable, user provided configuration. Items here take\n    /// precedence over items in `base`.\n    user: Option<Arc<Table>>,\n    /// A snapshot of base + user.\n    cache: Arc<Table>,\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair::new_with_base":["/// Returns a new `ConfigPair` with the provided base and the current\n/// user config.\nfn new_with_base<T: Into<Option<Table>>>(&self, table: T) -> Self{\n        let mut new_self = ConfigPair::with_base(table);\n        new_self.user = self.user.clone();\n        new_self.rebuild();\n        new_self\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair::rebuild":["fn rebuild(&mut self){\n        let mut cache = self.base.clone().unwrap_or_default();\n        if let Some(ref user) = self.user {\n            for (k, v) in user.iter() {\n                Arc::make_mut(&mut cache).insert(k.to_owned(), v.clone());\n            }\n        }\n        self.cache = cache;\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair::set_table":["fn set_table(&mut self, user: Table){\n        self.user = Some(Arc::new(user));\n        self.rebuild();\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair::table_for_update":["/// Returns the `Table` produced by updating `self.user` with the contents\n/// of `user`, deleting null entries.\nfn table_for_update(&self, user: Table) -> Table{\n        let mut new_user: Table =\n            self.user.as_ref().map(|arc| arc.as_ref().clone()).unwrap_or_default();\n        for (k, v) in user {\n            if v.is_null() {\n                new_user.remove(&k);\n            } else {\n                new_user.insert(k, v);\n            }\n        }\n        new_user\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::ConfigPair::with_base":["/// Creates a new `ConfigPair` with the provided base config.\nfn with_base<T: Into<Option<Table>>>(table: T) -> Self{\n        let base = table.into().map(Arc::new);\n        let cache = base.clone().unwrap_or_default();\n        ConfigPair { base, cache, user: None }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::LanguageTag":["/// The language associated with a given buffer; this is always detected\n/// but can also be manually set by the user.\nstruct LanguageTag {\n    detected: LanguageId,\n    user: Option<LanguageId>,\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::LanguageTag::new":["fn new(detected: LanguageId) -> Self{\n        LanguageTag { detected, user: None }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::LanguageTag::resolve":["fn resolve(&self) -> LanguageId{\n        self.user.as_ref().unwrap_or(&self.detected).clone()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::LanguageTag::set_detected":["/// Set the detected language. Returns `true` if this changes the resolved\n/// language.\nfn set_detected(&mut self, detected: LanguageId) -> bool{\n        let before = self.resolve();\n        self.detected = detected;\n        before != self.resolve()\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::LanguageTag::set_user":["/// Set the user-specified language. Returns `true` if this changes\n/// the resolved language.\n#[allow(dead_code)]\nfn set_user(&mut self, new_lang: Option<LanguageId>) -> bool{\n        let has_changed = self.user != new_lang;\n        self.user = new_lang;\n        has_changed\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::TableStack":["/// A collection of config tables representing a hierarchy, with each\n/// table's keys superseding keys in preceding tables.\nstruct TableStack(Vec<Arc<Table>>);","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::TableStack::collate":["/// Create a single table representing the final config values.\nfn collate(&self) -> Table{\n        // NOTE: This is fairly expensive; a future optimization would borrow\n        // from the underlying collections.\n        let mut out = Table::new();\n        for table in &self.0 {\n            for (k, v) in table.iter() {\n                if !out.contains_key(k) {\n                    // cloning these objects feels a bit gross, we could\n                    // improve this by implementing Deserialize for TableStack.\n                    out.insert(k.to_owned(), v.to_owned());\n                }\n            }\n        }\n        out\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::TableStack::diff":["/// Returns a new `Table` containing only those keys and values in `self`\n/// which have changed from `other`.\nfn diff(&self, other: &TableStack) -> Option<Table>{\n        let mut out: Option<Table> = None;\n        let this = self.collate();\n        for (k, v) in this.iter() {\n            if other.get(k) != Some(v) {\n                let out: &mut Table = out.get_or_insert(Table::new());\n                out.insert(k.to_owned(), v.to_owned());\n            }\n        }\n        out\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::TableStack::get":["/// Walks the tables in priority order, returning the first\n/// occurance of `key`.\nfn get<S: AsRef<str>>(&self, key: S) -> Option<&Value>{\n        for table in &self.0 {\n            if let Some(v) = table.get(key.as_ref()) {\n                return Some(v);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::TableStack::into_config":["/// Converts the underlying tables into a static `Config` instance.\nfn into_config<T>(self) -> Config<T>\n    where\n        for<'de> T: Deserialize<'de>,{\n        let out = self.collate();\n        let items: T = serde_json::from_value(out.into()).unwrap();\n        let source = self;\n        Config { source, items }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::deserialize_tab_size":["fn deserialize_tab_size<'de, D>(deserializer: D) -> Result<usize, D::Error>\nwhere\n    D: serde::Deserializer<'de>,{\n    let tab_size = usize::deserialize(deserializer)?;\n    if tab_size == 0 {\n        Err(de::Error::invalid_value(\n            de::Unexpected::Unsigned(tab_size as u64),\n            &\"tab_size must be at least 1\",\n        ))\n    } else {\n        Ok(tab_size)\n    }\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::from_toml_value":["/// Converts between toml (used to write config files) and json\n/// (used to store config values internally).\nfn from_toml_value(value: toml::Value) -> Value{\n    match value {\n        toml::Value::String(value) => value.into(),\n        toml::Value::Float(value) => value.into(),\n        toml::Value::Integer(value) => value.into(),\n        toml::Value::Boolean(value) => value.into(),\n        toml::Value::Datetime(value) => value.to_string().into(),\n\n        toml::Value::Table(table) => {\n            let mut m = Table::new();\n            for (key, value) in table {\n                m.insert(key.clone(), from_toml_value(value));\n            }\n            m.into()\n        }\n\n        toml::Value::Array(array) => {\n            let mut l = Vec::new();\n            for value in array {\n                l.push(from_toml_value(value));\n            }\n            l.into()\n        }\n    }\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::init_config_dir":["/// Creates initial config directory structure\npub(crate) fn init_config_dir(dir: &Path) -> io::Result<()>{\n    let builder = fs::DirBuilder::new();\n    builder.create(dir)?;\n    builder.create(dir.join(\"plugins\"))?;\n    Ok(())\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::load_base_config":["/// Loads the included base config settings.\nfn load_base_config() -> Table{\n    fn load(default: &str) -> Table {\n        table_from_toml_str(default).expect(\"default configs must load\")\n    }\n\n    fn platform_overrides() -> Option<Table> {\n        if cfg!(test) {\n            // Exit early if we are in tests and never have platform overrides.\n            // This makes sure we have a stable test environment.\n            None\n        } else if cfg!(windows) {\n            let toml = include_str!(\"../assets/windows.toml\");\n            Some(load(toml))\n        } else {\n            // All other platorms\n            None\n        }\n    }\n\n    let base_toml: &str = include_str!(\"../assets/defaults.toml\");\n    let mut base = load(base_toml);\n    if let Some(overrides) = platform_overrides() {\n        for (k, v) in overrides.iter() {\n            base.insert(k.to_owned(), v.to_owned());\n        }\n    }\n    base\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::load_base_config::load":["fn load(default: &str) -> Table{\n        table_from_toml_str(default).expect(\"default configs must load\")\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::load_base_config::platform_overrides":["fn platform_overrides() -> Option<Table>{\n        if cfg!(test) {\n            // Exit early if we are in tests and never have platform overrides.\n            // This makes sure we have a stable test environment.\n            None\n        } else if cfg!(windows) {\n            let toml = include_str!(\"../assets/windows.toml\");\n            Some(load(toml))\n        } else {\n            // All other platorms\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::table_from_toml_str":["pub(crate) fn table_from_toml_str(s: &str) -> Result<Table, toml::de::Error>{\n    let table = toml::from_str(&s)?;\n    let table = from_toml_value(table).as_object().unwrap().to_owned();\n    Ok(table)\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"config::try_load_from_file":["/// Attempts to load a config from a file. The config's domain is determined\n/// by the file name.\npub(crate) fn try_load_from_file(path: &Path) -> Result<Table, ConfigError>{\n    let mut file = fs::File::open(&path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    table_from_toml_str(&contents).map_err(|e| ConfigError::Parse(path.to_owned(), e))\n}","Real(LocalPath(\"core-lib/src/config.rs\"))"],"core::WeakXiCore":["/// A weak reference to the main state. This is passed to plugin threads.\npub struct WeakXiCore(Weak<Mutex<CoreState>>);","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::WeakXiCore::handle_plugin_update":["/// Handles the result of an update sent to a plugin.\n///\n/// All plugins must acknowledge when they are sent a new update, so that\n/// core can track which revisions are still 'live', that is can still\n/// be the base revision for a delta. Once a plugin has acknowledged a new\n/// revision, it can no longer send deltas against any older revision.\npub fn handle_plugin_update(\n        &self,\n        plugin: PluginId,\n        view: ViewId,\n        response: Result<Value, RpcError>,\n    ){\n        if let Some(core) = self.upgrade() {\n            let _t = xi_trace::trace_block(\"WeakXiCore::plugin_update\", &[\"core\"]);\n            core.inner().plugin_update(plugin, view, response);\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::WeakXiCore::plugin_connect":["/// Called immediately after attempting to start a plugin,\n/// from the plugin's thread.\npub fn plugin_connect(&self, plugin: Result<Plugin, io::Error>){\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_connect(plugin)\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::WeakXiCore::plugin_exit":["/// Called from a plugin runloop thread when the runloop exits.\npub fn plugin_exit(&self, plugin: PluginId, error: Result<(), ReadError>){\n        if let Some(core) = self.upgrade() {\n            core.inner().plugin_exit(plugin, error)\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::WeakXiCore::upgrade":["/// Attempts to upgrade the weak reference. Essentially a wrapper\n/// for `Arc::upgrade`.\nfn upgrade(&self) -> Option<XiCore>{\n        self.0.upgrade().map(XiCore::Running)\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::XiCore":["/// A reference to the main core state.\n///\n/// # Note\n///\n/// Various items of initial setup are dependent on how the client\n/// is configured, so we defer instantiating state until we have that\n/// information.\npub enum XiCore {\n    // TODO: profile startup, and determine what things (such as theme loading)\n    // we should be doing before client_init.\n    Waiting,\n    Running(Arc<Mutex<CoreState>>),\n}","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::XiCore::inner":["/// Returns a guard to the core state. A convenience around `Mutex::lock`.\n///\n/// # Panics\n///\n/// Panics if core has not yet received the `client_started` message.\npub fn inner(&self) -> MutexGuard<CoreState>{\n        match self {\n            XiCore::Running(ref inner) => inner.lock().unwrap(),\n            XiCore::Waiting => panic!(\n                \"core does not start until client_started \\\n                 RPC is received\"\n            ),\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::XiCore::is_waiting":["/// Returns `true` if the `client_started` has not been received.\nfn is_waiting(&self) -> bool{\n        matches!(*self, XiCore::Waiting)\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::XiCore::new":["pub fn new() -> Self{\n        XiCore::Waiting\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"core::XiCore::weak_self":["/// Returns a new reference to the core state, if core is running.\nfn weak_self(&self) -> Option<WeakXiCore>{\n        match self {\n            XiCore::Running(ref inner) => Some(WeakXiCore(Arc::downgrade(inner))),\n            XiCore::Waiting => None,\n        }\n    }","Real(LocalPath(\"core-lib/src/core.rs\"))"],"edit_ops::IndentDirection":["pub enum IndentDirection {\n    In,\n    Out,\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::capitalize_text":["pub fn capitalize_text(base: &Rope, regions: &[SelRegion]) -> (RopeDelta, Selection){\n    let mut builder = DeltaBuilder::new(base.len());\n    let mut final_selection = Selection::new();\n\n    for &region in regions {\n        final_selection.add_region(SelRegion::new(region.max(), region.max()));\n        let mut word_cursor = WordCursor::new(base, region.min());\n\n        loop {\n            // capitalize each word in the current selection\n            let (start, end) = word_cursor.select_word();\n\n            if start < end {\n                let interval = Interval::new(start, end);\n                let word = base.slice_to_cow(start..end);\n\n                // first letter is uppercase, remaining letters are lowercase\n                let (first_char, rest) = word.split_at(1);\n                let capitalized_text = [first_char.to_uppercase(), rest.to_lowercase()].concat();\n                builder.replace(interval, Rope::from(capitalized_text));\n            }\n\n            if word_cursor.next_boundary().is_none() || end > region.max() {\n                break;\n            }\n        }\n    }\n\n    (builder.build(), final_selection)\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::change_number":["/// Changes the number(s) under the cursor(s) with the `transform_function`.\n/// If there is a number next to or on the beginning of the region, then\n/// this number will be replaced with the result of `transform_function` and\n/// the cursor will be placed at the end of the number.\n/// Some Examples with a increment `transform_function`:\n///\n/// \"|1234\" -> \"1235|\"\n/// \"12|34\" -> \"1235|\"\n/// \"-|12\" -> \"-11|\"\n/// \"another number is 123|]\" -> \"another number is 124\"\n///\n/// This function also works fine with multiple regions.\npub fn change_number<F: Fn(i128) -> Option<i128>>(\n    base: &Rope,\n    regions: &[SelRegion],\n    transform_function: F,\n) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    for region in regions {\n        let mut cursor = WordCursor::new(base, region.end);\n        let (mut start, end) = cursor.select_word();\n\n        // if the word begins with '-', then it is a negative number\n        if start > 0 && base.byte_at(start - 1) == (b'-') {\n            start -= 1;\n        }\n\n        let word = base.slice_to_cow(start..end);\n        if let Some(number) = word.parse::<i128>().ok().and_then(&transform_function) {\n            let interval = Interval::new(start, end);\n            builder.replace(interval, Rope::from(number.to_string()));\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::delete_backward":["/// Used when the user presses the backspace key. If no delta is returned, then nothing changes.\npub fn delete_backward(base: &Rope, regions: &[SelRegion], config: &BufferItems) -> RopeDelta{\n    // TODO: this function is workable but probably overall code complexity\n    // could be improved by implementing a \"backspace\" movement instead.\n    let mut builder = DeltaBuilder::new(base.len());\n    for region in regions {\n        let start = offset_for_delete_backwards(&region, base, &config);\n        let iv = Interval::new(start, region.max());\n        if !iv.is_empty() {\n            builder.delete(iv);\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::delete_by_movement":["/// Common logic for a number of delete methods. For each region in the\n/// selection, if the selection is a caret, delete the region between\n/// the caret and the movement applied to the caret, otherwise delete\n/// the region.\n///\n/// If `save` is set, the tuple will contain a rope with the deleted text.\n///\n/// # Arguments\n///\n/// * `height` - viewport height\npub(crate) fn delete_by_movement(\n    base: &Rope,\n    regions: &[SelRegion],\n    lines: &Lines,\n    movement: Movement,\n    height: usize,\n    save: bool,\n) -> (RopeDelta, Option<Rope>){\n    // We compute deletions as a selection because the merge logic\n    // is convenient. Another possibility would be to make the delta\n    // builder able to handle overlapping deletions (with union semantics).\n    let mut deletions = Selection::new();\n    for &r in regions {\n        if r.is_caret() {\n            let new_region = region_movement(movement, r, lines, height, base, true);\n            deletions.add_region(new_region);\n        } else {\n            deletions.add_region(r);\n        }\n    }\n\n    let kill_ring = if save {\n        let saved = extract_sel_regions(base, &deletions).unwrap_or_default();\n        Some(Rope::from(saved))\n    } else {\n        None\n    };\n\n    (delete_sel_regions(base, &deletions), kill_ring)\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::delete_sel_regions":["/// Deletes the given regions.\npub(crate) fn delete_sel_regions(base: &Rope, sel_regions: &[SelRegion]) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    for region in sel_regions {\n        let iv = Interval::new(region.min(), region.max());\n        if !iv.is_empty() {\n            builder.delete(iv);\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::duplicate_line":["pub fn duplicate_line(base: &Rope, regions: &[SelRegion], config: &BufferItems) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    // get affected lines or regions\n    let mut to_duplicate = BTreeSet::new();\n\n    for region in regions {\n        let (first_line, _) = LogicalLines.offset_to_line_col(base, region.min());\n        let line_start = LogicalLines.offset_of_line(base, first_line);\n\n        let mut cursor = match region.is_caret() {\n            true => Cursor::new(base, line_start),\n            false => {\n                // duplicate all lines together that are part of the same selections\n                let (last_line, _) = LogicalLines.offset_to_line_col(base, region.max());\n                let line_end = LogicalLines.offset_of_line(base, last_line);\n                Cursor::new(base, line_end)\n            }\n        };\n\n        if let Some(line_end) = cursor.next::<LinesMetric>() {\n            to_duplicate.insert((line_start, line_end));\n        }\n    }\n\n    for (start, end) in to_duplicate {\n        // insert duplicates\n        let iv = Interval::new(start, start);\n        builder.replace(iv, base.slice(start..end));\n\n        // last line does not have new line character so it needs to be manually added\n        if end == base.len() {\n            builder.replace(iv, Rope::from(&config.line_ending))\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::extract_sel_regions":["/// Extracts non-caret selection regions into a string,\n/// joining multiple regions with newlines.\npub(crate) fn extract_sel_regions<'a>(\n    base: &'a Rope,\n    sel_regions: &[SelRegion],\n) -> Option<Cow<'a, str>>{\n    let mut saved = None;\n    for region in sel_regions {\n        if !region.is_caret() {\n            let val = base.slice_to_cow(region);\n            match saved {\n                None => saved = Some(val),\n                Some(ref mut s) => {\n                    s.to_mut().push('\\n');\n                    s.to_mut().push_str(&val);\n                }\n            }\n        }\n    }\n    saved\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::get_tab_text":["fn get_tab_text(config: &BufferItems, tab_size: Option<usize>) -> &'static str{\n    let tab_size = tab_size.unwrap_or(config.tab_size);\n    let tab_text = if config.translate_tabs_to_spaces { n_spaces(tab_size) } else { \"\\t\" };\n\n    tab_text\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::indent":["fn indent(base: &Rope, lines: BTreeSet<usize>, tab_text: &str) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    for line in lines {\n        let offset = LogicalLines.line_col_to_offset(base, line, 0);\n        let interval = Interval::new(offset, offset);\n        builder.replace(interval, Rope::from(tab_text));\n    }\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::insert":["/// Replaces the selection with the text `T`.\npub fn insert<T: Into<Rope>>(base: &Rope, regions: &[SelRegion], text: T) -> RopeDelta{\n    let rope = text.into();\n    let mut builder = DeltaBuilder::new(base.len());\n    for region in regions {\n        let iv = Interval::new(region.min(), region.max());\n        builder.replace(iv, rope.clone());\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::insert_newline":["pub fn insert_newline(base: &Rope, regions: &[SelRegion], config: &BufferItems) -> RopeDelta{\n    insert(base, regions, &config.line_ending)\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::insert_tab":["pub fn insert_tab(base: &Rope, regions: &[SelRegion], config: &BufferItems) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    let const_tab_text = get_tab_text(config, None);\n\n    for region in regions {\n        let line_range = LogicalLines.get_line_range(base, region);\n\n        if line_range.len() > 1 {\n            for line in line_range {\n                let offset = LogicalLines.line_col_to_offset(base, line, 0);\n                let iv = Interval::new(offset, offset);\n                builder.replace(iv, Rope::from(const_tab_text));\n            }\n        } else {\n            let (_, col) = LogicalLines.offset_to_line_col(base, region.start);\n            let mut tab_size = config.tab_size;\n            tab_size = tab_size - (col % tab_size);\n            let tab_text = get_tab_text(config, Some(tab_size));\n\n            let iv = Interval::new(region.min(), region.max());\n            builder.replace(iv, Rope::from(tab_text));\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::last_selection_region":["fn last_selection_region(regions: &[SelRegion]) -> Option<&SelRegion>{\n    for region in regions.iter().rev() {\n        if !region.is_caret() {\n            return Some(region);\n        }\n    }\n    None\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::modify_indent":["/// Indents or outdents lines based on selection and user's tab settings.\n/// Uses a BTreeSet to holds the collection of lines to modify.\n/// Preserves cursor position and current selection as much as possible.\n/// Tries to have behavior consistent with other editors like Atom,\n/// Sublime and VSCode, with non-caret selections not being modified.\npub fn modify_indent(\n    base: &Rope,\n    regions: &[SelRegion],\n    config: &BufferItems,\n    direction: IndentDirection,\n) -> RopeDelta{\n    let mut lines = BTreeSet::new();\n    let tab_text = get_tab_text(config, None);\n    for region in regions {\n        let line_range = LogicalLines.get_line_range(base, region);\n        for line in line_range {\n            lines.insert(line);\n        }\n    }\n    match direction {\n        IndentDirection::In => indent(base, lines, tab_text),\n        IndentDirection::Out => outdent(base, lines, tab_text),\n    }\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::n_spaces":["fn n_spaces(n: usize) -> &'static str{\n    let spaces = \"                                \";\n    assert!(n <= spaces.len());\n    &spaces[..n]\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::outdent":["fn outdent(base: &Rope, lines: BTreeSet<usize>, tab_text: &str) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    for line in lines {\n        let offset = LogicalLines.line_col_to_offset(base, line, 0);\n        let tab_offset = LogicalLines.line_col_to_offset(base, line, tab_text.len());\n        let interval = Interval::new(offset, tab_offset);\n        let leading_slice = base.slice_to_cow(interval.start()..interval.end());\n        if leading_slice == tab_text {\n            builder.delete(interval);\n        } else if let Some(first_char_col) = leading_slice.find(|c: char| !c.is_whitespace()) {\n            let first_char_offset = LogicalLines.line_col_to_offset(base, line, first_char_col);\n            let interval = Interval::new(offset, first_char_offset);\n            builder.delete(interval);\n        }\n    }\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::sel_region_to_interval_and_rope":["fn sel_region_to_interval_and_rope(base: &Rope, region: SelRegion) -> (Interval, Rope){\n    let as_interval = Interval::new(region.min(), region.max());\n    let interval_rope = base.subseq(as_interval);\n    (as_interval, interval_rope)\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::surround":["/// Leaves the current selection untouched, but surrounds it with two insertions.\npub fn surround<BT, AT>(\n    base: &Rope,\n    regions: &[SelRegion],\n    before_text: BT,\n    after_text: AT,\n) -> RopeDelta\nwhere\n    BT: Into<Rope>,\n    AT: Into<Rope>,{\n    let mut builder = DeltaBuilder::new(base.len());\n    let before_rope = before_text.into();\n    let after_rope = after_text.into();\n    for region in regions {\n        let before_iv = Interval::new(region.min(), region.min());\n        builder.replace(before_iv, before_rope.clone());\n        let after_iv = Interval::new(region.max(), region.max());\n        builder.replace(after_iv, after_rope.clone());\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::transform_text":["pub fn transform_text<F: Fn(&str) -> String>(\n    base: &Rope,\n    regions: &[SelRegion],\n    transform_function: F,\n) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n\n    for region in regions {\n        let selected_text = base.slice_to_cow(region);\n        let interval = Interval::new(region.min(), region.max());\n        builder.replace(interval, Rope::from(transform_function(&selected_text)));\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_ops::transpose":["pub fn transpose(base: &Rope, regions: &[SelRegion]) -> RopeDelta{\n    let mut builder = DeltaBuilder::new(base.len());\n    let mut last = 0;\n    let mut optional_previous_selection: Option<(Interval, Rope)> =\n        last_selection_region(regions).map(|&region| sel_region_to_interval_and_rope(base, region));\n\n    for &region in regions {\n        if region.is_caret() {\n            let mut middle = region.end;\n            let mut start = base.prev_grapheme_offset(middle).unwrap_or(0);\n            let mut end = base.next_grapheme_offset(middle).unwrap_or(middle);\n\n            // Note: this matches Emac's behavior. It swaps last\n            // two characters of line if at end of line.\n            if start >= last {\n                let end_line_offset =\n                    LogicalLines.offset_of_line(base, LogicalLines.line_of_offset(base, end));\n                // include end != base.len() because if the editor is entirely empty, we dont' want to pull from empty space\n                if (end == middle || end == end_line_offset) && end != base.len() {\n                    middle = start;\n                    start = base.prev_grapheme_offset(middle).unwrap_or(0);\n                    end = middle.wrapping_add(1);\n                }\n\n                let interval = Interval::new(start, end);\n                let before = base.slice_to_cow(start..middle);\n                let after = base.slice_to_cow(middle..end);\n                let swapped: String = [after, before].concat();\n                builder.replace(interval, Rope::from(swapped));\n                last = end;\n            }\n        } else if let Some(previous_selection) = optional_previous_selection {\n            let current_interval = sel_region_to_interval_and_rope(base, region);\n            builder.replace(current_interval.0, previous_selection.1);\n            optional_previous_selection = Some(current_interval);\n        }\n    }\n\n    builder.build()\n}","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))"],"edit_types::BufferEvent":["/// Events that modify the buffer\npub(crate) enum BufferEvent {\n    Delete { movement: Movement, kill: bool },\n    Backspace,\n    Transpose,\n    Undo,\n    Redo,\n    Uppercase,\n    Lowercase,\n    Capitalize,\n    Indent,\n    Outdent,\n    Insert(String),\n    Paste(String),\n    InsertNewline,\n    InsertTab,\n    Yank,\n    ReplaceNext,\n    ReplaceAll,\n    DuplicateLine,\n    IncreaseNumber,\n    DecreaseNumber,\n}","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"edit_types::EventDomain":["pub(crate) enum EventDomain {\n    View(ViewEvent),\n    Buffer(BufferEvent),\n    Special(SpecialEvent),\n}","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"edit_types::SpecialEvent":["/// An event that needs special handling\npub(crate) enum SpecialEvent {\n    DebugRewrap,\n    DebugWrapWidth,\n    DebugPrintSpans,\n    Resize(Size),\n    RequestLines(LineRange),\n    RequestHover { request_id: usize, position: Option<Position> },\n    DebugToggleComment,\n    Reindent,\n    ToggleRecording(Option<String>),\n    PlayRecording(String),\n    ClearRecording(String),\n}","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"edit_types::ViewEvent":["/// Events that only modify view state\npub(crate) enum ViewEvent {\n    Move(Movement),\n    ModifySelection(Movement),\n    SelectAll,\n    Scroll(LineRange),\n    AddSelectionAbove,\n    AddSelectionBelow,\n    Click(MouseAction),\n    Drag(MouseAction),\n    Gesture { line: u64, col: u64, ty: GestureType },\n    GotoLine { line: u64 },\n    Find { chars: String, case_sensitive: bool, regex: bool, whole_words: bool },\n    MultiFind { queries: Vec<FindQuery> },\n    FindNext { wrap_around: bool, allow_same: bool, modify_selection: SelectionModifier },\n    FindPrevious { wrap_around: bool, allow_same: bool, modify_selection: SelectionModifier },\n    FindAll,\n    HighlightFind { visible: bool },\n    SelectionForFind { case_sensitive: bool },\n    Replace { chars: String, preserve_case: bool },\n    SelectionForReplace,\n    SelectionIntoLines,\n    CollapseSelections,\n}","Real(LocalPath(\"core-lib/src/edit_types.rs\"))"],"editor::EditType":["#[serde(rename_all = \"snake_case\")]\npub enum EditType {\n    /// A catchall for edits that don't fit elsewhere, and which should\n    /// always have their own undo groups; used for things like cut/copy/paste.\n    Other,\n    /// An insert from the keyboard/IME (not a paste or a yank).\n    #[serde(rename = \"insert\")]\n    InsertChars,\n    #[serde(rename = \"newline\")]\n    InsertNewline,\n    /// An indentation adjustment.\n    Indent,\n    Delete,\n    Undo,\n    Redo,\n    Transpose,\n    Surround,\n}","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::EditType::breaks_undo_group":["/// Checks whether a new undo group should be created between two edits.\nfn breaks_undo_group(self, previous: EditType) -> bool{\n        self == EditType::Other || self == EditType::Transpose || self != previous\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor":["pub struct Editor {\n    /// The contents of the buffer.\n    text: Rope,\n    /// The CRDT engine, which tracks edit history and manages concurrent edits.\n    engine: Engine,\n\n    /// The most recent revision.\n    last_rev_id: RevId,\n    /// The revision of the last save.\n    pristine_rev_id: RevId,\n    undo_group_id: usize,\n    ///Undo groups that may still be toggled\n    live_undos: Vec<usize>,\n    /// The index of the current undo; subsequent undos are currently 'undone'\n    /// (but may be redone)\n    cur_undo: usize,\n    /// undo groups that are undone\n    undos: BTreeSet<usize>,\n    /// undo groups that are no longer live and should be gc'ed\n    gc_undos: BTreeSet<usize>,\n    force_undo_group: bool,\n\n    this_edit_type: EditType,\n    last_edit_type: EditType,\n\n    revs_in_flight: usize,\n\n    /// Used only on Fuchsia for syncing\n    #[allow(dead_code)]\n    sync_store: Option<SyncStore>,\n    #[allow(dead_code)]\n    last_synced_rev: RevId,\n\n    layers: Layers,\n}","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::add_delta":["/// Applies a delta to the text, and updates undo state.\n///\n/// Records the delta into the CRDT engine so that it can be undone. Also\n/// contains the logic for merging edits into the same undo group. At call\n/// time, self.this_edit_type should be set appropriately.\n///\n/// This method can be called multiple times, accumulating deltas that will\n/// be committed at once with `commit_delta`. Note that it does not update\n/// the views. Thus, view-associated state such as the selection and line\n/// breaks are to be considered invalid after this method, until the\n/// `commit_delta` call.\nfn add_delta(&mut self, delta: RopeDelta){\n        let head_rev_id = self.engine.get_head_rev_id();\n        let undo_group = self.calculate_undo_group();\n        self.last_edit_type = self.this_edit_type;\n        let priority = 0x10000;\n        self.engine.edit_rev(priority, undo_group, head_rev_id.token(), delta);\n        self.text = self.engine.get_head().clone();\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::apply_plugin_edit":["/// generates a delta from a plugin's response and applies it to the buffer.\npub fn apply_plugin_edit(&mut self, edit: PluginEdit){\n        let _t = trace_block(\"Editor::apply_plugin_edit\", &[\"core\"]);\n        //TODO: get priority working, so that plugin edits don't necessarily move cursor\n        let PluginEdit { rev, delta, priority, undo_group, .. } = edit;\n        let priority = priority as usize;\n        let undo_group = undo_group.unwrap_or_else(|| self.calculate_undo_group());\n        match self.engine.try_edit_rev(priority, undo_group, rev, delta) {\n            Err(e) => error!(\"Error applying plugin edit: {}\", e),\n            Ok(_) => self.text = self.engine.get_head().clone(),\n        };\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::calculate_undo_group":["pub(crate) fn calculate_undo_group(&mut self) -> usize{\n        let has_undos = !self.live_undos.is_empty();\n        let force_undo_group = self.force_undo_group;\n        let is_unbroken_group = !self.this_edit_type.breaks_undo_group(self.last_edit_type);\n\n        if has_undos && (force_undo_group || is_unbroken_group) {\n            *self.live_undos.last().unwrap()\n        } else {\n            let undo_group = self.undo_group_id;\n            self.gc_undos.extend(&self.live_undos[self.cur_undo..]);\n            self.live_undos.truncate(self.cur_undo);\n            self.live_undos.push(undo_group);\n            if self.live_undos.len() <= MAX_UNDOS {\n                self.cur_undo += 1;\n            } else {\n                self.gc_undos.insert(self.live_undos.remove(0));\n            }\n            self.undo_group_id += 1;\n            undo_group\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::commit_delta":["/// Commits the current delta. If the buffer has changed, returns\n/// a 3-tuple containing the delta representing the changes, the previous\n/// buffer, and an `InsertDrift` enum describing the correct selection update\n/// behaviour.\npub(crate) fn commit_delta(&mut self) -> Option<(RopeDelta, Rope, InsertDrift)>{\n        let _t = trace_block(\"Editor::commit_delta\", &[\"core\"]);\n\n        if self.engine.get_head_rev_id() == self.last_rev_id {\n            return None;\n        }\n\n        let last_token = self.last_rev_id.token();\n        let delta = self.engine.try_delta_rev_head(last_token).expect(\"last_rev not found\");\n        // TODO (performance): it's probably quicker to stash last_text\n        // rather than resynthesize it.\n        let last_text = self.engine.get_rev(last_token).expect(\"last_rev not found\");\n\n        // Transpose can rotate characters inside of a selection; this is why it's an Inside edit.\n        // Surround adds characters on either side of a selection, that's why it's an Outside edit.\n        let drift = match self.this_edit_type {\n            EditType::Transpose => InsertDrift::Inside,\n            EditType::Surround => InsertDrift::Outside,\n            _ => InsertDrift::Default,\n        };\n        self.layers.update_all(&delta);\n\n        self.last_rev_id = self.engine.get_head_rev_id();\n        self.sync_state_changed();\n        Some((delta, last_text, drift))\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::dec_revs_in_flight":["pub fn dec_revs_in_flight(&mut self){\n        self.revs_in_flight -= 1;\n        self.gc_undos();\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::delta_rev_head":["/// Attempts to find the delta from head for the given `RevToken`. Returns\n/// `None` if the revision is not found, so this result should be checked if\n/// the revision is coming from a plugin.\npub(crate) fn delta_rev_head(&self, target_rev_id: RevToken) -> Option<RopeDelta>{\n        self.engine.try_delta_rev_head(target_rev_id).ok()\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_capitalize_text":["fn do_capitalize_text(&mut self, view: &mut View){\n        let (delta, final_selection) = edit_ops::capitalize_text(&self.text, view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n\n        // at the end of the transformation carets are located at the end of the words that were\n        // transformed last in the selections\n        view.collapse_selections(&self.text);\n        view.set_selection(&self.text, final_selection);\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_change_number":["fn do_change_number<F: Fn(i128) -> Option<i128>>(\n        &mut self,\n        view: &View,\n        transform_function: F,\n    ){\n        let delta = edit_ops::change_number(&self.text, view.sel_regions(), transform_function);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_copy":["pub(crate) fn do_copy(&self, view: &View) -> Value{\n        if let Some(val) = edit_ops::extract_sel_regions(&self.text, view.sel_regions()) {\n            Value::String(val.into_owned())\n        } else {\n            Value::Null\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_cut":["pub(crate) fn do_cut(&mut self, view: &mut View) -> Value{\n        let result = self.do_copy(view);\n        let delta = edit_ops::delete_sel_regions(&self.text, &view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n        result\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_delete_backward":["fn do_delete_backward(&mut self, view: &View, config: &BufferItems){\n        let delta = edit_ops::delete_backward(&self.text, view.sel_regions(), config);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_delete_by_movement":["fn do_delete_by_movement(\n        &mut self,\n        view: &View,\n        movement: Movement,\n        save: bool,\n        kill_ring: &mut Rope,\n    ){\n        let (delta, rope) = edit_ops::delete_by_movement(\n            &self.text,\n            view.sel_regions(),\n            view.get_lines(),\n            movement,\n            view.scroll_height(),\n            save,\n        );\n        if let Some(rope) = rope {\n            *kill_ring = rope;\n        }\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Delete;\n            self.add_delta(delta);\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_duplicate_line":["fn do_duplicate_line(&mut self, view: &View, config: &BufferItems){\n        let delta = edit_ops::duplicate_line(&self.text, view.sel_regions(), config);\n        self.add_delta(delta);\n        self.this_edit_type = EditType::Other;\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_edit":["pub(crate) fn do_edit(\n        &mut self,\n        view: &mut View,\n        kill_ring: &mut Rope,\n        config: &BufferItems,\n        cmd: BufferEvent,\n    ){\n        use self::BufferEvent::*;\n        match cmd {\n            Delete { movement, kill } => {\n                self.do_delete_by_movement(view, movement, kill, kill_ring)\n            }\n            Backspace => self.do_delete_backward(view, config),\n            Transpose => self.do_transpose(view),\n            Undo => self.do_undo(),\n            Redo => self.do_redo(),\n            Uppercase => self.do_transform_text(view, |s| s.to_uppercase()),\n            Lowercase => self.do_transform_text(view, |s| s.to_lowercase()),\n            Capitalize => self.do_capitalize_text(view),\n            Indent => self.do_modify_indent(view, config, IndentDirection::In),\n            Outdent => self.do_modify_indent(view, config, IndentDirection::Out),\n            InsertNewline => self.do_insert_newline(view, config),\n            InsertTab => self.do_insert_tab(view, config),\n            Insert(chars) => self.do_insert(view, config, &chars),\n            Paste(chars) => self.do_paste(view, &chars),\n            Yank => self.do_yank(view, kill_ring),\n            ReplaceNext => self.do_replace(view, false),\n            ReplaceAll => self.do_replace(view, true),\n            DuplicateLine => self.do_duplicate_line(view, config),\n            IncreaseNumber => self.do_change_number(view, |s| s.checked_add(1)),\n            DecreaseNumber => self.do_change_number(view, |s| s.checked_sub(1)),\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_insert":["fn do_insert(&mut self, view: &View, config: &BufferItems, chars: &str){\n        let pair_search = config.surrounding_pairs.iter().find(|pair| pair.0 == chars);\n        let caret_exists = view.sel_regions().iter().any(|region| region.is_caret());\n        if let (Some(pair), false) = (pair_search, caret_exists) {\n            self.this_edit_type = EditType::Surround;\n            self.add_delta(edit_ops::surround(\n                &self.text,\n                view.sel_regions(),\n                pair.0.to_string(),\n                pair.1.to_string(),\n            ));\n        } else {\n            self.this_edit_type = EditType::InsertChars;\n            self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars));\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_insert_newline":["fn do_insert_newline(&mut self, view: &View, config: &BufferItems){\n        let delta = edit_ops::insert_newline(&self.text, view.sel_regions(), config);\n        self.add_delta(delta);\n        self.this_edit_type = EditType::InsertNewline;\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_insert_tab":["fn do_insert_tab(&mut self, view: &View, config: &BufferItems){\n        let regions = view.sel_regions();\n        let delta = edit_ops::insert_tab(&self.text, regions, config);\n\n        // if we indent multiple regions or multiple lines,\n        // we treat this as an indentation adjustment; otherwise it is\n        // just inserting text.\n        let condition = regions\n            .first()\n            .map(|x| LogicalLines.get_line_range(&self.text, x).len() > 1)\n            .unwrap_or(false);\n\n        self.add_delta(delta);\n        self.this_edit_type =\n            if regions.len() > 1 || condition { EditType::Indent } else { EditType::InsertChars };\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_modify_indent":["fn do_modify_indent(&mut self, view: &View, config: &BufferItems, direction: IndentDirection){\n        let delta = edit_ops::modify_indent(&self.text, view.sel_regions(), config, direction);\n        self.add_delta(delta);\n        self.this_edit_type = match direction {\n            IndentDirection::In => EditType::InsertChars,\n            IndentDirection::Out => EditType::Delete,\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_paste":["fn do_paste(&mut self, view: &View, chars: &str){\n        if view.sel_regions().len() == 1 || view.sel_regions().len() != count_lines(chars) {\n            self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars));\n        } else {\n            let mut builder = DeltaBuilder::new(self.text.len());\n            for (sel, line) in view.sel_regions().iter().zip(chars.lines()) {\n                let iv = Interval::new(sel.min(), sel.max());\n                builder.replace(iv, line.into());\n            }\n            self.add_delta(builder.build());\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_redo":["fn do_redo(&mut self){\n        if self.cur_undo < self.live_undos.len() {\n            assert!(self.undos.remove(&self.live_undos[self.cur_undo]));\n            self.cur_undo += 1;\n            self.this_edit_type = EditType::Redo;\n            self.update_undos();\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_replace":["fn do_replace(&mut self, view: &mut View, replace_all: bool){\n        if let Some(Replace { chars, .. }) = view.get_replace() {\n            // todo: implement preserve case\n            // store old selection because in case nothing is found the selection will be preserved\n            let mut old_selection = Selection::new();\n            for &region in view.sel_regions() {\n                old_selection.add_region(region);\n            }\n            view.collapse_selections(&self.text);\n\n            if replace_all {\n                view.do_find_all(&self.text);\n            } else {\n                view.do_find_next(&self.text, false, true, true, &SelectionModifier::Set);\n            }\n\n            match last_selection_region(view.sel_regions()) {\n                Some(_) => self.add_delta(edit_ops::insert(&self.text, view.sel_regions(), chars)),\n                None => return,\n            };\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_transform_text":["fn do_transform_text<F: Fn(&str) -> String>(&mut self, view: &View, transform_function: F){\n        let delta = edit_ops::transform_text(&self.text, view.sel_regions(), transform_function);\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Other;\n            self.add_delta(delta);\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_transpose":["fn do_transpose(&mut self, view: &View){\n        let delta = edit_ops::transpose(&self.text, view.sel_regions());\n        if !delta.is_identity() {\n            self.this_edit_type = EditType::Transpose;\n            self.add_delta(delta);\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_undo":["fn do_undo(&mut self){\n        if self.cur_undo > 1 {\n            self.cur_undo -= 1;\n            assert!(self.undos.insert(self.live_undos[self.cur_undo]));\n            self.this_edit_type = EditType::Undo;\n            self.update_undos();\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::do_yank":["fn do_yank(&mut self, view: &View, kill_ring: &Rope){\n        // TODO: if there are multiple cursors and the number of newlines\n        // is one less than the number of cursors, split and distribute one\n        // line per cursor.\n        let delta = edit_ops::insert(&self.text, view.sel_regions(), kill_ring.clone());\n        self.add_delta(delta);\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::gc_undos":["#[cfg(not(target_os = \"fuchsia\"))]\nfn gc_undos(&mut self){\n        if self.revs_in_flight == 0 && !self.gc_undos.is_empty() {\n            self.engine.gc(&self.gc_undos);\n            self.undos = &self.undos - &self.gc_undos;\n            self.gc_undos.clear();\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_active_undo_group":["pub(crate) fn get_active_undo_group(&self) -> usize{\n        *self.live_undos.last().unwrap_or(&0)\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_buffer":["pub(crate) fn get_buffer(&self) -> &Rope{\n        &self.text\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_edit_type":["pub(crate) fn get_edit_type(&self) -> EditType{\n        self.this_edit_type\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_head_rev_token":["pub(crate) fn get_head_rev_token(&self) -> u64{\n        self.engine.get_head_rev_id().token()\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_layers":["pub(crate) fn get_layers(&self) -> &Layers{\n        &self.layers\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_layers_mut":["pub(crate) fn get_layers_mut(&mut self) -> &mut Layers{\n        &mut self.layers\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::get_rev":["pub(crate) fn get_rev(&self, rev: RevToken) -> Option<Cow<Rope>>{\n        let text_cow = if rev == self.engine.get_head_rev_id().token() {\n            Cow::Borrowed(&self.text)\n        } else {\n            match self.engine.get_rev(rev) {\n                None => return None,\n                Some(text) => Cow::Owned(text),\n            }\n        };\n\n        Some(text_cow)\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::increment_revs_in_flight":["pub fn increment_revs_in_flight(&mut self){\n        self.revs_in_flight += 1;\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::is_pristine":["pub(crate) fn is_pristine(&self) -> bool{\n        self.engine.is_equivalent_revision(self.pristine_rev_id, self.engine.get_head_rev_id())\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::merge_new_state":["pub fn merge_new_state(&mut self, new_engine: Engine){\n        self.engine.merge(&new_engine);\n        self.text = self.engine.get_head().clone();\n        // TODO: better undo semantics. This only implements separate undo\n        // histories for low concurrency.\n        self.undo_group_id = self.engine.max_undo_group_id() + 1;\n        self.last_synced_rev = self.engine.get_head_rev_id();\n        self.commit_delta();\n        //self.render();\n        //FIXME: render after fuchsia sync\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::new":["/// Creates a new `Editor` with a new empty buffer.\npub fn new() -> Editor{\n        Self::with_text(\"\")\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::plugin_get_data":["pub fn plugin_get_data(\n        &self,\n        start: usize,\n        unit: TextUnit,\n        max_size: usize,\n        rev: RevToken,\n    ) -> Option<GetDataResponse>{\n        let _t = trace_block(\"Editor::plugin_get_data\", &[\"core\"]);\n        let text_cow = self.get_rev(rev)?;\n        let text = &text_cow;\n        // convert our offset into a valid byte offset\n        let offset = unit.resolve_offset(text.borrow(), start)?;\n\n        let max_size = min(max_size, MAX_SIZE_LIMIT);\n        let mut end_off = offset.saturating_add(max_size);\n        if end_off >= text.len() {\n            end_off = text.len();\n        } else {\n            // Snap end to codepoint boundary.\n            end_off = text.prev_codepoint_offset(end_off + 1).unwrap();\n        }\n\n        let chunk = text.slice_to_cow(offset..end_off).into_owned();\n        let first_line = text.line_of_offset(offset);\n        let first_line_offset = offset - text.offset_of_line(first_line);\n\n        Some(GetDataResponse { chunk, offset, first_line, first_line_offset })\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::plugin_n_lines":["pub fn plugin_n_lines(&self) -> usize{\n        self.text.measure::<LinesMetric>() + 1\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::reload":["/// Sets this Editor's contents to `text`, preserving undo state and cursor\n/// position when possible.\npub fn reload(&mut self, text: Rope){\n        let delta = LineHashDiff::compute_delta(self.get_buffer(), &text);\n        self.add_delta(delta);\n        self.set_pristine();\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::set_force_undo_group":["/// Set whether or not edits are forced into the same undo group rather than being split by\n/// their EditType.\n///\n/// This is used for things such as recording playback, where you don't want the\n/// individual events to be undoable, but instead the entire playback should be.\npub(crate) fn set_force_undo_group(&mut self, force_undo_group: bool){\n        trace_payload(\"Editor::set_force_undo_group\", &[\"core\"], force_undo_group.to_string());\n        self.force_undo_group = force_undo_group;\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::set_pristine":["pub(crate) fn set_pristine(&mut self){\n        self.pristine_rev_id = self.engine.get_head_rev_id();\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::set_session_id":["/// See `Engine::set_session_id`. Only useful for Fuchsia sync.\npub fn set_session_id(&mut self, session: (u64, u32)){\n        self.engine.set_session_id(session);\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::sync_state_changed":["#[cfg(not(feature = \"ledger\"))]\npub fn sync_state_changed(&mut self){}","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::theme_changed":["pub fn theme_changed(&mut self, style_map: &ThemeStyleMap){\n        self.layers.theme_changed(style_map);\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::update_annotations":["pub fn update_annotations(\n        &mut self,\n        view: &mut View,\n        plugin: PluginId,\n        start: usize,\n        len: usize,\n        annotation_spans: Vec<DataSpan>,\n        annotation_type: AnnotationType,\n        rev: RevToken,\n    ){\n        let _t = trace_block(\"Editor::update_annotations\", &[\"core\"]);\n\n        let mut start = start;\n        let mut end_offset = start + len;\n        let mut sb = SpansBuilder::new(len);\n        for span in annotation_spans {\n            sb.add_span(Interval::new(span.start, span.end), span.data);\n        }\n        let mut spans = sb.build();\n        if rev != self.engine.get_head_rev_id().token() {\n            if let Ok(delta) = self.engine.try_delta_rev_head(rev) {\n                let mut transformer = Transformer::new(&delta);\n                let new_start = transformer.transform(start, false);\n                if !transformer.interval_untouched(Interval::new(start, end_offset)) {\n                    spans = spans.transform(start, end_offset, &mut transformer);\n                }\n                start = new_start;\n                end_offset = transformer.transform(end_offset, true);\n            } else {\n                error!(\"Revision {} not found\", rev);\n            }\n        }\n        let iv = Interval::new(start, end_offset);\n        view.update_annotations(plugin, iv, Annotations { items: spans, annotation_type });\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::update_edit_type":["pub(crate) fn update_edit_type(&mut self){\n        self.last_edit_type = self.this_edit_type;\n        self.this_edit_type = EditType::Other\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::update_spans":["pub fn update_spans(\n        &mut self,\n        view: &mut View,\n        plugin: PluginId,\n        start: usize,\n        len: usize,\n        spans: Vec<ScopeSpan>,\n        rev: RevToken,\n    ){\n        let _t = trace_block(\"Editor::update_spans\", &[\"core\"]);\n        // TODO: more protection against invalid input\n        let mut start = start;\n        let mut end_offset = start + len;\n        let mut sb = SpansBuilder::new(len);\n        for span in spans {\n            sb.add_span(Interval::new(span.start, span.end), span.scope_id);\n        }\n        let mut spans = sb.build();\n        if rev != self.engine.get_head_rev_id().token() {\n            if let Ok(delta) = self.engine.try_delta_rev_head(rev) {\n                let mut transformer = Transformer::new(&delta);\n                let new_start = transformer.transform(start, false);\n                if !transformer.interval_untouched(Interval::new(start, end_offset)) {\n                    spans = spans.transform(start, end_offset, &mut transformer);\n                }\n                start = new_start;\n                end_offset = transformer.transform(end_offset, true);\n            } else {\n                error!(\"Revision {} not found\", rev);\n            }\n        }\n        let iv = Interval::new(start, end_offset);\n        self.layers.update_layer(plugin, iv, spans);\n        view.invalidate_styles(&self.text, start, end_offset);\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::update_undos":["fn update_undos(&mut self){\n        self.engine.undo(self.undos.clone());\n        self.text = self.engine.get_head().clone();\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::Editor::with_text":["/// Creates a new `Editor`, loading text into a new buffer.\npub fn with_text<T: Into<Rope>>(text: T) -> Editor{\n        let engine = Engine::new(text.into());\n        let buffer = engine.get_head().clone();\n        let last_rev_id = engine.get_head_rev_id();\n\n        Editor {\n            text: buffer,\n            engine,\n            last_rev_id,\n            pristine_rev_id: last_rev_id,\n            undo_group_id: 1,\n            // GC only works on undone edits or prefixes of the visible edits,\n            // but initial file loading can create an edit with undo group 0,\n            // so we want to collect that as part of the prefix.\n            live_undos: vec![0],\n            cur_undo: 1,\n            undos: BTreeSet::new(),\n            gc_undos: BTreeSet::new(),\n            force_undo_group: false,\n            last_edit_type: EditType::Other,\n            this_edit_type: EditType::Other,\n            layers: Layers::default(),\n            revs_in_flight: 0,\n            sync_store: None,\n            last_synced_rev: last_rev_id,\n        }\n    }","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::SyncStore":["#[cfg(not(feature = \"ledger\"))]\npub struct SyncStore;","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::count_lines":["/// Counts the number of lines in the string, not including any trailing newline.\nfn count_lines(s: &str) -> usize{\n    let mut newlines = count_newlines(s);\n    if s.as_bytes().last() == Some(&0xa) {\n        newlines -= 1;\n    }\n    1 + newlines\n}","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"editor::last_selection_region":["fn last_selection_region(regions: &[SelRegion]) -> Option<&SelRegion>{\n    for region in regions.iter().rev() {\n        if !region.is_caret() {\n            return Some(region);\n        }\n    }\n    None\n}","Real(LocalPath(\"core-lib/src/editor.rs\"))"],"event_context::EventContext":["/// A collection of all the state relevant for handling a particular event.\n///\n/// This is created dynamically for each event that arrives to the core,\n/// such as a user-initiated edit or style updates from a plugin.\npub struct EventContext<'a> {\n    pub(crate) view_id: ViewId,\n    pub(crate) buffer_id: BufferId,\n    pub(crate) editor: &'a RefCell<Editor>,\n    pub(crate) info: Option<&'a FileInfo>,\n    pub(crate) config: &'a BufferItems,\n    pub(crate) recorder: &'a RefCell<Recorder>,\n    pub(crate) language: LanguageId,\n    pub(crate) view: &'a RefCell<View>,\n    pub(crate) siblings: Vec<&'a RefCell<View>>,\n    pub(crate) plugins: Vec<&'a Plugin>,\n    pub(crate) client: &'a Client,\n    pub(crate) style_map: &'a RefCell<ThemeStyleMap>,\n    pub(crate) width_cache: &'a RefCell<WidthCache>,\n    pub(crate) kill_ring: &'a RefCell<Rope>,\n    pub(crate) weak_core: &'a WeakXiCore,\n}","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::_finish_delayed_render":["pub(crate) fn _finish_delayed_render(&mut self){\n        self.render();\n        self.view.borrow_mut().set_has_pending_render(false);\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::after_edit":["/// Commits any changes to the buffer, updating views and plugins as needed.\n/// This only updates internal state; it does not update the client.\nfn after_edit(&mut self, author: &str){\n        let _t = trace_block(\"EventContext::after_edit\", &[\"core\"]);\n\n        let edit_info = self.editor.borrow_mut().commit_delta();\n        let (delta, last_text, drift) = match edit_info {\n            Some(edit_info) => edit_info,\n            None => return,\n        };\n\n        self.update_views(&self.editor.borrow(), &delta, &last_text, drift);\n        self.update_plugins(&mut self.editor.borrow_mut(), delta, author);\n\n        //if we have no plugins we always render immediately.\n        if !self.plugins.is_empty() {\n            let mut view = self.view.borrow_mut();\n            if !view.has_pending_render() {\n                let timeout = Instant::now() + RENDER_DELAY;\n                let view_id: usize = self.view_id.into();\n                let token = RENDER_VIEW_IDLE_MASK | view_id;\n                self.client.schedule_timer(timeout, token);\n                view.set_has_pending_render(true);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::after_save":["pub(crate) fn after_save(&mut self, path: &Path){\n        // notify plugins\n        self.plugins.iter().for_each(|plugin| plugin.did_save(self.view_id, path));\n\n        self.editor.borrow_mut().set_pristine();\n        self.with_view(|view, text| view.set_dirty(text));\n        self.render()\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::close_view":["/// Returns `true` if this was the last view\npub(crate) fn close_view(&self) -> bool{\n        // we probably want to notify plugins _before_ we close the view\n        // TODO: determine what plugins we're stopping\n        self.plugins.iter().for_each(|plug| plug.close_view(self.view_id));\n        self.siblings.is_empty()\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::config_changed":["pub(crate) fn config_changed(&mut self, changes: &Table){\n        if changes.contains_key(\"wrap_width\") || changes.contains_key(\"word_wrap\") {\n            // FIXME: if switching from measurement-based widths to columnar widths,\n            // we need to reset the cache, since we're using different coordinate spaces\n            // for the same IDs. The long-term solution would be to include font\n            // information in the width cache, and then use real width even in the column\n            // case, getting the unit width for a typeface and multiplying that by\n            // a string's unicode width.\n            if changes.contains_key(\"word_wrap\") {\n                debug!(\"clearing {} items from width cache\", self.width_cache.borrow().len());\n                self.width_cache.replace(WidthCache::new());\n            }\n            self.update_wrap_settings(true);\n        }\n\n        self.client.config_changed(self.view_id, &changes);\n        self.plugins.iter().for_each(|plug| plug.config_changed(self.view_id, &changes));\n        self.render()\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::dispatch_event":["fn dispatch_event(&mut self, event: EventDomain){\n        use self::EventDomain as E;\n        match event {\n            E::View(cmd) => {\n                self.with_view(|view, text| view.do_edit(text, cmd));\n                self.editor.borrow_mut().update_edit_type();\n                if self.with_view(|v, t| v.needs_wrap_in_visible_region(t)) {\n                    self.rewrap();\n                }\n                if self.with_view(|v, _| v.find_in_progress()) {\n                    self.do_incremental_find();\n                }\n            }\n            E::Buffer(cmd) => {\n                self.with_editor(|ed, view, k_ring, conf| ed.do_edit(view, k_ring, conf, cmd))\n            }\n            E::Special(cmd) => self.do_special(cmd),\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_debug_toggle_comment":["fn do_debug_toggle_comment(&mut self){\n        let line_ranges = self.selected_line_ranges();\n\n        // this is handled by syntect only; this is definitely not the long-term solution.\n        if let Some(plug) = self.plugins.iter().find(|p| p.name == \"xi-syntect-plugin\") {\n            plug.dispatch_command(self.view_id, \"toggle_comment\", &json!(line_ranges));\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_edit":["pub(crate) fn do_edit(&mut self, cmd: EditNotification){\n        let event: EventDomain = cmd.into();\n\n        {\n            // Handle recording-- clone every non-toggle and play event into the recording buffer\n            let mut recorder = self.recorder.borrow_mut();\n            match (recorder.is_recording(), &event) {\n                (_, EventDomain::Special(SpecialEvent::ToggleRecording(recording_name))) => {\n                    recorder.toggle_recording(recording_name.clone());\n                }\n                // Don't save special events\n                (true, EventDomain::Special(_)) => {\n                    warn!(\"Special events cannot be recorded-- ignoring event {:?}\", event)\n                }\n                (true, event) => recorder.record(event.clone()),\n                _ => {}\n            }\n        }\n\n        self.dispatch_event(event);\n        self.after_edit(\"core\");\n        self.render_if_needed();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_edit_sync":["pub(crate) fn do_edit_sync(&mut self, cmd: EditRequest) -> Result<Value, RemoteError>{\n        use self::EditRequest::*;\n        let result = match cmd {\n            Cut => Ok(self.with_editor(|ed, view, _, _| ed.do_cut(view))),\n            Copy => Ok(self.with_editor(|ed, view, _, _| ed.do_copy(view))),\n        };\n        self.after_edit(\"core\");\n        self.render_if_needed();\n        result\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_incremental_find":["/// Does incremental find.\npub(crate) fn do_incremental_find(&mut self){\n        let _t = trace_block(\"EventContext::do_incremental_find\", &[\"find\"]);\n\n        self.find();\n        if self.view.borrow().find_in_progress() {\n            let ed = self.editor.borrow();\n            self.client.find_status(\n                self.view_id,\n                &json!(self.view.borrow().find_status(ed.get_buffer(), true)),\n            );\n            self.schedule_find();\n        }\n        self.render_if_needed();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_plugin_cmd":["pub(crate) fn do_plugin_cmd(&mut self, plugin: PluginId, cmd: PluginNotification){\n        use self::PluginNotification::*;\n        match cmd {\n            AddScopes { scopes } => {\n                let mut ed = self.editor.borrow_mut();\n                let style_map = self.style_map.borrow();\n                ed.get_layers_mut().add_scopes(plugin, scopes, &style_map);\n            }\n            UpdateSpans { start, len, spans, rev } => self.with_editor(|ed, view, _, _| {\n                ed.update_spans(view, plugin, start, len, spans, rev)\n            }),\n            Edit { edit } => self.with_editor(|ed, _, _, _| ed.apply_plugin_edit(edit)),\n            Alert { msg } => self.client.alert(&msg),\n            AddStatusItem { key, value, alignment } => {\n                let plugin_name = &self.plugins.iter().find(|p| p.id == plugin).unwrap().name;\n                self.client.add_status_item(self.view_id, plugin_name, &key, &value, &alignment);\n            }\n            UpdateStatusItem { key, value } => {\n                self.client.update_status_item(self.view_id, &key, &value)\n            }\n            UpdateAnnotations { start, len, spans, annotation_type, rev } => {\n                self.with_editor(|ed, view, _, _| {\n                    ed.update_annotations(view, plugin, start, len, spans, annotation_type, rev)\n                })\n            }\n            RemoveStatusItem { key } => self.client.remove_status_item(self.view_id, &key),\n            ShowHover { request_id, result } => self.do_show_hover(request_id, result),\n        };\n        self.after_edit(&plugin.to_string());\n        self.render_if_needed();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_plugin_cmd_sync":["pub(crate) fn do_plugin_cmd_sync(&mut self, _plugin: PluginId, cmd: PluginRequest) -> Value{\n        use self::PluginRequest::*;\n        match cmd {\n            LineCount => json!(self.editor.borrow().plugin_n_lines()),\n            GetData { start, unit, max_size, rev } => {\n                json!(self.editor.borrow().plugin_get_data(start, unit, max_size, rev))\n            }\n            GetSelections => json!(\"not implemented\"),\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_plugin_update":["pub(crate) fn do_plugin_update(&mut self, update: Result<Value, RpcError>){\n        match update.map(serde_json::from_value::<u64>) {\n            Ok(Ok(_)) => (),\n            Ok(Err(err)) => error!(\"plugin response json err: {:?}\", err),\n            Err(err) => error!(\"plugin shutdown, do something {:?}\", err),\n        }\n        self.editor.borrow_mut().dec_revs_in_flight();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_reindent":["fn do_reindent(&mut self){\n        let line_ranges = self.selected_line_ranges();\n        // this is handled by syntect only; this is definitely not the long-term solution.\n        if let Some(plug) = self.plugins.iter().find(|p| p.name == \"xi-syntect-plugin\") {\n            plug.dispatch_command(self.view_id, \"reindent\", &json!(line_ranges));\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_request_hover":["fn do_request_hover(&mut self, request_id: usize, position: Option<ClientPosition>){\n        if let Some(position) = self.get_resolved_position(position) {\n            self.with_each_plugin(|p| p.get_hover(self.view_id, request_id, position))\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_request_lines":["fn do_request_lines(&mut self, first: usize, last: usize){\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        view.request_lines(\n            ed.get_buffer(),\n            self.client,\n            self.style_map,\n            ed.get_layers().get_merged(),\n            first,\n            last,\n            ed.is_pristine(),\n        )\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_rewrap_batch":["/// Does a rewrap batch, and schedules follow-up work if needed.\npub(crate) fn do_rewrap_batch(&mut self){\n        self.rewrap();\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n        self.render_if_needed();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_show_hover":["fn do_show_hover(&mut self, request_id: usize, hover: Result<Hover, RemoteError>){\n        match hover {\n            Ok(hover) => {\n                // TODO: Get Range from hover here and use it to highlight text\n                self.client.show_hover(self.view_id, request_id, hover.content)\n            }\n            Err(err) => warn!(\"Hover Response from Client Error {:?}\", err),\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::do_special":["fn do_special(&mut self, cmd: SpecialEvent){\n        match cmd {\n            SpecialEvent::Resize(size) => {\n                self.with_view(|view, _| view.set_size(size));\n                if self.config.word_wrap {\n                    self.update_wrap_settings(false);\n                }\n            }\n            SpecialEvent::DebugRewrap | SpecialEvent::DebugWrapWidth => {\n                warn!(\"debug wrapping methods are removed, use the config system\")\n            }\n            SpecialEvent::DebugPrintSpans => self.with_editor(|ed, view, _, _| {\n                let sel = view.sel_regions().last().unwrap();\n                let iv = Interval::new(sel.min(), sel.max());\n                ed.get_layers().debug_print_spans(iv);\n            }),\n            SpecialEvent::RequestLines(LineRange { first, last }) => {\n                self.do_request_lines(first as usize, last as usize)\n            }\n            SpecialEvent::RequestHover { request_id, position } => {\n                self.do_request_hover(request_id, position)\n            }\n            SpecialEvent::DebugToggleComment => self.do_debug_toggle_comment(),\n            SpecialEvent::Reindent => self.do_reindent(),\n            SpecialEvent::ToggleRecording(_) => {}\n            SpecialEvent::PlayRecording(recording_name) => {\n                let recorder = self.recorder.borrow();\n\n                let starting_revision = self.editor.borrow_mut().get_head_rev_token();\n\n                // Don't group with the previous action\n                self.editor.borrow_mut().update_edit_type();\n                self.editor.borrow_mut().calculate_undo_group();\n\n                // No matter what, our entire block must belong to the same undo group\n                self.editor.borrow_mut().set_force_undo_group(true);\n                recorder.play(&recording_name, |event| {\n                    self.dispatch_event(event.clone());\n\n                    let mut editor = self.editor.borrow_mut();\n                    let (delta, last_text, drift) = match editor.commit_delta() {\n                        Some(edit_info) => edit_info,\n                        None => return,\n                    };\n                    self.update_views(&editor, &delta, &last_text, drift);\n                });\n                self.editor.borrow_mut().set_force_undo_group(false);\n\n                // The action that follows the block must belong to a separate undo group\n                self.editor.borrow_mut().update_edit_type();\n\n                let delta = self.editor.borrow_mut().delta_rev_head(starting_revision).unwrap();\n                self.update_plugins(&mut self.editor.borrow_mut(), delta, \"core\");\n            }\n            SpecialEvent::ClearRecording(recording_name) => {\n                let mut recorder = self.recorder.borrow_mut();\n                recorder.clear(&recording_name);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::find":["/// Tells the view to execute find on a batch of lines, if needed.\nfn find(&mut self){\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        view.do_find(ed.get_buffer());\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::finish_init":["pub(crate) fn finish_init(&mut self, config: &Table){\n        if !self.plugins.is_empty() {\n            let info = self.plugin_info();\n\n            self.plugins.iter().for_each(|plugin| {\n                plugin.new_buffer(&info);\n                self.plugin_started(plugin);\n            });\n        }\n\n        let available_plugins = self\n            .plugins\n            .iter()\n            .map(|plugin| ClientPluginInfo { name: plugin.name.clone(), running: true })\n            .collect::<Vec<_>>();\n        self.client.available_plugins(self.view_id, &available_plugins);\n\n        self.client.config_changed(self.view_id, config);\n        self.client.language_changed(self.view_id, &self.language);\n\n        // Rewrap and request a render.\n        // This is largely similar to update_wrap_settings(), the only difference\n        // being that the view is expected to be already initialized.\n        self.rewrap();\n\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n\n        self.with_view(|view, text| view.set_dirty(text));\n        self.render()\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::get_resolved_position":["/// Gives the requested position in UTF-8 offset format to be sent to plugin\n/// If position is `None`, it tries to get the current Caret Position and use\n/// that instead\nfn get_resolved_position(&mut self, position: Option<ClientPosition>) -> Option<usize>{\n        position\n            .map(|p| self.with_view(|view, text| view.line_col_to_offset(text, p.line, p.column)))\n            .or_else(|| self.view.borrow().get_caret_offset())\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::language_changed":["pub(crate) fn language_changed(&mut self, new_language_id: &LanguageId){\n        self.language = new_language_id.clone();\n        self.client.language_changed(self.view_id, new_language_id);\n        self.plugins.iter().for_each(|plug| plug.language_changed(self.view_id, new_language_id));\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::plugin_info":["pub(crate) fn plugin_info(&mut self) -> PluginBufferInfo{\n        let ed = self.editor.borrow();\n        let nb_lines = ed.get_buffer().measure::<LinesMetric>() + 1;\n        let views: Vec<ViewId> = iter::once(&self.view)\n            .chain(self.siblings.iter())\n            .map(|v| v.borrow().get_view_id())\n            .collect();\n\n        let changes = serde_json::to_value(self.config).unwrap();\n        let path = self.info.map(|info| info.path.to_owned());\n        PluginBufferInfo::new(\n            self.buffer_id,\n            &views,\n            ed.get_head_rev_token(),\n            ed.get_buffer().len(),\n            nb_lines,\n            path,\n            self.language.clone(),\n            changes.as_object().unwrap().to_owned(),\n        )\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::plugin_started":["pub(crate) fn plugin_started(&self, plugin: &Plugin){\n        self.client.plugin_started(self.view_id, &plugin.name)\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::plugin_stopped":["pub(crate) fn plugin_stopped(&mut self, plugin: &Plugin){\n        self.client.plugin_stopped(self.view_id, &plugin.name, 0);\n        let needs_render = self.with_editor(|ed, view, _, _| {\n            if ed.get_layers_mut().remove_layer(plugin.id).is_some() {\n                view.set_dirty(ed.get_buffer());\n                true\n            } else {\n                false\n            }\n        });\n        if needs_render {\n            self.render();\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::reload":["pub(crate) fn reload(&mut self, text: Rope){\n        self.with_editor(|ed, _, _, _| ed.reload(text));\n        self.after_edit(\"core\");\n        self.render();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::render":["/// Flushes any changes in the views out to the frontend.\nfn render(&mut self){\n        let _t = trace_block(\"EventContext::render\", &[\"core\"]);\n        let ed = self.editor.borrow();\n        //TODO: render other views\n        self.view.borrow_mut().render_if_dirty(\n            ed.get_buffer(),\n            self.client,\n            self.style_map,\n            ed.get_layers().get_merged(),\n            ed.is_pristine(),\n        )\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::render_if_needed":["/// Renders the view, if a render has not already been scheduled.\npub(crate) fn render_if_needed(&mut self){\n        let needed = !self.view.borrow().has_pending_render();\n        if needed {\n            self.render()\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::rewrap":["/// Tells the view to rewrap a batch of lines, if needed. This guarantees that\n/// the currently visible region will be correctly wrapped; the caller should\n/// check if additional wrapping is necessary and schedule that if so.\nfn rewrap(&mut self){\n        let mut view = self.view.borrow_mut();\n        let ed = self.editor.borrow();\n        let mut width_cache = self.width_cache.borrow_mut();\n        view.rewrap(ed.get_buffer(), &mut width_cache, self.client, ed.get_layers().get_merged());\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::schedule_find":["fn schedule_find(&self){\n        let view_id: usize = self.view_id.into();\n        let token = FIND_VIEW_IDLE_MASK | view_id;\n        self.client.schedule_idle(token);\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::schedule_rewrap":["fn schedule_rewrap(&self){\n        let view_id: usize = self.view_id.into();\n        let token = REWRAP_VIEW_IDLE_MASK | view_id;\n        self.client.schedule_idle(token);\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::selected_line_ranges":["fn selected_line_ranges(&mut self) -> Vec<(usize, usize)>{\n        let ed = self.editor.borrow();\n        let mut prev_range: Option<Range<usize>> = None;\n        let mut line_ranges = Vec::new();\n        // we send selection state to syntect in the form of a vec of line ranges,\n        // so we combine overlapping selections to get the minimum set of ranges.\n        for region in self.view.borrow().sel_regions().iter() {\n            let start = ed.get_buffer().line_of_offset(region.min());\n            let end = ed.get_buffer().line_of_offset(region.max()) + 1;\n            let line_range = start..end;\n            let prev = prev_range.take();\n            match (prev, line_range) {\n                (None, range) => prev_range = Some(range),\n                (Some(ref prev), ref range) if range.start <= prev.end => {\n                    let combined =\n                        Range { start: prev.start.min(range.start), end: prev.end.max(range.end) };\n                    prev_range = Some(combined);\n                }\n                (Some(prev), range) => {\n                    line_ranges.push((prev.start, prev.end));\n                    prev_range = Some(range);\n                }\n            }\n        }\n\n        if let Some(prev) = prev_range {\n            line_ranges.push((prev.start, prev.end));\n        }\n\n        line_ranges\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::text_for_save":["/// Returns the text to be saved, appending a newline if necessary.\npub(crate) fn text_for_save(&mut self) -> Rope{\n        let editor = self.editor.borrow();\n        let mut rope = editor.get_buffer().clone();\n        let rope_len = rope.len();\n\n        if rope_len < 1 || !self.config.save_with_newline {\n            return rope;\n        }\n\n        let cursor = Cursor::new(&rope, rope.len());\n        let has_newline_at_eof = match cursor.get_leaf() {\n            Some((last_chunk, _)) => last_chunk.ends_with(&self.config.line_ending),\n            // The rope can't be empty, since we would have returned earlier if it was\n            None => unreachable!(),\n        };\n\n        if !has_newline_at_eof {\n            let line_ending = &self.config.line_ending;\n            rope.edit(rope_len.., line_ending);\n            rope\n        } else {\n            rope\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::update_plugins":["fn update_plugins(&self, ed: &mut Editor, delta: RopeDelta, author: &str){\n        let new_len = delta.new_document_len();\n        let nb_lines = ed.get_buffer().measure::<LinesMetric>() + 1;\n        // don't send the actual delta if it is too large, by some heuristic\n        let approx_size = delta.inserts_len() + (delta.els.len() * 10);\n        let delta = if approx_size > MAX_SIZE_LIMIT { None } else { Some(delta) };\n\n        let undo_group = ed.get_active_undo_group();\n        //TODO: we want to just put EditType on the wire, but don't want\n        //to update the plugin lib quite yet.\n        let v: Value = serde_json::to_value(&ed.get_edit_type()).unwrap();\n        let edit_type_str = v.as_str().unwrap().to_string();\n\n        let update = PluginUpdate::new(\n            self.view_id,\n            ed.get_head_rev_token(),\n            delta,\n            new_len,\n            nb_lines,\n            Some(undo_group),\n            edit_type_str,\n            author.into(),\n        );\n\n        // we always increment and decrement regardless of whether we're\n        // sending plugins, to ensure that GC runs.\n        ed.increment_revs_in_flight();\n\n        self.plugins.iter().for_each(|plugin| {\n            ed.increment_revs_in_flight();\n            let weak_core = self.weak_core.clone();\n            let id = plugin.id;\n            let view_id = self.view_id;\n            plugin.update(&update, move |resp| {\n                weak_core.handle_plugin_update(id, view_id, resp);\n            });\n        });\n        ed.dec_revs_in_flight();\n        ed.update_edit_type();\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::update_views":["fn update_views(&self, ed: &Editor, delta: &RopeDelta, last_text: &Rope, drift: InsertDrift){\n        let mut width_cache = self.width_cache.borrow_mut();\n        let iter_views = iter::once(&self.view).chain(self.siblings.iter());\n        iter_views.for_each(|view| {\n            view.borrow_mut().after_edit(\n                ed.get_buffer(),\n                last_text,\n                delta,\n                self.client,\n                &mut width_cache,\n                drift,\n            )\n        });\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::update_wrap_settings":["/// Called after anything changes that effects word wrap, such as the size of\n/// the window or the user's wrap settings. `rewrap_immediately` should be `true`\n/// except in the resize case; during live resize we want to delay recalculation\n/// to avoid unnecessary work.\nfn update_wrap_settings(&mut self, rewrap_immediately: bool){\n        let wrap_width = self.config.wrap_width;\n        let word_wrap = self.config.word_wrap;\n        self.with_view(|view, text| view.update_wrap_settings(text, wrap_width, word_wrap));\n        if rewrap_immediately {\n            self.rewrap();\n            self.with_view(|view, text| view.set_dirty(text));\n        }\n        if self.view.borrow().needs_more_wrap() {\n            self.schedule_rewrap();\n        }\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::view_init":["pub(crate) fn view_init(&mut self){\n        let wrap_width = self.config.wrap_width;\n        let word_wrap = self.config.word_wrap;\n\n        self.with_view(|view, text| view.update_wrap_settings(text, wrap_width, word_wrap));\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::with_each_plugin":["fn with_each_plugin<F: FnMut(&&Plugin)>(&self, f: F){\n        self.plugins.iter().for_each(f)\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::with_editor":["/// Executes a closure with mutable references to the editor and the view,\n/// common in edit actions that modify the text.\npub(crate) fn with_editor<R, F>(&mut self, f: F) -> R\n    where\n        F: FnOnce(&mut Editor, &mut View, &mut Rope, &BufferItems) -> R,{\n        let mut editor = self.editor.borrow_mut();\n        let mut view = self.view.borrow_mut();\n        let mut kill_ring = self.kill_ring.borrow_mut();\n        f(&mut editor, &mut view, &mut kill_ring, &self.config)\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"event_context::EventContext::<'a>::with_view":["/// Executes a closure with a mutable reference to the view and a reference\n/// to the current text. This is common to most edits that just modify\n/// selection or viewport state.\nfn with_view<R, F>(&mut self, f: F) -> R\n    where\n        F: FnOnce(&mut View, &Rope) -> R,{\n        let editor = self.editor.borrow();\n        let mut view = self.view.borrow_mut();\n        f(&mut view, editor.get_buffer())\n    }","Real(LocalPath(\"core-lib/src/event_context.rs\"))"],"file::<impl std::convert::From<file::FileError> for xi_rpc::RemoteError>::from":["fn from(src: FileError) -> RemoteError{\n        //TODO: when we migrate to using the failure crate for error handling,\n        // this should return a better message\n        let code = src.error_code();\n        let message = src.to_string();\n        RemoteError::custom(code, message, None)\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::CharacterEncoding":["pub enum CharacterEncoding {\n    Utf8,\n    Utf8WithBom,\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::CharacterEncoding::guess":["fn guess(s: &[u8]) -> Self{\n        if s.starts_with(UTF8_BOM.as_bytes()) {\n            CharacterEncoding::Utf8WithBom\n        } else {\n            CharacterEncoding::Utf8\n        }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileError":["pub enum FileError {\n    Io(io::Error, PathBuf),\n    UnknownEncoding(PathBuf),\n    HasChanged(PathBuf),\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileError::error_code":["fn error_code(&self) -> i64{\n        match self {\n            FileError::Io(_, _) => 5,\n            FileError::UnknownEncoding(_) => 6,\n            FileError::HasChanged(_) => 7,\n        }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileInfo":["pub struct FileInfo {\n    pub encoding: CharacterEncoding,\n    pub path: PathBuf,\n    pub mod_time: Option<SystemTime>,\n    pub has_changed: bool,\n    #[cfg(target_family = \"unix\")]\n    pub permissions: Option<u32>,\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager":["/// Tracks all state related to open files.\npub struct FileManager {\n    open_files: HashMap<PathBuf, BufferId>,\n    file_info: HashMap<BufferId, FileInfo>,\n    /// A monitor of filesystem events, for things like reloading changed files.\n    #[cfg(feature = \"notify\")]\n    watcher: FileWatcher,\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::check_file":["/// Returns `true` if this file is open and has changed on disk.\n/// This state is stashed.\npub fn check_file(&mut self, path: &Path, id: BufferId) -> bool{\n        if let Some(info) = self.file_info.get_mut(&id) {\n            let mod_t = get_mod_time(path);\n            if mod_t != info.mod_time {\n                info.has_changed = true\n            }\n            return info.has_changed;\n        }\n        false\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::close":["pub fn close(&mut self, id: BufferId){\n        if let Some(info) = self.file_info.remove(&id) {\n            self.open_files.remove(&info.path);\n            #[cfg(feature = \"notify\")]\n            self.watcher.unwatch(&info.path, OPEN_FILE_EVENT_TOKEN);\n        }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::get_editor":["pub fn get_editor(&self, path: &Path) -> Option<BufferId>{\n        self.open_files.get(path).cloned()\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::get_info":["pub fn get_info(&self, id: BufferId) -> Option<&FileInfo>{\n        self.file_info.get(&id)\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::new":["#[cfg(feature = \"notify\")]\npub fn new(watcher: FileWatcher) -> Self{\n        FileManager { open_files: HashMap::new(), file_info: HashMap::new(), watcher }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::open":["pub fn open(&mut self, path: &Path, id: BufferId) -> Result<Rope, FileError>{\n        if !path.exists() {\n            return Ok(Rope::from(\"\"));\n        }\n\n        let (rope, info) = try_load_file(path)?;\n\n        self.open_files.insert(path.to_owned(), id);\n        if self.file_info.insert(id, info).is_none() {\n            #[cfg(feature = \"notify\")]\n            self.watcher.watch(path, false, OPEN_FILE_EVENT_TOKEN);\n        }\n        Ok(rope)\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::save":["pub fn save(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError>{\n        let is_existing = self.file_info.contains_key(&id);\n        if is_existing {\n            self.save_existing(path, text, id)\n        } else {\n            self.save_new(path, text, id)\n        }\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::save_existing":["fn save_existing(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError>{\n        let prev_path = self.file_info[&id].path.clone();\n        if prev_path != path {\n            self.save_new(path, text, id)?;\n            self.open_files.remove(&prev_path);\n            #[cfg(feature = \"notify\")]\n            self.watcher.unwatch(&prev_path, OPEN_FILE_EVENT_TOKEN);\n        } else if self.file_info[&id].has_changed {\n            return Err(FileError::HasChanged(path.to_owned()));\n        } else {\n            let encoding = self.file_info[&id].encoding;\n            try_save(path, text, encoding, self.get_info(id))\n                .map_err(|e| FileError::Io(e, path.to_owned()))?;\n            self.file_info.get_mut(&id).unwrap().mod_time = get_mod_time(path);\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::save_new":["fn save_new(&mut self, path: &Path, text: &Rope, id: BufferId) -> Result<(), FileError>{\n        try_save(path, text, CharacterEncoding::Utf8, self.get_info(id))\n            .map_err(|e| FileError::Io(e, path.to_owned()))?;\n        let info = FileInfo {\n            encoding: CharacterEncoding::Utf8,\n            path: path.to_owned(),\n            mod_time: get_mod_time(path),\n            has_changed: false,\n            #[cfg(target_family = \"unix\")]\n            permissions: get_permissions(path),\n        };\n        self.open_files.insert(path.to_owned(), id);\n        self.file_info.insert(id, info);\n        #[cfg(feature = \"notify\")]\n        self.watcher.watch(path, false, OPEN_FILE_EVENT_TOKEN);\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::FileManager::watcher":["#[cfg(feature = \"notify\")]\npub fn watcher(&mut self) -> &mut FileWatcher{\n        &mut self.watcher\n    }","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::get_mod_time":["/// Returns the modification timestamp for the file at a given path,\n/// if present.\nfn get_mod_time<P: AsRef<Path>>(path: P) -> Option<SystemTime>{\n    File::open(path).and_then(|f| f.metadata()).and_then(|meta| meta.modified()).ok()\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::get_permissions":["/// Returns the file permissions for the file at a given path on UNIXy systems,\n/// if present.\n#[cfg(target_family = \"unix\")]\nfn get_permissions<P: AsRef<Path>>(path: P) -> Option<u32>{\n    File::open(path).and_then(|f| f.metadata()).map(|meta| meta.permissions().mode()).ok()\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::try_decode":["fn try_decode(bytes: Vec<u8>, encoding: CharacterEncoding, path: &Path) -> Result<Rope, FileError>{\n    match encoding {\n        CharacterEncoding::Utf8 => Ok(Rope::from(\n            str::from_utf8(&bytes).map_err(|_e| FileError::UnknownEncoding(path.to_owned()))?,\n        )),\n        CharacterEncoding::Utf8WithBom => {\n            let s = String::from_utf8(bytes)\n                .map_err(|_e| FileError::UnknownEncoding(path.to_owned()))?;\n            Ok(Rope::from(&s[UTF8_BOM.len()..]))\n        }\n    }\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::try_load_file":["fn try_load_file<P>(path: P) -> Result<(Rope, FileInfo), FileError>\nwhere\n    P: AsRef<Path>,{\n    // TODO: support for non-utf8\n    // it's arguable that the rope crate should have file loading functionality\n    let mut f =\n        File::open(path.as_ref()).map_err(|e| FileError::Io(e, path.as_ref().to_owned()))?;\n    let mut bytes = Vec::new();\n    f.read_to_end(&mut bytes).map_err(|e| FileError::Io(e, path.as_ref().to_owned()))?;\n\n    let encoding = CharacterEncoding::guess(&bytes);\n    let rope = try_decode(bytes, encoding, path.as_ref())?;\n    let info = FileInfo {\n        encoding,\n        mod_time: get_mod_time(&path),\n        #[cfg(target_family = \"unix\")]\n        permissions: get_permissions(&path),\n        path: path.as_ref().to_owned(),\n        has_changed: false,\n    };\n    Ok((rope, info))\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"file::try_save":["#[allow(unused)]\nfn try_save(\n    path: &Path,\n    text: &Rope,\n    encoding: CharacterEncoding,\n    file_info: Option<&FileInfo>,\n) -> io::Result<()>{\n    let tmp_extension = path.extension().map_or_else(\n        || OsString::from(\"swp\"),\n        |ext| {\n            let mut ext = ext.to_os_string();\n            ext.push(\".swp\");\n            ext\n        },\n    );\n    let tmp_path = &path.with_extension(tmp_extension);\n\n    let mut f = File::create(tmp_path)?;\n    match encoding {\n        CharacterEncoding::Utf8WithBom => f.write_all(UTF8_BOM.as_bytes())?,\n        CharacterEncoding::Utf8 => (),\n    }\n\n    for chunk in text.iter_chunks(..text.len()) {\n        f.write_all(chunk.as_bytes())?;\n    }\n\n    fs::rename(tmp_path, path)?;\n\n    #[cfg(target_family = \"unix\")]\n    {\n        if let Some(info) = file_info {\n            fs::set_permissions(path, Permissions::from_mode(info.permissions.unwrap_or(0o644)))\n                .unwrap_or_else(|e| {\n                    warn!(\"Couldn't set permissions on file {} due to error {}\", path.display(), e)\n                });\n        }\n    }\n\n    Ok(())\n}","Real(LocalPath(\"core-lib/src/file.rs\"))"],"find::Find":["/// Contains logic to search text\npub struct Find {\n    /// Uniquely identifies this search query.\n    id: usize,\n\n    /// The occurrences, which determine the highlights, have been updated.\n    hls_dirty: bool,\n\n    /// The currently active search string.\n    search_string: Option<String>,\n\n    /// The case matching setting for the currently active search.\n    case_matching: CaseMatching,\n\n    /// The search query should be considered as regular expression.\n    regex: Option<Regex>,\n\n    /// Query matches only whole words.\n    whole_words: bool,\n\n    /// The set of all known find occurrences (highlights).\n    occurrences: Selection,\n}","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::find_status":["pub fn find_status(&self, view: &View, text: &Rope, matches_only: bool) -> FindStatus{\n        if matches_only {\n            FindStatus {\n                id: self.id,\n                chars: None,\n                case_sensitive: None,\n                is_regex: None,\n                whole_words: None,\n                matches: self.occurrences.len(),\n                lines: Vec::new(),\n            }\n        } else {\n            FindStatus {\n                id: self.id,\n                chars: self.search_string.clone(),\n                case_sensitive: Some(self.case_matching == CaseMatching::Exact),\n                is_regex: Some(self.regex.is_some()),\n                whole_words: Some(self.whole_words),\n                matches: self.occurrences.len(),\n                lines: self\n                    .occurrences\n                    .iter()\n                    .map(|o| view.offset_to_line_col(text, o.min()).0 + 1)\n                    .collect(),\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::hls_dirty":["pub fn hls_dirty(&self) -> bool{\n        self.hls_dirty\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::id":["pub fn id(&self) -> usize{\n        self.id\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::is_matching_whole_words":["/// Checks if the start and end of a match is matching whole words.\nfn is_matching_whole_words(&self, text: &Rope, start: usize, end: usize) -> bool{\n        let mut word_end_cursor = WordCursor::new(text, end - 1);\n        let mut word_start_cursor = WordCursor::new(text, start + 1);\n\n        if let Some(start_boundary) = word_start_cursor.prev_boundary() {\n            if start_boundary != start {\n                return false;\n            }\n        }\n\n        if let Some(end_boundary) = word_end_cursor.next_boundary() {\n            if end_boundary != end {\n                return false;\n            }\n        }\n\n        true\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::is_multiline_regex":["/// Returns `true` if the search query is a multi-line regex.\npub(crate) fn is_multiline_regex(&self) -> bool{\n        self.regex.is_some() && is_multiline_regex(self.search_string.as_ref().unwrap())\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::new":["pub fn new(id: usize) -> Find{\n        Find {\n            id,\n            hls_dirty: true,\n            search_string: None,\n            case_matching: CaseMatching::CaseInsensitive,\n            regex: None,\n            whole_words: false,\n            occurrences: Selection::new(),\n        }\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::next_occurrence":["/// Return the occurrence closest to the provided selection `sel`. If searched is reversed then\n/// the occurrence closest to the start of the selection is returned. `wrapped` indicates that\n/// if the end of the text is reached the search continues from the start.\npub fn next_occurrence(\n        &self,\n        text: &Rope,\n        reverse: bool,\n        wrapped: bool,\n        sel: &Selection,\n    ) -> Option<SelRegion>{\n        if self.occurrences.len() == 0 {\n            return None;\n        }\n\n        let (sel_start, sel_end) = match sel.last() {\n            Some(last) if last.is_caret() =>\n            // if last selection is caret then allow the current position to be part of the occurrence\n            {\n                (last.min(), last.max())\n            }\n            Some(last) if !last.is_caret() =>\n            // if the last selection is not a caret then continue searching after the caret\n            {\n                (last.min(), last.max() + 1)\n            }\n            _ => (0, 0),\n        };\n\n        if reverse {\n            let next_occurrence = match sel_start.checked_sub(1) {\n                Some(search_end) => self.occurrences.regions_in_range(0, search_end).last(),\n                None => None,\n            };\n\n            if next_occurrence.is_none() && !wrapped {\n                // get previous unselected occurrence\n                return self\n                    .occurrences\n                    .regions_in_range(0, text.len())\n                    .iter()\n                    .cloned()\n                    .filter(|o| sel.regions_in_range(o.min(), o.max()).is_empty())\n                    .collect::<Vec<SelRegion>>()\n                    .last()\n                    .cloned();\n            }\n\n            next_occurrence.cloned()\n        } else {\n            let next_occurrence = self.occurrences.regions_in_range(sel_end, text.len()).first();\n\n            if next_occurrence.is_none() && !wrapped {\n                // get next unselected occurrence\n                return self\n                    .occurrences\n                    .regions_in_range(0, text.len())\n                    .iter()\n                    .cloned()\n                    .filter(|o| sel.regions_in_range(o.min(), o.max()).is_empty())\n                    .collect::<Vec<SelRegion>>()\n                    .first()\n                    .cloned();\n            }\n\n            next_occurrence.cloned()\n        }\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::occurrences":["pub fn occurrences(&self) -> &Selection{\n        &self.occurrences\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::set_find":["/// Sets find parameters and search query. Returns `true` if parameters have been updated.\n/// Returns `false` to indicate that parameters haven't change.\npub(crate) fn set_find(\n        &mut self,\n        search_string: &str,\n        case_sensitive: bool,\n        is_regex: bool,\n        whole_words: bool,\n    ) -> bool{\n        if search_string.is_empty() {\n            self.unset();\n        }\n\n        let case_matching =\n            if case_sensitive { CaseMatching::Exact } else { CaseMatching::CaseInsensitive };\n\n        if let Some(ref s) = self.search_string {\n            if s == search_string\n                && case_matching == self.case_matching\n                && self.regex.is_some() == is_regex\n                && self.whole_words == whole_words\n            {\n                // search parameters did not change\n                return false;\n            }\n        }\n\n        self.unset();\n\n        self.search_string = Some(search_string.to_string());\n        self.case_matching = case_matching;\n        self.whole_words = whole_words;\n\n        // create regex from untrusted input\n        self.regex = match is_regex {\n            false => None,\n            true => RegexBuilder::new(search_string)\n                .size_limit(REGEX_SIZE_LIMIT)\n                .case_insensitive(case_matching == CaseMatching::CaseInsensitive)\n                .build()\n                .ok(),\n        };\n\n        true\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::set_hls_dirty":["pub fn set_hls_dirty(&mut self, is_dirty: bool){\n        self.hls_dirty = is_dirty\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::unset":["/// Unsets the search and removes all highlights from the view.\npub fn unset(&mut self){\n        self.search_string = None;\n        self.occurrences = Selection::new();\n        self.hls_dirty = true;\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::update_find":["/// Execute the search on the provided text in the range provided by `start` and `end`.\npub fn update_find(&mut self, text: &Rope, start: usize, end: usize, include_slop: bool){\n        if self.search_string.is_none() {\n            return;\n        }\n\n        // extend the search by twice the string length (twice, because case matching may increase\n        // the length of an occurrence)\n        let slop = if include_slop { self.search_string.as_ref().unwrap().len() * 2 } else { 0 };\n\n        let search_string = self.search_string.as_ref().unwrap();\n\n        // expand region to be able to find occurrences around the region's edges\n        let expanded_start = max(start, slop) - slop;\n        let expanded_end = min(end + slop, text.len());\n        let from = text.at_or_prev_codepoint_boundary(expanded_start).unwrap_or(0);\n        let to = text.at_or_next_codepoint_boundary(expanded_end).unwrap_or(text.len());\n        let mut to_cursor = Cursor::new(&text, to);\n        let _ = to_cursor.next_leaf();\n\n        let sub_text = text.subseq(Interval::new(0, to_cursor.pos()));\n        let mut find_cursor = Cursor::new(&sub_text, from);\n\n        let mut raw_lines = text.lines_raw(from..to);\n\n        while let Some(start) = find(\n            &mut find_cursor,\n            &mut raw_lines,\n            self.case_matching,\n            &search_string,\n            self.regex.as_ref(),\n        ) {\n            let end = find_cursor.pos();\n\n            if self.whole_words && !self.is_matching_whole_words(text, start, end) {\n                raw_lines = text.lines_raw(find_cursor.pos()..to);\n                continue;\n            }\n\n            let region = SelRegion::new(start, end);\n            let (_, e) = self.occurrences.add_range_distinct(region);\n            // in case of ambiguous search results (e.g. search \"aba\" in \"ababa\"),\n            // the search result closer to the beginning of the file wins\n            if e != end {\n                // Skip the search result and keep the occurrence that is closer to\n                // the beginning of the file. Re-align the cursor to the kept\n                // occurrence\n                find_cursor.set(e);\n                raw_lines = text.lines_raw(find_cursor.pos()..to);\n                continue;\n            }\n\n            // in case current cursor matches search result (for example query a* matches)\n            // all cursor positions, then cursor needs to be increased so that search\n            // continues at next position. Otherwise, search will result in overflow since\n            // search will always repeat at current cursor position.\n            if start == end {\n                // determine whether end of text is reached and stop search or increase\n                // cursor manually\n                if end + 1 >= text.len() {\n                    break;\n                } else {\n                    find_cursor.set(end + 1);\n                }\n            }\n\n            // update line iterator so that line starts at current cursor position\n            raw_lines = text.lines_raw(find_cursor.pos()..to);\n        }\n\n        self.hls_dirty = true;\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::Find::update_highlights":["pub fn update_highlights(&mut self, text: &Rope, delta: &RopeDelta){\n        // update search highlights for changed regions\n        if self.search_string.is_some() {\n            // invalidate occurrences around deletion positions\n            for DeltaRegion { old_offset, len, .. } in delta.iter_deletions() {\n                self.occurrences.delete_range(old_offset, old_offset + len, false);\n            }\n\n            self.occurrences = self.occurrences.apply_delta(delta, false, InsertDrift::Default);\n\n            // invalidate occurrences around insert positions\n            for DeltaRegion { new_offset, len, .. } in delta.iter_inserts() {\n                // also invalidate previous occurrence since it might expand after insertion\n                // eg. for regex .* every insertion after match will be part of match\n                self.occurrences.delete_range(\n                    new_offset.saturating_sub(1),\n                    new_offset + len,\n                    false,\n                );\n            }\n\n            // update find for the whole delta and everything after\n            let (iv, new_len) = delta.summary();\n\n            // get last valid occurrence that was unaffected by the delta\n            let start = match self.occurrences.regions_in_range(0, iv.start()).last() {\n                Some(reg) => reg.end,\n                None => 0,\n            };\n\n            // invalidate all search results from the point of the last valid search result until ...\n            let is_multiline = LinesMetric::next(self.search_string.as_ref().unwrap(), 0).is_some();\n\n            if is_multiline || self.is_multiline_regex() {\n                // ... the end of the file\n                self.occurrences.delete_range(iv.start(), text.len(), false);\n                self.update_find(text, start, text.len(), false);\n            } else {\n                // ... the end of the line including line break\n                let mut cursor = Cursor::new(&text, iv.end() + new_len);\n\n                let end_of_line = match cursor.next::<LinesMetric>() {\n                    Some(end) => end,\n                    None if cursor.pos() == text.len() => cursor.pos(),\n                    _ => return,\n                };\n\n                self.occurrences.delete_range(iv.start(), end_of_line, false);\n                self.update_find(text, start, end_of_line, false);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::FindStatus":["/// Information about search queries and number of matches for find\npub struct FindStatus {\n    /// Identifier for the current search query.\n    id: usize,\n\n    /// The current search query.\n    chars: Option<String>,\n\n    /// Whether the active search is case matching.\n    case_sensitive: Option<bool>,\n\n    /// Whether the search query is considered as regular expression.\n    is_regex: Option<bool>,\n\n    /// Query only matches whole words.\n    whole_words: Option<bool>,\n\n    /// Total number of matches.\n    matches: usize,\n\n    /// Line numbers which have find results.\n    lines: Vec<usize>,\n}","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/find.rs\"))"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/find.rs\"))"],"index_set::IndexSet":["pub struct IndexSet {\n    ranges: Vec<(usize, usize)>,\n}","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::apply_delta":["/// Computes a new set based on applying a delta to the old set. Collapsed regions are removed\n/// and contiguous regions are combined.\npub fn apply_delta(&self, delta: &RopeDelta) -> IndexSet{\n        let mut ranges: Vec<(usize, usize)> = Vec::new();\n        let mut transformer = Transformer::new(delta);\n        for &(start, end) in &self.ranges {\n            let new_range =\n                (transformer.transform(start, false), transformer.transform(end, false));\n            if new_range.0 == new_range.1 {\n                continue; // remove collapsed regions\n            }\n            if !ranges.is_empty() {\n                let ix = ranges.len() - 1;\n                if ranges[ix].1 == new_range.0 {\n                    ranges[ix] = (ranges[ix].0, new_range.1);\n                    continue;\n                }\n            }\n            ranges.push(new_range);\n        }\n        IndexSet { ranges }\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::clear":["/// Clear the set.\npub fn clear(&mut self){\n        self.ranges.clear();\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::delete_range":["/// Deletes the given range from the set.\npub fn delete_range(&mut self, start: usize, end: usize){\n        let mut ix = match self.ranges.binary_search_by(|r| r.1.cmp(&start)) {\n            Ok(ix) => ix,\n            Err(ix) => ix,\n        };\n\n        let mut del_from = None;\n        let mut del_len = 0;\n        while ix < self.ranges.len() {\n            if self.ranges[ix].0 >= end {\n                break;\n            }\n\n            if self.ranges[ix].0 < start {\n                if self.ranges[ix].1 > end {\n                    let range = (end, self.ranges[ix].1);\n                    self.ranges.insert(ix + 1, range);\n                }\n                self.ranges[ix].1 = start;\n            } else if self.ranges[ix].1 > end {\n                self.ranges[ix].0 = end;\n            } else {\n                if del_from.is_none() {\n                    del_from = Some(ix);\n                }\n                del_len += 1;\n            }\n\n            ix += 1;\n        }\n\n        if let Some(del_from) = del_from {\n            remove_n_at(&mut self.ranges, del_from, del_len);\n        }\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::minus_one_range":["/// Return an iterator that yields start..end minus the coverage in this set.\npub fn minus_one_range(&self, start: usize, end: usize) -> MinusIter{\n        let mut ranges = &self.ranges[..];\n        while !ranges.is_empty() && start >= ranges[0].1 {\n            ranges = &ranges[1..];\n        }\n        MinusIter { ranges, start, end }\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::new":["/// Create a new, empty set.\npub fn new() -> IndexSet{\n        IndexSet { ranges: Vec::new() }\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::IndexSet::union_one_range":["/// Add the range start..end to the set.\npub fn union_one_range(&mut self, start: usize, end: usize){\n        for i in 0..self.ranges.len() {\n            let (istart, iend) = self.ranges[i];\n            if start > iend {\n                continue;\n            } else if end < istart {\n                self.ranges.insert(i, (start, end));\n                return;\n            } else {\n                self.ranges[i].0 = min(start, istart);\n                let mut j = i;\n                while j + 1 < self.ranges.len() && end >= self.ranges[j + 1].0 {\n                    j += 1;\n                }\n                self.ranges[i].1 = max(end, self.ranges[j].1);\n                remove_n_at(&mut self.ranges, i + 1, j - i);\n                return;\n            }\n        }\n        self.ranges.push((start, end));\n    }","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::MinusIter":["/// The iterator generated by `minus_one_range`.\npub struct MinusIter<'a> {\n    ranges: &'a [(usize, usize)],\n    start: usize,\n    end: usize,\n}","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"index_set::remove_n_at":["pub fn remove_n_at<T: Clone>(v: &mut Vec<T>, index: usize, n: usize){\n    match n.cmp(&1) {\n        Ordering::Equal => {\n            v.remove(index);\n        }\n        Ordering::Greater => {\n            let new_len = v.len() - n;\n            for i in index..new_len {\n                v[i] = v[i + n].clone();\n            }\n            v.truncate(new_len);\n        }\n        Ordering::Less => (),\n    }\n}","Real(LocalPath(\"core-lib/src/index_set.rs\"))"],"layers::Layers":["/// A collection of layers containing scope information.\npub struct Layers {\n    layers: BTreeMap<PluginPid, ScopeLayer>,\n    deleted: HashSet<PluginPid>,\n    merged: Spans<Style>,\n}","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::add_scopes":["/// Adds the provided scopes to the layer's lookup table.\npub fn add_scopes(\n        &mut self,\n        layer: PluginPid,\n        scopes: Vec<Vec<String>>,\n        style_map: &ThemeStyleMap,\n    ){\n        let _t = trace_block(\"Layers::AddScopes\", &[\"core\"]);\n        if self.create_if_missing(layer).is_err() {\n            return;\n        }\n        self.layers.get_mut(&layer).unwrap().add_scopes(scopes, style_map);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::create_if_missing":["/// Returns an `Err` if this layer has been deleted; the caller should return.\nfn create_if_missing(&mut self, layer_id: PluginPid) -> Result<(), ()>{\n        if self.deleted.contains(&layer_id) {\n            return Err(());\n        }\n        if !self.layers.contains_key(&layer_id) {\n            self.layers.insert(layer_id, ScopeLayer::new(self.merged.len()));\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::debug_print_spans":["/// Prints scopes and style information for the given `Interval`.\npub fn debug_print_spans(&self, iv: Interval){\n        for (id, layer) in &self.layers {\n            let spans = layer.scope_spans.subseq(iv);\n            let styles = layer.style_spans.subseq(iv);\n            if spans.iter().next().is_some() {\n                info!(\"scopes for layer {:?}:\", id);\n                for (iv, val) in spans.iter() {\n                    info!(\"{}: {:?}\", iv, layer.stack_lookup[*val as usize]);\n                }\n                info!(\"styles:\");\n                for (iv, val) in styles.iter() {\n                    info!(\"{}: {:?}\", iv, val);\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::get_merged":["pub fn get_merged(&self) -> &Spans<Style>{\n        &self.merged\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::remove_layer":["/// Removes a given layer. This will remove all styles derived from\n/// that layer's scopes.\npub fn remove_layer(&mut self, layer: PluginPid) -> Option<ScopeLayer>{\n        self.deleted.insert(layer);\n        let layer = self.layers.remove(&layer);\n        if layer.is_some() {\n            let iv_all = Interval::new(0, self.merged.len());\n            //TODO: should Spans<T> have a clear() method?\n            self.merged = SpansBuilder::new(self.merged.len()).build();\n            self.resolve_styles(iv_all);\n        }\n        layer\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::resolve_styles":["/// Resolves styles from all layers for the given interval, updating\n/// the master style spans.\nfn resolve_styles(&mut self, iv: Interval){\n        if self.layers.is_empty() {\n            return;\n        }\n        let mut layer_iter = self.layers.values();\n        let mut resolved = layer_iter.next().unwrap().style_spans.subseq(iv);\n\n        for other in layer_iter {\n            let spans = other.style_spans.subseq(iv);\n            assert_eq!(resolved.len(), spans.len());\n            resolved = resolved.merge(&spans, |a, b| match b {\n                Some(b) => a.merge(b),\n                None => a.to_owned(),\n            });\n        }\n        self.merged.edit(iv, resolved);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::theme_changed":["pub fn theme_changed(&mut self, style_map: &ThemeStyleMap){\n        for layer in self.layers.values_mut() {\n            layer.theme_changed(style_map);\n        }\n        self.merged = SpansBuilder::new(self.merged.len()).build();\n        let iv_all = Interval::new(0, self.merged.len());\n        self.resolve_styles(iv_all);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::update_all":["/// Applies the delta to all layers, inserting empty intervals\n/// for any regions inserted in the delta.\n///\n/// This is useful for clearing spans, and for updating spans\n/// as edits occur.\npub fn update_all(&mut self, delta: &RopeDelta){\n        self.merged.apply_shape(delta);\n\n        for layer in self.layers.values_mut() {\n            layer.blank_scopes(delta);\n        }\n        let (iv, _len) = delta.summary();\n        self.resolve_styles(iv);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::Layers::update_layer":["/// Updates the scope spans for a given layer.\npub fn update_layer(&mut self, layer: PluginPid, iv: Interval, spans: Spans<u32>){\n        if self.create_if_missing(layer).is_err() {\n            return;\n        }\n        self.layers.get_mut(&layer).unwrap().update_scopes(iv, &spans);\n        self.resolve_styles(iv);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer":["/// A collection of scope spans from a single source.\npub struct ScopeLayer {\n    stack_lookup: Vec<Vec<Scope>>,\n    style_lookup: Vec<Style>,\n    // TODO: this might be efficient (in memory at least) if we use\n    // a prefix tree.\n    /// style state of existing scope spans, so we can more efficiently\n    /// compute styles of child spans.\n    style_cache: HashMap<Vec<Scope>, StyleModifier>,\n    /// Human readable scope names, for debugging\n    scope_spans: Spans<u32>,\n    style_spans: Spans<Style>,\n}","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::add_scopes":["fn add_scopes(&mut self, scopes: Vec<Vec<String>>, style_map: &ThemeStyleMap){\n        let mut stacks = Vec::with_capacity(scopes.len());\n        for stack in scopes {\n            let scopes = stack\n                .iter()\n                .map(|s| Scope::new(&s))\n                .filter(|result| match *result {\n                    Err(ref err) => {\n                        warn!(\"failed to resolve scope {}\\nErr: {:?}\", &stack.join(\" \"), err);\n                        false\n                    }\n                    _ => true,\n                })\n                .map(|s| s.unwrap())\n                .collect::<Vec<_>>();\n            stacks.push(scopes);\n        }\n\n        let mut new_styles = self.styles_for_stacks(stacks.as_slice(), style_map);\n        self.stack_lookup.append(&mut stacks);\n        self.style_lookup.append(&mut new_styles);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::blank_scopes":["/// Applies `delta`, which is presumed to contain empty spans.\n/// This is only used when we receive an edit, to adjust current span\n/// positions.\nfn blank_scopes(&mut self, delta: &RopeDelta){\n        self.style_spans.apply_shape(delta);\n        self.scope_spans.apply_shape(delta);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::new":["pub fn new(len: usize) -> Self{\n        ScopeLayer {\n            stack_lookup: Vec::new(),\n            style_lookup: Vec::new(),\n            style_cache: HashMap::new(),\n            scope_spans: SpansBuilder::new(len).build(),\n            style_spans: SpansBuilder::new(len).build(),\n        }\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::styles_for_stacks":["fn styles_for_stacks(\n        &mut self,\n        stacks: &[Vec<Scope>],\n        style_map: &ThemeStyleMap,\n    ) -> Vec<Style>{\n        //let style_map = style_map.borrow();\n        let highlighter = style_map.get_highlighter();\n        let mut new_styles = Vec::new();\n\n        for stack in stacks {\n            let mut last_style: Option<StyleModifier> = None;\n            let mut upper_bound_of_last = stack.len() as usize;\n\n            // walk backwards through stack to see if we have an existing\n            // style for any child stacks.\n            for i in 0..stack.len() - 1 {\n                let prev_range = 0..stack.len() - (i + 1);\n                if let Some(s) = self.style_cache.get(&stack[prev_range]) {\n                    last_style = Some(*s);\n                    upper_bound_of_last = stack.len() - (i + 1);\n                    break;\n                }\n            }\n            let mut base_style_mod = last_style.unwrap_or_default();\n\n            // apply the stack, generating children as needed.\n            for i in upper_bound_of_last..stack.len() {\n                let style_mod = highlighter.style_mod_for_stack(&stack[0..=i]);\n                base_style_mod = base_style_mod.apply(style_mod);\n            }\n\n            let style = Style::from_syntect_style_mod(&base_style_mod);\n            self.style_cache.insert(stack.clone(), base_style_mod);\n\n            new_styles.push(style);\n        }\n        new_styles\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::theme_changed":["fn theme_changed(&mut self, style_map: &ThemeStyleMap){\n        // recompute styles with the new theme\n        let cur_stacks = self.stack_lookup.clone();\n        self.style_lookup = self.styles_for_stacks(&cur_stacks, style_map);\n        let iv_all = Interval::new(0, self.style_spans.len());\n        self.style_spans = SpansBuilder::new(self.style_spans.len()).build();\n        // this feels unnecessary but we can't pass in a reference to self\n        // and I don't want to get fancy unless there's an actual perf problem\n        let scopes = self.scope_spans.clone();\n        self.update_styles(iv_all, &scopes)\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::update_scopes":["fn update_scopes(&mut self, iv: Interval, spans: &Spans<u32>){\n        self.scope_spans.edit(iv, spans.to_owned());\n        self.update_styles(iv, spans);\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"layers::ScopeLayer::update_styles":["/// Updates `self.style_spans`, mapping scopes to styles and combining\n/// adjacent and equal spans.\nfn update_styles(&mut self, iv: Interval, spans: &Spans<u32>){\n        // NOTE: This is a tradeoff. Keeping both u32 and Style spans for each\n        // layer makes debugging simpler and reduces the total number of spans\n        // on the wire (because we combine spans that resolve to the same style)\n        // but it does require additional computation + memory up front.\n        let mut sb = SpansBuilder::new(spans.len());\n        let mut spans_iter = spans.iter();\n        let mut prev = spans_iter.next();\n        {\n            // distinct adjacent scopes can often resolve to the same style,\n            // so we combine them when building the styles.\n            let style_eq = |i1: &u32, i2: &u32| {\n                self.style_lookup[*i1 as usize] == self.style_lookup[*i2 as usize]\n            };\n\n            while let Some((p_iv, p_val)) = prev {\n                match spans_iter.next() {\n                    Some((n_iv, n_val)) if n_iv.start() == p_iv.end() && style_eq(p_val, n_val) => {\n                        prev = Some((p_iv.union(n_iv), p_val));\n                    }\n                    other => {\n                        sb.add_span(p_iv, self.style_lookup[*p_val as usize].to_owned());\n                        prev = other;\n                    }\n                }\n            }\n        }\n        self.style_spans.edit(iv, sb.build());\n    }","Real(LocalPath(\"core-lib/src/layers.rs\"))"],"line_cache_shadow::Builder":["/// Builder for `LineCacheShadow` object.\npub struct Builder {\n    spans: Vec<Span>,\n    dirty: bool,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::Builder::add_span":["pub fn add_span(&mut self, n: usize, start_line_num: usize, validity: Validity){\n        if n > 0 {\n            if let Some(last) = self.spans.last_mut() {\n                if last.validity == validity\n                    && (validity == INVALID || last.start_line_num + last.n == start_line_num)\n                {\n                    last.n += n;\n                    return;\n                }\n            }\n            self.spans.push(Span { n, start_line_num, validity });\n        }\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::Builder::build":["pub fn build(self) -> LineCacheShadow{\n        LineCacheShadow { spans: self.spans, dirty: self.dirty }\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::Builder::new":["pub fn new() -> Builder{\n        Builder { spans: Vec::new(), dirty: false }\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::Builder::set_dirty":["pub fn set_dirty(&mut self, dirty: bool){\n        self.dirty = dirty;\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow":["/// The line cache shadow tracks the state of the line cache in the front-end.\n/// Any content marked as valid here is up-to-date in the current state of the\n/// view. Also, if `dirty` is false, then the entire line cache is valid.\npub struct LineCacheShadow {\n    spans: Vec<Span>,\n    dirty: bool,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow::edit":["pub fn edit(&mut self, start: usize, end: usize, replace: usize){\n        let mut b = Builder::new();\n        let mut line_num = 0;\n        let mut i = 0;\n        while i < self.spans.len() {\n            let span = &self.spans[i];\n            if line_num + span.n <= start {\n                b.add_span(span.n, span.start_line_num, span.validity);\n                line_num += span.n;\n                i += 1;\n            } else {\n                b.add_span(start - line_num, span.start_line_num, span.validity);\n                break;\n            }\n        }\n        b.add_span(replace, 0, INVALID);\n        for span in &self.spans[i..] {\n            if line_num + span.n > end {\n                let offset = end.saturating_sub(line_num);\n                b.add_span(span.n - offset, span.start_line_num + offset, span.validity);\n            }\n            line_num += span.n;\n        }\n        b.set_dirty(true);\n        *self = b.build();\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow::iter_with_plan":["pub fn iter_with_plan<'a>(&'a self, plan: &'a RenderPlan) -> PlanIterator<'a>{\n        PlanIterator {\n            lc_shadow: self,\n            plan,\n            shadow_ix: 0,\n            shadow_line_num: 0,\n            plan_ix: 0,\n            plan_line_num: 0,\n        }\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow::needs_render":["pub fn needs_render(&self, plan: &RenderPlan) -> bool{\n        self.dirty\n            || self\n                .iter_with_plan(plan)\n                .any(|seg| seg.tactic == RenderTactic::Render && seg.validity != ALL_VALID)\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow::partial_invalidate":["pub fn partial_invalidate(&mut self, start: usize, end: usize, invalid: Validity){\n        let mut clean = true;\n        let mut line_num = 0;\n        for span in &self.spans {\n            if start < line_num + span.n && end > line_num && (span.validity & invalid) != 0 {\n                clean = false;\n                break;\n            }\n            line_num += span.n;\n        }\n        if clean {\n            return;\n        }\n\n        let mut b = Builder::new();\n        let mut line_num = 0;\n        for span in &self.spans {\n            if start > line_num {\n                b.add_span(min(span.n, start - line_num), span.start_line_num, span.validity);\n            }\n            let invalid_start = max(start, line_num);\n            let invalid_end = min(end, line_num + span.n);\n            if invalid_end > invalid_start {\n                b.add_span(\n                    invalid_end - invalid_start,\n                    span.start_line_num + (invalid_start - line_num),\n                    span.validity & !invalid,\n                );\n            }\n            if line_num + span.n > end {\n                let offset = end.saturating_sub(line_num);\n                b.add_span(span.n - offset, span.start_line_num + offset, span.validity);\n            }\n            line_num += span.n;\n        }\n        b.set_dirty(true);\n        *self = b.build();\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::LineCacheShadow::spans":["pub fn spans(&self) -> &[Span]{\n        &self.spans\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::PlanIterator":["pub struct PlanIterator<'a> {\n    lc_shadow: &'a LineCacheShadow,\n    plan: &'a RenderPlan,\n    shadow_ix: usize,\n    shadow_line_num: usize,\n    plan_ix: usize,\n    plan_line_num: usize,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::PlanSegment":["pub struct PlanSegment {\n    /// Line number of start of segment, visual lines in current view state.\n    pub our_line_num: usize,\n    /// Line number of start of segment, visual lines in client's cache, if validity != 0.\n    pub their_line_num: usize,\n    /// Number of visual lines in this segment.\n    pub n: usize,\n    /// Validity of this segment in client's cache.\n    pub validity: Validity,\n    /// Tactic for rendering this segment.\n    pub tactic: RenderTactic,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::RenderPlan":["pub struct RenderPlan {\n    /// Each span is a number of lines and a tactic.\n    pub spans: Vec<(usize, RenderTactic)>,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::RenderPlan::create":["/// This function implements the policy of what to discard, what to preserve, and\n/// what to render.\npub fn create(total_height: usize, first_line: usize, height: usize) -> RenderPlan{\n        let mut spans = Vec::new();\n        let mut last = 0;\n        let first_line = min(first_line, total_height);\n        if first_line > PRESERVE_EXTENT {\n            last = first_line - PRESERVE_EXTENT;\n            spans.push((last, RenderTactic::Discard));\n        }\n        if first_line > SCROLL_SLOP {\n            let n = first_line - SCROLL_SLOP - last;\n            spans.push((n, RenderTactic::Preserve));\n            last += n;\n        }\n        let render_end = min(first_line + height + SCROLL_SLOP, total_height);\n        spans.push((render_end - last, RenderTactic::Render));\n        last = render_end;\n        let preserve_end = min(first_line + height + PRESERVE_EXTENT, total_height);\n        if preserve_end > last {\n            spans.push((preserve_end - last, RenderTactic::Preserve));\n            last = preserve_end;\n        }\n        if total_height > last {\n            spans.push((total_height - last, RenderTactic::Discard));\n        }\n        RenderPlan { spans }\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::RenderPlan::request_lines":["/// Upgrade a range of lines to the \"Render\" tactic.\npub fn request_lines(&mut self, start: usize, end: usize){\n        let mut spans: Vec<(usize, RenderTactic)> = Vec::new();\n        let mut i = 0;\n        let mut line_num = 0;\n        while i < self.spans.len() {\n            let span = &self.spans[i];\n            if line_num + span.0 <= start {\n                spans.push(*span);\n                line_num += span.0;\n                i += 1;\n            } else {\n                if line_num < start {\n                    spans.push((start - line_num, span.1));\n                }\n                break;\n            }\n        }\n        spans.push((end - start, RenderTactic::Render));\n        for span in &self.spans[i..] {\n            if line_num + span.0 > end {\n                let offset = end.saturating_sub(line_num);\n                spans.push((span.0 - offset, span.1));\n            }\n            line_num += span.0;\n        }\n        self.spans = spans;\n    }","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::RenderTactic":["pub enum RenderTactic {\n    /// Discard all content for this span. Used to keep storage reasonable.\n    Discard,\n    /// Preserve existing content.\n    Preserve,\n    /// Render content if it is invalid.\n    Render,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_cache_shadow::Span":["pub struct Span {\n    /// Number of lines in this span. Units are visual lines in the\n    /// current state of the view.\n    pub n: usize,\n    /// Starting line number. Units are visual lines in the front end's\n    /// current cache state (i.e. the last one rendered). Note: this is\n    /// irrelevant if validity is 0.\n    pub start_line_num: usize,\n    /// Validity of lines in this span, consisting of the above constants or'ed.\n    pub validity: Validity,\n}","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))"],"line_ending::LineEnding":["/// An enumeration of valid line endings\npub enum LineEnding {\n    CrLf, // DOS style, \\r\\n\n    Lf,   // *nix style, \\n\n}","Real(LocalPath(\"core-lib/src/line_ending.rs\"))"],"line_ending::LineEnding::parse":["/// Breaks a rope down into chunks, and checks each chunk for line endings\npub fn parse(rope: &Rope) -> Result<Option<Self>, MixedLineEndingError>{\n        let mut crlf = false;\n        let mut lf = false;\n\n        for chunk in rope.iter_chunks(..) {\n            match LineEnding::parse_chunk(&chunk) {\n                Ok(Some(LineEnding::CrLf)) => crlf = true,\n                Ok(Some(LineEnding::Lf)) => lf = true,\n                Ok(None) => (),\n                Err(e) => return Err(e),\n            }\n        }\n\n        match (crlf, lf) {\n            (true, false) => Ok(Some(LineEnding::CrLf)),\n            (false, true) => Ok(Some(LineEnding::Lf)),\n            (false, false) => Ok(None),\n            _ => Err(MixedLineEndingError),\n        }\n    }","Real(LocalPath(\"core-lib/src/line_ending.rs\"))"],"line_ending::LineEnding::parse_chunk":["/// Checks a chunk for line endings, assuming \\n or \\r\\n\npub fn parse_chunk(chunk: &str) -> Result<Option<Self>, MixedLineEndingError>{\n        let bytes = chunk.as_bytes();\n        let newline = memchr2(b'\\n', b'\\r', bytes);\n        match newline {\n            Some(x) if bytes[x] == b'\\r' && bytes.len() > x + 1 && bytes[x + 1] == b'\\n' => {\n                Ok(Some(LineEnding::CrLf))\n            }\n            Some(x) if bytes[x] == b'\\n' => Ok(Some(LineEnding::Lf)),\n            Some(_) => Err(MixedLineEndingError),\n            _ => Ok(None),\n        }\n    }","Real(LocalPath(\"core-lib/src/line_ending.rs\"))"],"line_ending::MixedLineEndingError":["/// A struct representing a mixed line ending error.\npub struct MixedLineEndingError;","Real(LocalPath(\"core-lib/src/line_ending.rs\"))"],"line_offset::LineOffset":["/// A trait from which lines and columns in a document can be calculated\n/// into offsets inside a rope an vice versa.\npub trait LineOffset {\n    // use own breaks if present, or text if not (no line wrapping)\n\n    /// Returns the byte offset corresponding to the given line.\n    fn offset_of_line(&self, text: &Rope, line: usize) -> usize {\n        text.offset_of_line(line)\n    }\n\n    /// Returns the visible line number containing the given offset.\n    fn line_of_offset(&self, text: &Rope, offset: usize) -> usize {\n        text.line_of_offset(offset)\n    }\n\n    // How should we count \"column\"? Valid choices include:\n    // * Unicode codepoints\n    // * grapheme clusters\n    // * Unicode width (so CJK counts as 2)\n    // * Actual measurement in text layout\n    // * Code units in some encoding\n    //\n    // Of course, all these are identical for ASCII. For now we use UTF-8 code units\n    // for simplicity.\n\n    fn offset_to_line_col(&self, text: &Rope, offset: usize) -> (usize, usize) {\n        let line = self.line_of_offset(text, offset);\n        (line, offset - self.offset_of_line(text, line))\n    }\n\n    fn line_col_to_offset(&self, text: &Rope, line: usize, col: usize) -> usize {\n        let mut offset = self.offset_of_line(text, line).saturating_add(col);\n        if offset >= text.len() {\n            offset = text.len();\n            if self.line_of_offset(text, offset) <= line {\n                return offset;\n            }\n        } else {\n            // Snap to grapheme cluster boundary\n            offset = text.prev_grapheme_offset(offset + 1).unwrap();\n        }\n\n        // clamp to end of line\n        let next_line_offset = self.offset_of_line(text, line + 1);\n        if offset >= next_line_offset {\n            if let Some(prev) = text.prev_grapheme_offset(next_line_offset) {\n                offset = prev;\n            }\n        }\n        offset\n    }\n\n    /// Get the line range of a selected region.\n    fn get_line_range(&self, text: &Rope, region: &SelRegion) -> Range<usize> {\n        let (first_line, _) = self.offset_to_line_col(text, region.min());\n        let (mut last_line, last_col) = self.offset_to_line_col(text, region.max());\n        if last_col == 0 && last_line > first_line {\n            last_line -= 1;\n        }\n\n        first_line..(last_line + 1)\n    }\n}","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LineOffset::get_line_range":["/// Get the line range of a selected region.\nfn get_line_range(&self, text: &Rope, region: &SelRegion) -> Range<usize>{\n        let (first_line, _) = self.offset_to_line_col(text, region.min());\n        let (mut last_line, last_col) = self.offset_to_line_col(text, region.max());\n        if last_col == 0 && last_line > first_line {\n            last_line -= 1;\n        }\n\n        first_line..(last_line + 1)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LineOffset::line_col_to_offset":["fn line_col_to_offset(&self, text: &Rope, line: usize, col: usize) -> usize{\n        let mut offset = self.offset_of_line(text, line).saturating_add(col);\n        if offset >= text.len() {\n            offset = text.len();\n            if self.line_of_offset(text, offset) <= line {\n                return offset;\n            }\n        } else {\n            // Snap to grapheme cluster boundary\n            offset = text.prev_grapheme_offset(offset + 1).unwrap();\n        }\n\n        // clamp to end of line\n        let next_line_offset = self.offset_of_line(text, line + 1);\n        if offset >= next_line_offset {\n            if let Some(prev) = text.prev_grapheme_offset(next_line_offset) {\n                offset = prev;\n            }\n        }\n        offset\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LineOffset::line_of_offset":["/// Returns the visible line number containing the given offset.\nfn line_of_offset(&self, text: &Rope, offset: usize) -> usize{\n        text.line_of_offset(offset)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LineOffset::offset_of_line":["/// Returns the byte offset corresponding to the given line.\nfn offset_of_line(&self, text: &Rope, line: usize) -> usize{\n        text.offset_of_line(line)\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LineOffset::offset_to_line_col":["fn offset_to_line_col(&self, text: &Rope, offset: usize) -> (usize, usize){\n        let line = self.line_of_offset(text, offset);\n        (line, offset - self.offset_of_line(text, line))\n    }","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"line_offset::LogicalLines":["/// A struct from which the default definitions for `offset_of_line`\n/// and `line_of_offset` can be accessed, and think in logical lines.\npub struct LogicalLines;","Real(LocalPath(\"core-lib/src/line_offset.rs\"))"],"linewrap::InvalLines":["/// Describes what has changed after a batch of word wrapping; this is used\n/// for minimal invalidation.\npub(crate) struct InvalLines {\n    pub(crate) start_line: usize,\n    pub(crate) inval_count: usize,\n    pub(crate) new_count: usize,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::LineBreakCursor":["struct LineBreakCursor<'a> {\n    inner: Cursor<'a, RopeInfo>,\n    lb_iter: LineBreakLeafIter,\n    last_byte: u8,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::LineBreakCursor::<'a>::new":["fn new(text: &'a Rope, pos: usize) -> LineBreakCursor<'a>{\n        let inner = Cursor::new(text, pos);\n        let lb_iter = match inner.get_leaf() {\n            Some((s, offset)) => LineBreakLeafIter::new(s.as_str(), offset),\n            _ => LineBreakLeafIter::default(),\n        };\n        LineBreakCursor { inner, lb_iter, last_byte: 0 }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::LineBreakCursor::<'a>::next":["fn next(&mut self) -> (usize, bool){\n        let mut leaf = self.inner.get_leaf();\n        loop {\n            match leaf {\n                Some((s, offset)) => {\n                    let (next, hard) = self.lb_iter.next(s.as_str());\n                    if next < s.len() {\n                        return (self.inner.pos() - offset + next, hard);\n                    }\n                    if !s.is_empty() {\n                        self.last_byte = s.as_bytes()[s.len() - 1];\n                    }\n                    leaf = self.inner.next_leaf();\n                }\n                // A little hacky but only reports last break as hard if final newline\n                None => return (self.inner.pos(), self.last_byte == b'\\n'),\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines":["/// Tracks state related to visual lines.\npub(crate) struct Lines {\n    breaks: Breaks,\n    wrap: WrapWidth,\n    /// Aka the 'frontier'; ranges of lines that still need to be wrapped.\n    work: Vec<Task>,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::add_task":["fn add_task<T: Into<Interval>>(&mut self, iv: T){\n        let iv = iv.into();\n        if iv.is_empty() {\n            return;\n        }\n\n        // keep everything that doesn't intersect. merge things that do.\n        let split_idx = match self.work.iter().position(|&t| !t.intersect(iv).is_empty()) {\n            Some(idx) => idx,\n            None => {\n                self.work.push(iv);\n                return;\n            }\n        };\n\n        let to_update = self.work.split_off(split_idx);\n        let mut new_task = Some(iv);\n\n        for t in &to_update {\n            match new_task.take() {\n                Some(new) if !t.intersect(new).is_empty() => new_task = Some(t.union(new)),\n                Some(new) => {\n                    self.work.push(new);\n                    self.work.push(*t);\n                }\n                None => self.work.push(*t),\n            }\n        }\n        if let Some(end) = new_task.take() {\n            self.work.push(end);\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::after_edit":["/// Updates breaks after an edit. Returns `InvalLines`, for minimal invalidation,\n/// when possible.\npub(crate) fn after_edit(\n        &mut self,\n        text: &Rope,\n        old_text: &Rope,\n        delta: &RopeDelta,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        visible_lines: Range<usize>,\n    ) -> Option<InvalLines>{\n        let (iv, newlen) = delta.summary();\n\n        let logical_start_line = text.line_of_offset(iv.start);\n        let old_logical_end_line = old_text.line_of_offset(iv.end) + 1;\n        let new_logical_end_line = text.line_of_offset(iv.start + newlen) + 1;\n        let old_logical_end_offset = old_text.offset_of_line(old_logical_end_line);\n        let old_hard_count = old_logical_end_line - logical_start_line;\n        let new_hard_count = new_logical_end_line - logical_start_line;\n\n        //TODO: we should be able to avoid wrapping the whole para in most cases,\n        // but the logic is trickier.\n        let prev_break = text.offset_of_line(logical_start_line);\n        let next_hard_break = text.offset_of_line(new_logical_end_line);\n\n        // count the soft breaks in the region we will rewrap, before we update them.\n        let inval_soft = self.breaks.count::<BreaksMetric>(old_logical_end_offset)\n            - self.breaks.count::<BreaksMetric>(prev_break);\n\n        // update soft breaks, adding empty spans in the edited region\n        let mut builder = BreakBuilder::new();\n        builder.add_no_break(newlen);\n        self.breaks.edit(iv, builder.build());\n        self.patchup_tasks(iv, newlen);\n\n        if self.wrap == WrapWidth::None {\n            return Some(InvalLines {\n                start_line: logical_start_line,\n                inval_count: old_hard_count,\n                new_count: new_hard_count,\n            });\n        }\n\n        let new_task = prev_break..next_hard_break;\n        self.add_task(new_task);\n\n        // possible if the whole buffer is deleted, e.g\n        if !self.work.is_empty() {\n            let summary = self.do_wrap_task(text, width_cache, client, visible_lines, None);\n            let WrapSummary { start_line, new_soft, .. } = summary;\n            // if we haven't converged after this update we can't do minimal invalidation\n            // because we don't have complete knowledge of the new breaks state.\n            if self.is_converged() {\n                let inval_count = old_hard_count + inval_soft;\n                let new_count = new_hard_count + new_soft;\n                Some(InvalLines { start_line, new_count, inval_count })\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::do_wrap_task":["fn do_wrap_task(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        visible_lines: Range<usize>,\n        max_lines: Option<usize>,\n    ) -> WrapSummary{\n        use self::WrapWidth::*;\n        let _t = trace_block(\"Lines::do_wrap_task\", &[\"core\"]);\n        // 'line' is a poor unit here; could do some fancy Duration thing?\n        const MAX_LINES_PER_BATCH: usize = 500;\n\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let visible_off = cursor.offset_of_line(visible_lines.start);\n        let logical_off = text.offset_of_line(text.line_of_offset(visible_off));\n\n        // task.start is a hard break; task.end is a boundary or EOF.\n        let task = self.get_next_task(logical_off).unwrap();\n        cursor.set_offset(task.start);\n        debug_assert_eq!(cursor.offset, task.start, \"task_start must be valid offset\");\n\n        let mut ctx = match self.wrap {\n            Bytes(b) => RewrapCtx::new(text, &CodepointMono, b as f64, width_cache, task.start),\n            Width(w) => RewrapCtx::new(text, client, w, width_cache, task.start),\n            None => unreachable!(),\n        };\n\n        let start_line = cursor.cur_line;\n        let max_lines = max_lines.unwrap_or(MAX_LINES_PER_BATCH);\n        // always wrap at least a screen worth of lines (unless we converge earlier)\n        let batch_size = max_lines.max(visible_lines.end - visible_lines.start);\n\n        let mut builder = BreakBuilder::new();\n        let mut lines_wrapped = 0;\n        let mut pos = task.start;\n        let mut old_next_maybe = cursor.next();\n\n        loop {\n            if let Some(new_next) = ctx.wrap_one_line(pos) {\n                while let Some(old_next) = old_next_maybe {\n                    if old_next >= new_next {\n                        break; // just advance old cursor and continue\n                    }\n                    old_next_maybe = cursor.next();\n                }\n\n                let is_hard = cursor.offset == new_next && cursor.is_hard_break();\n                if is_hard {\n                    builder.add_no_break(new_next - pos);\n                } else {\n                    builder.add_break(new_next - pos);\n                }\n                lines_wrapped += 1;\n                pos = new_next;\n                if pos == task.end || (lines_wrapped > batch_size && is_hard) {\n                    break;\n                }\n            } else {\n                // EOF\n                builder.add_no_break(text.len() - pos);\n                break;\n            }\n        }\n\n        let breaks = builder.build();\n        let end = task.start + breaks.len();\n\n        // this is correct *only* when an edit has not occured.\n        let inval_soft =\n            self.breaks.count::<BreaksMetric>(end) - self.breaks.count::<BreaksMetric>(task.start);\n\n        let hard_count = 1 + text.line_of_offset(end) - text.line_of_offset(task.start);\n\n        let inval_count = inval_soft + hard_count;\n        let new_soft = breaks.measure::<BreaksMetric>();\n        let new_count = new_soft + hard_count;\n\n        let iv = Interval::new(task.start, end);\n        self.breaks.edit(iv, breaks);\n        self.update_tasks_after_wrap(iv);\n\n        WrapSummary { start_line, inval_count, new_count, new_soft }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::get_next_task":["/// Returns the next task, prioritizing the currently visible region.\n/// Does not modify the task list; this is done after the task runs.\nfn get_next_task(&self, visible_offset: usize) -> Option<Task>{\n        // the first task t where t.end > visible_offset is the only task\n        // that might contain the visible region.\n        self.work\n            .iter()\n            .find(|t| t.end > visible_offset)\n            .map(|t| Task::new(t.start.max(visible_offset), t.end))\n            .or(self.work.last().cloned())\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::interval_needs_wrap":["/// Returns `true` if this interval is part of an incomplete task.\npub(crate) fn interval_needs_wrap(&self, iv: Interval) -> bool{\n        self.work.iter().any(|t| !t.intersect(iv).is_empty())\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::is_converged":["pub(crate) fn is_converged(&self) -> bool{\n        self.wrap == WrapWidth::None || self.work.is_empty()\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::iter_lines":["/// Returns an iterator over [`VisualLine`]s, starting at (and including)\n/// `start_line`.\npub(crate) fn iter_lines<'a>(\n        &'a self,\n        text: &'a Rope,\n        start_line: usize,\n    ) -> impl Iterator<Item = VisualLine> + 'a{\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let offset = cursor.offset_of_line(start_line);\n        let logical_line = text.line_of_offset(offset) + 1;\n        cursor.set_offset(offset);\n        VisualLines { offset, cursor, len: text.len(), logical_line, eof: false }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::logical_line_range":["pub fn logical_line_range(&self, text: &Rope, line: usize) -> (usize, usize){\n        let mut cursor = MergedBreaks::new(text, &self.breaks);\n        let offset = cursor.offset_of_line(line);\n        let logical_line = text.line_of_offset(offset);\n        let start_logical_line_offset = text.offset_of_line(logical_line);\n        let end_logical_line_offset = text.offset_of_line(logical_line + 1);\n        (start_logical_line_offset, end_logical_line_offset)\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::offset_of_visual_line":["/// Returns the byte offset corresponding to the line `line`.\npub(crate) fn offset_of_visual_line(&self, text: &Rope, line: usize) -> usize{\n        match self.wrap {\n            WrapWidth::None => {\n                // sanitize input\n                let line = line.min(text.measure::<LinesMetric>() + 1);\n                text.offset_of_line(line)\n            }\n            _ => {\n                let mut cursor = MergedBreaks::new(text, &self.breaks);\n                cursor.offset_of_line(line)\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::patchup_tasks":["/// Adjust offsets for any tasks after an edit.\nfn patchup_tasks<T: Into<Interval>>(&mut self, iv: T, new_len: usize){\n        let iv = iv.into();\n        let mut new_work = Vec::new();\n\n        for task in &self.work {\n            if task.is_before(iv.start) {\n                new_work.push(*task);\n            } else if task.contains(iv.start) {\n                let head = task.prefix(iv);\n                let tail_end = iv.start.max((task.end + new_len).saturating_sub(iv.size()));\n                let tail = Interval::new(iv.start, tail_end);\n                new_work.push(head);\n                new_work.push(tail);\n            } else {\n                // take task - our edit interval, then translate it (- old_size, + new_size)\n                let tail = task.suffix(iv).translate(new_len).translate_neg(iv.size());\n                new_work.push(tail);\n            }\n        }\n        new_work.retain(|iv| !iv.is_empty());\n        self.work.clear();\n        for task in new_work {\n            if let Some(prev) = self.work.last_mut() {\n                if prev.end >= task.start {\n                    *prev = prev.union(task);\n                    continue;\n                }\n            }\n            self.work.push(task);\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::rewrap_chunk":["/// Do a chunk of wrap work, if any exists.\npub(crate) fn rewrap_chunk(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        _spans: &Spans<Style>,\n        visible_lines: Range<usize>,\n    ) -> Option<InvalLines>{\n        if self.is_converged() {\n            None\n        } else {\n            let summary = self.do_wrap_task(text, width_cache, client, visible_lines, None);\n            let WrapSummary { start_line, inval_count, new_count, .. } = summary;\n            Some(InvalLines { start_line, inval_count, new_count })\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::set_wrap_width":["pub(crate) fn set_wrap_width(&mut self, text: &Rope, wrap: WrapWidth){\n        self.work.clear();\n        self.add_task(0..text.len());\n        if self.breaks.is_empty() || self.wrap.differs_in_kind(wrap) {\n            // we keep breaks while resizing, for more efficient invalidation\n            self.breaks = Breaks::new_no_break(text.len());\n        }\n        self.wrap = wrap;\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::update_tasks_after_wrap":["fn update_tasks_after_wrap<T: Into<Interval>>(&mut self, wrapped_iv: T){\n        if self.work.is_empty() {\n            return;\n        }\n        let wrapped_iv = wrapped_iv.into();\n\n        let mut work = Vec::new();\n        for task in &self.work {\n            if task.is_before(wrapped_iv.start) || task.is_after(wrapped_iv.end) {\n                work.push(*task);\n                continue;\n            }\n            if wrapped_iv.start > task.start {\n                work.push(task.prefix(wrapped_iv));\n            }\n            if wrapped_iv.end < task.end {\n                work.push(task.suffix(wrapped_iv));\n            }\n        }\n        self.work = work;\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::Lines::visual_line_of_offset":["pub(crate) fn visual_line_of_offset(&self, text: &Rope, offset: usize) -> usize{\n        let mut line = text.line_of_offset(offset);\n        if self.wrap != WrapWidth::None {\n            line += self.breaks.count::<BreaksMetric>(offset)\n        }\n        line\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks":["/// A cursor over both hard and soft breaks. Hard breaks are retrieved from\n/// the rope; the soft breaks are stored independently; this interleaves them.\n///\n/// # Invariants:\n///\n/// `self.offset` is always a valid break in one of the cursors, unless\n/// at 0 or EOF.\n///\n/// `self.offset == self.text.pos().min(self.soft.pos())`.\nstruct MergedBreaks<'a> {\n    text: Cursor<'a, RopeInfo>,\n    soft: Cursor<'a, BreaksInfo>,\n    offset: usize,\n    /// Starting from zero, how many calls to `next` to get to `self.offset`?\n    cur_line: usize,\n    total_lines: usize,\n    /// Total length, in base units\n    len: usize,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::at_eof":["fn at_eof(&self) -> bool{\n        self.offset == self.len\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::eof_without_newline":["fn eof_without_newline(&mut self) -> bool{\n        debug_assert!(self.at_eof());\n        self.text.set(self.len);\n        self.text.get_leaf().map(|(l, _)| l.as_bytes().last() != Some(&b'\\n')).unwrap()\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::is_hard_break":["fn is_hard_break(&self) -> bool{\n        self.offset == self.text.pos()\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::new":["fn new(text: &'a Rope, breaks: &'a Breaks) -> Self{\n        debug_assert_eq!(text.len(), breaks.len());\n        let text = Cursor::new(text, 0);\n        let soft = Cursor::new(breaks, 0);\n        let total_lines =\n            text.root().measure::<LinesMetric>() + soft.root().measure::<BreaksMetric>() + 1;\n        let len = text.total_len();\n        MergedBreaks { text, soft, offset: 0, cur_line: 0, total_lines, len }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::offset_of_line":["fn offset_of_line(&mut self, line: usize) -> usize{\n        match line {\n            0 => 0,\n            l if l >= self.total_lines => self.text.total_len(),\n            l if l == self.cur_line => self.offset,\n            l if l > self.cur_line && l - self.cur_line < MAX_LINEAR_DIST => {\n                self.offset_of_line_linear(l)\n            }\n            other => self.offset_of_line_bsearch(other),\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::offset_of_line_bsearch":["fn offset_of_line_bsearch(&mut self, line: usize) -> usize{\n        let mut range = 0..self.len;\n        loop {\n            let pivot = range.start + (range.end - range.start) / 2;\n            self.set_offset(pivot);\n\n            match self.cur_line {\n                l if l == line => break self.offset,\n                l if l > line => range = range.start..pivot,\n                l if line - l > MAX_LINEAR_DIST => range = pivot..range.end,\n                _else => break self.offset_of_line_linear(line),\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::offset_of_line_linear":["fn offset_of_line_linear(&mut self, line: usize) -> usize{\n        assert!(line > self.cur_line);\n        let dist = line - self.cur_line;\n        self.nth(dist - 1).unwrap_or(self.len)\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::MergedBreaks::<'a>::set_offset":["/// Sets the `self.offset` to the first valid break immediately at or preceding `offset`,\n/// and restores invariants.\nfn set_offset(&mut self, offset: usize){\n        self.text.set(offset);\n        self.soft.set(offset);\n        if offset > 0 {\n            if self.text.at_or_prev::<LinesMetric>().is_none() {\n                self.text.set(0);\n            }\n            if self.soft.at_or_prev::<BreaksMetric>().is_none() {\n                self.soft.set(0);\n            }\n        }\n\n        // self.offset should be at the first valid break immediately preceding `offset`, or 0.\n        // the position of the non-break cursor should be > than that of the break cursor, or EOF.\n        match self.text.pos().cmp(&self.soft.pos()) {\n            Ordering::Less => {\n                self.text.next::<LinesMetric>();\n            }\n            Ordering::Greater => {\n                self.soft.next::<BreaksMetric>();\n            }\n            Ordering::Equal => assert!(self.text.pos() == 0),\n        }\n\n        self.offset = self.text.pos().min(self.soft.pos());\n        self.cur_line = merged_line_of_offset(self.text.root(), self.soft.root(), self.offset);\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::PotentialBreak":["/// A potential opportunity to insert a break. In this representation, the widths\n/// have been requested (in a batch request) but are not necessarily known until\n/// the request is issued.\nstruct PotentialBreak {\n    /// The offset within the text of the end of the word.\n    pos: usize,\n    /// A token referencing the width of the word, to be resolved in the width cache.\n    tok: Token,\n    /// Whether the break is a hard break or a soft break.\n    hard: bool,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::RewrapCtx":["/// State for a rewrap in progress\nstruct RewrapCtx<'a> {\n    text: &'a Rope,\n    lb_cursor: LineBreakCursor<'a>,\n    lb_cursor_pos: usize,\n    width_cache: &'a mut WidthCache,\n    client: &'a dyn WidthMeasure,\n    pot_breaks: Vec<PotentialBreak>,\n    /// Index within `pot_breaks`\n    pot_break_ix: usize,\n    max_width: f64,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::RewrapCtx::<'a>::new":["fn new(\n        text: &'a Rope,\n        //_style_spans: &Spans<Style>,  client: &'a T,\n        client: &'a dyn WidthMeasure,\n        max_width: f64,\n        width_cache: &'a mut WidthCache,\n        start: usize,\n    ) -> RewrapCtx<'a>{\n        let lb_cursor_pos = start;\n        let lb_cursor = LineBreakCursor::new(text, start);\n        RewrapCtx {\n            text,\n            lb_cursor,\n            lb_cursor_pos,\n            width_cache,\n            client,\n            pot_breaks: Vec::new(),\n            pot_break_ix: 0,\n            max_width,\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::RewrapCtx::<'a>::refill_pot_breaks":["fn refill_pot_breaks(&mut self){\n        let mut req = self.width_cache.batch_req();\n\n        self.pot_breaks.clear();\n        self.pot_break_ix = 0;\n        let mut pos = self.lb_cursor_pos;\n        while pos < self.text.len() && self.pot_breaks.len() < MAX_POT_BREAKS {\n            let (next, hard) = self.lb_cursor.next();\n            let word = self.text.slice_to_cow(pos..next);\n            let tok = req.request(N_RESERVED_STYLES, &word);\n            pos = next;\n            self.pot_breaks.push(PotentialBreak { pos, tok, hard });\n        }\n        req.resolve_pending(self.client).unwrap();\n        self.lb_cursor_pos = pos;\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::RewrapCtx::<'a>::wrap_one_line":["/// Compute the next break, assuming `start` is a valid break.\n///\n/// Invariant: `start` corresponds to the start of the word referenced by `pot_break_ix`.\nfn wrap_one_line(&mut self, start: usize) -> Option<usize>{\n        let mut line_width = 0.0;\n        let mut pos = start;\n        while pos < self.text.len() {\n            if self.pot_break_ix >= self.pot_breaks.len() {\n                self.refill_pot_breaks();\n            }\n            let pot_break = &self.pot_breaks[self.pot_break_ix];\n            let width = self.width_cache.resolve(pot_break.tok);\n            if !pot_break.hard {\n                if line_width == 0.0 && width >= self.max_width {\n                    // we don't care about soft breaks at EOF\n                    if pot_break.pos == self.text.len() {\n                        return None;\n                    }\n                    self.pot_break_ix += 1;\n                    return Some(pot_break.pos);\n                }\n                line_width += width;\n                if line_width > self.max_width {\n                    return Some(pos);\n                }\n                self.pot_break_ix += 1;\n                pos = pot_break.pos;\n            } else if line_width != 0. && width + line_width > self.max_width {\n                // if this is a hard break but we would have broken at the previous\n                // pos otherwise, we still break at the previous pos.\n                return Some(pos);\n            } else {\n                self.pot_break_ix += 1;\n                return Some(pot_break.pos);\n            }\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::VisualLine":["pub(crate) struct VisualLine {\n    pub(crate) interval: Interval,\n    /// The logical line number for this line. Only present when this is the\n    /// first visual line in a logical line.\n    pub(crate) line_num: Option<usize>,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::VisualLine::new":["fn new<I: Into<Interval>, L: Into<Option<usize>>>(iv: I, line: L) -> Self{\n        VisualLine { interval: iv.into(), line_num: line.into() }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::VisualLines":["struct VisualLines<'a> {\n    cursor: MergedBreaks<'a>,\n    offset: usize,\n    /// The current logical line number.\n    logical_line: usize,\n    len: usize,\n    eof: bool,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::WrapSummary":["/// Detailed information about changes to linebreaks, used to generate\n/// invalidation information. The logic behind invalidation is different\n/// depending on whether we're updating breaks after an edit, or continuing\n/// a bulk rewrapping task. This is shared between the two cases, and contains\n/// the information relevant to both of them.\nstruct WrapSummary {\n    start_line: usize,\n    /// Total number of invalidated lines; this is meaningless in the after_edit case.\n    inval_count: usize,\n    /// The total number of new (hard + soft) breaks in the wrapped region.\n    new_count: usize,\n    /// The number of new soft breaks.\n    new_soft: usize,\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::WrapWidth":["/// The visual width of the buffer for the purpose of word wrapping.\npub(crate) enum WrapWidth {\n    /// No wrapping in effect.\n    None,\n\n    /// Width in bytes (utf-8 code units).\n    ///\n    /// Only works well for ASCII, will probably not be maintained long-term.\n    Bytes(usize),\n\n    /// Width in px units, requiring measurement by the front-end.\n    Width(f64),\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::WrapWidth::differs_in_kind":["fn differs_in_kind(self, other: WrapWidth) -> bool{\n        use self::WrapWidth::*;\n        match (self, other) {\n            (None, None) | (Bytes(_), Bytes(_)) | (Width(_), Width(_)) => false,\n            _else => true,\n        }\n    }","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"linewrap::merged_line_of_offset":["fn merged_line_of_offset(text: &Rope, soft: &Breaks, offset: usize) -> usize{\n    text.count::<LinesMetric>(offset) + soft.count::<BreaksMetric>(offset)\n}","Real(LocalPath(\"core-lib/src/linewrap.rs\"))"],"movement::Movement":["/// The specification of a movement.\npub enum Movement {\n    /// Move to the left by one grapheme cluster.\n    Left,\n    /// Move to the right by one grapheme cluster.\n    Right,\n    /// Move to the left by one word.\n    LeftWord,\n    /// Move to the right by one word.\n    RightWord,\n    /// Move to left end of visible line.\n    LeftOfLine,\n    /// Move to right end of visible line.\n    RightOfLine,\n    /// Move up one visible line.\n    Up,\n    /// Move down one visible line.\n    Down,\n    /// Move up one viewport height.\n    UpPage,\n    /// Move down one viewport height.\n    DownPage,\n    /// Move up to the next line that can preserve the cursor position.\n    UpExactPosition,\n    /// Move down to the next line that can preserve the cursor position.\n    DownExactPosition,\n    /// Move to the start of the text line.\n    StartOfParagraph,\n    /// Move to the end of the text line.\n    EndOfParagraph,\n    /// Move to the end of the text line, or next line if already at end.\n    EndOfParagraphKill,\n    /// Move to the start of the document.\n    StartOfDocument,\n    /// Move to the end of the document\n    EndOfDocument,\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::region_movement":["/// Compute the result of movement on one selection region.\n///\n/// # Arguments\n///\n/// * `height` - viewport height\npub fn region_movement(\n    m: Movement,\n    r: SelRegion,\n    lo: &dyn LineOffset,\n    height: usize,\n    text: &Rope,\n    modify: bool,\n) -> SelRegion{\n    let (offset, horiz) = match m {\n        Movement::Left => {\n            if r.is_caret() || modify {\n                if let Some(offset) = text.prev_grapheme_offset(r.end) {\n                    (offset, None)\n                } else {\n                    (0, r.horiz)\n                }\n            } else {\n                (r.min(), None)\n            }\n        }\n        Movement::Right => {\n            if r.is_caret() || modify {\n                if let Some(offset) = text.next_grapheme_offset(r.end) {\n                    (offset, None)\n                } else {\n                    (r.end, r.horiz)\n                }\n            } else {\n                (r.max(), None)\n            }\n        }\n        Movement::LeftWord => {\n            let mut word_cursor = WordCursor::new(text, r.end);\n            let offset = word_cursor.prev_boundary().unwrap_or(0);\n            (offset, None)\n        }\n        Movement::RightWord => {\n            let mut word_cursor = WordCursor::new(text, r.end);\n            let offset = word_cursor.next_boundary().unwrap_or_else(|| text.len());\n            (offset, None)\n        }\n        Movement::LeftOfLine => {\n            let line = lo.line_of_offset(text, r.end);\n            let offset = lo.offset_of_line(text, line);\n            (offset, None)\n        }\n        Movement::RightOfLine => {\n            let line = lo.line_of_offset(text, r.end);\n            let mut offset = text.len();\n\n            // calculate end of line\n            let next_line_offset = lo.offset_of_line(text, line + 1);\n            if line < lo.line_of_offset(text, offset) {\n                if let Some(prev) = text.prev_grapheme_offset(next_line_offset) {\n                    offset = prev;\n                }\n            }\n            (offset, None)\n        }\n        Movement::Up => vertical_motion(r, lo, text, -1, modify),\n        Movement::Down => vertical_motion(r, lo, text, 1, modify),\n        Movement::UpExactPosition => vertical_motion_exact_pos(r, lo, text, true, modify),\n        Movement::DownExactPosition => vertical_motion_exact_pos(r, lo, text, false, modify),\n        Movement::StartOfParagraph => {\n            // Note: TextEdit would start at modify ? r.end : r.min()\n            let mut cursor = Cursor::new(&text, r.end);\n            let offset = cursor.prev::<LinesMetric>().unwrap_or(0);\n            (offset, None)\n        }\n        Movement::EndOfParagraph => {\n            // Note: TextEdit would start at modify ? r.end : r.max()\n            let mut offset = r.end;\n            let mut cursor = Cursor::new(&text, offset);\n            if let Some(next_para_offset) = cursor.next::<LinesMetric>() {\n                if cursor.is_boundary::<LinesMetric>() {\n                    if let Some(eol) = text.prev_grapheme_offset(next_para_offset) {\n                        offset = eol;\n                    }\n                } else if cursor.pos() == text.len() {\n                    offset = text.len();\n                }\n                (offset, None)\n            } else {\n                //in this case we are already on a last line so just moving to EOL\n                (text.len(), None)\n            }\n        }\n        Movement::EndOfParagraphKill => {\n            // Note: TextEdit would start at modify ? r.end : r.max()\n            let mut offset = r.end;\n            let mut cursor = Cursor::new(&text, offset);\n            if let Some(next_para_offset) = cursor.next::<LinesMetric>() {\n                offset = next_para_offset;\n                if cursor.is_boundary::<LinesMetric>() {\n                    if let Some(eol) = text.prev_grapheme_offset(next_para_offset) {\n                        if eol != r.end {\n                            offset = eol;\n                        }\n                    }\n                }\n            }\n            (offset, None)\n        }\n        Movement::UpPage => vertical_motion(r, lo, text, -scroll_height(height), modify),\n        Movement::DownPage => vertical_motion(r, lo, text, scroll_height(height), modify),\n        Movement::StartOfDocument => (0, None),\n        Movement::EndOfDocument => (text.len(), None),\n    };\n    SelRegion::new(if modify { r.start } else { offset }, offset).with_horiz(horiz)\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::scroll_height":["/// Computes the actual desired amount of scrolling (generally slightly\n/// less than the height of the viewport, to allow overlap).\nfn scroll_height(height: usize) -> isize{\n    max(height as isize - SCROLL_OVERLAP, 1)\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::selection_movement":["/// Compute a new selection by applying a movement to an existing selection.\n///\n/// In a multi-region selection, this function applies the movement to each\n/// region in the selection, and returns the union of the results.\n///\n/// If `modify` is `true`, the selections are modified, otherwise the results\n/// of individual region movements become carets.\n///\n/// # Arguments\n///\n/// * `height` - viewport height\npub fn selection_movement(\n    m: Movement,\n    s: &Selection,\n    lo: &dyn LineOffset,\n    height: usize,\n    text: &Rope,\n    modify: bool,\n) -> Selection{\n    let mut result = Selection::new();\n    for &r in s.iter() {\n        let new_region = region_movement(m, r, lo, height, text, modify);\n        result.add_region(new_region);\n    }\n    result\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::selection_position":["/// Based on the current selection position this will return the cursor position, the current line, and the\n/// total number of lines of the file.\nfn selection_position(\n    r: SelRegion,\n    lo: &dyn LineOffset,\n    text: &Rope,\n    move_up: bool,\n    modify: bool,\n) -> (HorizPos, usize){\n    // The active point of the selection\n    let active = if modify {\n        r.end\n    } else if move_up {\n        r.min()\n    } else {\n        r.max()\n    };\n    let col = if let Some(col) = r.horiz { col } else { lo.offset_to_line_col(text, active).1 };\n    let line = lo.line_of_offset(text, active);\n\n    (col, line)\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::vertical_motion":["/// Compute movement based on vertical motion by the given number of lines.\n///\n/// Note: in non-exceptional cases, this function preserves the `horiz`\n/// field of the selection region.\nfn vertical_motion(\n    r: SelRegion,\n    lo: &dyn LineOffset,\n    text: &Rope,\n    line_delta: isize,\n    modify: bool,\n) -> (usize, Option<HorizPos>){\n    let (col, line) = selection_position(r, lo, text, line_delta < 0, modify);\n    let n_lines = lo.line_of_offset(text, text.len());\n\n    // This code is quite careful to avoid integer overflow.\n    // TODO: write tests to verify\n    if line_delta < 0 && (-line_delta as usize) > line {\n        return (0, Some(col));\n    }\n    let line = if line_delta < 0 {\n        line - (-line_delta as usize)\n    } else {\n        line.saturating_add(line_delta as usize)\n    };\n    if line > n_lines {\n        return (text.len(), Some(col));\n    }\n    let new_offset = lo.line_col_to_offset(text, line, col);\n    (new_offset, Some(col))\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"movement::vertical_motion_exact_pos":["/// Compute movement based on vertical motion by the given number of lines skipping\n/// any line that is shorter than the current cursor position.\nfn vertical_motion_exact_pos(\n    r: SelRegion,\n    lo: &dyn LineOffset,\n    text: &Rope,\n    move_up: bool,\n    modify: bool,\n) -> (usize, Option<HorizPos>){\n    let (col, init_line) = selection_position(r, lo, text, move_up, modify);\n    let n_lines = lo.line_of_offset(text, text.len());\n\n    let mut line_length =\n        lo.offset_of_line(text, init_line.saturating_add(1)) - lo.offset_of_line(text, init_line);\n    if move_up && init_line == 0 {\n        return (lo.line_col_to_offset(text, init_line, col), Some(col));\n    }\n    let mut line = if move_up { init_line - 1 } else { init_line.saturating_add(1) };\n\n    // If the active columns is longer than the current line, use the current line length.\n    let col = if line_length < col { line_length - 1 } else { col };\n\n    loop {\n        line_length = lo.offset_of_line(text, line + 1) - lo.offset_of_line(text, line);\n\n        // If the line is longer than the current cursor position, break.\n        // We use > instead of >= because line_length includes newline.\n        if line_length > col {\n            break;\n        }\n\n        // If you are trying to add a selection past the end of the file or before the first line, return original selection\n        if line >= n_lines || (line == 0 && move_up) {\n            line = init_line;\n            break;\n        }\n\n        line = if move_up { line - 1 } else { line.saturating_add(1) };\n    }\n\n    (lo.line_col_to_offset(text, line, col), Some(col))\n}","Real(LocalPath(\"core-lib/src/movement.rs\"))"],"plugins::Plugin":["pub struct Plugin {\n    peer: RpcPeer,\n    pub(crate) id: PluginId,\n    pub(crate) name: String,\n    #[allow(dead_code)]\n    process: Child,\n}","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::close_view":["pub fn close_view(&self, view_id: ViewId){\n        self.peer.send_rpc_notification(\"did_close\", &json!({ \"view_id\": view_id }))\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::collect_trace":["pub fn collect_trace(&self) -> Result<Value, xi_rpc::Error>{\n        self.peer.send_rpc_request(\"collect_trace\", &json!({}))\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::config_changed":["pub fn config_changed(&self, view_id: ViewId, changes: &Table){\n        self.peer.send_rpc_notification(\n            \"config_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"changes\": changes,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::did_save":["pub fn did_save(&self, view_id: ViewId, path: &Path){\n        self.peer.send_rpc_notification(\n            \"did_save\",\n            &json!({\n                \"view_id\": view_id,\n                \"path\": path,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::dispatch_command":["pub fn dispatch_command(&self, view_id: ViewId, method: &str, params: &Value){\n        self.peer.send_rpc_notification(\n            \"custom_command\",\n            &json!({\n                \"view_id\": view_id,\n                \"method\": method,\n                \"params\": params,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::get_hover":["pub fn get_hover(&self, view_id: ViewId, request_id: usize, position: usize){\n        self.peer.send_rpc_notification(\n            \"get_hover\",\n            &json!({\n                \"view_id\": view_id,\n                \"request_id\": request_id,\n                \"position\": position,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::initialize":["pub fn initialize(&self, info: Vec<PluginBufferInfo>){\n        self.peer.send_rpc_notification(\n            \"initialize\",\n            &json!({\n                \"plugin_id\": self.id,\n                \"buffer_info\": info,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::language_changed":["pub fn language_changed(&self, view_id: ViewId, new_lang: &LanguageId){\n        self.peer.send_rpc_notification(\n            \"language_changed\",\n            &json!({\n                \"view_id\": view_id,\n                \"new_lang\": new_lang,\n            }),\n        )\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::new_buffer":["pub fn new_buffer(&self, info: &PluginBufferInfo){\n        self.peer.send_rpc_notification(\"new_buffer\", &json!({ \"buffer_info\": [info] }))\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::shutdown":["pub fn shutdown(&self){\n        self.peer.send_rpc_notification(\"shutdown\", &json!({}));\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::toggle_tracing":["pub fn toggle_tracing(&self, enabled: bool){\n        self.peer.send_rpc_notification(\"tracing_config\", &json!({ \"enabled\": enabled }))\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::Plugin::update":["pub fn update<F>(&self, update: &PluginUpdate, callback: F)\n    where\n        F: FnOnce(Result<Value, xi_rpc::Error>) + Send + 'static,{\n        self.peer.send_rpc_request_async(\"update\", &json!(update), Box::new(callback))\n    }","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::PluginPid":["/// A process-unique identifier for a running plugin.\n///\n/// Note: two instances of the same executable will have different identifiers.\n/// Note: this identifier is distinct from the OS's process id.\npub struct PluginPid(pub(crate) usize);","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"plugins::catalog::PluginCatalog":["/// A catalog of all available plugins.\npub struct PluginCatalog {\n    items: HashMap<PluginName, Arc<PluginDescription>>,\n    locations: HashMap<PathBuf, Arc<PluginDescription>>,\n}","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::get_from_path":["/// Returns the plugin located at the provided file path.\npub fn get_from_path(&self, path: &PathBuf) -> Option<Arc<PluginDescription>>{\n        self.items\n            .values()\n            .find(|&v| v.exec_path.to_str().unwrap().contains(path.to_str().unwrap()))\n            .cloned()\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::get_named":["/// Returns a reference to the named plugin if it exists in the catalog.\npub fn get_named(&self, plugin_name: &str) -> Option<Arc<PluginDescription>>{\n        self.items.get(plugin_name).map(Arc::clone)\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::iter":["/// Returns an iterator over all plugins in the catalog, in arbitrary order.\npub fn iter(&'a self) -> impl Iterator<Item = Arc<PluginDescription>> + 'a{\n        self.items.values().cloned()\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::iter_names":["/// Returns an iterator over all plugin names in the catalog,\n/// in arbitrary order.\npub fn iter_names(&'a self) -> impl Iterator<Item = &'a PluginName>{\n        self.items.keys()\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::load_from_paths":["/// Loads plugins from paths and adds them to existing plugins.\npub fn load_from_paths(&mut self, paths: &[PathBuf]){\n        let all_manifests = find_all_manifests(paths);\n        for manifest_path in &all_manifests {\n            match load_manifest(manifest_path) {\n                Err(e) => warn!(\"error loading plugin {:?}\", e),\n                Ok(manifest) => {\n                    info!(\"loaded {}\", manifest.name);\n                    let manifest = Arc::new(manifest);\n                    self.items.insert(manifest.name.clone(), manifest.clone());\n                    self.locations.insert(manifest_path.clone(), manifest);\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::make_languages_map":["pub fn make_languages_map(&self) -> Languages{\n        let all_langs =\n            self.items.values().flat_map(|plug| plug.languages.iter().cloned()).collect::<Vec<_>>();\n        Languages::new(all_langs.as_slice())\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::reload_from_paths":["/// Loads any plugins discovered in these paths, replacing any existing\n/// plugins.\npub fn reload_from_paths(&mut self, paths: &[PathBuf]){\n        self.items.clear();\n        self.locations.clear();\n        self.load_from_paths(paths);\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginCatalog::remove_named":["/// Removes the named plugin.\npub fn remove_named(&mut self, plugin_name: &str){\n        self.items.remove(plugin_name);\n    }","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::PluginLoadError":["/// Errors that can occur while trying to load a plugin.\npub enum PluginLoadError {\n    Io(io::Error),\n    /// Malformed manifest\n    Parse(toml::de::Error),\n}","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::find_all_manifests":["fn find_all_manifests(paths: &[PathBuf]) -> Vec<PathBuf>{\n    let mut manifest_paths = Vec::new();\n    for path in paths.iter() {\n        let manif_path = path.join(\"manifest.toml\");\n        if manif_path.exists() {\n            manifest_paths.push(manif_path);\n            continue;\n        }\n\n        let result = path.read_dir().map(|dir| {\n            dir.flat_map(|item| item.map(|p| p.path()).ok())\n                .map(|dir| dir.join(\"manifest.toml\"))\n                .filter(|f| f.exists())\n                .for_each(|f| manifest_paths.push(f))\n        });\n        if let Err(e) = result {\n            error!(\"error reading plugin path {:?}, {:?}\", path, e);\n        }\n    }\n    manifest_paths\n}","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::catalog::load_manifest":["fn load_manifest(path: &Path) -> Result<PluginDescription, PluginLoadError>{\n    let mut file = fs::File::open(&path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    let mut manifest: PluginDescription = toml::from_str(&contents)?;\n    // normalize relative paths\n    if manifest.exec_path.starts_with(\"./\") {\n        manifest.exec_path = path.parent().unwrap().join(manifest.exec_path).canonicalize()?;\n    }\n\n    for lang in &mut manifest.languages {\n        let lang_config_path =\n            path.parent().unwrap().join(&lang.name.as_ref()).with_extension(\"toml\");\n        if !lang_config_path.exists() {\n            continue;\n        }\n        let lang_defaults = fs::read_to_string(&lang_config_path)?;\n        let lang_defaults = table_from_toml_str(&lang_defaults)?;\n        lang.default_config = Some(lang_defaults);\n    }\n    Ok(manifest)\n}","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))"],"plugins::manifest::ArgumentOption":["/// Represents an option for a user-selectable argument.\npub struct ArgumentOption {\n    pub title: String,\n    pub value: Value,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::ArgumentOption::new":["pub fn new<S: AsRef<str>, V: Serialize>(title: S, value: V) -> Self{\n        let title = title.as_ref().to_owned();\n        let value = serde_json::to_value(value).unwrap();\n        ArgumentOption { title, value }\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::ArgumentType":["pub enum ArgumentType {\n    Number,\n    Int,\n    PosInt,\n    Bool,\n    String,\n    Choice,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::Command":["/// Represents a custom command provided by a plugin.\npub struct Command {\n    /// Human readable title, for display in (for example) a menu.\n    pub title: String,\n    /// A short description of the command.\n    pub description: String,\n    /// Template of the command RPC as it should be sent to the plugin.\n    pub rpc_cmd: PlaceholderRpc,\n    /// A list of `CommandArgument`s, which the client should use to build the RPC.\n    pub args: Vec<CommandArgument>,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::Command::new":["pub fn new<S, V>(title: S, description: S, rpc_cmd: PlaceholderRpc, args: V) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Vec<CommandArgument>>>,{\n        let title = title.as_ref().to_owned();\n        let description = description.as_ref().to_owned();\n        let args = args.into().unwrap_or_else(Vec::new);\n        Command { title, description, rpc_cmd, args }\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::CommandArgument":["/// A user provided argument to a plugin command.\npub struct CommandArgument {\n    /// A human readable name for this argument, for use as placeholder\n    /// text or equivelant.\n    pub title: String,\n    /// A short (single sentence) description of this argument's use.\n    pub description: String,\n    pub key: String,\n    pub arg_type: ArgumentType,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    /// If `arg_type` is `Choice`, `options` must contain a list of options.\n    pub options: Option<Vec<ArgumentOption>>,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::CommandArgument::new":["pub fn new<S: AsRef<str>>(\n        title: S,\n        description: S,\n        key: S,\n        arg_type: ArgumentType,\n        options: Option<Vec<ArgumentOption>>,\n    ) -> Self{\n        let key = key.as_ref().to_owned();\n        let title = title.as_ref().to_owned();\n        let description = description.as_ref().to_owned();\n        if arg_type == ArgumentType::Choice {\n            assert!(options.is_some())\n        }\n        CommandArgument { title, description, key, arg_type, options }\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc":["#[serde(rename_all = \"snake_case\")]\n/// A placeholder type which can represent a generic RPC.\n///\n/// This is the type used for custom plugin commands, which may have arbitrary\n/// method names and parameters.\npub struct PlaceholderRpc {\n    pub method: String,\n    pub params: Value,\n    pub rpc_type: RpcType,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc::is_request":["pub fn is_request(&self) -> bool{\n        self.rpc_type == RpcType::Request\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc::method_ref":["/// Returns a reference to the placeholder's method.\npub fn method_ref(&self) -> &str{\n        &self.method\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc::new":["pub fn new<S, V>(method: S, params: V, request: bool) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Value>>,{\n        let method = method.as_ref().to_owned();\n        let params = params.into().unwrap_or(json!({}));\n        let rpc_type = if request { RpcType::Request } else { RpcType::Notification };\n\n        PlaceholderRpc { method, params, rpc_type }\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc::params_ref":["/// Returns a reference to the placeholder's params.\npub fn params_ref(&self) -> &Value{\n        &self.params\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PlaceholderRpc::params_ref_mut":["/// Returns a mutable reference to the placeholder's params.\npub fn params_ref_mut(&mut self) -> &mut Value{\n        &mut self.params\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PluginActivation":["/// `PluginActivation`s represent events that trigger running a plugin.\n#[serde(rename_all = \"snake_case\")]\npub enum PluginActivation {\n    /// Always run this plugin, when available.\n    Autorun,\n    /// Run this plugin if the provided SyntaxDefinition is active.\n    #[allow(dead_code)]\n    OnSyntax(LanguageId),\n    /// Run this plugin in response to a given command.\n    #[allow(dead_code)]\n    OnCommand,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PluginDescription":["/// Describes attributes and capabilities of a plugin.\n///\n/// Note: - these will eventually be loaded from manifest files.\n#[serde(rename_all = \"snake_case\")]\npub struct PluginDescription {\n    pub name: String,\n    pub version: String,\n    #[serde(default)]\n    pub scope: PluginScope,\n    // more metadata ...\n    /// path to plugin executable\n    #[serde(deserialize_with = \"platform_exec_path\")]\n    pub exec_path: PathBuf,\n    /// Events that cause this plugin to run\n    #[serde(default)]\n    pub activations: Vec<PluginActivation>,\n    #[serde(default)]\n    pub commands: Vec<Command>,\n    #[serde(default)]\n    pub languages: Vec<LanguageDefinition>,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PluginDescription::is_global":["/// Returns `true` if this plugin is globally scoped, else `false`.\npub fn is_global(&self) -> bool{\n        matches!(self.scope, PluginScope::Global)\n    }","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::PluginScope":["/// Describes the scope of events a plugin receives.\n#[serde(rename_all = \"snake_case\")]\npub enum PluginScope {\n    /// The plugin receives events from multiple buffers.\n    Global,\n    /// The plugin receives events for a single buffer.\n    BufferLocal,\n    /// The plugin is launched in response to a command, and receives no\n    /// further updates.\n    SingleInvocation,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::RpcType":["#[serde(rename_all = \"snake_case\")]\npub enum RpcType {\n    Notification,\n    Request,\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::manifest::platform_exec_path":["fn platform_exec_path<'de, D: Deserializer<'de>>(deserializer: D) -> Result<PathBuf, D::Error>{\n    let exec_path = PathBuf::deserialize(deserializer)?;\n    if cfg!(windows) {\n        Ok(exec_path.with_extension(\"exe\"))\n    } else {\n        Ok(exec_path)\n    }\n}","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))"],"plugins::rpc::ClientPluginInfo":["/// Describes an available plugin to the client.\npub struct ClientPluginInfo {\n    pub name: String,\n    pub running: bool,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::DataSpan":["pub struct DataSpan {\n    pub start: usize,\n    pub end: usize,\n    pub data: Value,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::EmptyStruct":["pub struct EmptyStruct {}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::GetDataResponse":["/// The object returned by the `get_data` RPC.\npub struct GetDataResponse {\n    pub chunk: String,\n    pub offset: usize,\n    pub first_line: usize,\n    pub first_line_offset: usize,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::HostNotification":["#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\n/// RPC Notifications sent from the host\npub enum HostNotification {\n    Ping(EmptyStruct),\n    Initialize { plugin_id: PluginPid, buffer_info: Vec<PluginBufferInfo> },\n    DidSave { view_id: ViewId, path: PathBuf },\n    ConfigChanged { view_id: ViewId, changes: Table },\n    NewBuffer { buffer_info: Vec<PluginBufferInfo> },\n    DidClose { view_id: ViewId },\n    GetHover { view_id: ViewId, request_id: usize, position: usize },\n    Shutdown(EmptyStruct),\n    TracingConfig { enabled: bool },\n    LanguageChanged { view_id: ViewId, new_lang: LanguageId },\n    CustomCommand { view_id: ViewId, method: String, params: Value },\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::HostRequest":["#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\n/// RPC requests sent from the host\npub enum HostRequest {\n    Update(PluginUpdate),\n    CollectTrace(EmptyStruct),\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::Hover":["/// Hover Item sent from Plugin to Core\n#[serde(rename_all = \"snake_case\")]\npub struct Hover {\n    pub content: String,\n    pub range: Option<Range>,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginBufferInfo":["/// Buffer information sent on plugin init.\npub struct PluginBufferInfo {\n    /// The buffer's unique identifier.\n    pub buffer_id: BufferIdentifier,\n    /// The buffer's current views.\n    pub views: Vec<ViewId>,\n    pub rev: u64,\n    pub buf_size: usize,\n    pub nb_lines: usize,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub path: Option<String>,\n    pub syntax: LanguageId,\n    pub config: Table,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginBufferInfo::new":["pub fn new(\n        buffer_id: BufferIdentifier,\n        views: &[ViewId],\n        rev: u64,\n        buf_size: usize,\n        nb_lines: usize,\n        path: Option<PathBuf>,\n        syntax: LanguageId,\n        config: Table,\n    ) -> Self{\n        //TODO: do make any current assertions about paths being valid utf-8? do we want to?\n        let path = path.map(|p| p.to_str().unwrap().to_owned());\n        let views = views.to_owned();\n        PluginBufferInfo { buffer_id, views, rev, buf_size, nb_lines, path, syntax, config }\n    }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginCommand":["/// Common wrapper for plugin-originating RPCs.\npub struct PluginCommand<T> {\n    pub view_id: ViewId,\n    pub plugin_id: PluginPid,\n    pub cmd: T,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginEdit":["/// A simple edit, received from a plugin.\npub struct PluginEdit {\n    pub rev: u64,\n    pub delta: RopeDelta,\n    /// the edit priority determines the resolution strategy when merging\n    /// concurrent edits. The highest priority edit will be applied last.\n    pub priority: u64,\n    /// whether the inserted text prefers to be to the right of the cursor.\n    pub after_cursor: bool,\n    /// the originator of this edit: some identifier (plugin name, 'core', etc)\n    /// undo_group associated with this edit\n    pub undo_group: Option<usize>,\n    pub author: String,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginNotification":["#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\n/// RPC commands sent from plugins.\npub enum PluginNotification {\n    AddScopes {\n        scopes: Vec<Vec<String>>,\n    },\n    UpdateSpans {\n        start: usize,\n        len: usize,\n        spans: Vec<ScopeSpan>,\n        rev: u64,\n    },\n    Edit {\n        edit: PluginEdit,\n    },\n    Alert {\n        msg: String,\n    },\n    AddStatusItem {\n        key: String,\n        value: String,\n        alignment: String,\n    },\n    UpdateStatusItem {\n        key: String,\n        value: String,\n    },\n    RemoveStatusItem {\n        key: String,\n    },\n    ShowHover {\n        request_id: usize,\n        result: Result<Hover, RemoteError>,\n    },\n    UpdateAnnotations {\n        start: usize,\n        len: usize,\n        spans: Vec<DataSpan>,\n        annotation_type: AnnotationType,\n        rev: u64,\n    },\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginRequest":["#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\n/// RPC requests sent from plugins.\npub enum PluginRequest {\n    GetData { start: usize, unit: TextUnit, max_size: usize, rev: u64 },\n    LineCount,\n    GetSelections,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginUpdate":["/// A simple update, sent to a plugin.\npub struct PluginUpdate {\n    pub view_id: ViewId,\n    /// The delta representing changes to the document.\n    ///\n    /// Note: Is `Some` in the general case; only if the delta involves\n    /// inserting more than some maximum number of bytes, will this be `None`,\n    /// indicating the plugin should flush cache and fetch manually.\n    pub delta: Option<RopeDelta>,\n    /// The size of the document after applying this delta.\n    pub new_len: usize,\n    /// The total number of lines in the document after applying this delta.\n    pub new_line_count: usize,\n    pub rev: u64,\n    /// The undo_group associated with this update. The plugin may pass\n    /// this value back to core when making an edit, to associate the\n    /// plugin's edit with this undo group. Core uses undo_group\n    //  to undo actions occurred due to plugins after a user action\n    // in a single step.\n    pub undo_group: Option<usize>,\n    pub edit_type: String,\n    pub author: String,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::PluginUpdate::new":["pub fn new<D>(\n        view_id: ViewId,\n        rev: u64,\n        delta: D,\n        new_len: usize,\n        new_line_count: usize,\n        undo_group: Option<usize>,\n        edit_type: String,\n        author: String,\n    ) -> Self\n    where\n        D: Into<Option<RopeDelta>>,{\n        let delta = delta.into();\n        PluginUpdate { view_id, delta, new_len, new_line_count, rev, undo_group, edit_type, author }\n    }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::Range":["/// Range expressed in terms of PluginPosition. Meant to be sent from\n/// plugin to core.\n#[serde(rename_all = \"snake_case\")]\npub struct Range {\n    pub start: usize,\n    pub end: usize,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::ScopeSpan":["pub struct ScopeSpan {\n    pub start: usize,\n    pub end: usize,\n    pub scope_id: u32,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::TextUnit":["/// The unit of measure when requesting data.\n#[serde(rename_all = \"snake_case\")]\npub enum TextUnit {\n    /// The requested offset is in bytes. The returned chunk will be valid\n    /// UTF8, and is guaranteed to include the byte specified the offset.\n    Utf8,\n    /// The requested offset is a line number. The returned chunk will begin\n    /// at the offset of the requested line.\n    Line,\n}","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::TextUnit::resolve_offset":["/// Converts an offset in some unit to a concrete byte offset. Returns\n/// `None` if the input offset is out of bounds in its unit space.\npub fn resolve_offset<T: Borrow<Rope>>(self, text: T, offset: usize) -> Option<usize>{\n        let text = text.borrow();\n        match self {\n            TextUnit::Utf8 => {\n                if offset > text.len() {\n                    None\n                } else {\n                    text.at_or_prev_codepoint_boundary(offset)\n                }\n            }\n            TextUnit::Line => {\n                let max_line_number = text.measure::<LinesMetric>() + 1;\n                if offset > max_line_number {\n                    None\n                } else {\n                    text.offset_of_line(offset).into()\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))"],"plugins::start_plugin_process":["pub(crate) fn start_plugin_process(\n    plugin_desc: Arc<PluginDescription>,\n    id: PluginId,\n    core: WeakXiCore,\n){\n    let spawn_result = thread::Builder::new()\n        .name(format!(\"<{}> core host thread\", &plugin_desc.name))\n        .spawn(move || {\n            info!(\"starting plugin {}\", &plugin_desc.name);\n            let child = ProcCommand::new(&plugin_desc.exec_path)\n                .stdin(Stdio::piped())\n                .stdout(Stdio::piped())\n                .spawn();\n\n            match child {\n                Ok(mut child) => {\n                    let child_stdin = child.stdin.take().unwrap();\n                    let child_stdout = child.stdout.take().unwrap();\n                    let mut looper = RpcLoop::new(child_stdin);\n                    let peer: RpcPeer = Box::new(looper.get_raw_peer());\n                    let name = plugin_desc.name.clone();\n                    peer.send_rpc_notification(\"ping\", &Value::Array(Vec::new()));\n                    let plugin = Plugin { peer, process: child, name, id };\n\n                    // set tracing immediately\n                    if xi_trace::is_enabled() {\n                        plugin.toggle_tracing(true);\n                    }\n\n                    core.plugin_connect(Ok(plugin));\n                    let mut core = core;\n                    let err = looper.mainloop(|| BufReader::new(child_stdout), &mut core);\n                    core.plugin_exit(id, err);\n                }\n                Err(err) => core.plugin_connect(Err(err)),\n            }\n        });\n\n    if let Err(err) = spawn_result {\n        error!(\"thread spawn failed for {}, {:?}\", id, err);\n    }\n}","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))"],"recorder::Recorder":["/// A container that manages and holds all recordings for the current editing session\npub(crate) struct Recorder {\n    active_recording: Option<String>,\n    recording_buffer: Vec<EventDomain>,\n    recordings: HashMap<String, Recording>,\n}","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::clear":["/// Completely removes the specified recording from the Recorder\npub(crate) fn clear(&mut self, recording_name: &str){\n        self.recordings.remove(recording_name);\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::is_recording":["pub(crate) fn is_recording(&self) -> bool{\n        self.active_recording.is_some()\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::new":["pub(crate) fn new() -> Recorder{\n        Recorder {\n            active_recording: None,\n            recording_buffer: Vec::new(),\n            recordings: HashMap::new(),\n        }\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::play":["/// Iterates over a specified recording's buffer and runs the specified action\n/// on each event.\npub(crate) fn play<F>(&self, recording_name: &str, action: F)\n    where\n        F: FnMut(&EventDomain),{\n        let is_current_recording: bool = self\n            .active_recording\n            .as_ref()\n            .map_or(false, |current_recording| current_recording == recording_name);\n\n        if is_current_recording {\n            warn!(\"Cannot play recording while it's currently active!\");\n            return;\n        }\n\n        if let Some(recording) = self.recordings.get(recording_name) {\n            recording.play(action);\n        }\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::record":["/// Saves an event into the currently active recording.\n///\n/// Every sequential `BufferEvent::Insert` event will be merged together to cut down the number of\n/// `Editor::commit_delta` calls we need to make when playing back.\npub(crate) fn record(&mut self, current_event: EventDomain){\n        assert!(self.is_recording());\n\n        let recording_buffer = &mut self.recording_buffer;\n\n        if recording_buffer.last().is_none() {\n            recording_buffer.push(current_event);\n            return;\n        }\n\n        {\n            let last_event = recording_buffer.last_mut().unwrap();\n            if let (\n                EventDomain::Buffer(BufferEvent::Insert(old_characters)),\n                EventDomain::Buffer(BufferEvent::Insert(new_characters)),\n            ) = (last_event, &current_event)\n            {\n                old_characters.push_str(new_characters);\n                return;\n            }\n        }\n\n        recording_buffer.push(current_event);\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::save_recording_buffer":["/// Cleans the recording buffer by filtering out any undo or redo events and then saving it\n/// with the specified name.\n///\n/// A recording should not store any undos or redos--\n/// call this once a recording is 'finalized.'\nfn save_recording_buffer(&mut self, recording_name: String){\n        let mut saw_undo = false;\n        let mut saw_redo = false;\n\n        // Walk the recording backwards and remove any undo / redo events\n        let filtered: Vec<EventDomain> = self\n            .recording_buffer\n            .clone()\n            .into_iter()\n            .rev()\n            .filter(|event| {\n                if let EventDomain::Buffer(event) = event {\n                    return match event {\n                        BufferEvent::Undo => {\n                            saw_undo = !saw_redo;\n                            saw_redo = false;\n                            false\n                        }\n                        BufferEvent::Redo => {\n                            saw_redo = !saw_undo;\n                            saw_undo = false;\n                            false\n                        }\n                        _ => {\n                            let ret = !saw_undo;\n                            saw_undo = false;\n                            saw_redo = false;\n                            ret\n                        }\n                    };\n                }\n\n                true\n            })\n            .collect::<Vec<EventDomain>>()\n            .into_iter()\n            .rev()\n            .collect();\n\n        let current_recording = Recording::new(filtered);\n        self.recordings.insert(recording_name, current_recording);\n        self.recording_buffer.clear();\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recorder::toggle_recording":["/// Starts or stops the specified recording.\n///\n///\n/// There are three outcome behaviors:\n/// - If the current recording name is specified, the active recording is saved\n/// - If no recording name is specified, the currently active recording is saved\n/// - If a recording name other than the active recording is specified,\n/// the current recording will be thrown out and will be switched to the new name\n///\n/// In addition to the above:\n/// - If the recording was saved, there is no active recording\n/// - If the recording was switched, there will be a new active recording\npub(crate) fn toggle_recording(&mut self, recording_name: Option<String>){\n        let is_recording = self.is_recording();\n        let last_recording = self.active_recording.take();\n\n        match (is_recording, &last_recording, &recording_name) {\n            (true, Some(last_recording), None) => {\n                self.save_recording_buffer(last_recording.clone())\n            }\n            (true, Some(last_recording), Some(recording_name)) => {\n                if last_recording != recording_name {\n                    self.recording_buffer.clear();\n                } else {\n                    self.save_recording_buffer(last_recording.clone());\n                    return;\n                }\n            }\n            _ => {}\n        }\n\n        self.active_recording = recording_name;\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recording":["struct Recording {\n    events: Vec<EventDomain>,\n}","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recording::new":["fn new(events: Vec<EventDomain>) -> Recording{\n        Recording { events }\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"recorder::Recording::play":["/// Iterates over the recording buffer and runs the specified action\n/// on each event.\nfn play<F>(&self, action: F)\n    where\n        F: FnMut(&EventDomain),{\n        let _guard = trace_block(\"Recording::play\", &[\"core\", \"recording\"]);\n        self.events.iter().for_each(action)\n    }","Real(LocalPath(\"core-lib/src/recorder.rs\"))"],"rpc::CoreNotification":["/// The notifications which make up the base of the protocol.\n///\n/// # Note\n///\n/// For serialization, all identifiers are converted to \"snake_case\".\n///\n/// # Examples\n///\n/// The `close_view` command:\n///\n/// ```\n/// # extern crate xi_core_lib as xi_core;\n/// extern crate serde_json;\n/// use crate::xi_core::rpc::CoreNotification;\n///\n/// let json = r#\"{\n///     \"method\": \"close_view\",\n///     \"params\": { \"view_id\": \"view-id-1\" }\n///     }\"#;\n///\n/// let cmd: CoreNotification = serde_json::from_str(&json).unwrap();\n/// match cmd {\n///     CoreNotification::CloseView { .. } => (), // expected\n///     other => panic!(\"Unexpected variant\"),\n/// }\n/// ```\n///\n/// The `client_started` command:\n///\n/// ```\n/// # extern crate xi_core_lib as xi_core;\n/// extern crate serde_json;\n/// use crate::xi_core::rpc::CoreNotification;\n///\n/// let json = r#\"{\n///     \"method\": \"client_started\",\n///     \"params\": {}\n///     }\"#;\n///\n/// let cmd: CoreNotification = serde_json::from_str(&json).unwrap();\n/// match cmd {\n///     CoreNotification::ClientStarted { .. }  => (), // expected\n///     other => panic!(\"Unexpected variant\"),\n/// }\n/// ```\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\npub enum CoreNotification {\n    /// The 'edit' namespace, for view-specific editor actions.\n    ///\n    /// The params object has internal `method` and `params` members,\n    /// which are parsed into the appropriate `EditNotification`.\n    ///\n    /// # Note:\n    ///\n    /// All edit commands (notifications and requests) include in their\n    /// inner params object a `view_id` field. On the xi-core side, we\n    /// pull out this value during parsing, and use it for routing.\n    ///\n    /// For more on the edit commands, see [`EditNotification`] and\n    /// [`EditRequest`].\n    ///\n    /// [`EditNotification`]: enum.EditNotification.html\n    /// [`EditRequest`]: enum.EditRequest.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate xi_core_lib as xi_core;\n    /// #[macro_use]\n    /// extern crate serde_json;\n    /// use crate::xi_core::rpc::*;\n    /// # fn main() {\n    /// let edit = EditCommand {\n    ///     view_id: 1.into(),\n    ///     cmd: EditNotification::Insert { chars: \"hello!\".into() },\n    /// };\n    /// let rpc = CoreNotification::Edit(edit);\n    /// let expected = json!({\n    ///     \"method\": \"edit\",\n    ///     \"params\": {\n    ///         \"method\": \"insert\",\n    ///         \"view_id\": \"view-id-1\",\n    ///         \"params\": {\n    ///             \"chars\": \"hello!\",\n    ///         }\n    ///     }\n    /// });\n    /// assert_eq!(serde_json::to_value(&rpc).unwrap(), expected);\n    /// # }\n    /// ```\n    Edit(EditCommand<EditNotification>),\n    /// The 'plugin' namespace, for interacting with plugins.\n    ///\n    /// As with edit commands, the params object has is a nested RPC,\n    /// with the name of the command included as the `command` field.\n    ///\n    /// (this should be changed to more accurately reflect the behaviour\n    /// of the edit commands).\n    ///\n    /// For the available commands, see [`PluginNotification`].\n    ///\n    /// [`PluginNotification`]: enum.PluginNotification.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate xi_core_lib as xi_core;\n    /// #[macro_use]\n    /// extern crate serde_json;\n    /// use crate::xi_core::rpc::*;\n    /// # fn main() {\n    /// let rpc = CoreNotification::Plugin(\n    ///     PluginNotification::Start {\n    ///         view_id: 1.into(),\n    ///         plugin_name: \"syntect\".into(),\n    ///     });\n    ///\n    /// let expected = json!({\n    ///     \"method\": \"plugin\",\n    ///     \"params\": {\n    ///         \"command\": \"start\",\n    ///         \"view_id\": \"view-id-1\",\n    ///         \"plugin_name\": \"syntect\",\n    ///     }\n    /// });\n    /// assert_eq!(serde_json::to_value(&rpc).unwrap(), expected);\n    /// # }\n    /// ```\n    Plugin(PluginNotification),\n    /// Tells `xi-core` to close the specified view.\n    CloseView { view_id: ViewId },\n    /// Tells `xi-core` to save the contents of the specified view's\n    /// buffer to the specified path.\n    Save { view_id: ViewId, file_path: String },\n    /// Tells `xi-core` to set the theme.\n    SetTheme { theme_name: String },\n    /// Notifies `xi-core` that the client has started.\n    ClientStarted {\n        #[serde(default)]\n        config_dir: Option<PathBuf>,\n        /// Path to additional plugins, included by the client.\n        #[serde(default)]\n        client_extras_dir: Option<PathBuf>,\n    },\n    /// Updates the user's config for the given domain. Where keys in\n    /// `changes` are `null`, those keys are cleared in the user config\n    /// for that domain; otherwise the config is updated with the new\n    /// value.\n    ///\n    /// Note: If the client is using file-based config, the only valid\n    /// domain argument is `ConfigDomain::UserOverride(_)`, which\n    /// represents non-persistent view-specific settings, such as when\n    /// a user manually changes whitespace settings for a given view.\n    ModifyUserConfig { domain: ConfigDomainExternal, changes: Table },\n    /// Control whether the tracing infrastructure is enabled.\n    /// This propagates to all peers that should respond by toggling its own\n    /// infrastructure on/off.\n    TracingConfig { enabled: bool },\n    /// Save trace data to the given path.  The core will first send\n    /// CoreRequest::CollectTrace to all peers to collect the samples.\n    SaveTrace { destination: PathBuf, frontend_samples: Value },\n    /// Tells `xi-core` to set the language id for the view.\n    SetLanguage { view_id: ViewId, language_id: LanguageId },\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::CoreRequest":["/// The requests which make up the base of the protocol.\n///\n/// All requests expect a response.\n///\n/// # Examples\n///\n/// The `new_view` command:\n///\n/// ```\n/// # extern crate xi_core_lib as xi_core;\n/// extern crate serde_json;\n/// use crate::xi_core::rpc::CoreRequest;\n///\n/// let json = r#\"{\n///     \"method\": \"new_view\",\n///     \"params\": { \"file_path\": \"~/my_very_fun_file.rs\" }\n///     }\"#;\n///\n/// let cmd: CoreRequest = serde_json::from_str(&json).unwrap();\n/// match cmd {\n///     CoreRequest::NewView { .. } => (), // expected\n///     other => panic!(\"Unexpected variant {:?}\", other),\n/// }\n/// ```\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\npub enum CoreRequest {\n    /// The 'edit' namespace, for view-specific requests.\n    Edit(EditCommand<EditRequest>),\n    /// Tells `xi-core` to create a new view. If the `file_path`\n    /// argument is present, `xi-core` should attempt to open the file\n    /// at that location.\n    ///\n    /// Returns the view identifier that should be used to interact\n    /// with the newly created view.\n    NewView { file_path: Option<String> },\n    /// Returns the current collated config object for the given view.\n    GetConfig { view_id: ViewId },\n    /// Returns the contents of the buffer for a given `ViewId`.\n    /// In the future this might also be used to return structured data (such\n    /// as for printing).\n    DebugGetContents { view_id: ViewId },\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::EditCommand":["/// A helper type, which extracts the `view_id` field from edit\n/// requests and notifications.\n///\n/// Edit requests and notifications have 'method', 'params', and\n/// 'view_id' param members. We use this wrapper, which has custom\n/// `Deserialize` and `Serialize` implementations, to pull out the\n/// `view_id` field.\n///\n/// # Examples\n///\n/// ```\n/// # extern crate xi_core_lib as xi_core;\n/// extern crate serde_json;\n/// use crate::xi_core::rpc::*;\n///\n/// let json = r#\"{\n///     \"view_id\": \"view-id-1\",\n///     \"method\": \"scroll\",\n///     \"params\": [0, 6]\n///     }\"#;\n///\n/// let cmd: EditCommand<EditNotification> = serde_json::from_str(&json).unwrap();\n/// match cmd.cmd {\n///     EditNotification::Scroll( .. ) => (), // expected\n///     other => panic!(\"Unexpected variant {:?}\", other),\n/// }\n/// ```\npub struct EditCommand<T> {\n    pub view_id: ViewId,\n    pub cmd: T,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::EditNotification":["/// The edit-related notifications.\n///\n/// Alongside the [`EditRequest`] members, these commands constitute\n/// the API for interacting with a particular window and document.\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\npub enum EditNotification {\n    Insert {\n        chars: String,\n    },\n    Paste {\n        chars: String,\n    },\n    DeleteForward,\n    DeleteBackward,\n    DeleteWordForward,\n    DeleteWordBackward,\n    DeleteToEndOfParagraph,\n    DeleteToBeginningOfLine,\n    InsertNewline,\n    InsertTab,\n    MoveUp,\n    MoveUpAndModifySelection,\n    MoveDown,\n    MoveDownAndModifySelection,\n    MoveLeft,\n    // synoynm for `MoveLeft`\n    MoveBackward,\n    MoveLeftAndModifySelection,\n    MoveRight,\n    // synoynm for `MoveRight`\n    MoveForward,\n    MoveRightAndModifySelection,\n    MoveWordLeft,\n    MoveWordLeftAndModifySelection,\n    MoveWordRight,\n    MoveWordRightAndModifySelection,\n    MoveToBeginningOfParagraph,\n    MoveToBeginningOfParagraphAndModifySelection,\n    MoveToEndOfParagraph,\n    MoveToEndOfParagraphAndModifySelection,\n    MoveToLeftEndOfLine,\n    MoveToLeftEndOfLineAndModifySelection,\n    MoveToRightEndOfLine,\n    MoveToRightEndOfLineAndModifySelection,\n    MoveToBeginningOfDocument,\n    MoveToBeginningOfDocumentAndModifySelection,\n    MoveToEndOfDocument,\n    MoveToEndOfDocumentAndModifySelection,\n    ScrollPageUp,\n    PageUpAndModifySelection,\n    ScrollPageDown,\n    PageDownAndModifySelection,\n    SelectAll,\n    AddSelectionAbove,\n    AddSelectionBelow,\n    Scroll(LineRange),\n    Resize(Size),\n    GotoLine {\n        line: u64,\n    },\n    RequestLines(LineRange),\n    Yank,\n    Transpose,\n    Click(MouseAction),\n    Drag(MouseAction),\n    Gesture {\n        line: u64,\n        col: u64,\n        ty: GestureType,\n    },\n    Undo,\n    Redo,\n    Find {\n        chars: String,\n        case_sensitive: bool,\n        #[serde(default)]\n        regex: bool,\n        #[serde(default)]\n        whole_words: bool,\n    },\n    MultiFind {\n        queries: Vec<FindQuery>,\n    },\n    FindNext {\n        #[serde(default)]\n        wrap_around: bool,\n        #[serde(default)]\n        allow_same: bool,\n        #[serde(default)]\n        modify_selection: SelectionModifier,\n    },\n    FindPrevious {\n        #[serde(default)]\n        wrap_around: bool,\n        #[serde(default)]\n        allow_same: bool,\n        #[serde(default)]\n        modify_selection: SelectionModifier,\n    },\n    FindAll,\n    DebugRewrap,\n    DebugWrapWidth,\n    /// Prints the style spans present in the active selection.\n    DebugPrintSpans,\n    DebugToggleComment,\n    Uppercase,\n    Lowercase,\n    Capitalize,\n    Reindent,\n    Indent,\n    Outdent,\n    /// Indicates whether find highlights should be rendered\n    HighlightFind {\n        visible: bool,\n    },\n    SelectionForFind {\n        #[serde(default)]\n        case_sensitive: bool,\n    },\n    Replace {\n        chars: String,\n        #[serde(default)]\n        preserve_case: bool,\n    },\n    ReplaceNext,\n    ReplaceAll,\n    SelectionForReplace,\n    RequestHover {\n        request_id: usize,\n        position: Option<Position>,\n    },\n    SelectionIntoLines,\n    DuplicateLine,\n    IncreaseNumber,\n    DecreaseNumber,\n    ToggleRecording {\n        recording_name: Option<String>,\n    },\n    PlayRecording {\n        recording_name: String,\n    },\n    ClearRecording {\n        recording_name: String,\n    },\n    CollapseSelections,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::EditRequest":["/// The edit related requests.\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"method\", content = \"params\")]\npub enum EditRequest {\n    /// Cuts the active selection, returning their contents,\n    /// or `Null` if the selection was empty.\n    Cut,\n    /// Copies the active selection, returning their contents or\n    /// or `Null` if the selection was empty.\n    Copy,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::EmptyStruct":["#[doc(hidden)]\npub struct EmptyStruct {}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::FindQuery":["#[serde(rename_all = \"snake_case\")]\npub struct FindQuery {\n    pub id: Option<usize>,\n    pub chars: String,\n    pub case_sensitive: bool,\n    #[serde(default)]\n    pub regex: bool,\n    #[serde(default)]\n    pub whole_words: bool,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::GestureType":["/// An enum representing touch and mouse gestures applied to the text.\n#[serde(rename_all = \"snake_case\")]\npub enum GestureType {\n    Select { granularity: SelectionGranularity, multi: bool },\n    SelectExtend { granularity: SelectionGranularity },\n    Drag,\n\n    // Deprecated\n    PointSelect,\n    ToggleSel,\n    RangeSelect,\n    LineSelect,\n    WordSelect,\n    MultiLineSelect,\n    MultiWordSelect,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::LineRange":["/// An inclusive range.\n///\n/// # Note:\n///\n/// Several core protocol commands use a params array to pass arguments\n/// which are named, internally. this type use custom Serialize /\n/// Deserialize impls to accommodate this.\npub struct LineRange {\n    pub first: i64,\n    pub last: i64,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::MouseAction":["/// A mouse event. See the note for [`LineRange`].\n///\n/// [`LineRange`]: enum.LineRange.html\npub struct MouseAction {\n    pub line: u64,\n    pub column: u64,\n    pub flags: u64,\n    pub click_count: Option<u64>,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::PluginNotification":["/// The plugin related notifications.\n#[serde(tag = \"command\")]\n#[serde(rename_all = \"snake_case\")]\npub enum PluginNotification {\n    Start { view_id: ViewId, plugin_name: String },\n    Stop { view_id: ViewId, plugin_name: String },\n    PluginRpc { view_id: ViewId, receiver: String, rpc: PlaceholderRpc },\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::Position":["pub struct Position {\n    pub line: usize,\n    pub column: usize,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::SelectionGranularity":["/// The smallest unit of text that a gesture can select\n#[serde(rename_all = \"snake_case\")]\npub enum SelectionGranularity {\n    /// Selects any point or character range\n    Point,\n    /// Selects one word at a time\n    Word,\n    /// Selects one line at a time\n    Line,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::SelectionModifier":["/// Represents how the current selection is modified (used by find\n/// operations).\n#[serde(rename_all = \"snake_case\")]\npub enum SelectionModifier {\n    None,\n    Set,\n    Add,\n    AddRemovingCurrent,\n}","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged":["Serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))"],"selection::<impl std::convert::From<&'a selection::SelRegion> for xi_rope::Interval>::from":["fn from(src: &'a SelRegion) -> Interval{\n        Interval::new(src.min(), src.max())\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Affinity":["/// The \"affinity\" of a cursor which is sitting exactly on a line break.\n///\n/// We say \"cursor\" here rather than \"caret\" because (depending on presentation)\n/// the front-end may draw a cursor even when the region is not a caret.\npub enum Affinity {\n    /// The cursor should be displayed downstream of the line break. For\n    /// example, if the buffer is \"abcd\", and the cursor is on a line break\n    /// after \"ab\", it should be displayed on the second line before \"cd\".\n    Downstream,\n    /// The cursor should be displayed upstream of the line break. For\n    /// example, if the buffer is \"abcd\", and the cursor is on a line break\n    /// after \"ab\", it should be displayed on the previous line after \"ab\".\n    Upstream,\n}","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::InsertDrift":["/// Indicates if an edit should try to drift inside or outside nearby selections. If the selection\n/// is zero width, that is, it is a caret, this value will be ignored, the equivalent of the\n/// `Default` value.\npub enum InsertDrift {\n    /// Indicates this edit should happen within any (non-caret) selections if possible.\n    Inside,\n    /// Indicates this edit should happen outside any selections if possible.\n    Outside,\n    /// Indicates to do whatever the `after` bool says to do\n    Default,\n}","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion":["/// A type representing a single contiguous region of a selection. We use the\n/// term \"caret\" (sometimes also \"cursor\", more loosely) to refer to a selection\n/// region with an empty interior. A \"non-caret region\" is one with a non-empty\n/// interior (i.e. `start != end`).\npub struct SelRegion {\n    /// The inactive edge of a selection, as a byte offset. When\n    /// equal to end, the selection range acts as a caret.\n    pub start: usize,\n\n    /// The active edge of a selection, as a byte offset.\n    pub end: usize,\n\n    /// A saved horizontal position (used primarily for line up/down movement).\n    pub horiz: Option<HorizPos>,\n\n    /// The affinity of the cursor.\n    pub affinity: Affinity,\n}","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::caret":["/// Returns a new caret region (`start == end`).\npub fn caret(pos: usize) -> Self{\n        Self { start: pos, end: pos, horiz: None, affinity: Affinity::default() }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::is_caret":["/// Determines whether the region is a caret (ie has an empty interior).\npub fn is_caret(self) -> bool{\n        self.start == self.end\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::is_upstream":["/// Determines whether the region's affinity is upstream.\npub fn is_upstream(self) -> bool{\n        self.affinity == Affinity::Upstream\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::max":["/// Gets the latest offset within the region, ie the maximum of both edges.\npub fn max(self) -> usize{\n        max(self.start, self.end)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::merge_with":["fn merge_with(self, other: SelRegion) -> SelRegion{\n        let is_forward = self.end >= self.start;\n        let new_min = min(self.min(), other.min());\n        let new_max = max(self.max(), other.max());\n        let (start, end) = if is_forward { (new_min, new_max) } else { (new_max, new_min) };\n        // Could try to preserve horiz/affinity from one of the\n        // sources, but very likely not worth it.\n        SelRegion::new(start, end)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::min":["/// Gets the earliest offset within the region, ie the minimum of both edges.\npub fn min(self) -> usize{\n        min(self.start, self.end)\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::new":["/// Returns a new region.\npub fn new(start: usize, end: usize) -> Self{\n        Self { start, end, horiz: None, affinity: Affinity::default() }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::should_merge":["fn should_merge(self, other: SelRegion) -> bool{\n        other.min() < self.max()\n            || ((self.is_caret() || other.is_caret()) && other.min() == self.max())\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::with_affinity":["/// Returns a region with the given affinity.\npub fn with_affinity(self, affinity: Affinity) -> Self{\n        Self { affinity, ..self }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::SelRegion::with_horiz":["/// Returns a region with the given horizontal position.\npub fn with_horiz(self, horiz: Option<HorizPos>) -> Self{\n        Self { horiz, ..self }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection":["/// A set of zero or more selection regions, representing a selection state.\npub struct Selection {\n    // An invariant: regions[i].max() <= regions[i+1].min()\n    // and < if either is_caret()\n    regions: Vec<SelRegion>,\n}","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::add_range_distinct":["/// Add a region to the selection. This method does not merge regions and does not allow\n/// ambiguous regions (regions that overlap).\n///\n/// On ambiguous regions, the region with the lower start position wins. That is, in such a\n/// case, the new region is either not added at all, because there is an ambiguous region with\n/// a lower start position, or existing regions that intersect with the new region but do\n/// not start before the new region, are deleted.\npub fn add_range_distinct(&mut self, region: SelRegion) -> (usize, usize){\n        let mut ix = self.search(region.min());\n\n        if ix < self.regions.len() && self.regions[ix].max() == region.min() {\n            ix += 1;\n        }\n\n        if ix < self.regions.len() {\n            // in case of ambiguous regions the region closer to the left wins\n            let occ = &self.regions[ix];\n            let is_eq = occ.min() == region.min() && occ.max() == region.max();\n            let is_intersect_before = region.min() >= occ.min() && occ.max() > region.min();\n            if is_eq || is_intersect_before {\n                return (occ.min(), occ.max());\n            }\n        }\n\n        // delete ambiguous regions to the right\n        let mut last = self.search(region.max());\n        if last < self.regions.len() && self.regions[last].min() < region.max() {\n            last += 1;\n        }\n        remove_n_at(&mut self.regions, ix, last - ix);\n\n        if ix == self.regions.len() {\n            self.regions.push(region);\n        } else {\n            self.regions.insert(ix, region);\n        }\n\n        (self.regions[ix].min(), self.regions[ix].max())\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::add_region":["/// Add a region to the selection. This method implements merging logic.\n///\n/// Two non-caret regions merge if their interiors intersect; merely\n/// touching at the edges does not cause a merge. A caret merges with\n/// a non-caret if it is in the interior or on either edge. Two carets\n/// merge if they are the same offset.\n///\n/// Performance note: should be O(1) if the new region strictly comes\n/// after all the others in the selection, otherwise O(n).\npub fn add_region(&mut self, region: SelRegion){\n        let mut ix = self.search(region.min());\n        if ix == self.regions.len() {\n            self.regions.push(region);\n            return;\n        }\n        let mut region = region;\n        let mut end_ix = ix;\n        if self.regions[ix].min() <= region.min() {\n            if self.regions[ix].should_merge(region) {\n                region = region.merge_with(self.regions[ix]);\n            } else {\n                ix += 1;\n            }\n            end_ix += 1;\n        }\n        while end_ix < self.regions.len() && region.should_merge(self.regions[end_ix]) {\n            region = region.merge_with(self.regions[end_ix]);\n            end_ix += 1;\n        }\n        if ix == end_ix {\n            self.regions.insert(ix, region);\n        } else {\n            self.regions[ix] = region;\n            remove_n_at(&mut self.regions, ix + 1, end_ix - ix - 1);\n        }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::apply_delta":["/// Computes a new selection based on applying a delta to the old selection.\n///\n/// When new text is inserted at a caret, the new caret can be either before\n/// or after the inserted text, depending on the `after` parameter.\n///\n/// Whether or not the preceding selections are restored depends on the keep_selections\n/// value (only set to true on transpose).\npub fn apply_delta(&self, delta: &RopeDelta, after: bool, drift: InsertDrift) -> Selection{\n        let mut result = Selection::new();\n        let mut transformer = Transformer::new(delta);\n        for region in self.iter() {\n            let is_caret = region.start == region.end;\n            let is_region_forward = region.start < region.end;\n\n            let (start_after, end_after) = match (drift, is_caret) {\n                (InsertDrift::Inside, false) => (!is_region_forward, is_region_forward),\n                (InsertDrift::Outside, false) => (is_region_forward, !is_region_forward),\n                _ => (after, after),\n            };\n\n            let new_region = SelRegion::new(\n                transformer.transform(region.start, start_after),\n                transformer.transform(region.end, end_after),\n            )\n            .with_affinity(region.affinity);\n            result.add_region(new_region);\n        }\n        result\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::clear":["/// Clear the selection.\npub fn clear(&mut self){\n        self.regions.clear();\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::collapse":["/// Collapse all selections into a single caret.\npub fn collapse(&mut self){\n        self.regions.truncate(1);\n        self.regions[0].start = self.regions[0].end;\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::delete_range":["/// Deletes all the regions that intersect or (if delete_adjacent = true) touch the given range.\npub fn delete_range(&mut self, start: usize, end: usize, delete_adjacent: bool){\n        let mut first = self.search(start);\n        let mut last = self.search(end);\n        if first >= self.regions.len() {\n            return;\n        }\n        if !delete_adjacent && self.regions[first].max() == start {\n            first += 1;\n        }\n        if last < self.regions.len()\n            && ((delete_adjacent && self.regions[last].min() <= end)\n                || (!delete_adjacent && self.regions[last].min() < end))\n        {\n            last += 1;\n        }\n        remove_n_at(&mut self.regions, first, last - first);\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::new":["/// Creates a new empty selection.\npub fn new() -> Selection{\n        Selection::default()\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::new_simple":["/// Creates a selection with a single region.\npub fn new_simple(region: SelRegion) -> Selection{\n        Selection { regions: vec![region] }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::regions_in_range":["/// Gets a slice of regions that intersect the given range. Regions that\n/// merely touch the range at the edges are also included, so it is the\n/// caller's responsibility to further trim them, in particular to only\n/// display one caret in the upstream/downstream cases.\n///\n/// Performance note: O(log n).\npub fn regions_in_range(&self, start: usize, end: usize) -> &[SelRegion]{\n        let first = self.search(start);\n        let mut last = self.search(end);\n        if last < self.regions.len() && self.regions[last].min() <= end {\n            last += 1;\n        }\n        &self.regions[first..last]\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"selection::Selection::search":["pub fn search(&self, offset: usize) -> usize{\n        if self.regions.is_empty() || offset > self.regions.last().unwrap().max() {\n            return self.regions.len();\n        }\n        match self.regions.binary_search_by(|r| r.max().cmp(&offset)) {\n            Ok(ix) => ix,\n            Err(ix) => ix,\n        }\n    }","Real(LocalPath(\"core-lib/src/selection.rs\"))"],"styles::Style":["/// A mergeable style. All values except priority are optional.\n///\n/// Note: A `None` value represents the absense of preference; in the case of\n/// boolean options, `Some(false)` means that this style will override a lower\n/// priority value in the same field.\npub struct Style {\n    /// The priority of this style, in the range (0, 1000). Used to resolve\n    /// conflicting fields when merging styles. The higher priority wins.\n    #[serde(skip_serializing)]\n    pub priority: u16,\n    /// The foreground text color, in ARGB.\n    pub fg_color: Option<u32>,\n    /// The background text color, in ARGB.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub bg_color: Option<u32>,\n    /// The font-weight, in the range 100-900, interpreted like the CSS\n    /// font-weight property.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub weight: Option<u16>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub underline: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub italic: Option<bool>,\n}","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::default_for_theme":["/// Returns the default style for the given `Theme`.\npub fn default_for_theme(theme: &Theme) -> Self{\n        let fg = theme.settings.foreground.unwrap_or(Color::BLACK);\n        Style::new(\n            SYNTAX_PRIORITY_LOWEST,\n            Some(Self::rgba_from_syntect_color(fg)),\n            None,\n            None,\n            None,\n            None,\n        )\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::from_syntect_style_mod":["/// Creates a new `Style` by converting from a `Syntect::StyleModifier`.\npub fn from_syntect_style_mod(style: &SynStyleModifier) -> Self{\n        let font_style = style.font_style.map(|s| s.bits()).unwrap_or_default();\n        let weight = if (font_style & 1) != 0 { Some(700) } else { None };\n        let underline = if (font_style & 2) != 0 { Some(true) } else { None };\n        let italic = if (font_style & 4) != 0 { Some(true) } else { None };\n\n        Self::new(\n            SYNTAX_PRIORITY_DEFAULT,\n            style.foreground.map(Self::rgba_from_syntect_color),\n            style.background.map(Self::rgba_from_syntect_color),\n            weight,\n            underline,\n            italic,\n        )\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::merge":["/// Creates a new style by combining attributes of `self` and `other`.\n/// If both styles define an attribute, the highest priority wins; `other`\n/// wins in the case of a tie.\n///\n/// Note: when merging multiple styles, apply them in increasing priority.\npub fn merge(&self, other: &Style) -> Style{\n        let (p1, p2) = if self.priority > other.priority { (self, other) } else { (other, self) };\n\n        Style::new(\n            p1.priority,\n            p1.fg_color.or(p2.fg_color),\n            p1.bg_color.or(p2.bg_color),\n            p1.weight.or(p2.weight),\n            p1.underline.or(p2.underline),\n            p1.italic.or(p2.italic),\n        )\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::new":["pub fn new<O32, O16, OB>(\n        priority: u16,\n        fg_color: O32,\n        bg_color: O32,\n        weight: O16,\n        underline: OB,\n        italic: OB,\n    ) -> Self\n    where\n        O32: Into<Option<u32>>,\n        O16: Into<Option<u16>>,\n        OB: Into<Option<bool>>,{\n        assert!(priority <= 1000);\n        Style {\n            priority,\n            fg_color: fg_color.into(),\n            bg_color: bg_color.into(),\n            weight: weight.into(),\n            underline: underline.into(),\n            italic: italic.into(),\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::rgba_from_syntect_color":["fn rgba_from_syntect_color(color: Color) -> u32{\n        let Color { r, g, b, a } = color;\n        ((a as u32) << 24) | ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::Style::to_json":["/// Encode this `Style`, setting the `id` property.\n///\n/// Note: this should only be used when sending the `def_style` RPC.\npub fn to_json(&self, id: usize) -> Value{\n        let mut as_val = serde_json::to_value(self).expect(\"failed to encode style\");\n        as_val[\"id\"] = id.into();\n        as_val\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap":["/// A map from styles to client identifiers for a given `Theme`.\npub struct ThemeStyleMap {\n    themes: ThemeSet,\n    theme_name: String,\n    theme: Theme,\n\n    // Keeps a list of default themes.\n    default_themes: Vec<String>,\n    default_style: Style,\n    map: HashMap<Style, usize>,\n\n    // Maintains the map of found themes and their paths.\n    path_map: BTreeMap<String, PathBuf>,\n\n    // It's not obvious we actually have to store the style, we seem to only need it\n    // as the key in the map.\n    styles: Vec<Style>,\n    themes_dir: Option<PathBuf>,\n    cache_dir: Option<PathBuf>,\n    caching_enabled: bool,\n}","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::add":["pub fn add(&mut self, style: &Style) -> usize{\n        let result = self.styles.len() + N_RESERVED_STYLES;\n        self.map.insert(style.clone(), result);\n        self.styles.push(style.clone());\n        result\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::contains_theme":["pub fn contains_theme(&self, k: &str) -> bool{\n        self.themes.themes.contains_key(k)\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_default_style":["pub fn get_default_style(&self) -> &Style{\n        &self.default_style\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_dump_path":["/// Returns dump's path corresponding to the given theme name.\nfn get_dump_path(&self, theme_name: &str) -> Option<PathBuf>{\n        self.cache_dir.as_ref().map(|p| p.join(theme_name).with_extension(\"tmdump\"))\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_highlighter":["pub fn get_highlighter(&self) -> Highlighter{\n        Highlighter::new(&self.theme)\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_theme_name":["pub fn get_theme_name(&self) -> &str{\n        &self.theme_name\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_theme_names":["pub fn get_theme_names(&self) -> Vec<String>{\n        self.path_map.keys().chain(self.default_themes.iter()).cloned().collect()\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::get_theme_settings":["pub fn get_theme_settings(&self) -> &ThemeSettings{\n        &self.theme.settings\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::init_cache_dir":["/// Creates the cache dir returns true\n/// if it is successfully initialized or\n/// already exists.\nfn init_cache_dir(&mut self) -> bool{\n        self.cache_dir = self.themes_dir.clone().map(|p| p.join(\"cache\"));\n\n        if let Some(ref p) = self.cache_dir {\n            if p.exists() {\n                return true;\n            }\n            fs::DirBuilder::new().create(&p).is_ok()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::insert_to_map":["fn insert_to_map(&mut self, k: String, v: Theme){\n        self.themes.themes.insert(k, v);\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::load_theme":["/// Loads theme using syntect's `get_theme` fn to our `theme` path map.\n/// Stores binary dump in a file with `tmdump` extension, only if\n/// caching is enabled.\nfn load_theme(&mut self, theme_name: &str) -> Result<(), LoadingError>{\n        // If it is the current theme (the user has edited it), we load it again.\n        // Otherwise, if it's a default theme or the theme has already been loaded, we can move on.\n        if self.contains_theme(theme_name) && self.get_theme_name() != theme_name {\n            return Ok(());\n        }\n        // If we haven't loaded the theme before, we try to load it from the dump if a dump\n        // exists or load it from the theme file itself.\n        let theme_p = &self.path_map.get(theme_name).cloned();\n        if let Some(theme_p) = theme_p {\n            match self.try_load_from_dump(theme_p) {\n                Some((dump_theme_name, dump_theme_data)) => {\n                    self.insert_to_map(dump_theme_name, dump_theme_data);\n                }\n                None => {\n                    let theme = ThemeSet::get_theme(theme_p)?;\n                    if self.caching_enabled {\n                        if let Some(dump_p) = self.get_dump_path(theme_name) {\n                            let _ = dump_to_file(&theme, dump_p);\n                        }\n                    }\n                    self.insert_to_map(theme_name.to_owned(), theme);\n                }\n            }\n            Ok(())\n        } else {\n            Err(LoadingError::BadPath)\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::load_theme_dir":["/// Cache all themes names and their paths inside the given directory.\npub(crate) fn load_theme_dir(&mut self){\n        if let Some(themes_dir) = self.themes_dir.clone() {\n            match ThemeSet::discover_theme_paths(themes_dir) {\n                Ok(themes) => {\n                    self.caching_enabled = self.caching_enabled && self.init_cache_dir();\n                    // We look through the theme folder here and cache their names/paths to a\n                    // path hashmap.\n                    for theme_p in &themes {\n                        match self.load_theme_info_from_path(theme_p) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"Encountered error {:?} loading theme at {:?}\", e, theme_p)\n                            }\n                        }\n                    }\n                }\n                Err(e) => error!(\"Error loading themes dir: {:?}\", e),\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::load_theme_info_from_path":["/// Loads a theme's name and its respective path into the theme path map.\npub(crate) fn load_theme_info_from_path(\n        &mut self,\n        theme_p: &Path,\n    ) -> Result<String, LoadingError>{\n        validate_theme_file(theme_p)?;\n        let theme_name =\n            theme_p.file_stem().and_then(OsStr::to_str).ok_or(LoadingError::BadPath)?;\n\n        self.path_map.insert(theme_name.to_string(), theme_p.to_path_buf());\n\n        Ok(theme_name.to_owned())\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::lookup":["pub fn lookup(&self, style: &Style) -> Option<usize>{\n        self.map.get(style).cloned()\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::merge_with_default":["pub fn merge_with_default(&self, style: &Style) -> Style{\n        self.default_style.merge(style)\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::new":["pub fn new(themes_dir: Option<PathBuf>) -> ThemeStyleMap{\n        let themes = ThemeSet::load_defaults();\n        let theme_name = DEFAULT_THEME.to_owned();\n        let theme = themes.themes.get(&theme_name).expect(\"missing theme\").to_owned();\n        let default_themes = themes.themes.keys().cloned().collect();\n        let default_style = Style::default_for_theme(&theme);\n        let cache_dir = None;\n        let caching_enabled = true;\n\n        ThemeStyleMap {\n            themes,\n            theme_name,\n            theme,\n            default_themes,\n            default_style,\n            map: HashMap::new(),\n            path_map: BTreeMap::new(),\n            styles: Vec::new(),\n            themes_dir,\n            cache_dir,\n            caching_enabled,\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::remove_theme":["/// Delete key and the corresponding dump file from the themes map.\npub(crate) fn remove_theme(&mut self, path: &Path) -> Option<String>{\n        validate_theme_file(path).ok()?;\n\n        let theme_name = path.file_stem().and_then(OsStr::to_str)?;\n        self.themes.themes.remove(theme_name);\n        self.path_map.remove(theme_name);\n\n        let dump_p = self.get_dump_path(theme_name)?;\n        if dump_p.exists() {\n            let _ = fs::remove_file(dump_p);\n        }\n\n        Some(theme_name.to_string())\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::set_theme":["pub fn set_theme(&mut self, theme_name: &str) -> Result<(), &'static str>{\n        match self.load_theme(theme_name) {\n            Ok(()) => {\n                if let Some(new_theme) = self.themes.themes.get(theme_name) {\n                    self.theme = new_theme.to_owned();\n                    self.theme_name = theme_name.to_owned();\n                    self.default_style = Style::default_for_theme(&self.theme);\n                    self.map = HashMap::new();\n                    self.styles = Vec::new();\n                    Ok(())\n                } else {\n                    Err(\"unknown theme\")\n                }\n            }\n            Err(e) => {\n                error!(\"Encountered error {:?} while trying to load {:?}\", e, theme_name);\n                Err(\"could not load theme\")\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::sync_dir":["/// Compare the stored file paths in `self.state`\n/// to the present ones.\npub(crate) fn sync_dir(&mut self, dir: Option<&Path>){\n        if let Some(themes_dir) = dir {\n            if let Ok(paths) = ThemeSet::discover_theme_paths(themes_dir) {\n                let current_state: HashSet<PathBuf> = HashSet::from_iter(paths.into_iter());\n                let maintained_state: HashSet<PathBuf> =\n                    HashSet::from_iter(self.path_map.values().cloned());\n\n                let to_insert = current_state.difference(&maintained_state);\n                for path in to_insert {\n                    let _ = self.load_theme_info_from_path(path);\n                }\n                let to_remove = maintained_state.difference(&current_state);\n                for path in to_remove {\n                    self.remove_theme(path);\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::ThemeStyleMap::try_load_from_dump":["/// A wrapper around `from_dump_file`\n/// to validate the state of dump file.\n/// Invalidates if mod time of dump is less\n/// than the original one.\nfn try_load_from_dump(&self, theme_p: &Path) -> Option<(String, Theme)>{\n        if !self.caching_enabled {\n            return None;\n        }\n\n        let theme_name = theme_p.file_stem().and_then(OsStr::to_str)?;\n\n        let dump_p = self.get_dump_path(theme_name)?;\n\n        if !&dump_p.exists() {\n            return None;\n        }\n\n        //NOTE: `try_load_from_dump` will return `None` if the file at\n        //`dump_p` or `theme_p` is deleted before the execution of this fn.\n        let mod_t = fs::metadata(&dump_p).and_then(|md| md.modified()).ok()?;\n        let mod_t_orig = fs::metadata(theme_p).and_then(|md| md.modified()).ok()?;\n\n        if mod_t >= mod_t_orig {\n            from_dump_file(&dump_p).ok().map(|t| (theme_name.to_owned(), t))\n        } else {\n            // Delete dump file\n            let _ = fs::remove_file(&dump_p);\n            None\n        }\n    }","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"styles::validate_theme_file":["/// Used to remove files with extension other than `tmTheme`.\nfn validate_theme_file(path: &Path) -> Result<bool, LoadingError>{\n    path.extension().map(|e| e != \"tmTheme\").ok_or(LoadingError::BadPath)\n}","Real(LocalPath(\"core-lib/src/styles.rs\"))"],"syntax::LanguageDefinition":["/// Describes a `LanguageDefinition`. Although these are provided by plugins,\n/// they are a fundamental concept in core, used to determine things like\n/// plugin activations and active user config tables.\npub struct LanguageDefinition {\n    pub name: LanguageId,\n    pub extensions: Vec<String>,\n    pub first_line_match: Option<String>,\n    pub scope: String,\n    #[serde(skip)]\n    pub default_config: Option<Table>,\n}","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::LanguageId":["/// The canonical identifier for a particular `LanguageDefinition`.\n#[allow(clippy::rc_buffer)]\npub struct LanguageId(Arc<String>);","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages":["/// A repository of all loaded `LanguageDefinition`s.\npub struct Languages {\n    // NOTE: BTreeMap is used for sorting the languages by name alphabetically\n    named: BTreeMap<LanguageId, Arc<LanguageDefinition>>,\n    extensions: HashMap<String, Arc<LanguageDefinition>>,\n}","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages::difference":["/// Returns a Vec of any `LanguageDefinition`s which exist\n/// in `self` but not `other`.\npub fn difference(&self, other: &Languages) -> Vec<Arc<LanguageDefinition>>{\n        self.named\n            .iter()\n            .filter(|(k, _)| !other.named.contains_key(*k))\n            .map(|(_, v)| v.clone())\n            .collect()\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages::iter":["pub fn iter(&self) -> impl Iterator<Item = &Arc<LanguageDefinition>>{\n        self.named.values()\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages::language_for_name":["pub fn language_for_name<S>(&self, name: S) -> Option<Arc<LanguageDefinition>>\n    where\n        S: AsRef<str>,{\n        self.named.get(name.as_ref()).map(Arc::clone)\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages::language_for_path":["pub fn language_for_path(&self, path: &Path) -> Option<Arc<LanguageDefinition>>{\n        path.extension()\n            .or_else(|| path.file_name())\n            .and_then(|ext| self.extensions.get(ext.to_str().unwrap_or_default()))\n            .map(Arc::clone)\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::Languages::new":["pub fn new(language_defs: &[LanguageDefinition]) -> Self{\n        let mut named = BTreeMap::new();\n        let mut extensions = HashMap::new();\n        for lang in language_defs.iter() {\n            let lang_arc = Arc::new(lang.clone());\n            named.insert(lang.name.clone(), lang_arc.clone());\n            for ext in &lang.extensions {\n                extensions.insert(ext.clone(), lang_arc.clone());\n            }\n        }\n        Languages { named, extensions }\n    }","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/syntax.rs\"))"],"tabs::<impl std::convert::From<tabs::ViewId> for usize>::from":["fn from(src: ViewId) -> usize{\n        src.0\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::BufferId":["/// BufferIds uniquely identify open buffers.\npub struct BufferId(pub(crate) usize);","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::BufferId::new":["pub fn new(val: usize) -> Self{\n        BufferId(val)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState":["#[allow(dead_code)]\npub struct CoreState {\n    editors: BTreeMap<BufferId, RefCell<Editor>>,\n    views: BTreeMap<ViewId, RefCell<View>>,\n    file_manager: FileManager,\n    /// A local pasteboard.\n    kill_ring: RefCell<Rope>,\n    /// Theme and style state.\n    style_map: RefCell<ThemeStyleMap>,\n    width_cache: RefCell<WidthCache>,\n    /// User and platform specific settings\n    config_manager: ConfigManager,\n    /// Recorded editor actions\n    recorder: RefCell<Recorder>,\n    /// A weak reference to the main state container, stashed so that\n    /// it can be passed to plugins.\n    self_ref: Option<WeakXiCore>,\n    /// Views which need to have setup finished.\n    pending_views: Vec<(ViewId, Table)>,\n    peer: Client,\n    id_counter: Counter,\n    plugins: PluginCatalog,\n    // for the time being we auto-start all plugins we find on launch.\n    running_plugins: Vec<Plugin>,\n}","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::_test_open_editors":["pub fn _test_open_editors(&self) -> Vec<BufferId>{\n        self.editors.keys().cloned().collect()\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::_test_open_views":["pub fn _test_open_views(&self) -> Vec<ViewId>{\n        self.views.keys().cloned().collect()\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::after_stop_plugin":["fn after_stop_plugin(&mut self, plugin: &Plugin){\n        self.iter_groups().for_each(|mut cx| cx.plugin_stopped(plugin));\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::client_notification":["pub(crate) fn client_notification(&mut self, cmd: CoreNotification){\n        use self::CoreNotification::*;\n        use self::CorePluginNotification as PN;\n        match cmd {\n            Edit(crate::rpc::EditCommand { view_id, cmd }) => self.do_edit(view_id, cmd),\n            Save { view_id, file_path } => self.do_save(view_id, file_path),\n            CloseView { view_id } => self.do_close_view(view_id),\n            ModifyUserConfig { domain, changes } => self.do_modify_user_config(domain, changes),\n            SetTheme { theme_name } => self.do_set_theme(&theme_name),\n            SaveTrace { destination, frontend_samples } => {\n                self.save_trace(&destination, frontend_samples)\n            }\n            Plugin(cmd) => match cmd {\n                PN::Start { view_id, plugin_name } => self.do_start_plugin(view_id, &plugin_name),\n                PN::Stop { view_id, plugin_name } => self.do_stop_plugin(view_id, &plugin_name),\n                PN::PluginRpc { view_id, receiver, rpc } => {\n                    self.do_plugin_rpc(view_id, &receiver, &rpc.method, &rpc.params)\n                }\n            },\n            TracingConfig { enabled } => self.toggle_tracing(enabled),\n            // handled at the top level\n            ClientStarted { .. } => (),\n            SetLanguage { view_id, language_id } => self.do_set_language(view_id, language_id),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::client_request":["pub(crate) fn client_request(&mut self, cmd: CoreRequest) -> Result<Value, RemoteError>{\n        use self::CoreRequest::*;\n        match cmd {\n            //TODO: make file_path be an Option<PathBuf>\n            //TODO: make this a notification\n            NewView { file_path } => self.do_new_view(file_path.map(PathBuf::from)),\n            Edit(crate::rpc::EditCommand { view_id, cmd }) => self.do_edit_sync(view_id, cmd),\n            //TODO: why is this a request?? make a notification?\n            GetConfig { view_id } => self.do_get_config(view_id).map(|c| json!(c)),\n            DebugGetContents { view_id } => self.do_get_contents(view_id).map(|c| json!(c)),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::detect_whitespace":["fn detect_whitespace(&mut self, id: ViewId, config: &Table) -> Option<Table>{\n        let buffer_id = self.views.get(&id).map(|v| v.borrow().get_buffer_id())?;\n        let editor = self\n            .editors\n            .get(&buffer_id)\n            .expect(\"existing buffer_id must have corresponding editor\");\n\n        if editor.borrow().get_buffer().is_empty() {\n            return None;\n        }\n\n        let autodetect_whitespace =\n            self.config_manager.get_buffer_config(buffer_id).items.autodetect_whitespace;\n        if !autodetect_whitespace {\n            return None;\n        }\n\n        let mut changes = Table::new();\n        let indentation = Indentation::parse(editor.borrow().get_buffer());\n        match indentation {\n            Ok(Some(Indentation::Tabs)) => {\n                changes.insert(\"translate_tabs_to_spaces\".into(), false.into());\n            }\n            Ok(Some(Indentation::Spaces(n))) => {\n                changes.insert(\"translate_tabs_to_spaces\".into(), true.into());\n                changes.insert(\"tab_size\".into(), n.into());\n            }\n            Err(_) => info!(\"detected mixed indentation\"),\n            Ok(None) => info!(\"file contains no indentation\"),\n        }\n\n        let line_ending = LineEnding::parse(editor.borrow().get_buffer());\n        match line_ending {\n            Ok(Some(LineEnding::CrLf)) => {\n                changes.insert(\"line_ending\".into(), \"\\r\\n\".into());\n            }\n            Ok(Some(LineEnding::Lf)) => {\n                changes.insert(\"line_ending\".into(), \"\\n\".into());\n            }\n            Err(_) => info!(\"detected mixed line endings\"),\n            Ok(None) => info!(\"file contains no supported line endings\"),\n        }\n\n        let config_delta =\n            self.config_manager.table_for_update(ConfigDomain::SysOverride(buffer_id), changes);\n        match self\n            .config_manager\n            .set_user_config(ConfigDomain::SysOverride(buffer_id), config_delta)\n        {\n            Ok(ref mut items) if !items.is_empty() => {\n                assert!(\n                    items.len() == 1,\n                    \"whitespace overrides can only update a single buffer's config\\n{:?}\",\n                    items\n                );\n                let table = items.remove(0).1;\n                let mut config = config.clone();\n                config.extend(table);\n                Some(config)\n            }\n            Ok(_) => {\n                warn!(\"set_user_config failed to update config, no tables were returned\");\n                None\n            }\n            Err(err) => {\n                warn!(\"detect_whitespace failed to update config: {:?}\", err);\n                None\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_close_view":["fn do_close_view(&mut self, view_id: ViewId){\n        let close_buffer = self.make_context(view_id).map(|ctx| ctx.close_view()).unwrap_or(true);\n\n        let buffer_id = self.views.remove(&view_id).map(|v| v.borrow().get_buffer_id());\n\n        if let Some(buffer_id) = buffer_id {\n            if close_buffer {\n                self.editors.remove(&buffer_id);\n                self.file_manager.close(buffer_id);\n                self.config_manager.remove_buffer(buffer_id);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_edit":["fn do_edit(&mut self, view_id: ViewId, cmd: EditNotification){\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_edit(cmd);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_edit_sync":["fn do_edit_sync(&mut self, view_id: ViewId, cmd: EditRequest) -> Result<Value, RemoteError>{\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_edit_sync(cmd)\n        } else {\n            // TODO: some custom error tpye that can Into<RemoteError>\n            Err(RemoteError::custom(404, format!(\"missing view {:?}\", view_id), None))\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_get_config":["fn do_get_config(&self, view_id: ViewId) -> Result<Table, RemoteError>{\n        let _t = trace_block(\"CoreState::get_config\", &[\"core\"]);\n        self.views\n            .get(&view_id)\n            .map(|v| v.borrow().get_buffer_id())\n            .map(|id| self.config_manager.get_buffer_config(id).to_table())\n            .ok_or(RemoteError::custom(404, format!(\"missing {}\", view_id), None))\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_get_contents":["fn do_get_contents(&self, view_id: ViewId) -> Result<Rope, RemoteError>{\n        self.make_context(view_id)\n            .map(|ctx| ctx.editor.borrow().get_buffer().to_owned())\n            .ok_or_else(|| RemoteError::custom(404, format!(\"No view for id {}\", view_id), None))\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_modify_user_config":["/// Updates the config for a given domain.\nfn do_modify_user_config(&mut self, domain: ConfigDomainExternal, changes: Table){\n        // the client sends ViewId but we need BufferId so we do a dance\n        let domain: ConfigDomain = match domain {\n            ConfigDomainExternal::General => ConfigDomain::General,\n            ConfigDomainExternal::Syntax(id) => ConfigDomain::Language(id),\n            ConfigDomainExternal::Language(id) => ConfigDomain::Language(id),\n            ConfigDomainExternal::UserOverride(view_id) => match self.views.get(&view_id) {\n                Some(v) => ConfigDomain::UserOverride(v.borrow().get_buffer_id()),\n                None => return,\n            },\n        };\n        let new_config = self.config_manager.table_for_update(domain.clone(), changes);\n        self.set_config(domain, new_config);\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_new_view":["fn do_new_view(&mut self, path: Option<PathBuf>) -> Result<Value, RemoteError>{\n        let view_id = self.next_view_id();\n        let buffer_id = self.next_buffer_id();\n\n        let rope = match path.as_ref() {\n            Some(p) => self.file_manager.open(p, buffer_id)?,\n            None => Rope::from(\"\"),\n        };\n\n        let editor = RefCell::new(Editor::with_text(rope));\n        let view = RefCell::new(View::new(view_id, buffer_id));\n\n        self.editors.insert(buffer_id, editor);\n        self.views.insert(view_id, view);\n\n        let config = self.config_manager.add_buffer(buffer_id, path.as_deref());\n\n        // NOTE: because this is a synchronous call, we have to initialize the\n        // view and return the view_id before we can send any events to this\n        // view. We call view_init(), mark the view as pending and schedule the\n        // idle handler so that we can finish setting up this view on the next\n        // runloop pass, in finalize_new_views.\n\n        let mut edit_ctx = self.make_context(view_id).unwrap();\n        edit_ctx.view_init();\n\n        self.pending_views.push((view_id, config));\n        self.peer.schedule_idle(NEW_VIEW_IDLE_TOKEN);\n\n        Ok(json!(view_id))\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_plugin_rpc":["fn do_plugin_rpc(&self, view_id: ViewId, receiver: &str, method: &str, params: &Value){\n        self.running_plugins\n            .iter()\n            .filter(|p| p.name == receiver)\n            .for_each(|p| p.dispatch_command(view_id, method, params))\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_save":["fn do_save<P>(&mut self, view_id: ViewId, path: P)\n    where\n        P: AsRef<Path>,{\n        let _t = trace_block(\"CoreState::do_save\", &[\"core\"]);\n        let path = path.as_ref();\n        let buffer_id = self.views.get(&view_id).map(|v| v.borrow().get_buffer_id());\n        let buffer_id = match buffer_id {\n            Some(id) => id,\n            None => return,\n        };\n\n        let mut save_ctx = self.make_context(view_id).unwrap();\n        let fin_text = save_ctx.text_for_save();\n\n        if let Err(e) = self.file_manager.save(path, &fin_text, buffer_id) {\n            let error_message = e.to_string();\n            error!(\"File error: {:?}\", error_message);\n            self.peer.alert(error_message);\n            return;\n        }\n\n        let changes = self.config_manager.update_buffer_path(buffer_id, path);\n        let language = self.config_manager.get_buffer_language(buffer_id);\n\n        self.make_context(view_id).unwrap().after_save(path);\n        self.make_context(view_id).unwrap().language_changed(&language);\n\n        // update the config _after_ sending save related events\n        if let Some(changes) = changes {\n            self.make_context(view_id).unwrap().config_changed(&changes);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_set_language":["fn do_set_language(&mut self, view_id: ViewId, language_id: LanguageId){\n        if let Some(view) = self.views.get(&view_id) {\n            let buffer_id = view.borrow().get_buffer_id();\n            let changes = self.config_manager.override_language(buffer_id, language_id.clone());\n\n            let mut context = self.make_context(view_id).unwrap();\n            context.language_changed(&language_id);\n            if let Some(changes) = changes {\n                context.config_changed(&changes);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_set_theme":["fn do_set_theme(&self, theme_name: &str){\n        //Set only if requested theme is different from the\n        //current one.\n        if theme_name != self.style_map.borrow().get_theme_name() {\n            if let Err(e) = self.style_map.borrow_mut().set_theme(&theme_name) {\n                error!(\"error setting theme: {:?}, {:?}\", theme_name, e);\n                return;\n            }\n        }\n        self.notify_client_and_update_views();\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_start_plugin":["fn do_start_plugin(&mut self, _view_id: ViewId, plugin: &str){\n        if self.running_plugins.iter().any(|p| p.name == plugin) {\n            info!(\"plugin {} already running\", plugin);\n            return;\n        }\n\n        if let Some(manifest) = self.plugins.get_named(plugin) {\n            //TODO: lots of races possible here, we need to keep track of\n            //pending launches.\n            start_plugin_process(\n                manifest,\n                self.next_plugin_id(),\n                self.self_ref.as_ref().unwrap().clone(),\n            );\n        } else {\n            warn!(\"no plugin found with name '{}'\", plugin);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::do_stop_plugin":["fn do_stop_plugin(&mut self, _view_id: ViewId, plugin: &str){\n        if let Some(p) = self\n            .running_plugins\n            .iter()\n            .position(|p| p.name == plugin)\n            .map(|ix| self.running_plugins.remove(ix))\n        {\n            //TODO: verify shutdown; kill if necessary\n            p.shutdown();\n            self.after_stop_plugin(&p);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::finalize_new_views":["fn finalize_new_views(&mut self){\n        let to_start = mem::replace(&mut self.pending_views, Vec::new());\n\n        to_start.iter().for_each(|(id, config)| {\n            let modified = self.detect_whitespace(*id, config);\n            let config = modified.as_ref().unwrap_or(config);\n            let mut edit_ctx = self.make_context(*id).unwrap();\n            edit_ctx.finish_init(&config);\n        });\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::finish_setup":["pub(crate) fn finish_setup(&mut self, self_ref: WeakXiCore){\n        self.self_ref = Some(self_ref);\n\n        if let Some(path) = self.config_manager.base_config_file_path() {\n            self.load_file_based_config(&path);\n        }\n\n        // Load the custom theme files.\n        self.style_map.borrow_mut().load_theme_dir();\n\n        // instead of having to do this here, config should just own\n        // the plugin catalog and reload automatically\n        let plugin_paths = self.config_manager.get_plugin_paths();\n        self.plugins.reload_from_paths(&plugin_paths);\n        let languages = self.plugins.make_languages_map();\n        let languages_ids = languages.iter().map(|l| l.name.clone()).collect::<Vec<_>>();\n        self.peer.available_languages(languages_ids);\n        self.config_manager.set_languages(languages);\n        let theme_names = self.style_map.borrow().get_theme_names();\n        self.peer.available_themes(theme_names);\n\n        // FIXME: temporary: we just launch every plugin we find at startup\n        for manifest in self.plugins.iter() {\n            start_plugin_process(\n                manifest.clone(),\n                self.next_plugin_id(),\n                self.self_ref.as_ref().unwrap().clone(),\n            );\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_config_changes":["/// Notify editors/views/plugins of config changes.\nfn handle_config_changes(&self, changes: Vec<(BufferId, Table)>){\n        for (id, table) in changes {\n            let view_id = self\n                .views\n                .values()\n                .find(|v| v.borrow().get_buffer_id() == id)\n                .map(|v| v.borrow().get_view_id())\n                .unwrap();\n\n            self.make_context(view_id).unwrap().config_changed(&table)\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_config_fs_event":["/// Handles a config related file system event.\n#[cfg(feature = \"notify\")]\nfn handle_config_fs_event(&mut self, event: Event){\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Modify(ModifyKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any)) => {\n                self.load_file_based_config(&event.paths[0])\n            }\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                self.remove_config_at_path(&event.paths[0])\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                self.remove_config_at_path(&event.paths[0]);\n                self.load_file_based_config(&event.paths[1]);\n            }\n            _ => (),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_find_callback":["/// Callback for doing incremental find in a view\nfn handle_find_callback(&mut self, token: usize){\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx.do_incremental_find();\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_fs_events":["#[cfg(feature = \"notify\")]\nfn handle_fs_events(&mut self){\n        let _t = trace_block(\"CoreState::handle_fs_events\", &[\"core\"]);\n        let mut events = self.file_manager.watcher().take_events();\n\n        for (token, event) in events.drain(..) {\n            match token {\n                OPEN_FILE_EVENT_TOKEN => self.handle_open_file_fs_event(event),\n                CONFIG_EVENT_TOKEN => self.handle_config_fs_event(event),\n                THEME_FILE_EVENT_TOKEN => self.handle_themes_fs_event(event),\n                PLUGIN_EVENT_TOKEN => self.handle_plugin_fs_event(event),\n                _ => warn!(\"unexpected fs event token {:?}\", token),\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_idle":["pub(crate) fn handle_idle(&mut self, token: usize){\n        match token {\n            NEW_VIEW_IDLE_TOKEN => self.finalize_new_views(),\n            WATCH_IDLE_TOKEN => self.handle_fs_events(),\n            other if (other & RENDER_VIEW_IDLE_MASK) != 0 => {\n                self.handle_render_timer(other ^ RENDER_VIEW_IDLE_MASK)\n            }\n            other if (other & REWRAP_VIEW_IDLE_MASK) != 0 => {\n                self.handle_rewrap_callback(other ^ REWRAP_VIEW_IDLE_MASK)\n            }\n            other if (other & FIND_VIEW_IDLE_MASK) != 0 => {\n                self.handle_find_callback(other ^ FIND_VIEW_IDLE_MASK)\n            }\n            other => panic!(\"unexpected idle token {}\", other),\n        };\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_open_file_fs_event":["/// Handles a file system event related to a currently open file\n#[cfg(feature = \"notify\")]\nfn handle_open_file_fs_event(&mut self, event: Event){\n        use notify::event::*;\n        let path = match event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Modify(ModifyKind::Any) => &event.paths[0],\n            other => {\n                debug!(\"Ignoring event in open file {:?}\", other);\n                return;\n            }\n        };\n\n        let buffer_id = match self.file_manager.get_editor(path) {\n            Some(id) => id,\n            None => return,\n        };\n\n        let has_changes = self.file_manager.check_file(path, buffer_id);\n        let is_pristine = self.editors.get(&buffer_id).map(|ed| ed.borrow().is_pristine()).unwrap();\n        //TODO: currently we only use the file's modification time when\n        // determining if a file has been changed by another process.\n        // A more robust solution would also hash the file's contents.\n\n        if has_changes && is_pristine {\n            if let Ok(text) = self.file_manager.open(path, buffer_id) {\n                // this is ugly; we don't map buffer_id -> view_id anywhere\n                // but we know we must have a view.\n                let view_id = self\n                    .views\n                    .values()\n                    .find(|v| v.borrow().get_buffer_id() == buffer_id)\n                    .map(|v| v.borrow().get_view_id())\n                    .unwrap();\n                self.make_context(view_id).unwrap().reload(text);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_plugin_fs_event":["/// Handles changes in plugin files.\n#[cfg(feature = \"notify\")]\nfn handle_plugin_fs_event(&mut self, event: Event){\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any) | EventKind::Modify(ModifyKind::Any) => {\n                self.plugins.load_from_paths(&[event.paths[0].clone()]);\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_start_plugin(ViewId(0), &plugin.name);\n                }\n            }\n            // the way FSEvents on macOS work, we want to verify that this path\n            // has actually be removed before we do anything.\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_stop_plugin(ViewId(0), &plugin.name);\n                    self.plugins.remove_named(&plugin.name);\n                }\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                let old = &event.paths[0];\n                let new = &event.paths[1];\n                if let Some(old_plugin) = self.plugins.get_from_path(old) {\n                    self.do_stop_plugin(ViewId(0), &old_plugin.name);\n                    self.plugins.remove_named(&old_plugin.name);\n                }\n\n                self.plugins.load_from_paths(&[new.clone()]);\n                if let Some(new_plugin) = self.plugins.get_from_path(new) {\n                    self.do_start_plugin(ViewId(0), &new_plugin.name);\n                }\n            }\n            EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Remove(RemoveKind::Any) => {\n                if let Some(plugin) = self.plugins.get_from_path(&event.paths[0]) {\n                    self.do_stop_plugin(ViewId(0), &plugin.name);\n                    self.do_start_plugin(ViewId(0), &plugin.name);\n                }\n            }\n            _ => (),\n        }\n\n        self.views.keys().for_each(|view_id| {\n            let available_plugins = self\n                .plugins\n                .iter()\n                .map(|plugin| ClientPluginInfo { name: plugin.name.clone(), running: true })\n                .collect::<Vec<_>>();\n            self.peer.available_plugins(*view_id, &available_plugins);\n        });\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_render_timer":["fn handle_render_timer(&mut self, token: usize){\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx._finish_delayed_render();\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_rewrap_callback":["/// Callback for doing word wrap on a view\nfn handle_rewrap_callback(&mut self, token: usize){\n        let id: ViewId = token.into();\n        if let Some(mut ctx) = self.make_context(id) {\n            ctx.do_rewrap_batch();\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::handle_themes_fs_event":["/// Handles changes in theme files.\n#[cfg(feature = \"notify\")]\nfn handle_themes_fs_event(&mut self, event: Event){\n        use notify::event::*;\n        match event.kind {\n            EventKind::Create(CreateKind::Any) | EventKind::Modify(ModifyKind::Any) => {\n                self.load_theme_file(&event.paths[0])\n            }\n            // the way FSEvents on macOS work, we want to verify that this path\n            // has actually be removed before we do anything.\n            EventKind::Remove(RemoveKind::Any) if !event.paths[0].exists() => {\n                self.remove_theme(&event.paths[0]);\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                let old = &event.paths[0];\n                let new = &event.paths[1];\n                self.remove_theme(old);\n                self.load_theme_file(new);\n            }\n            EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any))\n            | EventKind::Remove(RemoveKind::Any) => {\n                self.style_map.borrow_mut().sync_dir(event.paths[0].parent())\n            }\n            _ => (),\n        }\n        let theme_names = self.style_map.borrow().get_theme_names();\n        self.peer.available_themes(theme_names);\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::iter_groups":["/// Produces an iterator over all event contexts, with each view appearing\n/// exactly once.\nfn iter_groups<'a>(&'a self) -> Iter<'a, Box<dyn Iterator<Item = &ViewId> + 'a>>{\n        Iter { views: Box::new(self.views.keys()), seen: HashSet::new(), inner: self }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::load_file_based_config":["/// Attempt to load a config file.\nfn load_file_based_config(&mut self, path: &Path){\n        let _t = trace_block(\"CoreState::load_config_file\", &[\"core\"]);\n        if let Some(domain) = self.config_manager.domain_for_path(path) {\n            match config::try_load_from_file(&path) {\n                Ok(table) => self.set_config(domain, table),\n                Err(e) => self.peer.alert(e.to_string()),\n            }\n        } else {\n            self.peer.alert(format!(\"Unexpected config file {:?}\", path));\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::load_theme_file":["/// Load a single theme file. Updates if already present.\nfn load_theme_file(&mut self, path: &Path){\n        let _t = trace_block(\"CoreState::load_theme_file\", &[\"core\"]);\n\n        let result = self.style_map.borrow_mut().load_theme_info_from_path(path);\n        match result {\n            Ok(theme_name) => {\n                if theme_name == self.style_map.borrow().get_theme_name() {\n                    if self.style_map.borrow_mut().set_theme(&theme_name).is_ok() {\n                        self.notify_client_and_update_views();\n                    }\n                }\n            }\n            Err(e) => error!(\"Error loading theme file: {:?}, {:?}\", path, e),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::make_context":["/// Creates an `EventContext` for the provided `ViewId`. This context\n/// holds references to the `Editor` and `View` backing this `ViewId`,\n/// as well as to sibling views, plugins, and other state necessary\n/// for handling most events.\npub(crate) fn make_context(&self, view_id: ViewId) -> Option<EventContext>{\n        self.views.get(&view_id).map(|view| {\n            let buffer_id = view.borrow().get_buffer_id();\n\n            let editor = &self.editors[&buffer_id];\n            let info = self.file_manager.get_info(buffer_id);\n            let plugins = self.running_plugins.iter().collect::<Vec<_>>();\n            let config = self.config_manager.get_buffer_config(buffer_id);\n            let language = self.config_manager.get_buffer_language(buffer_id);\n\n            EventContext {\n                view_id,\n                buffer_id,\n                view,\n                editor,\n                config: &config.items,\n                recorder: &self.recorder,\n                language,\n                info,\n                siblings: Vec::new(),\n                plugins,\n                client: &self.peer,\n                style_map: &self.style_map,\n                width_cache: &self.width_cache,\n                kill_ring: &self.kill_ring,\n                weak_core: self.self_ref.as_ref().unwrap(),\n            }\n        })\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::new":["pub(crate) fn new(\n        peer: &RpcPeer,\n        config_dir: Option<PathBuf>,\n        extras_dir: Option<PathBuf>,\n    ) -> Self{\n        #[cfg(feature = \"notify\")]\n        let mut watcher = FileWatcher::new(peer.clone());\n\n        if let Some(p) = config_dir.as_ref() {\n            if !p.exists() {\n                if let Err(e) = config::init_config_dir(p) {\n                    //TODO: report this error?\n                    error!(\"error initing file based configs: {:?}\", e);\n                }\n            }\n\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, CONFIG_EVENT_TOKEN, |p| {\n                p.extension().and_then(OsStr::to_str).unwrap_or(\"\") == \"xiconfig\"\n            });\n        }\n\n        let config_manager = ConfigManager::new(config_dir, extras_dir);\n\n        let themes_dir = config_manager.get_themes_dir();\n        if let Some(p) = themes_dir.as_ref() {\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, THEME_FILE_EVENT_TOKEN, |p| {\n                p.extension().and_then(OsStr::to_str).unwrap_or(\"\") == \"tmTheme\"\n            });\n        }\n\n        let plugins_dir = config_manager.get_plugins_dir();\n        if let Some(p) = plugins_dir.as_ref() {\n            #[cfg(feature = \"notify\")]\n            watcher.watch_filtered(p, true, PLUGIN_EVENT_TOKEN, |p| p.is_dir() || !p.exists());\n        }\n\n        CoreState {\n            views: BTreeMap::new(),\n            editors: BTreeMap::new(),\n            #[cfg(feature = \"notify\")]\n            file_manager: FileManager::new(watcher),\n            #[cfg(not(feature = \"notify\"))]\n            file_manager: FileManager::new(),\n            kill_ring: RefCell::new(Rope::from(\"\")),\n            style_map: RefCell::new(ThemeStyleMap::new(themes_dir)),\n            width_cache: RefCell::new(WidthCache::new()),\n            config_manager,\n            recorder: RefCell::new(Recorder::new()),\n            self_ref: None,\n            pending_views: Vec::new(),\n            peer: Client::new(peer.clone()),\n            id_counter: Counter::default(),\n            plugins: PluginCatalog::default(),\n            running_plugins: Vec::new(),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::next_buffer_id":["fn next_buffer_id(&self) -> BufferId{\n        BufferId(self.id_counter.next())\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::next_plugin_id":["fn next_plugin_id(&self) -> PluginId{\n        PluginPid(self.id_counter.next())\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::next_view_id":["fn next_view_id(&self) -> ViewId{\n        ViewId(self.id_counter.next())\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::notify_client_and_update_views":["fn notify_client_and_update_views(&self){\n        {\n            let style_map = self.style_map.borrow();\n            self.peer.theme_changed(style_map.get_theme_name(), style_map.get_theme_settings());\n        }\n\n        self.iter_groups().for_each(|mut edit_ctx| {\n            edit_ctx.with_editor(|ed, view, _, _| {\n                ed.theme_changed(&self.style_map.borrow());\n                view.set_dirty(ed.get_buffer());\n            });\n            edit_ctx.render_if_needed();\n        });\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::plugin_connect":["/// Called from a plugin's thread after trying to start the plugin.\npub(crate) fn plugin_connect(&mut self, plugin: Result<Plugin, io::Error>){\n        match plugin {\n            Ok(plugin) => {\n                let init_info =\n                    self.iter_groups().map(|mut ctx| ctx.plugin_info()).collect::<Vec<_>>();\n                plugin.initialize(init_info);\n                self.running_plugins.push(plugin);\n            }\n            Err(e) => error!(\"failed to start plugin {:?}\", e),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::plugin_exit":["pub(crate) fn plugin_exit(&mut self, id: PluginId, error: Result<(), ReadError>){\n        warn!(\"plugin {:?} exited with result {:?}\", id, error);\n        let running_idx = self.running_plugins.iter().position(|p| p.id == id);\n        if let Some(idx) = running_idx {\n            let plugin = self.running_plugins.remove(idx);\n            self.after_stop_plugin(&plugin);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::plugin_notification":["pub(crate) fn plugin_notification(\n        &mut self,\n        _ctx: &RpcCtx,\n        view_id: ViewId,\n        plugin_id: PluginId,\n        cmd: PluginNotification,\n    ){\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_plugin_cmd(plugin_id, cmd)\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::plugin_request":["pub(crate) fn plugin_request(\n        &mut self,\n        _ctx: &RpcCtx,\n        view_id: ViewId,\n        plugin_id: PluginId,\n        cmd: PluginRequest,\n    ) -> Result<Value, RemoteError>{\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            Ok(edit_ctx.do_plugin_cmd_sync(plugin_id, cmd))\n        } else {\n            Err(RemoteError::custom(404, \"missing view\", None))\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::plugin_update":["/// Handles the response to a sync update sent to a plugin.\npub(crate) fn plugin_update(\n        &mut self,\n        _plugin_id: PluginId,\n        view_id: ViewId,\n        response: Result<Value, xi_rpc::Error>,\n    ){\n        if let Some(mut edit_ctx) = self.make_context(view_id) {\n            edit_ctx.do_plugin_update(response);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::remove_config_at_path":["fn remove_config_at_path(&mut self, path: &Path){\n        if let Some(domain) = self.config_manager.domain_for_path(path) {\n            self.set_config(domain, Table::default());\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::remove_theme":["fn remove_theme(&mut self, path: &Path){\n        let result = self.style_map.borrow_mut().remove_theme(path);\n\n        // Set default theme if the removed theme was the\n        // current one.\n        if let Some(theme_name) = result {\n            if theme_name == self.style_map.borrow().get_theme_name() {\n                self.do_set_theme(DEFAULT_THEME);\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::save_trace":["fn save_trace<P>(&self, path: P, frontend_samples: Value)\n    where\n        P: AsRef<Path>,{\n        use xi_trace::chrome_trace_dump;\n        let mut all_traces = xi_trace::samples_cloned_unsorted();\n        if let Ok(mut traces) = chrome_trace_dump::decode(frontend_samples) {\n            all_traces.append(&mut traces);\n        }\n\n        for plugin in &self.running_plugins {\n            match plugin.collect_trace() {\n                Ok(json) => {\n                    let mut trace = chrome_trace_dump::decode(json).unwrap();\n                    all_traces.append(&mut trace);\n                }\n                Err(e) => error!(\"trace error {:?}\", e),\n            }\n        }\n\n        all_traces.sort_unstable();\n\n        let mut trace_file = match File::create(path.as_ref()) {\n            Ok(f) => f,\n            Err(e) => {\n                error!(\"error saving trace {:?}\", e);\n                return;\n            }\n        };\n\n        if let Err(e) = chrome_trace_dump::serialize(&all_traces, &mut trace_file) {\n            error!(\"error saving trace {:?}\", e);\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::set_config":["/// Sets (overwriting) the config for a given domain.\nfn set_config(&mut self, domain: ConfigDomain, table: Table){\n        match self.config_manager.set_user_config(domain, table) {\n            Err(e) => self.peer.alert(format!(\"{}\", &e)),\n            Ok(changes) => self.handle_config_changes(changes),\n        }\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::CoreState::toggle_tracing":["fn toggle_tracing(&self, enabled: bool){\n        self.running_plugins.iter().for_each(|plugin| plugin.toggle_tracing(enabled))\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::Counter":["pub(crate) struct Counter(Cell<usize>);","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::Counter::next":["pub(crate) fn next(&self) -> usize{\n        let n = self.0.get();\n        self.0.set(n + 1);\n        n + 1\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::Iter":["/// A multi-view aware iterator over `EventContext`s. A view which appears\n/// as a sibling will not appear again as a main view.\npub struct Iter<'a, I> {\n    views: I,\n    seen: HashSet<ViewId>,\n    inner: &'a CoreState,\n}","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::ViewId":["/// ViewIds are the primary means of routing messages between\n/// xi-core and a client view.\npub struct ViewId(pub(crate) usize);","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::test_helpers::new_buffer_id":["pub fn new_buffer_id(id: usize) -> BufferId{\n        BufferId(id)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"tabs::test_helpers::new_view_id":["pub fn new_view_id(id: usize) -> ViewId{\n        ViewId(id)\n    }","Real(LocalPath(\"core-lib/src/tabs.rs\"))"],"view::DragState":["/// State required to resolve a drag gesture into a selection.\nstruct DragState {\n    /// All the selection regions other than the one being dragged.\n    base_sel: Selection,\n\n    /// Start of the region selected when drag was started (region is\n    /// assumed to be forward).\n    min: usize,\n\n    /// End of the region selected when drag was started.\n    max: usize,\n\n    granularity: SelectionGranularity,\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::FindProgress":["/// Indicates what changed in the find state.\nenum FindProgress {\n    /// Incremental find is done/not running.\n    Ready,\n\n    /// The find process just started.\n    Started,\n\n    /// Incremental find is in progress. Keeps tracked of already searched range.\n    InProgress(Range<usize>),\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::FindStatusChange":["/// Indicates what changed in the find state.\nenum FindStatusChange {\n    /// None of the find parameters or number of matches changed.\n    None,\n\n    /// Find parameters and number of matches changed.\n    All,\n\n    /// Only number of matches changed\n    Matches,\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::Replace":["/// Contains replacement string and replace options.\npub struct Replace {\n    /// Replacement string.\n    pub chars: String,\n    pub preserve_case: bool,\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::Size":["/// A size, in pixel units (not display pixels).\npub struct Size {\n    pub width: f64,\n    pub height: f64,\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View":["/// A view to a buffer. It is the buffer plus additional information\n/// like line breaks and selection state.\npub struct View {\n    view_id: ViewId,\n    buffer_id: BufferId,\n\n    /// Tracks whether this view has been scheduled to render.\n    /// We attempt to reduce duplicate renders by setting a small timeout\n    /// after an edit is applied, to allow batching with any plugin updates.\n    pending_render: bool,\n    size: Size,\n    /// The selection state for this view. Invariant: non-empty.\n    selection: Selection,\n\n    drag_state: Option<DragState>,\n\n    /// vertical scroll position\n    first_line: usize,\n    /// height of visible portion\n    height: usize,\n    lines: Lines,\n\n    /// Front end's line cache state for this view. See the `LineCacheShadow`\n    /// description for the invariant.\n    lc_shadow: LineCacheShadow,\n\n    /// New offset to be scrolled into position after an edit.\n    scroll_to: Option<usize>,\n\n    /// The state for finding text for this view.\n    /// Each instance represents a separate search query.\n    find: Vec<Find>,\n\n    /// Tracks the IDs for additional search queries in find.\n    find_id_counter: Counter,\n\n    /// Tracks whether there has been changes in find results or find parameters.\n    /// This is used to determined whether FindStatus should be sent to the frontend.\n    find_changed: FindStatusChange,\n\n    /// Tracks the progress of incremental find.\n    find_progress: FindProgress,\n\n    /// Tracks whether find highlights should be rendered.\n    /// Highlights are only rendered when search dialog is open.\n    highlight_find: bool,\n\n    /// The state for replacing matches for this view.\n    replace: Option<Replace>,\n\n    /// Tracks whether the replacement string or replace parameters changed.\n    replace_changed: bool,\n\n    /// Annotations provided by plugins.\n    annotations: AnnotationStore,\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::add_find":["fn add_find(&mut self){\n        let id = self.find_id_counter.next();\n        self.find.push(Find::new(id));\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::add_selection_by_movement":["fn add_selection_by_movement(&mut self, text: &Rope, movement: Movement){\n        let mut sel = Selection::new();\n        for &region in self.sel_regions() {\n            sel.add_region(region);\n            let new_region =\n                region_movement(movement, region, self, self.scroll_height(), &text, false);\n            sel.add_region(new_region);\n        }\n        self.set_selection(text, sel);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::after_edit":["/// Updates the view after the text has been modified by the given `delta`.\n/// This method is responsible for updating the cursors, and also for\n/// recomputing line wraps.\npub fn after_edit(\n        &mut self,\n        text: &Rope,\n        last_text: &Rope,\n        delta: &RopeDelta,\n        client: &Client,\n        width_cache: &mut WidthCache,\n        drift: InsertDrift,\n    ){\n        let visible = self.first_line..self.first_line + self.height;\n        match self.lines.after_edit(text, last_text, delta, width_cache, client, visible) {\n            Some(InvalLines { start_line, inval_count, new_count }) => {\n                self.lc_shadow.edit(start_line, start_line + inval_count, new_count);\n            }\n            None => self.set_dirty(text),\n        }\n\n        // Any edit cancels a drag. This is good behavior for edits initiated through\n        // the front-end, but perhaps not for async edits.\n        self.drag_state = None;\n\n        // all annotations that come after the edit need to be invalidated\n        let (iv, _) = delta.summary();\n        self.annotations.invalidate(iv);\n\n        // update only find highlights affected by change\n        for find in &mut self.find {\n            find.update_highlights(text, delta);\n            self.find_changed = FindStatusChange::All;\n        }\n\n        // Note: for committing plugin edits, we probably want to know the priority\n        // of the delta so we can set the cursor before or after the edit, as needed.\n        let new_sel = self.selection.apply_delta(delta, true, drift);\n        self.set_selection_for_edit(text, new_sel);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::collapse_selections":["/// Collapse all selections in this view into a single caret\npub fn collapse_selections(&mut self, text: &Rope){\n        let mut sel = self.selection.clone();\n        sel.collapse();\n        self.set_selection(text, sel);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::debug_force_rewrap_cols":["/// Exposed for benchmarking\n#[doc(hidden)]\npub fn debug_force_rewrap_cols(&mut self, text: &Rope, cols: usize){\n        use xi_rpc::test_utils::DummyPeer;\n\n        let spans: Spans<Style> = Spans::default();\n        let mut width_cache = WidthCache::new();\n        let client = Client::new(Box::new(DummyPeer));\n        self.update_wrap_settings(text, cols, false);\n        self.rewrap(text, &mut width_cache, &client, &spans);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::deselect_at_offset":["/// Removes any selection present at the given offset.\n/// Returns true if a selection was removed, false otherwise.\npub fn deselect_at_offset(&mut self, text: &Rope, offset: usize) -> bool{\n        if !self.selection.regions_in_range(offset, offset).is_empty() {\n            let mut sel = self.selection.clone();\n            sel.delete_range(offset, offset, true);\n            if !sel.is_empty() {\n                self.drag_state = None;\n                self.set_selection_raw(text, sel);\n                return true;\n            }\n        }\n        false\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_drag":["/// Does a drag gesture, setting the selection from a combination of the drag\n/// state and new offset.\nfn do_drag(&mut self, text: &Rope, offset: usize, affinity: Affinity){\n        let new_sel = self.drag_state.as_ref().map(|drag_state| {\n            let mut sel = drag_state.base_sel.clone();\n            let start = (drag_state.min, drag_state.max);\n            let new_region = self.range_region(text, start, offset, drag_state.granularity);\n            sel.add_region(new_region.with_horiz(None).with_affinity(affinity));\n            sel\n        });\n\n        if let Some(sel) = new_sel {\n            self.set_selection(text, sel);\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_edit":["pub(crate) fn do_edit(&mut self, text: &Rope, cmd: ViewEvent){\n        use self::ViewEvent::*;\n        match cmd {\n            Move(movement) => self.do_move(text, movement, false),\n            ModifySelection(movement) => self.do_move(text, movement, true),\n            SelectAll => self.select_all(text),\n            Scroll(range) => self.set_scroll(range.first, range.last),\n            AddSelectionAbove => self.add_selection_by_movement(text, Movement::UpExactPosition),\n            AddSelectionBelow => self.add_selection_by_movement(text, Movement::DownExactPosition),\n            Gesture { line, col, ty } => self.do_gesture(text, line, col, ty),\n            GotoLine { line } => self.goto_line(text, line),\n            Find { chars, case_sensitive, regex, whole_words } => {\n                let id = self.find.first().map(|q| q.id());\n                let query_changes = FindQuery { id, chars, case_sensitive, regex, whole_words };\n                self.set_find(text, [query_changes].to_vec())\n            }\n            MultiFind { queries } => self.set_find(text, queries),\n            FindNext { wrap_around, allow_same, modify_selection } => {\n                self.do_find_next(text, false, wrap_around, allow_same, &modify_selection)\n            }\n            FindPrevious { wrap_around, allow_same, modify_selection } => {\n                self.do_find_next(text, true, wrap_around, allow_same, &modify_selection)\n            }\n            FindAll => self.do_find_all(text),\n            Click(MouseAction { line, column, flags, click_count }) => {\n                // Deprecated (kept for client compatibility):\n                // should be removed in favor of do_gesture\n                warn!(\"Usage of click is deprecated; use do_gesture\");\n                if (flags & FLAG_SELECT) != 0 {\n                    self.do_gesture(\n                        text,\n                        line,\n                        column,\n                        GestureType::SelectExtend { granularity: SelectionGranularity::Point },\n                    )\n                } else if click_count == Some(2) {\n                    self.do_gesture(text, line, column, GestureType::WordSelect)\n                } else if click_count == Some(3) {\n                    self.do_gesture(text, line, column, GestureType::LineSelect)\n                } else {\n                    self.do_gesture(text, line, column, GestureType::PointSelect)\n                }\n            }\n            Drag(MouseAction { line, column, .. }) => {\n                warn!(\"Usage of drag is deprecated; use gesture instead\");\n                self.do_gesture(text, line, column, GestureType::Drag)\n            }\n            CollapseSelections => self.collapse_selections(text),\n            HighlightFind { visible } => {\n                self.highlight_find = visible;\n                self.find_changed = FindStatusChange::All;\n                self.set_dirty(text);\n            }\n            SelectionForFind { case_sensitive } => self.do_selection_for_find(text, case_sensitive),\n            Replace { chars, preserve_case } => self.do_set_replace(chars, preserve_case),\n            SelectionForReplace => self.do_selection_for_replace(text),\n            SelectionIntoLines => self.do_split_selection_into_lines(text),\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_find":["pub fn do_find(&mut self, text: &Rope){\n        let search_range = match &self.find_progress.clone() {\n            FindProgress::Started => {\n                // start incremental find on visible region\n                let start = self.offset_of_line(text, self.first_line);\n                let end = min(text.len(), start + FIND_BATCH_SIZE);\n                self.find_changed = FindStatusChange::Matches;\n                self.find_progress = FindProgress::InProgress(Range { start, end });\n                Some((start, end))\n            }\n            FindProgress::InProgress(searched_range) => {\n                if searched_range.start == 0 && searched_range.end >= text.len() {\n                    // the entire text has been searched\n                    // end find by executing multi-line regex queries on entire text\n                    // stop incremental find\n                    self.find_progress = FindProgress::Ready;\n                    self.find_changed = FindStatusChange::All;\n                    Some((0, text.len()))\n                } else {\n                    self.find_changed = FindStatusChange::Matches;\n                    // expand find to un-searched regions\n                    let start_off = self.offset_of_line(text, self.first_line);\n\n                    // If there is unsearched text before the visible region, we want to include it in this search operation\n                    let search_preceding_range = start_off.saturating_sub(searched_range.start)\n                        < searched_range.end.saturating_sub(start_off)\n                        && searched_range.start > 0;\n\n                    if search_preceding_range || searched_range.end >= text.len() {\n                        let start = searched_range.start.saturating_sub(FIND_BATCH_SIZE);\n                        self.find_progress =\n                            FindProgress::InProgress(Range { start, end: searched_range.end });\n                        Some((start, searched_range.start))\n                    } else if searched_range.end < text.len() {\n                        let end = min(text.len(), searched_range.end + FIND_BATCH_SIZE);\n                        self.find_progress =\n                            FindProgress::InProgress(Range { start: searched_range.start, end });\n                        Some((searched_range.end, end))\n                    } else {\n                        self.find_changed = FindStatusChange::All;\n                        None\n                    }\n                }\n            }\n            _ => {\n                self.find_changed = FindStatusChange::None;\n                None\n            }\n        };\n\n        if let Some((search_range_start, search_range_end)) = search_range {\n            for query in &mut self.find {\n                if !query.is_multiline_regex() {\n                    query.update_find(text, search_range_start, search_range_end, true);\n                } else {\n                    // only execute multi-line regex queries if we are searching the entire text (last step)\n                    if search_range_start == 0 && search_range_end == text.len() {\n                        query.update_find(text, search_range_start, search_range_end, true);\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_find_all":["/// Selects all find matches.\npub fn do_find_all(&mut self, text: &Rope){\n        let mut selection = Selection::new();\n        for find in &self.find {\n            for &occurrence in find.occurrences().iter() {\n                selection.add_region(occurrence);\n            }\n        }\n\n        if !selection.is_empty() {\n            // todo: invalidate so that nothing selected accidentally replaced\n            self.set_selection(text, selection);\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_find_next":["/// Selects the next find match.\npub fn do_find_next(\n        &mut self,\n        text: &Rope,\n        reverse: bool,\n        wrap: bool,\n        allow_same: bool,\n        modify_selection: &SelectionModifier,\n    ){\n        self.select_next_occurrence(text, reverse, false, allow_same, modify_selection);\n        if self.scroll_to.is_none() && wrap {\n            self.select_next_occurrence(text, reverse, true, allow_same, modify_selection);\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_gesture":["fn do_gesture(&mut self, text: &Rope, line: u64, col: u64, ty: GestureType){\n        let line = line as usize;\n        let col = col as usize;\n        let offset = self.line_col_to_offset(text, line, col);\n        match ty {\n            GestureType::Select { granularity, multi } => {\n                self.select(text, offset, granularity, multi)\n            }\n            GestureType::SelectExtend { granularity } => {\n                self.extend_selection(text, offset, granularity)\n            }\n            GestureType::Drag => self.do_drag(text, offset, Affinity::default()),\n\n            _ => {\n                warn!(\"Deprecated gesture type sent to do_gesture method\");\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_move":["/// Move the selection by the given movement. Return value is the offset of\n/// a point that should be scrolled into view.\n///\n/// If `modify` is `true`, the selections are modified, otherwise the results\n/// of individual region movements become carets.\npub fn do_move(&mut self, text: &Rope, movement: Movement, modify: bool){\n        self.drag_state = None;\n        let new_sel =\n            selection_movement(movement, &self.selection, self, self.scroll_height(), text, modify);\n        self.set_selection(text, new_sel);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_selection_for_find":["fn do_selection_for_find(&mut self, text: &Rope, case_sensitive: bool){\n        // set last selection or word under current cursor as search query\n        let search_query = match self.selection.last() {\n            Some(region) => {\n                if !region.is_caret() {\n                    text.slice_to_cow(region)\n                } else {\n                    let (start, end) = {\n                        let mut word_cursor = WordCursor::new(text, region.max());\n                        word_cursor.select_word()\n                    };\n                    text.slice_to_cow(start..end)\n                }\n            }\n            _ => return,\n        };\n\n        self.set_dirty(text);\n\n        // set selection as search query for first find if no additional search queries are used\n        // otherwise add new find with selection as search query\n        if self.find.len() != 1 {\n            self.add_find();\n        }\n\n        self.find.last_mut().unwrap().set_find(&search_query, case_sensitive, false, true);\n        self.find_progress = FindProgress::Started;\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_selection_for_replace":["fn do_selection_for_replace(&mut self, text: &Rope){\n        // set last selection or word under current cursor as replacement string\n        let replacement = match self.selection.last() {\n            Some(region) => {\n                if !region.is_caret() {\n                    text.slice_to_cow(region)\n                } else {\n                    let (start, end) = {\n                        let mut word_cursor = WordCursor::new(text, region.max());\n                        word_cursor.select_word()\n                    };\n                    text.slice_to_cow(start..end)\n                }\n            }\n            _ => return,\n        };\n\n        self.set_dirty(text);\n        self.do_set_replace(replacement.into_owned(), false);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_set_replace":["fn do_set_replace(&mut self, chars: String, preserve_case: bool){\n        self.replace = Some(Replace { chars, preserve_case });\n        self.replace_changed = true;\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::do_split_selection_into_lines":["/// Splits current selections into lines.\nfn do_split_selection_into_lines(&mut self, text: &Rope){\n        let mut selection = Selection::new();\n\n        for region in self.selection.iter() {\n            if region.is_caret() {\n                selection.add_region(SelRegion::caret(region.max()));\n            } else {\n                let mut cursor = Cursor::new(&text, region.min());\n\n                while cursor.pos() < region.max() {\n                    let sel_start = cursor.pos();\n                    let end_of_line = match cursor.next::<LinesMetric>() {\n                        Some(end) if end >= region.max() => max(0, region.max() - 1),\n                        Some(end) => max(0, end - 1),\n                        None if cursor.pos() == text.len() => cursor.pos(),\n                        _ => break,\n                    };\n\n                    selection.add_region(SelRegion::new(sel_start, end_of_line));\n                }\n            }\n        }\n\n        self.set_selection_raw(text, selection);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::encode_line":["fn encode_line(\n        &self,\n        client: &Client,\n        styles: &StyleMap,\n        line: VisualLine,\n        text: Option<&Rope>,\n        style_spans: Option<&Spans<Style>>,\n        last_pos: usize,\n    ) -> Value{\n        let start_pos = line.interval.start;\n        let pos = line.interval.end;\n        let mut cursors = Vec::new();\n        let mut selections = Vec::new();\n        for region in self.selection.regions_in_range(start_pos, pos) {\n            // cursor\n            let c = region.end;\n\n            if (c > start_pos && c < pos)\n                || (!region.is_upstream() && c == start_pos)\n                || (region.is_upstream() && c == pos)\n                || (c == pos && c == last_pos)\n            {\n                cursors.push(c - start_pos);\n            }\n\n            // selection with interior\n            let sel_start_ix = clamp(region.min(), start_pos, pos) - start_pos;\n            let sel_end_ix = clamp(region.max(), start_pos, pos) - start_pos;\n            if sel_end_ix > sel_start_ix {\n                selections.push((sel_start_ix, sel_end_ix));\n            }\n        }\n\n        let mut hls = Vec::new();\n\n        if self.highlight_find {\n            for find in &self.find {\n                let mut cur_hls = Vec::new();\n                for region in find.occurrences().regions_in_range(start_pos, pos) {\n                    let sel_start_ix = clamp(region.min(), start_pos, pos) - start_pos;\n                    let sel_end_ix = clamp(region.max(), start_pos, pos) - start_pos;\n                    if sel_end_ix > sel_start_ix {\n                        cur_hls.push((sel_start_ix, sel_end_ix));\n                    }\n                }\n                hls.push(cur_hls);\n            }\n        }\n\n        let mut result = json!({});\n\n        if let Some(text) = text {\n            result[\"text\"] = json!(text.slice_to_cow(start_pos..pos));\n        }\n        if let Some(style_spans) = style_spans {\n            result[\"styles\"] = json!(self.encode_styles(\n                client,\n                styles,\n                start_pos,\n                pos,\n                &selections,\n                &hls,\n                style_spans\n            ));\n        }\n        if !cursors.is_empty() {\n            result[\"cursor\"] = json!(cursors);\n        }\n        if let Some(line_num) = line.line_num {\n            result[\"ln\"] = json!(line_num);\n        }\n        result\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::encode_styles":["pub fn encode_styles(\n        &self,\n        client: &Client,\n        styles: &StyleMap,\n        start: usize,\n        end: usize,\n        sel: &[(usize, usize)],\n        hls: &Vec<Vec<(usize, usize)>>,\n        style_spans: &Spans<Style>,\n    ) -> Vec<isize>{\n        let mut encoded_styles = Vec::new();\n        assert!(start <= end, \"{} {}\", start, end);\n        let style_spans = style_spans.subseq(Interval::new(start, end));\n\n        let mut ix = 0;\n        // we add the special find highlights (1 to N) and selection (0) styles first.\n        // We add selection after find because we want it to be preferred if the\n        // same span exists in both sets (as when there is an active selection)\n        for (index, cur_find_hls) in hls.iter().enumerate() {\n            for &(sel_start, sel_end) in cur_find_hls {\n                encoded_styles.push((sel_start as isize) - ix);\n                encoded_styles.push(sel_end as isize - sel_start as isize);\n                encoded_styles.push(index as isize + 1);\n                ix = sel_end as isize;\n            }\n        }\n        for &(sel_start, sel_end) in sel {\n            encoded_styles.push((sel_start as isize) - ix);\n            encoded_styles.push(sel_end as isize - sel_start as isize);\n            encoded_styles.push(0);\n            ix = sel_end as isize;\n        }\n        for (iv, style) in style_spans.iter() {\n            let style_id = self.get_or_def_style_id(client, styles, &style);\n            encoded_styles.push((iv.start() as isize) - ix);\n            encoded_styles.push(iv.end() as isize - iv.start() as isize);\n            encoded_styles.push(style_id as isize);\n            ix = iv.end() as isize;\n        }\n        encoded_styles\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::extend_selection":["/// Extends an existing selection (eg. when the user performs SHIFT + click).\npub fn extend_selection(\n        &mut self,\n        text: &Rope,\n        offset: usize,\n        granularity: SelectionGranularity,\n    ){\n        if self.sel_regions().is_empty() {\n            return;\n        }\n\n        let (base_sel, last) = {\n            let mut base = Selection::new();\n            let (last, rest) = self.sel_regions().split_last().unwrap();\n            for &region in rest {\n                base.add_region(region);\n            }\n            (base, *last)\n        };\n\n        let mut sel = base_sel.clone();\n        self.drag_state =\n            Some(DragState { base_sel, min: last.start, max: last.start, granularity });\n\n        let start = (last.start, last.start);\n        let new_region = self.range_region(text, start, offset, granularity);\n\n        // TODO: small nit, merged region should be backward if end < start.\n        // This could be done by explicitly overriding, or by tweaking the\n        // merge logic.\n        sel.add_region(new_region);\n        self.set_selection(text, sel);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::find_in_progress":["pub(crate) fn find_in_progress(&self) -> bool{\n        match self.find_progress {\n            FindProgress::InProgress(_) => true,\n            FindProgress::Started => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::find_status":["/// Determines the current number of find results and search parameters to send them to\n/// the frontend.\npub fn find_status(&self, text: &Rope, matches_only: bool) -> Vec<FindStatus>{\n        self.find\n            .iter()\n            .map(|find| find.find_status(&self, text, matches_only))\n            .collect::<Vec<FindStatus>>()\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_buffer_id":["pub(crate) fn get_buffer_id(&self) -> BufferId{\n        self.buffer_id\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_caret_offset":["pub fn get_caret_offset(&self) -> Option<usize>{\n        match self.selection.len() {\n            1 if self.selection[0].is_caret() => {\n                let offset = self.selection[0].start;\n                Some(offset)\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_lines":["pub(crate) fn get_lines(&self) -> &Lines{\n        &self.lines\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_or_def_style_id":["fn get_or_def_style_id(&self, client: &Client, style_map: &StyleMap, style: &Style) -> usize{\n        let mut style_map = style_map.borrow_mut();\n        if let Some(ix) = style_map.lookup(style) {\n            return ix;\n        }\n        let ix = style_map.add(style);\n        let style = style_map.merge_with_default(style);\n        client.def_style(&style.to_json(ix));\n        ix\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_replace":["pub(crate) fn get_replace(&self) -> Option<Replace>{\n        self.replace.clone()\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::get_view_id":["pub(crate) fn get_view_id(&self) -> ViewId{\n        self.view_id\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::goto_line":["fn goto_line(&mut self, text: &Rope, line: u64){\n        let offset = self.line_col_to_offset(text, line as usize, 0);\n        self.set_selection(text, SelRegion::caret(offset));\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::has_pending_render":["pub(crate) fn has_pending_render(&self) -> bool{\n        self.pending_render\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::interval_of_visible_region":["/// Returns the byte range of the currently visible lines.\nfn interval_of_visible_region(&self, text: &Rope) -> Interval{\n        let start = self.offset_of_line(text, self.first_line);\n        let end = self.offset_of_line(text, self.first_line + self.height + 1);\n        Interval::new(start, end)\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::invalidate_selection":["/// Invalidate the current selection. Note that we could be even more\n/// fine-grained in the case of multiple cursors, but we also want this\n/// method to be fast even when the selection is large.\nfn invalidate_selection(&mut self, text: &Rope){\n        // TODO: refine for upstream (caret appears on prev line)\n        let first_line = self.line_of_offset(text, self.selection.first().unwrap().min());\n        let last_line = self.line_of_offset(text, self.selection.last().unwrap().max()) + 1;\n        let all_caret = self.selection.iter().all(|region| region.is_caret());\n        let invalid = if all_caret {\n            line_cache_shadow::CURSOR_VALID\n        } else {\n            line_cache_shadow::CURSOR_VALID | line_cache_shadow::STYLES_VALID\n        };\n        self.lc_shadow.partial_invalidate(first_line, last_line, invalid);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::invalidate_styles":["/// Invalidates the styles of the given range (start and end are offsets within\n/// the text).\npub fn invalidate_styles(&mut self, text: &Rope, start: usize, end: usize){\n        let first_line = self.line_of_offset(text, start);\n        let (mut last_line, last_col) = self.offset_to_line_col(text, end);\n        last_line += if last_col > 0 { 1 } else { 0 };\n        self.lc_shadow.partial_invalidate(first_line, last_line, line_cache_shadow::STYLES_VALID);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::is_point_in_selection":["/// Determines whether the offset is in any selection (counting carets and\n/// selection edges).\npub fn is_point_in_selection(&self, offset: usize) -> bool{\n        !self.selection.regions_in_range(offset, offset).is_empty()\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::needs_more_wrap":["pub(crate) fn needs_more_wrap(&self) -> bool{\n        !self.lines.is_converged()\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::needs_wrap_in_visible_region":["pub(crate) fn needs_wrap_in_visible_region(&self, text: &Rope) -> bool{\n        if self.lines.is_converged() {\n            false\n        } else {\n            let visible_region = self.interval_of_visible_region(text);\n            self.lines.interval_needs_wrap(visible_region)\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::new":["pub fn new(view_id: ViewId, buffer_id: BufferId) -> View{\n        View {\n            view_id,\n            buffer_id,\n            pending_render: false,\n            selection: SelRegion::caret(0).into(),\n            scroll_to: Some(0),\n            size: Size::default(),\n            drag_state: None,\n            first_line: 0,\n            height: 10,\n            lines: Lines::default(),\n            lc_shadow: LineCacheShadow::default(),\n            find: Vec::new(),\n            find_id_counter: Counter::default(),\n            find_changed: FindStatusChange::None,\n            find_progress: FindProgress::Ready,\n            highlight_find: false,\n            replace: None,\n            replace_changed: false,\n            annotations: AnnotationStore::new(),\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::range_region":["/// Creates a `SelRegion` for range select or drag operations.\npub fn range_region(\n        &self,\n        text: &Rope,\n        start: (usize, usize),\n        offset: usize,\n        granularity: SelectionGranularity,\n    ) -> SelRegion{\n        let (min_start, max_start) = start;\n        let end = self.unit(text, offset, granularity);\n        let (min_end, max_end) = (end.start, end.end);\n        if offset >= min_start {\n            SelRegion::new(min_start, max_end)\n        } else {\n            SelRegion::new(max_start, min_end)\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::render_if_dirty":["/// Update front-end with any changes to view since the last time sent.\n/// The `pristine` argument indicates whether or not the buffer has\n/// unsaved changes.\npub fn render_if_dirty(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        pristine: bool,\n    ){\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let plan = RenderPlan::create(height, self.first_line, self.height);\n        self.send_update_for_plan(text, client, styles, style_spans, &plan, pristine);\n        if let Some(new_scroll_pos) = self.scroll_to.take() {\n            let (line, col) = self.offset_to_line_col(text, new_scroll_pos);\n            client.scroll_to(self.view_id, line, col);\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::request_lines":["pub fn request_lines(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        first_line: usize,\n        last_line: usize,\n        pristine: bool,\n    ){\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let mut plan = RenderPlan::create(height, self.first_line, self.height);\n        plan.request_lines(first_line, last_line);\n        self.send_update_for_plan(text, client, styles, style_spans, &plan, pristine);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::rewrap":["/// Generate line breaks, based on current settings. Currently batch-mode,\n/// and currently in a debugging state.\npub(crate) fn rewrap(\n        &mut self,\n        text: &Rope,\n        width_cache: &mut WidthCache,\n        client: &Client,\n        spans: &Spans<Style>,\n    ){\n        let _t = trace_block(\"View::rewrap\", &[\"core\"]);\n        let visible = self.first_line..self.first_line + self.height;\n        let inval = self.lines.rewrap_chunk(text, width_cache, client, spans, visible);\n        if let Some(InvalLines { start_line, inval_count, new_count }) = inval {\n            self.lc_shadow.edit(start_line, start_line + inval_count, new_count);\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::scroll_height":["pub fn scroll_height(&self) -> usize{\n        self.height\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::scroll_to_cursor":["fn scroll_to_cursor(&mut self, text: &Rope){\n        let end = self.sel_regions().last().unwrap().end;\n        let line = self.line_of_offset(text, end);\n        if line < self.first_line {\n            self.first_line = line;\n        } else if self.first_line + self.height <= line {\n            self.first_line = line - (self.height - 1);\n        }\n        // We somewhat arbitrarily choose the last region for setting the old-style\n        // selection state, and for scrolling it into view if needed. This choice can\n        // likely be improved.\n        self.scroll_to = Some(end);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::sel_regions":["/// Returns the regions of the current selection.\npub fn sel_regions(&self) -> &[SelRegion]{\n        &self.selection\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::select":["/// Selects text with a certain granularity and supports multi_selection\nfn select(\n        &mut self,\n        text: &Rope,\n        offset: usize,\n        granularity: SelectionGranularity,\n        multi: bool,\n    ){\n        // If multi-select is enabled, toggle existing regions\n        if multi\n            && granularity == SelectionGranularity::Point\n            && self.deselect_at_offset(text, offset)\n        {\n            return;\n        }\n\n        let region = self.unit(text, offset, granularity).into();\n\n        let base_sel = match multi {\n            true => self.selection.clone(),\n            false => Selection::new(),\n        };\n        let mut selection = base_sel.clone();\n        selection.add_region(region);\n        self.set_selection(text, selection);\n\n        self.drag_state =\n            Some(DragState { base_sel, min: region.start, max: region.end, granularity });\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::select_all":["/// Select entire buffer.\n///\n/// Note: unlike movement based selection, this does not scroll.\npub fn select_all(&mut self, text: &Rope){\n        let selection = SelRegion::new(0, text.len()).into();\n        self.set_selection_raw(text, selection);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::select_next_occurrence":["/// Select the next occurrence relative to the last cursor. `reverse` determines whether the\n/// next occurrence before (`true`) or after (`false`) the last cursor is selected. `wrapped`\n/// indicates a search for the next occurrence past the end of the file.\npub fn select_next_occurrence(\n        &mut self,\n        text: &Rope,\n        reverse: bool,\n        wrapped: bool,\n        _allow_same: bool,\n        modify_selection: &SelectionModifier,\n    ){\n        let (cur_start, cur_end) = match self.selection.last() {\n            Some(sel) => (sel.min(), sel.max()),\n            _ => (0, 0),\n        };\n\n        // multiple queries; select closest occurrence\n        let closest_occurrence = self\n            .find\n            .iter()\n            .flat_map(|x| x.next_occurrence(text, reverse, wrapped, &self.selection))\n            .min_by_key(|x| match reverse {\n                true if x.end > cur_end => 2 * text.len() - x.end,\n                true => cur_end - x.end,\n                false if x.start < cur_start => x.start + text.len(),\n                false => x.start - cur_start,\n            });\n\n        if let Some(occ) = closest_occurrence {\n            match modify_selection {\n                SelectionModifier::Set => self.set_selection(text, occ),\n                SelectionModifier::Add => {\n                    let mut selection = self.selection.clone();\n                    selection.add_region(occ);\n                    self.set_selection(text, selection);\n                }\n                SelectionModifier::AddRemovingCurrent => {\n                    let mut selection = self.selection.clone();\n\n                    if let Some(last_selection) = self.selection.last() {\n                        if !last_selection.is_caret() {\n                            selection.delete_range(\n                                last_selection.min(),\n                                last_selection.max(),\n                                false,\n                            );\n                        }\n                    }\n\n                    selection.add_region(occ);\n                    self.set_selection(text, selection);\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::send_update_for_plan":["fn send_update_for_plan(\n        &mut self,\n        text: &Rope,\n        client: &Client,\n        styles: &StyleMap,\n        style_spans: &Spans<Style>,\n        plan: &RenderPlan,\n        pristine: bool,\n    ){\n        // every time current visible range changes, annotations are sent to frontend\n        let start_off = self.offset_of_line(text, self.first_line);\n        let end_off = self.offset_of_line(text, self.first_line + self.height + 2);\n        let visible_range = Interval::new(start_off, end_off);\n        let selection_annotations =\n            self.selection.get_annotations(visible_range, &self, text).to_json();\n        let find_annotations =\n            self.find.iter().map(|ref f| f.get_annotations(visible_range, &self, text).to_json());\n        let plugin_annotations =\n            self.annotations.iter_range(&self, text, visible_range).map(|a| a.to_json());\n\n        let annotations = iter::once(selection_annotations)\n            .chain(find_annotations)\n            .chain(plugin_annotations)\n            .collect::<Vec<_>>();\n\n        if !self.lc_shadow.needs_render(plan) {\n            let total_lines = self.line_of_offset(text, text.len()) + 1;\n            let update =\n                Update { ops: vec![UpdateOp::copy(total_lines, 1)], pristine, annotations };\n            client.update_view(self.view_id, &update);\n            return;\n        }\n\n        // send updated find status only if there have been changes\n        if self.find_changed != FindStatusChange::None {\n            let matches_only = self.find_changed == FindStatusChange::Matches;\n            client.find_status(self.view_id, &json!(self.find_status(text, matches_only)));\n            self.find_changed = FindStatusChange::None;\n        }\n\n        // send updated replace status if changed\n        if self.replace_changed {\n            if let Some(replace) = self.get_replace() {\n                client.replace_status(self.view_id, &json!(replace))\n            }\n        }\n\n        let mut b = line_cache_shadow::Builder::new();\n        let mut ops = Vec::new();\n        let mut line_num = 0; // tracks old line cache\n\n        for seg in self.lc_shadow.iter_with_plan(plan) {\n            match seg.tactic {\n                RenderTactic::Discard => {\n                    ops.push(UpdateOp::invalidate(seg.n));\n                    b.add_span(seg.n, 0, 0);\n                }\n                RenderTactic::Preserve | RenderTactic::Render => {\n                    // Depending on the state of TEXT_VALID, STYLES_VALID and\n                    // CURSOR_VALID, perform one of the following actions:\n                    //\n                    //   - All the three are valid => send the \"copy\" op\n                    //     (+leading \"skip\" to catch up with \"ln\" to update);\n                    //\n                    //   - Text and styles are valid, cursors are not => same,\n                    //     but send an \"update\" op instead of \"copy\" to move\n                    //     the cursors;\n                    //\n                    //   - Text or styles are invalid:\n                    //     => send \"invalidate\" if RenderTactic is \"Preserve\";\n                    //     => send \"skip\"+\"insert\" (recreate the lines) if\n                    //        RenderTactic is \"Render\".\n                    if (seg.validity & line_cache_shadow::TEXT_VALID) != 0\n                        && (seg.validity & line_cache_shadow::STYLES_VALID) != 0\n                    {\n                        let n_skip = seg.their_line_num - line_num;\n                        if n_skip > 0 {\n                            ops.push(UpdateOp::skip(n_skip));\n                        }\n                        let line_offset = self.offset_of_line(text, seg.our_line_num);\n                        let logical_line = text.line_of_offset(line_offset);\n                        if (seg.validity & line_cache_shadow::CURSOR_VALID) != 0 {\n                            // ALL_VALID; copy lines as-is\n                            ops.push(UpdateOp::copy(seg.n, logical_line + 1));\n                        } else {\n                            // !CURSOR_VALID; update cursors\n                            let start_line = seg.our_line_num;\n\n                            let encoded_lines = self\n                                .lines\n                                .iter_lines(text, start_line)\n                                .take(seg.n)\n                                .map(|l| {\n                                    self.encode_line(\n                                        client,\n                                        styles,\n                                        l,\n                                        /* text = */ None,\n                                        /* style_spans = */ None,\n                                        text.len(),\n                                    )\n                                })\n                                .collect::<Vec<_>>();\n\n                            let logical_line_opt =\n                                if logical_line == 0 { None } else { Some(logical_line + 1) };\n                            ops.push(UpdateOp::update(encoded_lines, logical_line_opt));\n                        }\n                        b.add_span(seg.n, seg.our_line_num, seg.validity);\n                        line_num = seg.their_line_num + seg.n;\n                    } else {\n                        if seg.tactic == RenderTactic::Preserve {\n                            ops.push(UpdateOp::invalidate(seg.n));\n                            b.add_span(seg.n, 0, 0);\n                        } else if seg.tactic == RenderTactic::Render {\n                            let start_line = seg.our_line_num;\n                            let encoded_lines = self\n                                .lines\n                                .iter_lines(text, start_line)\n                                .take(seg.n)\n                                .map(|l| {\n                                    self.encode_line(\n                                        client,\n                                        styles,\n                                        l,\n                                        Some(text),\n                                        Some(style_spans),\n                                        text.len(),\n                                    )\n                                })\n                                .collect::<Vec<_>>();\n                            debug_assert_eq!(encoded_lines.len(), seg.n);\n                            ops.push(UpdateOp::insert(encoded_lines));\n                            b.add_span(seg.n, seg.our_line_num, line_cache_shadow::ALL_VALID);\n                        }\n                    }\n                }\n            }\n        }\n\n        self.lc_shadow = b.build();\n        for find in &mut self.find {\n            find.set_hls_dirty(false)\n        }\n\n        let update = Update { ops, pristine, annotations };\n        client.update_view(self.view_id, &update);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_dirty":["/// Invalidates front-end's entire line cache, forcing a full render at the next\n/// update cycle. This should be a last resort, updates should generally cause\n/// finer grain invalidation.\npub fn set_dirty(&mut self, text: &Rope){\n        let height = self.line_of_offset(text, text.len()) + 1;\n        let mut b = line_cache_shadow::Builder::new();\n        b.add_span(height, 0, 0);\n        b.set_dirty(true);\n        self.lc_shadow = b.build();\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_find":["fn set_find(&mut self, text: &Rope, queries: Vec<FindQuery>){\n        // checks if at least query has been changed, otherwise we don't need to rerun find\n        let mut find_changed = queries.len() != self.find.len();\n\n        // remove deleted queries\n        self.find.retain(|f| queries.iter().any(|q| q.id == Some(f.id())));\n\n        for query in &queries {\n            let pos = match query.id {\n                Some(id) => {\n                    // update existing query\n                    match self.find.iter().position(|f| f.id() == id) {\n                        Some(p) => p,\n                        None => return,\n                    }\n                }\n                None => {\n                    // add new query\n                    self.add_find();\n                    self.find.len() - 1\n                }\n            };\n\n            if self.find[pos].set_find(\n                &query.chars.clone(),\n                query.case_sensitive,\n                query.regex,\n                query.whole_words,\n            ) {\n                find_changed = true;\n            }\n        }\n\n        if find_changed {\n            self.set_dirty(text);\n            self.find_progress = FindProgress::Started;\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_has_pending_render":["pub(crate) fn set_has_pending_render(&mut self, pending: bool){\n        self.pending_render = pending\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_scroll":["pub fn set_scroll(&mut self, first: i64, last: i64){\n        let first = max(first, 0) as usize;\n        let last = max(last, 0) as usize;\n        self.first_line = first;\n        self.height = last - first;\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_selection":["/// Set the selection to a new value.\npub fn set_selection<S: Into<Selection>>(&mut self, text: &Rope, sel: S){\n        self.set_selection_raw(text, sel.into());\n        self.scroll_to_cursor(text);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_selection_for_edit":["/// Sets the selection to a new value, without invalidating.\nfn set_selection_for_edit(&mut self, text: &Rope, sel: Selection){\n        self.selection = sel;\n        self.scroll_to_cursor(text);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_selection_raw":["/// Sets the selection to a new value, invalidating the line cache as needed.\n/// This function does not perform any scrolling.\nfn set_selection_raw(&mut self, text: &Rope, sel: Selection){\n        self.invalidate_selection(text);\n        self.selection = sel;\n        self.invalidate_selection(text);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::set_size":["pub fn set_size(&mut self, size: Size){\n        self.size = size;\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::unit":["/// Finds the unit of text containing the given offset.\nfn unit(&self, text: &Rope, offset: usize, granularity: SelectionGranularity) -> Interval{\n        match granularity {\n            SelectionGranularity::Point => Interval::new(offset, offset),\n            SelectionGranularity::Word => {\n                let mut word_cursor = WordCursor::new(text, offset);\n                let (start, end) = word_cursor.select_word();\n                Interval::new(start, end)\n            }\n            SelectionGranularity::Line => {\n                let (line, _) = self.offset_to_line_col(text, offset);\n                let (start, end) = self.lines.logical_line_range(text, line);\n                Interval::new(start, end)\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::update_annotations":["pub fn update_annotations(\n        &mut self,\n        plugin: PluginId,\n        interval: Interval,\n        annotations: Annotations,\n    ){\n        self.annotations.update(plugin, interval, annotations)\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::View::update_wrap_settings":["pub(crate) fn update_wrap_settings(&mut self, text: &Rope, wrap_cols: usize, word_wrap: bool){\n        let wrap_width = match (word_wrap, wrap_cols) {\n            (true, _) => WrapWidth::Width(self.size.width),\n            (false, 0) => WrapWidth::None,\n            (false, cols) => WrapWidth::Bytes(cols),\n        };\n        self.lines.set_wrap_width(text, wrap_width);\n    }","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/view.rs\"))"],"view::clamp":["fn clamp(x: usize, min: usize, max: usize) -> usize{\n    if x < min {\n        min\n    } else if x < max {\n        x\n    } else {\n        max\n    }\n}","Real(LocalPath(\"core-lib/src/view.rs\"))"],"watcher::FileWatcher":["/// Wrapper around a `notify::Watcher`. It runs the inner watcher\n/// in a separate thread, and communicates with it via a [crossbeam channel].\n/// [crossbeam channel]: https://docs.rs/crossbeam-channel\npub struct FileWatcher {\n    inner: RecommendedWatcher,\n    state: Arc<Mutex<WatcherState>>,\n}","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::new":["pub fn new<T: Notify + 'static>(peer: T) -> Self{\n        let (tx_event, rx_event) = unbounded();\n\n        let state = Arc::new(Mutex::new(WatcherState::default()));\n        let state_clone = state.clone();\n\n        let inner = watcher(tx_event, Duration::from_millis(100)).expect(\"watcher should spawn\");\n\n        thread::spawn(move || {\n            while let Ok(Ok(event)) = rx_event.recv() {\n                let mut state = state_clone.lock().unwrap();\n                let WatcherState { ref mut events, ref mut watchees } = *state;\n\n                watchees\n                    .iter()\n                    .filter(|w| w.wants_event(&event))\n                    .map(|w| w.token)\n                    .for_each(|t| events.push_back((t, event.clone())));\n\n                peer.notify();\n            }\n        });\n\n        FileWatcher { inner, state }\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::take_events":["/// Takes ownership of this `Watcher`'s current event queue.\npub fn take_events(&mut self) -> VecDeque<(WatchToken, Event)>{\n        let mut state = self.state.lock().unwrap();\n        let WatcherState { ref mut events, .. } = *state;\n        mem::replace(events, VecDeque::new())\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::unwatch":["/// Removes the provided token/path pair from the watch list.\n/// Does not stop watching this path, if it is associated with\n/// other tokens.\npub fn unwatch(&mut self, path: &Path, token: WatchToken){\n        let mut state = self.state.lock().unwrap();\n\n        let idx = state.watchees.iter().position(|w| w.token == token && w.path == path);\n\n        if let Some(idx) = idx {\n            let removed = state.watchees.remove(idx);\n            if !state.watchees.iter().any(|w| w.path == removed.path) {\n                if let Err(e) = self.inner.unwatch(&removed.path) {\n                    warn!(\"unwatching error {:?}\", e);\n                }\n            }\n            //TODO: Ideally we would be tracking what paths we're watching with\n            // some prefix-tree-like structure, which would let us keep track\n            // of when some child path might need to be reregistered. How this\n            // works and when registration would be required is dependent on\n            // the underlying notification mechanism, however. There's an\n            // in-progress rewrite of the Notify crate which use under the\n            // hood, and a component of that rewrite is adding this\n            // functionality; so until that lands we're using a fairly coarse\n            // heuristic to determine if we need to re-watch subpaths.\n\n            // if this was recursive, check if any child paths need to be\n            // manually re-added\n            if removed.recursive {\n                // do this in two steps because we've borrowed mutably up top\n                let to_add = state\n                    .watchees\n                    .iter()\n                    .filter(|w| w.path.starts_with(&removed.path))\n                    .map(|w| (w.path.to_owned(), mode_from_bool(w.recursive)))\n                    .collect::<Vec<_>>();\n\n                for (path, mode) in to_add {\n                    if let Err(e) = self.inner.watch(&path, mode) {\n                        warn!(\"watching error {:?}\", e);\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::watch":["/// Begin watching `path`. As `Event`s (documented in the\n/// [notify](https://docs.rs/notify) crate) arrive, they are stored\n/// with the associated `token` and a task is added to the runloop's\n/// idle queue.\n///\n/// Delivery of events then requires that the runloop's handler\n/// correctly forward the `handle_idle` call to the interested party.\npub fn watch(&mut self, path: &Path, recursive: bool, token: WatchToken){\n        self.watch_impl(path, recursive, token, None);\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::watch_filtered":["/// Like `watch`, but taking a predicate function that filters delivery\n/// of events based on their path.\npub fn watch_filtered<F>(&mut self, path: &Path, recursive: bool, token: WatchToken, filter: F)\n    where\n        F: Fn(&Path) -> bool + Send + 'static,{\n        let filter = Box::new(filter) as Box<PathFilter>;\n        self.watch_impl(path, recursive, token, Some(filter));\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::FileWatcher::watch_impl":["fn watch_impl(\n        &mut self,\n        path: &Path,\n        recursive: bool,\n        token: WatchToken,\n        filter: Option<Box<PathFilter>>,\n    ){\n        let path = match path.canonicalize() {\n            Ok(ref p) => p.to_owned(),\n            Err(e) => {\n                warn!(\"error watching {:?}: {:?}\", path, e);\n                return;\n            }\n        };\n\n        let mut state = self.state.lock().unwrap();\n\n        let w = Watchee { path, recursive, token, filter };\n        let mode = mode_from_bool(w.recursive);\n\n        if !state.watchees.iter().any(|w2| w.path == w2.path) {\n            if let Err(e) = self.inner.watch(&w.path, mode) {\n                warn!(\"watching error {:?}\", e);\n            }\n        }\n\n        state.watchees.push(w);\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::Notify":["/// A trait for types which can be notified of new events.\n/// New events are accessible through the `FileWatcher` instance.\npub trait Notify: Send {\n    fn notify(&self);\n}","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::WatchToken":["/// Token provided to `FileWatcher`, to associate events with\n/// interested parties.\n///\n/// Note: `WatchToken`s are assumed to correspond with an\n/// 'area of interest'; that is, they are used to route delivery\n/// of events.\npub struct WatchToken(pub usize);","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::Watchee":["/// Tracks a registered 'that-which-is-watched'.\n#[doc(hidden)]\nstruct Watchee {\n    path: PathBuf,\n    recursive: bool,\n    token: WatchToken,\n    filter: Option<Box<PathFilter>>,\n}","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::Watchee::applies_to_path":["fn applies_to_path(&self, path: &Path) -> bool{\n        let general_case = if path.starts_with(&self.path) {\n            (self.recursive || self.path == path) || path.parent() == Some(&self.path)\n        } else {\n            false\n        };\n\n        if let Some(ref filter) = self.filter {\n            general_case && filter(path)\n        } else {\n            general_case\n        }\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::Watchee::wants_event":["fn wants_event(&self, event: &Event) -> bool{\n        match &event.kind {\n            EventKind::Create(CreateKind::Any)\n            | EventKind::Remove(RemoveKind::Any)\n            | EventKind::Modify(ModifyKind::Any)\n            | EventKind::Modify(ModifyKind::Metadata(MetadataKind::Any)) => {\n                if event.paths.len() == 1 {\n                    self.applies_to_path(&event.paths[0])\n                } else {\n                    info!(\n                        \"Rejecting event {:?} with incorrect paths. Expected 1 found {}.\",\n                        event,\n                        event.paths.len()\n                    );\n                    false\n                }\n            }\n            EventKind::Modify(ModifyKind::Name(RenameMode::Both)) => {\n                if event.paths.len() == 2 {\n                    //There will be two paths. First is \"from\" and other is \"to\".\n                    self.applies_to_path(&event.paths[0]) || self.applies_to_path(&event.paths[1])\n                } else {\n                    info!(\n                        \"Rejecting event {:?} with incorrect paths. Expected 2 found {}.\",\n                        event,\n                        event.paths.len()\n                    );\n                    false\n                }\n            }\n            _ => false,\n        }\n    }","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::WatcherState":["struct WatcherState {\n    events: EventQueue,\n    watchees: Vec<Watchee>,\n}","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"watcher::mode_from_bool":["fn mode_from_bool(is_recursive: bool) -> RecursiveMode{\n    if is_recursive {\n        RecursiveMode::Recursive\n    } else {\n        RecursiveMode::NonRecursive\n    }\n}","Real(LocalPath(\"core-lib/src/watcher.rs\"))"],"whitespace::Indentation":["/// An enumeration of legal indentation types.\npub enum Indentation {\n    Tabs,\n    Spaces(usize),\n}","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"whitespace::Indentation::parse":["/// Parses a rope for indentation settings.\npub fn parse(rope: &Rope) -> Result<Option<Self>, MixedIndentError>{\n        let lines = rope.lines_raw(..);\n        let mut tabs = false;\n        let mut spaces: BTreeMap<usize, usize> = BTreeMap::new();\n\n        for line in lines {\n            match Indentation::parse_line(&line) {\n                Ok(Some(Indentation::Spaces(size))) => {\n                    let counter = spaces.entry(size).or_insert(0);\n                    *counter += 1;\n                }\n                Ok(Some(Indentation::Tabs)) => tabs = true,\n                Ok(None) => continue,\n                Err(e) => return Err(e),\n            }\n        }\n\n        match (tabs, !spaces.is_empty()) {\n            (true, true) => Err(MixedIndentError),\n            (true, false) => Ok(Some(Indentation::Tabs)),\n            (false, true) => {\n                let tab_size = extract_count(spaces);\n                if tab_size > 0 {\n                    Ok(Some(Indentation::Spaces(tab_size)))\n                } else {\n                    Ok(None)\n                }\n            }\n            _ => Ok(None),\n        }\n    }","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"whitespace::Indentation::parse_line":["/// Detects the indentation on a specific line.\n/// Parses whitespace until first occurrence of something else\npub fn parse_line(line: &str) -> Result<Option<Self>, MixedIndentError>{\n        let mut spaces = 0;\n\n        for char in line.as_bytes() {\n            match char {\n                b' ' => spaces += 1,\n                b'\\t' if spaces > 0 => return Err(MixedIndentError),\n                b'\\t' => return Ok(Some(Indentation::Tabs)),\n                _ => break,\n            }\n        }\n\n        if spaces > 0 {\n            Ok(Some(Indentation::Spaces(spaces)))\n        } else {\n            Ok(None)\n        }\n    }","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"whitespace::MixedIndentError":["/// A struct representing the mixed indentation error.\npub struct MixedIndentError;","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"whitespace::extract_count":["/// Uses a heuristic to calculate the greatest common denominator of most used indentation depths.\n///\n/// As BTreeMaps are ordered by value, using take on the iterator ensures the indentation levels\n/// most frequently used in the file are extracted.\nfn extract_count(spaces: BTreeMap<usize, usize>) -> usize{\n    let mut take_size = 4;\n\n    if spaces.len() < take_size {\n        take_size = spaces.len();\n    }\n\n    // Fold results using GCD, skipping numbers which result in gcd returning 1\n    spaces.iter().take(take_size).fold(0, |a, (b, _)| {\n        let d = gcd(a, *b);\n        if d == 1 {\n            a\n        } else {\n            d\n        }\n    })\n}","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"whitespace::gcd":["/// Simple implementation to calculate greatest common divisor, based on Euclid's algorithm\nfn gcd(a: usize, b: usize) -> usize{\n    if a == 0 {\n        b\n    } else if b == 0 || a == b {\n        a\n    } else {\n        let mut a = a;\n        let mut b = b;\n\n        while b > 0 {\n            let r = a % b;\n            a = b;\n            b = r;\n        }\n        a\n    }\n}","Real(LocalPath(\"core-lib/src/whitespace.rs\"))"],"width_cache::CodepointMono":["/// A measure in which each codepoint has width of 1.\npub struct CodepointMono;","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthBatchReq":["/// A batched request, so that a number of strings can be measured in a\n/// a single RPC.\npub struct WidthBatchReq<'a> {\n    cache: &'a mut WidthCache,\n    pending_tok: Token,\n    req: Vec<WidthReq>,\n    req_toks: Vec<Vec<Token>>,\n    // maps style id to index into req/req_toks\n    req_ids: BTreeMap<StyleId, Token>,\n}","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthBatchReq::<'a>::request":["/// Request measurement of one string/style pair within the batch.\npub fn request(&mut self, id: StyleId, s: &str) -> Token{\n        let key = WidthCacheKey { id, s: Cow::Borrowed(s) };\n        if let Some(tok) = self.cache.m.get(&key) {\n            return *tok;\n        }\n        // cache miss, add the request\n        let key = WidthCacheKey { id, s: Cow::Owned(s.to_owned()) };\n        let req = &mut self.req;\n        let req_toks = &mut self.req_toks;\n        let id_off = *self.req_ids.entry(id).or_insert_with(|| {\n            let id_off = req.len();\n            req.push(WidthReq { id, strings: Vec::new() });\n            req_toks.push(Vec::new());\n            id_off\n        });\n        // To avoid this second clone, we could potentially do a tricky thing where\n        // we extract the strings from the WidthReq. Probably not worth it though.\n        req[id_off].strings.push(s.to_owned());\n        let tok = self.pending_tok;\n        self.cache.m.insert(key, tok);\n        self.pending_tok += 1;\n        req_toks[id_off].push(tok);\n        tok\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthBatchReq::<'a>::resolve_pending":["/// Resolves pending measurements to concrete widths using the provided [`WidthMeasure`].\n/// On success, the tokens given by `request` will resolve in the cache.\npub fn resolve_pending<T: WidthMeasure + ?Sized>(\n        &mut self,\n        handler: &T,\n    ) -> Result<(), xi_rpc::Error>{\n        // The 0.0 values should all get replaced with actual widths, assuming the\n        // shape of the response from the front-end matches that of the request.\n        if self.pending_tok > self.cache.widths.len() {\n            self.cache.widths.resize(self.pending_tok, 0.0);\n            let widths = handler.measure_width(&self.req)?;\n            for (w, t) in widths.iter().zip(self.req_toks.iter()) {\n                for (width, tok) in w.iter().zip(t.iter()) {\n                    self.cache.widths[*tok] = *width;\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCache":["pub struct WidthCache {\n    /// maps cache key to index within widths\n    m: HashMap<WidthCacheKey<'static>, Token>,\n    widths: Vec<Width>,\n}","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCache::batch_req":["/// Create a new batch of requests.\npub fn batch_req(self: &mut WidthCache) -> WidthBatchReq{\n        let pending_tok = self.widths.len();\n        WidthBatchReq {\n            cache: self,\n            pending_tok,\n            req: Vec::new(),\n            req_toks: Vec::new(),\n            req_ids: BTreeMap::new(),\n        }\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCache::len":["/// Returns the number of items currently in the cache.\npub(crate) fn len(&self) -> usize{\n        self.m.len()\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCache::new":["pub fn new() -> WidthCache{\n        WidthCache { m: HashMap::new(), widths: Vec::new() }\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCache::resolve":["/// Resolve a previously obtained token into a width value.\npub fn resolve(&self, tok: Token) -> Width{\n        self.widths[tok]\n    }","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthCacheKey":["struct WidthCacheKey<'a> {\n    id: StyleId,\n    s: Cow<'a, str>,\n}","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthMeasure":["/// A trait for types that provide width measurement. In the general case this\n/// will be provided by the frontend, but alternative implementations might\n/// be provided for faster measurement of 'fixed-width' fonts, or for testing.\npub trait WidthMeasure {\n    fn measure_width(&self, request: &[WidthReq]) -> Result<WidthResponse, xi_rpc::Error>;\n}","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::WidthReq":["/// A request for measuring the widths of strings all of the same style\n/// (a request from core to front-end).\npub struct WidthReq {\n    pub id: StyleId,\n    pub strings: Vec<String>,\n}","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"core-lib/src/width_cache.rs\"))"],"word_boundaries::WordBoundary":["enum WordBoundary {\n    Interior,\n    Start, // a boundary indicating the end of a word\n    End,   // a boundary indicating the start of a word\n    Both,\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordBoundary::is_boundary":["fn is_boundary(&self) -> bool{\n        *self != WordBoundary::Interior\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordBoundary::is_end":["fn is_end(&self) -> bool{\n        *self == WordBoundary::End || *self == WordBoundary::Both\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordBoundary::is_start":["fn is_start(&self) -> bool{\n        *self == WordBoundary::Start || *self == WordBoundary::Both\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordCursor":["pub struct WordCursor<'a> {\n    inner: Cursor<'a, RopeInfo>,\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordCursor::<'a>::new":["pub fn new(text: &'a Rope, pos: usize) -> WordCursor<'a>{\n        let inner = Cursor::new(text, pos);\n        WordCursor { inner }\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordCursor::<'a>::next_boundary":["/// Get next boundary, and set the cursor at the boundary found.\npub fn next_boundary(&mut self) -> Option<usize>{\n        if let Some(ch) = self.inner.next_codepoint() {\n            let mut prop = get_word_property(ch);\n            let mut candidate = self.inner.pos();\n            while let Some(next) = self.inner.next_codepoint() {\n                let prop_next = get_word_property(next);\n                if classify_boundary(prop, prop_next).is_end() {\n                    break;\n                }\n                prop = prop_next;\n                candidate = self.inner.pos();\n            }\n            self.inner.set(candidate);\n            return Some(candidate);\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordCursor::<'a>::prev_boundary":["/// Get previous boundary, and set the cursor at the boundary found.\npub fn prev_boundary(&mut self) -> Option<usize>{\n        if let Some(ch) = self.inner.prev_codepoint() {\n            let mut prop = get_word_property(ch);\n            let mut candidate = self.inner.pos();\n            while let Some(prev) = self.inner.prev_codepoint() {\n                let prop_prev = get_word_property(prev);\n                if classify_boundary(prop_prev, prop).is_start() {\n                    break;\n                }\n                prop = prop_prev;\n                candidate = self.inner.pos();\n            }\n            self.inner.set(candidate);\n            return Some(candidate);\n        }\n        None\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordCursor::<'a>::select_word":["/// Return the selection for the word containing the current cursor. The\n/// cursor is moved to the end of that selection.\npub fn select_word(&mut self) -> (usize, usize){\n        let initial = self.inner.pos();\n        let init_prop_after = self.inner.next_codepoint().map(get_word_property);\n        self.inner.set(initial);\n        let init_prop_before = self.inner.prev_codepoint().map(get_word_property);\n        let mut start = initial;\n        let init_boundary = if let (Some(pb), Some(pa)) = (init_prop_before, init_prop_after) {\n            classify_boundary_initial(pb, pa)\n        } else {\n            WordBoundary::Both\n        };\n        let mut prop_after = init_prop_after;\n        let mut prop_before = init_prop_before;\n        if prop_after.is_none() {\n            start = self.inner.pos();\n            prop_after = prop_before;\n            prop_before = self.inner.prev_codepoint().map(get_word_property);\n        }\n        while let (Some(pb), Some(pa)) = (prop_before, prop_after) {\n            if start == initial {\n                if init_boundary.is_start() {\n                    break;\n                }\n            } else if !init_boundary.is_boundary() {\n                if classify_boundary(pb, pa).is_boundary() {\n                    break;\n                }\n            } else if classify_boundary(pb, pa).is_start() {\n                break;\n            }\n            start = self.inner.pos();\n            prop_after = prop_before;\n            prop_before = self.inner.prev_codepoint().map(get_word_property);\n        }\n        self.inner.set(initial);\n        let mut end = initial;\n        prop_after = init_prop_after;\n        prop_before = init_prop_before;\n        if prop_before.is_none() {\n            prop_before = self.inner.next_codepoint().map(get_word_property);\n            end = self.inner.pos();\n            prop_after = self.inner.next_codepoint().map(get_word_property);\n        }\n        while let (Some(pb), Some(pa)) = (prop_before, prop_after) {\n            if end == initial {\n                if init_boundary.is_end() {\n                    break;\n                }\n            } else if !init_boundary.is_boundary() {\n                if classify_boundary(pb, pa).is_boundary() {\n                    break;\n                }\n            } else if classify_boundary(pb, pa).is_end() {\n                break;\n            }\n            end = self.inner.pos();\n            prop_before = prop_after;\n            prop_after = self.inner.next_codepoint().map(get_word_property);\n        }\n        self.inner.set(end);\n        (start, end)\n    }","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::WordProperty":["enum WordProperty {\n    Lf,\n    Space,\n    Punctuation,\n    Other, // includes letters and all of non-ascii unicode\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::classify_boundary":["fn classify_boundary(prev: WordProperty, next: WordProperty) -> WordBoundary{\n    use self::WordBoundary::*;\n    use self::WordProperty::*;\n    match (prev, next) {\n        (Lf, _) => Both,\n        (_, Lf) => Both,\n        (Space, Other) => Start,\n        (Space, Punctuation) => Start,\n        (Punctuation, Other) => Start,\n        (Other, Space) => End,\n        (Punctuation, Space) => End,\n        (Other, Punctuation) => End,\n        _ => Interior,\n    }\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::classify_boundary_initial":["fn classify_boundary_initial(prev: WordProperty, next: WordProperty) -> WordBoundary{\n    use self::WordBoundary::*;\n    use self::WordProperty::*;\n    match (prev, next) {\n        (Lf, Other) => Start,\n        (Other, Lf) => End,\n        (Lf, Space) => Interior,\n        (Lf, Punctuation) => Interior,\n        (Space, Lf) => Interior,\n        (Punctuation, Lf) => Interior,\n        (Space, Punctuation) => Interior,\n        (Punctuation, Space) => Interior,\n        _ => classify_boundary(prev, next),\n    }\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"],"word_boundaries::get_word_property":["fn get_word_property(codepoint: char) -> WordProperty{\n    if codepoint <= ' ' {\n        // TODO: deal with \\r\n        if codepoint == '\\n' {\n            return WordProperty::Lf;\n        }\n        return WordProperty::Space;\n    } else if codepoint <= '\\u{3f}' {\n        // Hardcoded: !\"#$%&'()*+,-./:;<=>?\n        if (0xfc00fffe00000000u64 >> (codepoint as u32)) & 1 != 0 {\n            return WordProperty::Punctuation;\n        }\n    } else if codepoint <= '\\u{7f}' {\n        // Hardcoded: @[\\]^`{|}~\n        if (0x7800000178000001u64 >> ((codepoint as u32) & 0x3f)) & 1 != 0 {\n            return WordProperty::Punctuation;\n        }\n    }\n    WordProperty::Other\n}","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))"]},"struct_constructor":{"&'static str":["get_tab_text","n_spaces"],"&[line_cache_shadow::Span]":["spans"],"&[selection::SelRegion]":["deref","regions_in_range","sel_regions"],"&file::FileInfo":["get_info"],"&layers::Layers":["get_layers"],"&linewrap::Lines":["get_lines"],"&mut layers::Layers":["get_layers_mut"],"&mut serde_json::Value":["params_ref_mut"],"&mut watcher::FileWatcher":["watcher"],"&selection::SelRegion":["last_selection_region"],"&selection::Selection":["occurrences"],"&serde_json::Value":["get","params_ref"],"&str":["as_ref","as_str","borrow","file_stem","get_theme_name","method_ref"],"&styles::Style":["get_default_style"],"&syntect::highlighting::ThemeSettings":["get_theme_settings"],"(std::string::String, syntect::highlighting::Theme)":["try_load_from_dump"],"(usize, bool)":["next"],"(usize, std::option::Option<usize>)":["vertical_motion","vertical_motion_exact_pos"],"(usize, usize)":["add_range_distinct","logical_line_range","next","offset_to_line_col","select_word","selection_position"],"(xi_rope::Delta<xi_rope::RopeInfo>, selection::Selection)":["capitalize_text"],"(xi_rope::Delta<xi_rope::RopeInfo>, std::option::Option<xi_rope::tree::Node<xi_rope::RopeInfo>>)":["delete_by_movement"],"(xi_rope::Delta<xi_rope::RopeInfo>, xi_rope::tree::Node<xi_rope::RopeInfo>, selection::InsertDrift)":["commit_delta"],"(xi_rope::Interval, xi_rope::tree::Node<xi_rope::RopeInfo>)":["sel_region_to_interval_and_rope"],"(xi_rope::tree::Node<xi_rope::RopeInfo>, file::FileInfo)":["try_load_file"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_seq"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<S as serde::Serializer>::Ok":["serialize"],"<__S as serde::Serializer>::Ok":["serialize"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["deserialize"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["deserialize"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor<'de, T> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<index_set::MinusIter<'a> as std::iter::Iterator>::Item":["next_back"],"<plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_newtype_struct","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":["deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":["deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":["deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":["deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":["deserialize"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":["deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_enum"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_newtype_struct","visit_seq"],"<tabs::Iter<'a, I> as std::iter::Iterator>::Item":["next"],"<tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_newtype_struct","visit_seq"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"annotations::AnnotationRange":["clone","default","deserialize"],"annotations::AnnotationSlice":["clone","deserialize","get_annotations","new"],"annotations::AnnotationStore":["new"],"annotations::AnnotationType":["clone","deserialize"],"annotations::Annotations":["clone"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":["deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":["deserialize"],"bool":["applies_to_path","at_eof","breaks_undo_group","check_file","close_view","contains_theme","deselect_at_offset","differs_in_kind","eof_without_newline","eq","find_in_progress","has_pending_render","hls_dirty","init_cache_dir","interval_needs_wrap","is_boundary","is_caret","is_converged","is_end","is_global","is_hard_break","is_matching_whole_words","is_multiline_regex","is_point_in_selection","is_pristine","is_recording","is_request","is_start","is_upstream","is_waiting","needs_more_wrap","needs_render","needs_wrap_in_visible_region","set_detected","set_user","should_merge","validate_theme_file","wants_event"],"client::Client":["new"],"client::OpType":["clone"],"client::UpdateOp":["copy","insert","invalidate","skip","update"],"config::BufferItems":["clone","deserialize"],"config::Config":["clone","deserialize","generate_buffer_config","into_config"],"config::ConfigDomain":["clone","deserialize","domain_for_path","from"],"config::ConfigDomainExternal":["clone","deserialize"],"config::ConfigError":["from"],"config::ConfigManager":["new"],"config::ConfigPair":["new_with_base","with_base"],"config::LanguageTag":["clone","new"],"config::TableStack":["clone","default"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":["deserialize"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":["deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":["deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":["deserialize"],"core::WeakXiCore":["clone","weak_self"],"core::XiCore":["new","upgrade"],"edit_ops::IndentDirection":["clone"],"edit_types::BufferEvent":["clone"],"edit_types::EventDomain":["clone","from"],"edit_types::SpecialEvent":["clone"],"edit_types::ViewEvent":["clone"],"editor::EditType":["clone","deserialize","get_edit_type"],"editor::Editor":["new","with_text"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":["deserialize"],"event_context::EventContext":["make_context"],"f64":["resolve"],"file::CharacterEncoding":["clone","guess"],"file::FileManager":["new"],"find::Find":["new"],"find::FindStatus":["deserialize","find_status"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":["deserialize"],"i64":["error_code"],"impl std::iter::Iterator<Item = &'a std::string::String>":["iter_names"],"impl std::iter::Iterator<Item = &std::sync::Arc<syntax::LanguageDefinition>>":["iter"],"impl std::iter::Iterator<Item = annotations::AnnotationSlice> + 'c":["iter_range"],"impl std::iter::Iterator<Item = linewrap::VisualLine> + 'a":["iter_lines"],"impl std::iter::Iterator<Item = std::sync::Arc<plugins::manifest::PluginDescription>> + 'a":["iter"],"index_set::IndexSet":["apply_delta","new"],"index_set::MinusIter":["minus_one_range"],"isize":["scroll_height"],"layers::Layers":["default"],"layers::ScopeLayer":["default","new","remove_layer"],"line_cache_shadow::Builder":["new"],"line_cache_shadow::LineCacheShadow":["build","default"],"line_cache_shadow::PlanIterator":["iter_with_plan"],"line_cache_shadow::PlanSegment":["next"],"line_cache_shadow::RenderPlan":["create"],"line_cache_shadow::RenderTactic":["clone"],"line_ending::LineEnding":["clone","parse","parse_chunk"],"linewrap::InvalLines":["after_edit","rewrap_chunk"],"linewrap::LineBreakCursor":["new"],"linewrap::Lines":["default"],"linewrap::MergedBreaks":["new"],"linewrap::RewrapCtx":["new"],"linewrap::VisualLine":["new","next"],"linewrap::WrapSummary":["do_wrap_task"],"linewrap::WrapWidth":["clone","default"],"movement::Movement":["clone"],"notify::RecursiveMode":["mode_from_bool"],"plugins::PluginPid":["clone","default","deserialize","next_plugin_id"],"plugins::catalog::PluginCatalog":["clone","default"],"plugins::catalog::PluginLoadError":["from"],"plugins::manifest::ArgumentOption":["clone","deserialize","new"],"plugins::manifest::ArgumentType":["clone","deserialize"],"plugins::manifest::Command":["clone","deserialize","new"],"plugins::manifest::CommandArgument":["clone","deserialize","new"],"plugins::manifest::PlaceholderRpc":["clone","deserialize","new"],"plugins::manifest::PluginActivation":["clone","deserialize"],"plugins::manifest::PluginDescription":["clone","deserialize","load_manifest"],"plugins::manifest::PluginScope":["clone","default","deserialize"],"plugins::manifest::RpcType":["clone","deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":["deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":["deserialize"],"plugins::rpc::ClientPluginInfo":["deserialize"],"plugins::rpc::DataSpan":["clone","deserialize"],"plugins::rpc::EmptyStruct":["clone","deserialize"],"plugins::rpc::GetDataResponse":["deserialize","plugin_get_data"],"plugins::rpc::HostNotification":["clone","deserialize"],"plugins::rpc::HostRequest":["clone","deserialize"],"plugins::rpc::Hover":["clone","deserialize"],"plugins::rpc::PluginBufferInfo":["clone","deserialize","new","plugin_info"],"plugins::rpc::PluginCommand":["deserialize"],"plugins::rpc::PluginEdit":["clone","deserialize"],"plugins::rpc::PluginNotification":["clone","deserialize"],"plugins::rpc::PluginRequest":["clone","deserialize"],"plugins::rpc::PluginUpdate":["clone","deserialize","new"],"plugins::rpc::Range":["clone","deserialize"],"plugins::rpc::ScopeSpan":["clone","deserialize"],"plugins::rpc::TextUnit":["clone","deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":["deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":["deserialize"],"recorder::Recorder":["new"],"recorder::Recording":["new"],"rpc::CoreNotification":["deserialize"],"rpc::CoreRequest":["deserialize"],"rpc::EditCommand":["clone","deserialize"],"rpc::EditNotification":["deserialize"],"rpc::EditRequest":["deserialize"],"rpc::EmptyStruct":["deserialize"],"rpc::FindQuery":["clone","deserialize"],"rpc::GestureType":["clone","deserialize"],"rpc::LineRange":["clone","deserialize"],"rpc::MouseAction":["clone","deserialize"],"rpc::PluginNotification":["deserialize"],"rpc::Position":["clone","deserialize"],"rpc::SelectionGranularity":["clone","deserialize"],"rpc::SelectionModifier":["clone","default","deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":["deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":["deserialize"],"selection::Affinity":["clone","default"],"selection::InsertDrift":["clone"],"selection::SelRegion":["caret","clone","from","new","next_occurrence","range_region"],"selection::Selection":["apply_delta","clone","default","from","new","new_simple","selection_movement"],"serde_json::Map":["add_buffer","changes_from","collate","detect_whitespace","diff","do_get_config","load","load_base_config","load_user_config_file","override_language","platform_overrides","table_from_toml_str","to_table","try_load_from_file","update_buffer_config","update_buffer_path"],"serde_json::Value":["client_request","collect_trace","do_copy","do_cut","do_edit_sync","do_new_view","do_plugin_cmd_sync","encode_line","from_toml_value","handle_request","plugin_request","to_json"],"std::borrow::Cow":["extract_sel_regions","get_rev"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::VecDeque":["take_events"],"std::ops::Range":["get_line_range"],"std::path::PathBuf":["base_config_file_path","get_dump_path","get_plugins_dir","get_themes_dir","platform_exec_path"],"std::string::String":["load_theme_info_from_path","remove_theme"],"std::sync::Arc":["get_from_path","get_named","language_for_name","language_for_path"],"std::sync::MutexGuard":["inner"],"std::time::SystemTime":["get_mod_time"],"std::vec::Vec":["_test_open_editors","_test_open_views","difference","encode_styles","find_all_manifests","find_status","get_plugin_paths","get_theme_names","measure_width","selected_line_ranges","set_user_config","styles_for_stacks","update_all_buffer_configs"],"styles::Style":["clone","default","default_for_theme","deserialize","from_syntect_style_mod","merge","merge_with_default","new"],"styles::ThemeStyleMap":["new"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":["deserialize"],"syntax::LanguageDefinition":["clone","deserialize"],"syntax::LanguageId":["clone","default","deserialize","from","get_buffer_language","language_for_path","resolve"],"syntax::Languages":["default","make_languages_map","new"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":["deserialize"],"syntect::highlighting::Highlighter":["get_highlighter"],"tabs::BufferId":["clone","deserialize","get_buffer_id","get_editor","new","new_buffer_id","next_buffer_id"],"tabs::CoreState":["new"],"tabs::Counter":["default"],"tabs::Iter":["iter_groups"],"tabs::ViewId":["clone","deserialize","from","get_view_id","new_view_id","next_view_id"],"u32":["get_permissions","rgba_from_syntect_color"],"u64":["get_head_rev_token"],"usize":["add","calculate_undo_group","count_lines","deserialize_tab_size","extract_count","from","get_active_undo_group","get_caret_offset","get_or_def_style_id","get_resolved_position","id","len","lookup","max","min","next","next_boundary","offset_for_delete_backwards","plugin_n_lines","prev_boundary","scroll_height"],"view::FindProgress":["clone"],"view::Replace":["clone","default","deserialize","get_replace"],"view::Size":["clone","default","deserialize"],"view::View":["new"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":["deserialize"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":["deserialize"],"watcher::FileWatcher":["new"],"watcher::WatchToken":["clone"],"watcher::WatcherState":["default"],"whitespace::Indentation":["clone","parse","parse_line"],"width_cache::WidthBatchReq":["batch_req"],"width_cache::WidthCache":["new"],"width_cache::WidthReq":["deserialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":["deserialize"],"word_boundaries::WordBoundary":["classify_boundary","classify_boundary_initial"],"word_boundaries::WordCursor":["new"],"word_boundaries::WordProperty":["clone","get_word_property"],"xi_rope::Delta":["change_number","delete_backward","delete_sel_regions","delta_rev_head","duplicate_line","indent","insert","insert_newline","insert_tab","modify_indent","outdent","surround","transform_text","transpose"],"xi_rope::Interval":["from","get_next_task","interval_of_visible_region","unit"],"xi_rope::tree::Node":["do_get_contents","open","text_for_save","try_decode"],"xi_rpc::RemoteError":["from"]},"struct_to_trait":{"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["serde::Deserialize"],"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["serde::Deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["serde::Deserialize"],"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":["serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":["serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":["serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor":["serde::de::Visitor"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":["serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":["serde::Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":["serde::Deserialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor":["serde::de::Visitor"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":["serde::Deserialize"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor":["serde::de::Visitor"],"<rpc::MouseAction as serde::Serialize>::serialize::Helper":["serde::Serialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":["serde::Deserialize"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor":["serde::de::Visitor"],"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor":["serde::de::Visitor"],"annotations::AnnotationRange":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"annotations::AnnotationSlice":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"annotations::AnnotationType":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"annotations::Annotations":["std::clone::Clone","std::fmt::Debug"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":["serde::Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor":["serde::de::Visitor"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor":["serde::de::Visitor"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":["serde::Deserialize"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor":["serde::de::Visitor"],"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor":["serde::de::Visitor"],"backspace::offset_for_delete_backwards::State":["std::cmp::PartialEq","std::marker::StructuralPartialEq"],"client::Client":["width_cache::WidthMeasure"],"client::OpType":["serde::Serialize","std::clone::Clone","std::fmt::Debug"],"client::Update":["serde::Serialize","std::fmt::Debug"],"client::UpdateOp":["serde::Serialize","std::fmt::Debug"],"config::BufferItems":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"config::Config":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"],"config::ConfigDomain":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"config::ConfigDomainExternal":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"config::ConfigError":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"config::ConfigManager":["std::fmt::Debug"],"config::ConfigPair":["std::fmt::Debug"],"config::LanguageTag":["std::clone::Clone","std::fmt::Debug"],"config::TableStack":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":["serde::Deserialize"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":["serde::Deserialize"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":["serde::Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":["serde::Deserialize"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor":["serde::de::Visitor"],"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor":["serde::de::Visitor"],"core::WeakXiCore":["std::clone::Clone","xi_rpc::Handler"],"core::XiCore":["xi_rpc::Handler"],"edit_ops::IndentDirection":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"edit_types::BufferEvent":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"edit_types::EventDomain":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"edit_types::SpecialEvent":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"edit_types::ViewEvent":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"editor::EditType":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":["serde::Deserialize"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor":["serde::de::Visitor"],"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor":["serde::de::Visitor"],"file::CharacterEncoding":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"file::FileError":["std::fmt::Display"],"file::FileInfo":["std::fmt::Debug"],"find::Find":["annotations::ToAnnotation"],"find::FindStatus":["serde::Deserialize","serde::Serialize","std::fmt::Debug"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":["serde::Deserialize"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor":["serde::de::Visitor"],"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor":["serde::de::Visitor"],"index_set::MinusIter":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"layers::Layers":["std::default::Default"],"layers::ScopeLayer":["std::default::Default"],"line_cache_shadow::LineCacheShadow":["std::default::Default","std::fmt::Debug"],"line_cache_shadow::PlanIterator":["std::iter::Iterator"],"line_cache_shadow::RenderTactic":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq"],"line_cache_shadow::Span":["std::fmt::Debug"],"line_ending::LineEnding":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"line_ending::MixedLineEndingError":["std::fmt::Debug"],"line_offset::LogicalLines":["line_offset::LineOffset"],"linewrap::Lines":["line_offset::LineOffset","std::default::Default"],"linewrap::MergedBreaks":["std::iter::Iterator"],"linewrap::VisualLines":["std::iter::Iterator"],"linewrap::WrapWidth":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"movement::Movement":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"plugins::PluginPid":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::catalog::PluginCatalog":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"plugins::catalog::PluginLoadError":["std::convert::From","std::fmt::Debug"],"plugins::manifest::ArgumentOption":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"plugins::manifest::ArgumentType":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"plugins::manifest::Command":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::manifest::CommandArgument":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::manifest::PlaceholderRpc":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"plugins::manifest::PluginActivation":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::manifest::PluginDescription":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::manifest::PluginScope":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::default::Default","std::fmt::Debug"],"plugins::manifest::RpcType":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":["serde::Deserialize"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::ClientPluginInfo":["serde::Deserialize","serde::Serialize","std::fmt::Debug"],"plugins::rpc::DataSpan":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::EmptyStruct":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::GetDataResponse":["serde::Deserialize","serde::Serialize","std::fmt::Debug"],"plugins::rpc::HostNotification":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::HostRequest":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::Hover":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::PluginBufferInfo":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::PluginCommand":["serde::Deserialize","serde::Serialize"],"plugins::rpc::PluginEdit":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::PluginNotification":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::PluginRequest":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::PluginUpdate":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::Range":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"plugins::rpc::ScopeSpan":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"plugins::rpc::TextUnit":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed":["serde::de::DeserializeSeed"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed":["serde::de::DeserializeSeed"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed":["serde::de::DeserializeSeed"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed":["serde::de::DeserializeSeed"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":["serde::Deserialize"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor":["serde::de::Visitor"],"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged":["serde::Serialize"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged":["serde::Serialize"],"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged":["serde::Serialize"],"rpc::CoreNotification":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::CoreRequest":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::EditCommand":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::EditNotification":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::EditRequest":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::EmptyStruct":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::FindQuery":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::GestureType":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::LineRange":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::MouseAction":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::PluginNotification":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"rpc::Position":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::SelectionGranularity":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::SelectionModifier":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed":["serde::de::DeserializeSeed"],"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed":["serde::de::DeserializeSeed"],"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed":["serde::de::DeserializeSeed"],"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed":["serde::de::DeserializeSeed"],"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":["serde::Deserialize"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor":["serde::de::Visitor"],"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor":["serde::de::Visitor"],"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged":["serde::Serialize"],"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged":["serde::Serialize"],"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged":["serde::Serialize"],"selection::Affinity":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"selection::InsertDrift":["std::clone::Clone","std::marker::Copy"],"selection::SelRegion":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"selection::Selection":["annotations::ToAnnotation","std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::ops::Deref"],"styles::Style":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":["serde::Deserialize"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor":["serde::de::Visitor"],"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor":["serde::de::Visitor"],"syntax::LanguageDefinition":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"syntax::LanguageId":["serde::Deserialize","serde::Serialize","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"syntax::Languages":["std::default::Default","std::fmt::Debug"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":["serde::Deserialize"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor":["serde::de::Visitor"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor":["serde::de::Visitor"],"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor":["serde::de::Visitor"],"tabs::BufferId":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"tabs::Counter":["std::default::Default","std::fmt::Debug"],"tabs::Iter":["std::iter::Iterator"],"tabs::ViewId":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor":["serde::de::Visitor"],"view::FindProgress":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"view::FindStatusChange":["std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"view::Replace":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"view::Size":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"view::View":["line_offset::LineOffset"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":["serde::Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor":["serde::de::Visitor"],"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor":["serde::de::Visitor"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":["serde::Deserialize"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor":["serde::de::Visitor"],"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor":["serde::de::Visitor"],"watcher::WatchToken":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"watcher::Watchee":["std::fmt::Debug"],"watcher::WatcherState":["std::default::Default","std::fmt::Debug"],"whitespace::Indentation":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"whitespace::MixedIndentError":["std::fmt::Debug"],"width_cache::CodepointMono":["width_cache::WidthMeasure"],"width_cache::WidthCacheKey":["std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"width_cache::WidthReq":["serde::Deserialize","serde::Serialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":["serde::Deserialize"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor":["serde::de::Visitor"],"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor":["serde::de::Visitor"],"word_boundaries::WordBoundary":["std::cmp::Eq","std::cmp::PartialEq","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"word_boundaries::WordProperty":["std::clone::Clone","std::marker::Copy"],"xi_rope::Interval":["std::convert::From"],"xi_rope::breaks::Breaks":["line_offset::LineOffset"],"xi_rpc::RemoteError":["std::convert::From"],"xi_rpc::RpcPeer":["watcher::Notify"]},"targets":{"<annotations::AnnotationRange as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))","serde::Deserialize"],"<annotations::AnnotationRange as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/annotations.rs\"))","serde::Serialize"],"<client::Client as width_cache::WidthMeasure>::measure_width":["measure_width","Real(LocalPath(\"core-lib/src/width_cache.rs\"))","width_cache::WidthMeasure"],"<config::Config<T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"core-lib/src/config.rs\"))","std::cmp::PartialEq"],"<config::ConfigDomain as std::convert::From<syntax::LanguageId>>::from":["from","Real(LocalPath(\"core-lib/src/config.rs\"))","std::convert::From"],"<config::ConfigDomain as std::convert::From<tabs::BufferId>>::from":["from","Real(LocalPath(\"core-lib/src/config.rs\"))","std::convert::From"],"<config::ConfigError as std::convert::From<serde_json::Error>>::from":["from","Real(LocalPath(\"core-lib/src/config.rs\"))","std::convert::From"],"<config::ConfigError as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"core-lib/src/config.rs\"))","std::convert::From"],"<config::ConfigError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/config.rs\"))","std::fmt::Display"],"<core::WeakXiCore as xi_rpc::Handler>::handle_notification":["handle_notification","Real(LocalPath(\"core-lib/src/core.rs\"))","xi_rpc::Handler"],"<core::WeakXiCore as xi_rpc::Handler>::handle_request":["handle_request","Real(LocalPath(\"core-lib/src/core.rs\"))","xi_rpc::Handler"],"<core::XiCore as xi_rpc::Handler>::handle_notification":["handle_notification","Real(LocalPath(\"core-lib/src/core.rs\"))","xi_rpc::Handler"],"<core::XiCore as xi_rpc::Handler>::handle_request":["handle_request","Real(LocalPath(\"core-lib/src/core.rs\"))","xi_rpc::Handler"],"<core::XiCore as xi_rpc::Handler>::idle":["idle","Real(LocalPath(\"core-lib/src/core.rs\"))","xi_rpc::Handler"],"<edit_types::EventDomain as std::convert::From<edit_types::BufferEvent>>::from":["from","Real(LocalPath(\"core-lib/src/edit_types.rs\"))","std::convert::From"],"<edit_types::EventDomain as std::convert::From<edit_types::SpecialEvent>>::from":["from","Real(LocalPath(\"core-lib/src/edit_types.rs\"))","std::convert::From"],"<edit_types::EventDomain as std::convert::From<edit_types::ViewEvent>>::from":["from","Real(LocalPath(\"core-lib/src/edit_types.rs\"))","std::convert::From"],"<edit_types::EventDomain as std::convert::From<rpc::EditNotification>>::from":["from","Real(LocalPath(\"core-lib/src/edit_types.rs\"))","std::convert::From"],"<file::FileError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/file.rs\"))","std::fmt::Display"],"<find::Find as annotations::ToAnnotation>::get_annotations":["get_annotations","Real(LocalPath(\"core-lib/src/find.rs\"))","annotations::ToAnnotation"],"<index_set::MinusIter<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"core-lib/src/index_set.rs\"))","std::iter::DoubleEndedIterator"],"<index_set::MinusIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"core-lib/src/index_set.rs\"))","std::iter::Iterator"],"<layers::ScopeLayer as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/layers.rs\"))","std::default::Default"],"<line_cache_shadow::LineCacheShadow as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))","std::default::Default"],"<line_cache_shadow::PlanIterator<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))","std::iter::Iterator"],"<line_cache_shadow::Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))","std::fmt::Debug"],"<linewrap::Lines as line_offset::LineOffset>::line_of_offset":["line_of_offset","Real(LocalPath(\"core-lib/src/line_offset.rs\"))","line_offset::LineOffset"],"<linewrap::Lines as line_offset::LineOffset>::offset_of_line":["offset_of_line","Real(LocalPath(\"core-lib/src/line_offset.rs\"))","line_offset::LineOffset"],"<linewrap::MergedBreaks<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"core-lib/src/linewrap.rs\"))","std::iter::Iterator"],"<linewrap::VisualLines<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"core-lib/src/linewrap.rs\"))","std::iter::Iterator"],"<linewrap::WrapWidth as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/linewrap.rs\"))","std::default::Default"],"<plugins::PluginPid as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))","std::fmt::Display"],"<plugins::catalog::PluginLoadError as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))","std::convert::From"],"<plugins::catalog::PluginLoadError as std::convert::From<toml::de::Error>>::from":["from","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))","std::convert::From"],"<plugins::manifest::PluginScope as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))","std::default::Default"],"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))","serde::Deserialize"],"<plugins::rpc::PluginCommand<T> as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))","serde::Serialize"],"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Deserialize"],"<rpc::EditCommand<T> as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Serialize"],"<rpc::LineRange as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Deserialize"],"<rpc::LineRange as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Serialize"],"<rpc::MouseAction as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Deserialize"],"<rpc::MouseAction as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/rpc.rs\"))","serde::Serialize"],"<rpc::SelectionModifier as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/rpc.rs\"))","std::default::Default"],"<selection::Affinity as std::default::Default>::default":["default","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::default::Default"],"<selection::SelRegion as std::convert::From<xi_rope::Interval>>::from":["from","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::convert::From"],"<selection::SelRegion as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::fmt::Display"],"<selection::Selection as annotations::ToAnnotation>::get_annotations":["get_annotations","Real(LocalPath(\"core-lib/src/selection.rs\"))","annotations::ToAnnotation"],"<selection::Selection as std::convert::From<selection::SelRegion>>::from":["from","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::convert::From"],"<selection::Selection as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::fmt::Display"],"<selection::Selection as std::ops::Deref>::deref":["deref","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::ops::Deref"],"<std::boxed::Box<(dyn xi_rpc::Peer + 'static)> as watcher::Notify>::notify":["notify","Real(LocalPath(\"core-lib/src/watcher.rs\"))","watcher::Notify"],"<styles::Style as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"core-lib/src/styles.rs\"))","std::fmt::Debug"],"<styles::Style as std::fmt::Debug>::fmt::fmt_color":["fmt_color","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"<syntax::LanguageId as std::borrow::Borrow<str>>::borrow":["borrow","Real(LocalPath(\"core-lib/src/syntax.rs\"))","std::borrow::Borrow"],"<syntax::LanguageId as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"core-lib/src/syntax.rs\"))","std::convert::AsRef"],"<syntax::LanguageId as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"core-lib/src/syntax.rs\"))","std::convert::From"],"<tabs::BufferId as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/tabs.rs\"))","std::fmt::Display"],"<tabs::Iter<'a, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"core-lib/src/tabs.rs\"))","std::iter::Iterator"],"<tabs::ViewId as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"core-lib/src/tabs.rs\"))","serde::Deserialize"],"<tabs::ViewId as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"core-lib/src/tabs.rs\"))","serde::Serialize"],"<tabs::ViewId as std::convert::From<usize>>::from":["from","Real(LocalPath(\"core-lib/src/tabs.rs\"))","std::convert::From"],"<tabs::ViewId as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"core-lib/src/tabs.rs\"))","std::fmt::Display"],"<view::View as line_offset::LineOffset>::line_of_offset":["line_of_offset","Real(LocalPath(\"core-lib/src/view.rs\"))","line_offset::LineOffset"],"<view::View as line_offset::LineOffset>::offset_of_line":["offset_of_line","Real(LocalPath(\"core-lib/src/view.rs\"))","line_offset::LineOffset"],"<watcher::Watchee as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"core-lib/src/watcher.rs\"))","std::fmt::Debug"],"<width_cache::CodepointMono as width_cache::WidthMeasure>::measure_width":["measure_width","Real(LocalPath(\"core-lib/src/width_cache.rs\"))","width_cache::WidthMeasure"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::line_of_offset":["line_of_offset","Real(LocalPath(\"core-lib/src/line_offset.rs\"))","line_offset::LineOffset"],"<xi_rope::tree::Node<xi_rope::breaks::BreaksInfo> as line_offset::LineOffset>::offset_of_line":["offset_of_line","Real(LocalPath(\"core-lib/src/line_offset.rs\"))","line_offset::LineOffset"],"annotations::AnnotationSlice::new":["new","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationSlice::to_json":["to_json","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationStore::clear":["clear","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationStore::invalidate":["invalidate","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationStore::iter_range":["iter_range","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationStore::new":["new","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationStore::update":["update","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::AnnotationType::as_str":["as_str","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::Annotations::invalidate":["invalidate","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"annotations::Annotations::update":["update","Real(LocalPath(\"core-lib/src/annotations.rs\"))",""],"backspace::offset_for_delete_backwards":["offset_for_delete_backwards","Real(LocalPath(\"core-lib/src/backspace.rs\"))",""],"client::Client::add_status_item":["add_status_item","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::alert":["alert","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::available_languages":["available_languages","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::available_plugins":["available_plugins","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::available_themes":["available_themes","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::config_changed":["config_changed","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::def_style":["def_style","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::find_status":["find_status","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::language_changed":["language_changed","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::measure_width":["measure_width","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::new":["new","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::plugin_started":["plugin_started","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::plugin_stopped":["plugin_stopped","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::remove_status_item":["remove_status_item","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::replace_status":["replace_status","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::schedule_idle":["schedule_idle","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::schedule_timer":["schedule_timer","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::scroll_to":["scroll_to","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::show_hover":["show_hover","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::theme_changed":["theme_changed","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::update_cmds":["update_cmds","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::update_status_item":["update_status_item","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::Client::update_view":["update_view","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::UpdateOp::copy":["copy","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::UpdateOp::insert":["insert","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::UpdateOp::invalidate":["invalidate","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::UpdateOp::skip":["skip","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"client::UpdateOp::update":["update","Real(LocalPath(\"core-lib/src/client.rs\"))",""],"config::Config::<T>::changes_from":["changes_from","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::Config::<T>::to_table":["to_table","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigDomain::file_stem":["file_stem","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::add_buffer":["add_buffer","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::base_config_file_path":["base_config_file_path","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::check_table":["check_table","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::domain_for_path":["domain_for_path","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::generate_buffer_config":["generate_buffer_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::get_buffer_config":["get_buffer_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::get_buffer_language":["get_buffer_language","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::get_plugin_paths":["get_plugin_paths","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::get_plugins_dir":["get_plugins_dir","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::get_themes_dir":["get_themes_dir","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::language_for_path":["language_for_path","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::load_user_config_file":["load_user_config_file","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::new":["new","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::override_language":["override_language","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::remove_buffer":["remove_buffer","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::set_languages":["set_languages","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::set_user_config":["set_user_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::table_for_update":["table_for_update","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::update_all_buffer_configs":["update_all_buffer_configs","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::update_buffer_config":["update_buffer_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigManager::update_buffer_path":["update_buffer_path","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigPair::new_with_base":["new_with_base","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigPair::rebuild":["rebuild","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigPair::set_table":["set_table","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigPair::table_for_update":["table_for_update","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::ConfigPair::with_base":["with_base","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::LanguageTag::new":["new","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::LanguageTag::resolve":["resolve","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::LanguageTag::set_detected":["set_detected","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::LanguageTag::set_user":["set_user","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::TableStack::collate":["collate","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::TableStack::diff":["diff","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::TableStack::get":["get","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::TableStack::into_config":["into_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::deserialize_tab_size":["deserialize_tab_size","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::from_toml_value":["from_toml_value","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::init_config_dir":["init_config_dir","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::load_base_config":["load_base_config","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::load_base_config::load":["load","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::load_base_config::platform_overrides":["platform_overrides","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::table_from_toml_str":["table_from_toml_str","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"config::try_load_from_file":["try_load_from_file","Real(LocalPath(\"core-lib/src/config.rs\"))",""],"core::WeakXiCore::handle_plugin_update":["handle_plugin_update","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::WeakXiCore::plugin_connect":["plugin_connect","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::WeakXiCore::plugin_exit":["plugin_exit","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::WeakXiCore::upgrade":["upgrade","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::XiCore::inner":["inner","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::XiCore::is_waiting":["is_waiting","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::XiCore::new":["new","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"core::XiCore::weak_self":["weak_self","Real(LocalPath(\"core-lib/src/core.rs\"))",""],"edit_ops::capitalize_text":["capitalize_text","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::change_number":["change_number","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::delete_backward":["delete_backward","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::delete_by_movement":["delete_by_movement","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::delete_sel_regions":["delete_sel_regions","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::duplicate_line":["duplicate_line","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::extract_sel_regions":["extract_sel_regions","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::get_tab_text":["get_tab_text","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::indent":["indent","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::insert":["insert","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::insert_newline":["insert_newline","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::insert_tab":["insert_tab","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::last_selection_region":["last_selection_region","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::modify_indent":["modify_indent","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::n_spaces":["n_spaces","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::outdent":["outdent","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::sel_region_to_interval_and_rope":["sel_region_to_interval_and_rope","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::surround":["surround","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::transform_text":["transform_text","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"edit_ops::transpose":["transpose","Real(LocalPath(\"core-lib/src/edit_ops.rs\"))",""],"editor::EditType::breaks_undo_group":["breaks_undo_group","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::add_delta":["add_delta","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::apply_plugin_edit":["apply_plugin_edit","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::calculate_undo_group":["calculate_undo_group","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::commit_delta":["commit_delta","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::dec_revs_in_flight":["dec_revs_in_flight","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::delta_rev_head":["delta_rev_head","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_capitalize_text":["do_capitalize_text","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_change_number":["do_change_number","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_copy":["do_copy","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_cut":["do_cut","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_delete_backward":["do_delete_backward","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_delete_by_movement":["do_delete_by_movement","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_duplicate_line":["do_duplicate_line","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_edit":["do_edit","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_insert":["do_insert","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_insert_newline":["do_insert_newline","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_insert_tab":["do_insert_tab","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_modify_indent":["do_modify_indent","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_paste":["do_paste","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_redo":["do_redo","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_replace":["do_replace","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_transform_text":["do_transform_text","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_transpose":["do_transpose","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_undo":["do_undo","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::do_yank":["do_yank","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::gc_undos":["gc_undos","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_active_undo_group":["get_active_undo_group","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_buffer":["get_buffer","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_edit_type":["get_edit_type","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_head_rev_token":["get_head_rev_token","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_layers":["get_layers","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_layers_mut":["get_layers_mut","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::get_rev":["get_rev","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::increment_revs_in_flight":["increment_revs_in_flight","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::is_pristine":["is_pristine","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::merge_new_state":["merge_new_state","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::new":["new","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::plugin_get_data":["plugin_get_data","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::plugin_n_lines":["plugin_n_lines","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::reload":["reload","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::set_force_undo_group":["set_force_undo_group","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::set_pristine":["set_pristine","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::set_session_id":["set_session_id","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::sync_state_changed":["sync_state_changed","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::theme_changed":["theme_changed","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::update_annotations":["update_annotations","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::update_edit_type":["update_edit_type","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::update_spans":["update_spans","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::update_undos":["update_undos","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::Editor::with_text":["with_text","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::count_lines":["count_lines","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"editor::last_selection_region":["last_selection_region","Real(LocalPath(\"core-lib/src/editor.rs\"))",""],"event_context::EventContext::<'a>::_finish_delayed_render":["_finish_delayed_render","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::after_edit":["after_edit","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::after_save":["after_save","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::close_view":["close_view","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::config_changed":["config_changed","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::dispatch_event":["dispatch_event","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_debug_toggle_comment":["do_debug_toggle_comment","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_edit":["do_edit","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_edit_sync":["do_edit_sync","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_incremental_find":["do_incremental_find","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_plugin_cmd":["do_plugin_cmd","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_plugin_cmd_sync":["do_plugin_cmd_sync","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_plugin_update":["do_plugin_update","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_reindent":["do_reindent","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_request_hover":["do_request_hover","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_request_lines":["do_request_lines","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_rewrap_batch":["do_rewrap_batch","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_show_hover":["do_show_hover","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::do_special":["do_special","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::find":["find","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::finish_init":["finish_init","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::get_resolved_position":["get_resolved_position","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::language_changed":["language_changed","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::plugin_info":["plugin_info","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::plugin_started":["plugin_started","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::plugin_stopped":["plugin_stopped","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::reload":["reload","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::render":["render","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::render_if_needed":["render_if_needed","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::rewrap":["rewrap","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::schedule_find":["schedule_find","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::schedule_rewrap":["schedule_rewrap","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::selected_line_ranges":["selected_line_ranges","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::text_for_save":["text_for_save","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::update_plugins":["update_plugins","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::update_views":["update_views","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::update_wrap_settings":["update_wrap_settings","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::view_init":["view_init","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::with_each_plugin":["with_each_plugin","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::with_editor":["with_editor","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"event_context::EventContext::<'a>::with_view":["with_view","Real(LocalPath(\"core-lib/src/event_context.rs\"))",""],"file::<impl std::convert::From<file::FileError> for xi_rpc::RemoteError>::from":["from","Real(LocalPath(\"core-lib/src/file.rs\"))","std::convert::From"],"file::CharacterEncoding::guess":["guess","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileError::error_code":["error_code","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::check_file":["check_file","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::close":["close","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::get_editor":["get_editor","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::get_info":["get_info","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::new":["new","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::open":["open","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::save":["save","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::save_existing":["save_existing","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::save_new":["save_new","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::FileManager::watcher":["watcher","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::get_mod_time":["get_mod_time","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::get_permissions":["get_permissions","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::try_decode":["try_decode","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::try_load_file":["try_load_file","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"file::try_save":["try_save","Real(LocalPath(\"core-lib/src/file.rs\"))",""],"find::Find::find_status":["find_status","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::hls_dirty":["hls_dirty","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::id":["id","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::is_matching_whole_words":["is_matching_whole_words","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::is_multiline_regex":["is_multiline_regex","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::new":["new","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::next_occurrence":["next_occurrence","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::occurrences":["occurrences","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::set_find":["set_find","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::set_hls_dirty":["set_hls_dirty","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::unset":["unset","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::update_find":["update_find","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"find::Find::update_highlights":["update_highlights","Real(LocalPath(\"core-lib/src/find.rs\"))",""],"index_set::IndexSet::apply_delta":["apply_delta","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::IndexSet::clear":["clear","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::IndexSet::delete_range":["delete_range","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::IndexSet::minus_one_range":["minus_one_range","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::IndexSet::new":["new","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::IndexSet::union_one_range":["union_one_range","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"index_set::remove_n_at":["remove_n_at","Real(LocalPath(\"core-lib/src/index_set.rs\"))",""],"layers::Layers::add_scopes":["add_scopes","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::create_if_missing":["create_if_missing","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::debug_print_spans":["debug_print_spans","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::get_merged":["get_merged","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::remove_layer":["remove_layer","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::resolve_styles":["resolve_styles","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::theme_changed":["theme_changed","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::update_all":["update_all","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::Layers::update_layer":["update_layer","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::add_scopes":["add_scopes","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::blank_scopes":["blank_scopes","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::new":["new","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::styles_for_stacks":["styles_for_stacks","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::theme_changed":["theme_changed","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::update_scopes":["update_scopes","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"layers::ScopeLayer::update_styles":["update_styles","Real(LocalPath(\"core-lib/src/layers.rs\"))",""],"line_cache_shadow::Builder::add_span":["add_span","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::Builder::build":["build","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::Builder::new":["new","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::Builder::set_dirty":["set_dirty","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::LineCacheShadow::edit":["edit","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::LineCacheShadow::iter_with_plan":["iter_with_plan","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::LineCacheShadow::needs_render":["needs_render","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::LineCacheShadow::partial_invalidate":["partial_invalidate","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::LineCacheShadow::spans":["spans","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::RenderPlan::create":["create","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_cache_shadow::RenderPlan::request_lines":["request_lines","Real(LocalPath(\"core-lib/src/line_cache_shadow.rs\"))",""],"line_ending::LineEnding::parse":["parse","Real(LocalPath(\"core-lib/src/line_ending.rs\"))",""],"line_ending::LineEnding::parse_chunk":["parse_chunk","Real(LocalPath(\"core-lib/src/line_ending.rs\"))",""],"line_offset::LineOffset::get_line_range":["get_line_range","Real(LocalPath(\"core-lib/src/line_offset.rs\"))",""],"line_offset::LineOffset::line_col_to_offset":["line_col_to_offset","Real(LocalPath(\"core-lib/src/line_offset.rs\"))",""],"line_offset::LineOffset::line_of_offset":["line_of_offset","Real(LocalPath(\"core-lib/src/line_offset.rs\"))",""],"line_offset::LineOffset::offset_of_line":["offset_of_line","Real(LocalPath(\"core-lib/src/line_offset.rs\"))",""],"line_offset::LineOffset::offset_to_line_col":["offset_to_line_col","Real(LocalPath(\"core-lib/src/line_offset.rs\"))",""],"linewrap::LineBreakCursor::<'a>::new":["new","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::LineBreakCursor::<'a>::next":["next","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::add_task":["add_task","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::after_edit":["after_edit","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::do_wrap_task":["do_wrap_task","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::get_next_task":["get_next_task","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::interval_needs_wrap":["interval_needs_wrap","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::is_converged":["is_converged","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::iter_lines":["iter_lines","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::logical_line_range":["logical_line_range","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::offset_of_visual_line":["offset_of_visual_line","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::patchup_tasks":["patchup_tasks","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::rewrap_chunk":["rewrap_chunk","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::set_wrap_width":["set_wrap_width","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::update_tasks_after_wrap":["update_tasks_after_wrap","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::Lines::visual_line_of_offset":["visual_line_of_offset","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::at_eof":["at_eof","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::eof_without_newline":["eof_without_newline","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::is_hard_break":["is_hard_break","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::new":["new","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::offset_of_line":["offset_of_line","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::offset_of_line_bsearch":["offset_of_line_bsearch","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::offset_of_line_linear":["offset_of_line_linear","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::MergedBreaks::<'a>::set_offset":["set_offset","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::RewrapCtx::<'a>::new":["new","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::RewrapCtx::<'a>::refill_pot_breaks":["refill_pot_breaks","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::RewrapCtx::<'a>::wrap_one_line":["wrap_one_line","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::VisualLine::new":["new","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::WrapWidth::differs_in_kind":["differs_in_kind","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"linewrap::merged_line_of_offset":["merged_line_of_offset","Real(LocalPath(\"core-lib/src/linewrap.rs\"))",""],"movement::region_movement":["region_movement","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"movement::scroll_height":["scroll_height","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"movement::selection_movement":["selection_movement","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"movement::selection_position":["selection_position","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"movement::vertical_motion":["vertical_motion","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"movement::vertical_motion_exact_pos":["vertical_motion_exact_pos","Real(LocalPath(\"core-lib/src/movement.rs\"))",""],"plugins::Plugin::close_view":["close_view","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::collect_trace":["collect_trace","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::config_changed":["config_changed","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::did_save":["did_save","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::dispatch_command":["dispatch_command","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::get_hover":["get_hover","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::initialize":["initialize","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::language_changed":["language_changed","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::new_buffer":["new_buffer","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::shutdown":["shutdown","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::toggle_tracing":["toggle_tracing","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::Plugin::update":["update","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"plugins::catalog::PluginCatalog::get_from_path":["get_from_path","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::get_named":["get_named","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::iter":["iter","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::iter_names":["iter_names","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::load_from_paths":["load_from_paths","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::make_languages_map":["make_languages_map","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::reload_from_paths":["reload_from_paths","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::PluginCatalog::remove_named":["remove_named","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::find_all_manifests":["find_all_manifests","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::catalog::load_manifest":["load_manifest","Real(LocalPath(\"core-lib/src/plugins/catalog.rs\"))",""],"plugins::manifest::ArgumentOption::new":["new","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::Command::new":["new","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::CommandArgument::new":["new","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PlaceholderRpc::is_request":["is_request","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PlaceholderRpc::method_ref":["method_ref","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PlaceholderRpc::new":["new","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PlaceholderRpc::params_ref":["params_ref","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PlaceholderRpc::params_ref_mut":["params_ref_mut","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::PluginDescription::is_global":["is_global","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::manifest::platform_exec_path":["platform_exec_path","Real(LocalPath(\"core-lib/src/plugins/manifest.rs\"))",""],"plugins::rpc::PluginBufferInfo::new":["new","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))",""],"plugins::rpc::PluginUpdate::new":["new","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))",""],"plugins::rpc::TextUnit::resolve_offset":["resolve_offset","Real(LocalPath(\"core-lib/src/plugins/rpc.rs\"))",""],"plugins::start_plugin_process":["start_plugin_process","Real(LocalPath(\"core-lib/src/plugins/mod.rs\"))",""],"recorder::Recorder::clear":["clear","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::is_recording":["is_recording","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::new":["new","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::play":["play","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::record":["record","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::save_recording_buffer":["save_recording_buffer","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recorder::toggle_recording":["toggle_recording","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recording::new":["new","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"recorder::Recording::play":["play","Real(LocalPath(\"core-lib/src/recorder.rs\"))",""],"selection::<impl std::convert::From<&'a selection::SelRegion> for xi_rope::Interval>::from":["from","Real(LocalPath(\"core-lib/src/selection.rs\"))","std::convert::From"],"selection::SelRegion::caret":["caret","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::is_caret":["is_caret","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::is_upstream":["is_upstream","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::max":["max","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::merge_with":["merge_with","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::min":["min","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::new":["new","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::should_merge":["should_merge","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::with_affinity":["with_affinity","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::SelRegion::with_horiz":["with_horiz","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::add_range_distinct":["add_range_distinct","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::add_region":["add_region","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::apply_delta":["apply_delta","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::clear":["clear","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::collapse":["collapse","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::delete_range":["delete_range","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::new":["new","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::new_simple":["new_simple","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::regions_in_range":["regions_in_range","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"selection::Selection::search":["search","Real(LocalPath(\"core-lib/src/selection.rs\"))",""],"styles::Style::default_for_theme":["default_for_theme","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::Style::from_syntect_style_mod":["from_syntect_style_mod","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::Style::merge":["merge","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::Style::new":["new","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::Style::rgba_from_syntect_color":["rgba_from_syntect_color","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::Style::to_json":["to_json","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::add":["add","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::contains_theme":["contains_theme","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_default_style":["get_default_style","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_dump_path":["get_dump_path","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_highlighter":["get_highlighter","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_theme_name":["get_theme_name","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_theme_names":["get_theme_names","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::get_theme_settings":["get_theme_settings","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::init_cache_dir":["init_cache_dir","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::insert_to_map":["insert_to_map","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::load_theme":["load_theme","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::load_theme_dir":["load_theme_dir","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::load_theme_info_from_path":["load_theme_info_from_path","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::lookup":["lookup","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::merge_with_default":["merge_with_default","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::new":["new","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::remove_theme":["remove_theme","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::set_theme":["set_theme","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::sync_dir":["sync_dir","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::ThemeStyleMap::try_load_from_dump":["try_load_from_dump","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"styles::validate_theme_file":["validate_theme_file","Real(LocalPath(\"core-lib/src/styles.rs\"))",""],"syntax::Languages::difference":["difference","Real(LocalPath(\"core-lib/src/syntax.rs\"))",""],"syntax::Languages::iter":["iter","Real(LocalPath(\"core-lib/src/syntax.rs\"))",""],"syntax::Languages::language_for_name":["language_for_name","Real(LocalPath(\"core-lib/src/syntax.rs\"))",""],"syntax::Languages::language_for_path":["language_for_path","Real(LocalPath(\"core-lib/src/syntax.rs\"))",""],"syntax::Languages::new":["new","Real(LocalPath(\"core-lib/src/syntax.rs\"))",""],"tabs::<impl std::convert::From<tabs::ViewId> for usize>::from":["from","Real(LocalPath(\"core-lib/src/tabs.rs\"))","std::convert::From"],"tabs::BufferId::new":["new","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::_test_open_editors":["_test_open_editors","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::_test_open_views":["_test_open_views","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::after_stop_plugin":["after_stop_plugin","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::client_notification":["client_notification","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::client_request":["client_request","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::detect_whitespace":["detect_whitespace","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_close_view":["do_close_view","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_edit":["do_edit","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_edit_sync":["do_edit_sync","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_get_config":["do_get_config","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_get_contents":["do_get_contents","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_modify_user_config":["do_modify_user_config","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_new_view":["do_new_view","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_plugin_rpc":["do_plugin_rpc","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_save":["do_save","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_set_language":["do_set_language","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_set_theme":["do_set_theme","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_start_plugin":["do_start_plugin","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::do_stop_plugin":["do_stop_plugin","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::finalize_new_views":["finalize_new_views","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::finish_setup":["finish_setup","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_config_changes":["handle_config_changes","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_config_fs_event":["handle_config_fs_event","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_find_callback":["handle_find_callback","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_fs_events":["handle_fs_events","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_idle":["handle_idle","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_open_file_fs_event":["handle_open_file_fs_event","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_plugin_fs_event":["handle_plugin_fs_event","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_render_timer":["handle_render_timer","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_rewrap_callback":["handle_rewrap_callback","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::handle_themes_fs_event":["handle_themes_fs_event","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::iter_groups":["iter_groups","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::load_file_based_config":["load_file_based_config","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::load_theme_file":["load_theme_file","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::make_context":["make_context","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::new":["new","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::next_buffer_id":["next_buffer_id","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::next_plugin_id":["next_plugin_id","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::next_view_id":["next_view_id","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::notify_client_and_update_views":["notify_client_and_update_views","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::plugin_connect":["plugin_connect","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::plugin_exit":["plugin_exit","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::plugin_notification":["plugin_notification","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::plugin_request":["plugin_request","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::plugin_update":["plugin_update","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::remove_config_at_path":["remove_config_at_path","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::remove_theme":["remove_theme","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::save_trace":["save_trace","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::set_config":["set_config","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::CoreState::toggle_tracing":["toggle_tracing","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::Counter::next":["next","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::test_helpers::new_buffer_id":["new_buffer_id","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"tabs::test_helpers::new_view_id":["new_view_id","Real(LocalPath(\"core-lib/src/tabs.rs\"))",""],"view::View::add_find":["add_find","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::add_selection_by_movement":["add_selection_by_movement","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::after_edit":["after_edit","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::collapse_selections":["collapse_selections","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::debug_force_rewrap_cols":["debug_force_rewrap_cols","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::deselect_at_offset":["deselect_at_offset","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_drag":["do_drag","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_edit":["do_edit","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_find":["do_find","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_find_all":["do_find_all","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_find_next":["do_find_next","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_gesture":["do_gesture","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_move":["do_move","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_selection_for_find":["do_selection_for_find","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_selection_for_replace":["do_selection_for_replace","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_set_replace":["do_set_replace","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::do_split_selection_into_lines":["do_split_selection_into_lines","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::encode_line":["encode_line","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::encode_styles":["encode_styles","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::extend_selection":["extend_selection","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::find_in_progress":["find_in_progress","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::find_status":["find_status","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_buffer_id":["get_buffer_id","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_caret_offset":["get_caret_offset","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_lines":["get_lines","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_or_def_style_id":["get_or_def_style_id","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_replace":["get_replace","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::get_view_id":["get_view_id","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::goto_line":["goto_line","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::has_pending_render":["has_pending_render","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::interval_of_visible_region":["interval_of_visible_region","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::invalidate_selection":["invalidate_selection","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::invalidate_styles":["invalidate_styles","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::is_point_in_selection":["is_point_in_selection","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::needs_more_wrap":["needs_more_wrap","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::needs_wrap_in_visible_region":["needs_wrap_in_visible_region","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::new":["new","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::range_region":["range_region","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::render_if_dirty":["render_if_dirty","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::request_lines":["request_lines","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::rewrap":["rewrap","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::scroll_height":["scroll_height","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::scroll_to_cursor":["scroll_to_cursor","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::sel_regions":["sel_regions","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::select":["select","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::select_all":["select_all","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::select_next_occurrence":["select_next_occurrence","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::send_update_for_plan":["send_update_for_plan","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_dirty":["set_dirty","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_find":["set_find","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_has_pending_render":["set_has_pending_render","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_scroll":["set_scroll","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_selection":["set_selection","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_selection_for_edit":["set_selection_for_edit","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_selection_raw":["set_selection_raw","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::set_size":["set_size","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::unit":["unit","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::update_annotations":["update_annotations","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::View::update_wrap_settings":["update_wrap_settings","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"view::clamp":["clamp","Real(LocalPath(\"core-lib/src/view.rs\"))",""],"watcher::FileWatcher::new":["new","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::FileWatcher::take_events":["take_events","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::FileWatcher::unwatch":["unwatch","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::FileWatcher::watch":["watch","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::FileWatcher::watch_filtered":["watch_filtered","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::FileWatcher::watch_impl":["watch_impl","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::Watchee::applies_to_path":["applies_to_path","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::Watchee::wants_event":["wants_event","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"watcher::mode_from_bool":["mode_from_bool","Real(LocalPath(\"core-lib/src/watcher.rs\"))",""],"whitespace::Indentation::parse":["parse","Real(LocalPath(\"core-lib/src/whitespace.rs\"))",""],"whitespace::Indentation::parse_line":["parse_line","Real(LocalPath(\"core-lib/src/whitespace.rs\"))",""],"whitespace::extract_count":["extract_count","Real(LocalPath(\"core-lib/src/whitespace.rs\"))",""],"whitespace::gcd":["gcd","Real(LocalPath(\"core-lib/src/whitespace.rs\"))",""],"width_cache::WidthBatchReq::<'a>::request":["request","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"width_cache::WidthBatchReq::<'a>::resolve_pending":["resolve_pending","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"width_cache::WidthCache::batch_req":["batch_req","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"width_cache::WidthCache::len":["len","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"width_cache::WidthCache::new":["new","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"width_cache::WidthCache::resolve":["resolve","Real(LocalPath(\"core-lib/src/width_cache.rs\"))",""],"word_boundaries::WordBoundary::is_boundary":["is_boundary","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordBoundary::is_end":["is_end","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordBoundary::is_start":["is_start","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordCursor::<'a>::new":["new","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordCursor::<'a>::next_boundary":["next_boundary","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordCursor::<'a>::prev_boundary":["prev_boundary","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::WordCursor::<'a>::select_word":["select_word","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::classify_boundary":["classify_boundary","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::classify_boundary_initial":["classify_boundary_initial","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""],"word_boundaries::get_word_property":["get_word_property","Real(LocalPath(\"core-lib/src/word_boundaries.rs\"))",""]},"trait_to_struct":{"annotations::ToAnnotation":["find::Find","selection::Selection"],"line_offset::LineOffset":["line_offset::LogicalLines","linewrap::Lines","view::View","xi_rope::breaks::Breaks"],"serde::Deserialize":["<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field","<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationType","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field","config::BufferItems","config::Config","config::ConfigDomain","config::ConfigDomainExternal","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field","editor::EditType","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field","find::FindStatus","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field","plugins::PluginPid","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::Command","plugins::manifest::CommandArgument","plugins::manifest::PlaceholderRpc","plugins::manifest::PluginActivation","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","plugins::manifest::RpcType","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field","plugins::rpc::ClientPluginInfo","plugins::rpc::DataSpan","plugins::rpc::EmptyStruct","plugins::rpc::GetDataResponse","plugins::rpc::HostNotification","plugins::rpc::HostRequest","plugins::rpc::Hover","plugins::rpc::PluginBufferInfo","plugins::rpc::PluginCommand","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","plugins::rpc::PluginRequest","plugins::rpc::PluginUpdate","plugins::rpc::Range","plugins::rpc::ScopeSpan","plugins::rpc::TextUnit","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field","rpc::CoreNotification","rpc::CoreRequest","rpc::EditCommand","rpc::EditNotification","rpc::EditRequest","rpc::EmptyStruct","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::PluginNotification","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field","styles::Style","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field","syntax::LanguageDefinition","syntax::LanguageId","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field","tabs::BufferId","tabs::ViewId","view::Replace","view::Size","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field","width_cache::WidthReq","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field"],"serde::Serialize":["<rpc::MouseAction as serde::Serialize>::serialize::Helper","annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationType","client::OpType","client::Update","client::UpdateOp","config::BufferItems","config::Config","config::ConfigDomain","config::ConfigDomainExternal","editor::EditType","find::FindStatus","plugins::PluginPid","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::Command","plugins::manifest::CommandArgument","plugins::manifest::PlaceholderRpc","plugins::manifest::PluginActivation","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","plugins::manifest::RpcType","plugins::rpc::ClientPluginInfo","plugins::rpc::DataSpan","plugins::rpc::EmptyStruct","plugins::rpc::GetDataResponse","plugins::rpc::HostNotification","plugins::rpc::HostRequest","plugins::rpc::Hover","plugins::rpc::PluginBufferInfo","plugins::rpc::PluginCommand","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","plugins::rpc::PluginRequest","plugins::rpc::PluginUpdate","plugins::rpc::Range","plugins::rpc::ScopeSpan","plugins::rpc::TextUnit","plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged","rpc::CoreNotification","rpc::CoreRequest","rpc::EditCommand","rpc::EditNotification","rpc::EditRequest","rpc::EmptyStruct","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::PluginNotification","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged","rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged","rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged","styles::Style","syntax::LanguageDefinition","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::Replace","view::Size","width_cache::WidthReq"],"serde::de::DeserializeSeed":["plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed"],"serde::de::Visitor":["<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor"],"std::borrow::Borrow":["syntax::LanguageId"],"std::clone::Clone":["annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationType","annotations::Annotations","client::OpType","config::BufferItems","config::Config","config::ConfigDomain","config::ConfigDomainExternal","config::LanguageTag","config::TableStack","core::WeakXiCore","edit_ops::IndentDirection","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","editor::EditType","file::CharacterEncoding","line_cache_shadow::RenderTactic","line_ending::LineEnding","linewrap::WrapWidth","movement::Movement","plugins::PluginPid","plugins::catalog::PluginCatalog","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::Command","plugins::manifest::CommandArgument","plugins::manifest::PlaceholderRpc","plugins::manifest::PluginActivation","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","plugins::manifest::RpcType","plugins::rpc::DataSpan","plugins::rpc::EmptyStruct","plugins::rpc::HostNotification","plugins::rpc::HostRequest","plugins::rpc::Hover","plugins::rpc::PluginBufferInfo","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","plugins::rpc::PluginRequest","plugins::rpc::PluginUpdate","plugins::rpc::Range","plugins::rpc::ScopeSpan","plugins::rpc::TextUnit","rpc::EditCommand","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::InsertDrift","selection::SelRegion","selection::Selection","styles::Style","syntax::LanguageDefinition","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::FindProgress","view::Replace","view::Size","watcher::WatchToken","whitespace::Indentation","word_boundaries::WordProperty"],"std::cmp::Eq":["config::ConfigDomain","config::ConfigDomainExternal","editor::EditType","line_ending::LineEnding","plugins::PluginPid","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::SelRegion","styles::Style","syntax::LanguageId","tabs::BufferId","tabs::ViewId","watcher::WatchToken","whitespace::Indentation","width_cache::WidthCacheKey","word_boundaries::WordBoundary"],"std::cmp::Ord":["plugins::PluginPid","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"std::cmp::PartialEq":["annotations::AnnotationRange","annotations::AnnotationType","backspace::offset_for_delete_backwards::State","config::BufferItems","config::Config","config::ConfigDomain","config::ConfigDomainExternal","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","editor::EditType","line_cache_shadow::RenderTactic","line_ending::LineEnding","linewrap::WrapWidth","movement::Movement","plugins::PluginPid","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::CoreRequest","rpc::EditCommand","rpc::EditNotification","rpc::EditRequest","rpc::EmptyStruct","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::PluginNotification","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::SelRegion","styles::Style","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Replace","view::Size","watcher::WatchToken","whitespace::Indentation","width_cache::WidthCacheKey","word_boundaries::WordBoundary"],"std::cmp::PartialOrd":["plugins::PluginPid","syntax::LanguageId","tabs::BufferId","tabs::ViewId"],"std::convert::AsRef":["syntax::LanguageId"],"std::convert::From":["config::ConfigDomain","config::ConfigError","edit_types::EventDomain","plugins::catalog::PluginLoadError","selection::SelRegion","selection::Selection","syntax::LanguageId","tabs::ViewId","xi_rope::Interval","xi_rpc::RemoteError"],"std::default::Default":["annotations::AnnotationRange","config::TableStack","layers::Layers","layers::ScopeLayer","line_cache_shadow::LineCacheShadow","linewrap::Lines","linewrap::WrapWidth","plugins::PluginPid","plugins::catalog::PluginCatalog","plugins::manifest::PluginScope","rpc::SelectionModifier","selection::Affinity","selection::Selection","styles::Style","syntax::LanguageId","syntax::Languages","tabs::Counter","view::Replace","view::Size","watcher::WatcherState"],"std::error::Error":["config::ConfigError"],"std::fmt::Debug":["annotations::AnnotationRange","annotations::AnnotationSlice","annotations::AnnotationType","annotations::Annotations","client::OpType","client::Update","client::UpdateOp","config::BufferItems","config::Config","config::ConfigDomain","config::ConfigDomainExternal","config::ConfigError","config::ConfigManager","config::ConfigPair","config::LanguageTag","config::TableStack","edit_ops::IndentDirection","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","editor::EditType","file::CharacterEncoding","file::FileInfo","find::FindStatus","line_cache_shadow::LineCacheShadow","line_cache_shadow::Span","line_ending::LineEnding","line_ending::MixedLineEndingError","linewrap::WrapWidth","movement::Movement","plugins::PluginPid","plugins::catalog::PluginCatalog","plugins::catalog::PluginLoadError","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::Command","plugins::manifest::CommandArgument","plugins::manifest::PlaceholderRpc","plugins::manifest::PluginActivation","plugins::manifest::PluginDescription","plugins::manifest::PluginScope","plugins::manifest::RpcType","plugins::rpc::ClientPluginInfo","plugins::rpc::DataSpan","plugins::rpc::EmptyStruct","plugins::rpc::GetDataResponse","plugins::rpc::HostNotification","plugins::rpc::HostRequest","plugins::rpc::Hover","plugins::rpc::PluginBufferInfo","plugins::rpc::PluginEdit","plugins::rpc::PluginNotification","plugins::rpc::PluginRequest","plugins::rpc::PluginUpdate","plugins::rpc::Range","plugins::rpc::ScopeSpan","plugins::rpc::TextUnit","rpc::CoreNotification","rpc::CoreRequest","rpc::EditCommand","rpc::EditNotification","rpc::EditRequest","rpc::EmptyStruct","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::PluginNotification","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::SelRegion","selection::Selection","styles::Style","syntax::LanguageDefinition","syntax::LanguageId","syntax::Languages","tabs::BufferId","tabs::Counter","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Replace","view::Size","watcher::WatchToken","watcher::Watchee","watcher::WatcherState","whitespace::Indentation","whitespace::MixedIndentError"],"std::fmt::Display":["config::ConfigError","file::FileError","plugins::PluginPid","selection::SelRegion","selection::Selection","tabs::BufferId","tabs::ViewId"],"std::hash::Hash":["config::ConfigDomain","config::ConfigDomainExternal","line_ending::LineEnding","plugins::PluginPid","styles::Style","syntax::LanguageId","tabs::BufferId","tabs::ViewId","whitespace::Indentation","width_cache::WidthCacheKey"],"std::iter::DoubleEndedIterator":["index_set::MinusIter"],"std::iter::Iterator":["index_set::MinusIter","line_cache_shadow::PlanIterator","linewrap::MergedBreaks","linewrap::VisualLines","tabs::Iter"],"std::marker::Copy":["annotations::AnnotationRange","edit_ops::IndentDirection","editor::EditType","file::CharacterEncoding","line_cache_shadow::RenderTactic","line_ending::LineEnding","linewrap::WrapWidth","movement::Movement","plugins::PluginPid","plugins::rpc::ScopeSpan","plugins::rpc::TextUnit","rpc::GestureType","rpc::SelectionGranularity","selection::Affinity","selection::InsertDrift","selection::SelRegion","tabs::BufferId","tabs::ViewId","watcher::WatchToken","whitespace::Indentation","word_boundaries::WordProperty"],"std::marker::StructuralEq":["config::ConfigDomain","config::ConfigDomainExternal","editor::EditType","line_ending::LineEnding","plugins::PluginPid","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::SelRegion","styles::Style","syntax::LanguageId","tabs::BufferId","tabs::ViewId","watcher::WatchToken","whitespace::Indentation","width_cache::WidthCacheKey","word_boundaries::WordBoundary"],"std::marker::StructuralPartialEq":["annotations::AnnotationRange","annotations::AnnotationType","backspace::offset_for_delete_backwards::State","config::BufferItems","config::ConfigDomain","config::ConfigDomainExternal","edit_types::BufferEvent","edit_types::EventDomain","edit_types::SpecialEvent","edit_types::ViewEvent","editor::EditType","line_cache_shadow::RenderTactic","line_ending::LineEnding","linewrap::WrapWidth","movement::Movement","plugins::PluginPid","plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType","plugins::manifest::PlaceholderRpc","plugins::manifest::RpcType","rpc::CoreNotification","rpc::CoreRequest","rpc::EditCommand","rpc::EditNotification","rpc::EditRequest","rpc::EmptyStruct","rpc::FindQuery","rpc::GestureType","rpc::LineRange","rpc::MouseAction","rpc::PluginNotification","rpc::Position","rpc::SelectionGranularity","rpc::SelectionModifier","selection::Affinity","selection::SelRegion","styles::Style","syntax::LanguageId","tabs::BufferId","tabs::ViewId","view::FindProgress","view::FindStatusChange","view::Replace","view::Size","watcher::WatchToken","whitespace::Indentation","width_cache::WidthCacheKey","word_boundaries::WordBoundary"],"std::ops::Deref":["selection::Selection"],"watcher::Notify":["xi_rpc::RpcPeer"],"width_cache::WidthMeasure":["client::Client","width_cache::CodepointMono"],"xi_rpc::Handler":["core::WeakXiCore","core::XiCore"]},"type_to_def_path":{"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de>":"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de>":"<config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de>":"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de>":"<plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Field","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__FieldVisitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor<'de>":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_IdsWrapper::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::IdsWrapper>::deserialize::__Visitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Field","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__FieldVisitor","<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor<'de>":"<plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerIds::<impl serde::Deserialize<'de> for <plugins::rpc::PluginCommand<T> as serde::Deserialize<'de>>::deserialize::InnerIds>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId":"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field":"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Field","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor":"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__FieldVisitor","<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor<'de>":"<rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_InnerId::<impl serde::Deserialize<'de> for <rpc::EditCommand<T> as serde::Deserialize<'de>>::deserialize::InnerId>::deserialize::__Visitor","<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple":"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple","<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor<'de>":"<rpc::LineRange as serde::Deserialize<'de>>::deserialize::_IMPL_DESERIALIZE_FOR_TwoTuple::<impl serde::Deserialize<'de> for <rpc::LineRange as serde::Deserialize<'de>>::deserialize::TwoTuple>::deserialize::__Visitor","<rpc::MouseAction as serde::Serialize>::serialize::Helper":"<rpc::MouseAction as serde::Serialize>::serialize::Helper","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Field","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de> as serde::de::DeserializeSeed<'de>>::deserialize::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Field","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__Visitor","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field":"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor":"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor","<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>":"<rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor","annotations::AnnotationRange":"annotations::AnnotationRange","annotations::AnnotationSlice":"annotations::AnnotationSlice","annotations::AnnotationStore":"annotations::AnnotationStore","annotations::AnnotationType":"annotations::AnnotationType","annotations::Annotations":"annotations::Annotations","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Field","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__FieldVisitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor<'de>":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationSlice::<impl serde::Deserialize<'de> for annotations::AnnotationSlice>::deserialize::__Visitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Field","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__FieldVisitor","annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor<'de>":"annotations::_IMPL_DESERIALIZE_FOR_AnnotationType::<impl serde::Deserialize<'de> for annotations::AnnotationType>::deserialize::__Visitor","backspace::offset_for_delete_backwards::State":"backspace::offset_for_delete_backwards::State","client::Client":"client::Client","client::OpType":"client::OpType","client::Update":"client::Update","client::UpdateOp":"client::UpdateOp","config::BufferItems":"config::BufferItems","config::Config<T>":"config::Config","config::ConfigDomain":"config::ConfigDomain","config::ConfigDomainExternal":"config::ConfigDomainExternal","config::ConfigError":"config::ConfigError","config::ConfigManager":"config::ConfigManager","config::ConfigPair":"config::ConfigPair","config::LanguageTag":"config::LanguageTag","config::TableStack":"config::TableStack","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field":"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor":"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor<'de>":"config::_IMPL_DESERIALIZE_FOR_BufferItems::<impl serde::Deserialize<'de> for config::BufferItems>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field":"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor":"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor<'de, T>":"config::_IMPL_DESERIALIZE_FOR_Config::<impl serde::Deserialize<'de> for config::Config<T>>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field":"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor":"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor<'de>":"config::_IMPL_DESERIALIZE_FOR_ConfigDomain::<impl serde::Deserialize<'de> for config::ConfigDomain>::deserialize::__Visitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field":"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Field","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor":"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__FieldVisitor","config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor<'de>":"config::_IMPL_DESERIALIZE_FOR_ConfigDomainExternal::<impl serde::Deserialize<'de> for config::ConfigDomainExternal>::deserialize::__Visitor","core::WeakXiCore":"core::WeakXiCore","core::XiCore":"core::XiCore","edit_ops::IndentDirection":"edit_ops::IndentDirection","edit_types::BufferEvent":"edit_types::BufferEvent","edit_types::EventDomain":"edit_types::EventDomain","edit_types::SpecialEvent":"edit_types::SpecialEvent","edit_types::ViewEvent":"edit_types::ViewEvent","editor::EditType":"editor::EditType","editor::Editor":"editor::Editor","editor::SyncStore":"editor::SyncStore","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field":"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Field","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor":"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__FieldVisitor","editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor<'de>":"editor::_IMPL_DESERIALIZE_FOR_EditType::<impl serde::Deserialize<'de> for editor::EditType>::deserialize::__Visitor","event_context::EventContext<'a>":"event_context::EventContext","file::CharacterEncoding":"file::CharacterEncoding","file::FileError":"file::FileError","file::FileInfo":"file::FileInfo","file::FileManager":"file::FileManager","find::Find":"find::Find","find::FindStatus":"find::FindStatus","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field":"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Field","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor":"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__FieldVisitor","find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor<'de>":"find::_IMPL_DESERIALIZE_FOR_FindStatus::<impl serde::Deserialize<'de> for find::FindStatus>::deserialize::__Visitor","index_set::IndexSet":"index_set::IndexSet","index_set::MinusIter<'a>":"index_set::MinusIter","layers::Layers":"layers::Layers","layers::ScopeLayer":"layers::ScopeLayer","line_cache_shadow::Builder":"line_cache_shadow::Builder","line_cache_shadow::LineCacheShadow":"line_cache_shadow::LineCacheShadow","line_cache_shadow::PlanIterator<'a>":"line_cache_shadow::PlanIterator","line_cache_shadow::PlanSegment":"line_cache_shadow::PlanSegment","line_cache_shadow::RenderPlan":"line_cache_shadow::RenderPlan","line_cache_shadow::RenderTactic":"line_cache_shadow::RenderTactic","line_cache_shadow::Span":"line_cache_shadow::Span","line_ending::LineEnding":"line_ending::LineEnding","line_ending::MixedLineEndingError":"line_ending::MixedLineEndingError","line_offset::LogicalLines":"line_offset::LogicalLines","linewrap::InvalLines":"linewrap::InvalLines","linewrap::LineBreakCursor<'a>":"linewrap::LineBreakCursor","linewrap::Lines":"linewrap::Lines","linewrap::MergedBreaks<'a>":"linewrap::MergedBreaks","linewrap::PotentialBreak":"linewrap::PotentialBreak","linewrap::RewrapCtx<'a>":"linewrap::RewrapCtx","linewrap::VisualLine":"linewrap::VisualLine","linewrap::VisualLines<'a>":"linewrap::VisualLines","linewrap::WrapSummary":"linewrap::WrapSummary","linewrap::WrapWidth":"linewrap::WrapWidth","movement::Movement":"movement::Movement","plugins::Plugin":"plugins::Plugin","plugins::PluginPid":"plugins::PluginPid","plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor<'de>":"plugins::_IMPL_DESERIALIZE_FOR_PluginPid::<impl serde::Deserialize<'de> for plugins::PluginPid>::deserialize::__Visitor","plugins::catalog::PluginCatalog":"plugins::catalog::PluginCatalog","plugins::catalog::PluginLoadError":"plugins::catalog::PluginLoadError","plugins::manifest::ArgumentOption":"plugins::manifest::ArgumentOption","plugins::manifest::ArgumentType":"plugins::manifest::ArgumentType","plugins::manifest::Command":"plugins::manifest::Command","plugins::manifest::CommandArgument":"plugins::manifest::CommandArgument","plugins::manifest::PlaceholderRpc":"plugins::manifest::PlaceholderRpc","plugins::manifest::PluginActivation":"plugins::manifest::PluginActivation","plugins::manifest::PluginDescription":"plugins::manifest::PluginDescription","plugins::manifest::PluginScope":"plugins::manifest::PluginScope","plugins::manifest::RpcType":"plugins::manifest::RpcType","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentOption::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentOption>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_ArgumentType::<impl serde::Deserialize<'de> for plugins::manifest::ArgumentType>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_Command::<impl serde::Deserialize<'de> for plugins::manifest::Command>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_CommandArgument::<impl serde::Deserialize<'de> for plugins::manifest::CommandArgument>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PlaceholderRpc::<impl serde::Deserialize<'de> for plugins::manifest::PlaceholderRpc>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginActivation::<impl serde::Deserialize<'de> for plugins::manifest::PluginActivation>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginDescription::<impl serde::Deserialize<'de> for plugins::manifest::PluginDescription>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_PluginScope::<impl serde::Deserialize<'de> for plugins::manifest::PluginScope>::deserialize::__Visitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field":"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Field","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor":"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__FieldVisitor","plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor<'de>":"plugins::manifest::_IMPL_DESERIALIZE_FOR_RpcType::<impl serde::Deserialize<'de> for plugins::manifest::RpcType>::deserialize::__Visitor","plugins::rpc::ClientPluginInfo":"plugins::rpc::ClientPluginInfo","plugins::rpc::DataSpan":"plugins::rpc::DataSpan","plugins::rpc::EmptyStruct":"plugins::rpc::EmptyStruct","plugins::rpc::GetDataResponse":"plugins::rpc::GetDataResponse","plugins::rpc::HostNotification":"plugins::rpc::HostNotification","plugins::rpc::HostRequest":"plugins::rpc::HostRequest","plugins::rpc::Hover":"plugins::rpc::Hover","plugins::rpc::PluginBufferInfo":"plugins::rpc::PluginBufferInfo","plugins::rpc::PluginCommand<T>":"plugins::rpc::PluginCommand","plugins::rpc::PluginEdit":"plugins::rpc::PluginEdit","plugins::rpc::PluginNotification":"plugins::rpc::PluginNotification","plugins::rpc::PluginRequest":"plugins::rpc::PluginRequest","plugins::rpc::PluginUpdate":"plugins::rpc::PluginUpdate","plugins::rpc::Range":"plugins::rpc::Range","plugins::rpc::ScopeSpan":"plugins::rpc::ScopeSpan","plugins::rpc::TextUnit":"plugins::rpc::TextUnit","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ClientPluginInfo::<impl serde::Deserialize<'de> for plugins::rpc::ClientPluginInfo>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_DataSpan::<impl serde::Deserialize<'de> for plugins::rpc::DataSpan>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for plugins::rpc::EmptyStruct>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_GetDataResponse::<impl serde::Deserialize<'de> for plugins::rpc::GetDataResponse>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostNotification::<impl serde::Deserialize<'de> for plugins::rpc::HostNotification>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_HostRequest::<impl serde::Deserialize<'de> for plugins::rpc::HostRequest>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Hover::<impl serde::Deserialize<'de> for plugins::rpc::Hover>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginBufferInfo::<impl serde::Deserialize<'de> for plugins::rpc::PluginBufferInfo>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginEdit::<impl serde::Deserialize<'de> for plugins::rpc::PluginEdit>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for plugins::rpc::PluginNotification>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Seed","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginRequest::<impl serde::Deserialize<'de> for plugins::rpc::PluginRequest>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_PluginUpdate::<impl serde::Deserialize<'de> for plugins::rpc::PluginUpdate>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_Range::<impl serde::Deserialize<'de> for plugins::rpc::Range>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_ScopeSpan::<impl serde::Deserialize<'de> for plugins::rpc::ScopeSpan>::deserialize::__Visitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field":"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Field","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor":"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__FieldVisitor","plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor<'de>":"plugins::rpc::_IMPL_DESERIALIZE_FOR_TextUnit::<impl serde::Deserialize<'de> for plugins::rpc::TextUnit>::deserialize::__Visitor","plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged<'__a>":"plugins::rpc::_IMPL_SERIALIZE_FOR_HostNotification::<impl serde::Serialize for plugins::rpc::HostNotification>::serialize::__AdjacentlyTagged","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged<'__a>":"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginNotification::<impl serde::Serialize for plugins::rpc::PluginNotification>::serialize::__AdjacentlyTagged","plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged<'__a>":"plugins::rpc::_IMPL_SERIALIZE_FOR_PluginRequest::<impl serde::Serialize for plugins::rpc::PluginRequest>::serialize::__AdjacentlyTagged","recorder::Recorder":"recorder::Recorder","recorder::Recording":"recorder::Recording","rpc::CoreNotification":"rpc::CoreNotification","rpc::CoreRequest":"rpc::CoreRequest","rpc::EditCommand<T>":"rpc::EditCommand","rpc::EditNotification":"rpc::EditNotification","rpc::EditRequest":"rpc::EditRequest","rpc::EmptyStruct":"rpc::EmptyStruct","rpc::FindQuery":"rpc::FindQuery","rpc::GestureType":"rpc::GestureType","rpc::LineRange":"rpc::LineRange","rpc::MouseAction":"rpc::MouseAction","rpc::PluginNotification":"rpc::PluginNotification","rpc::Position":"rpc::Position","rpc::SelectionGranularity":"rpc::SelectionGranularity","rpc::SelectionModifier":"rpc::SelectionModifier","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed<'de>":"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_CoreNotification::<impl serde::Deserialize<'de> for rpc::CoreNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed<'de>":"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_CoreRequest::<impl serde::Deserialize<'de> for rpc::CoreRequest>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed<'de>":"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_EditNotification::<impl serde::Deserialize<'de> for rpc::EditNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed<'de>":"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Seed","rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_EditRequest::<impl serde::Deserialize<'de> for rpc::EditRequest>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_EmptyStruct::<impl serde::Deserialize<'de> for rpc::EmptyStruct>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_FindQuery::<impl serde::Deserialize<'de> for rpc::FindQuery>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_GestureType::<impl serde::Deserialize<'de> for rpc::GestureType>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_PluginNotification::<impl serde::Deserialize<'de> for rpc::PluginNotification>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_Position::<impl serde::Deserialize<'de> for rpc::Position>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_SelectionGranularity::<impl serde::Deserialize<'de> for rpc::SelectionGranularity>::deserialize::__Visitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field":"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Field","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor":"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__FieldVisitor","rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor<'de>":"rpc::_IMPL_DESERIALIZE_FOR_SelectionModifier::<impl serde::Deserialize<'de> for rpc::SelectionModifier>::deserialize::__Visitor","rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged<'__a>":"rpc::_IMPL_SERIALIZE_FOR_CoreNotification::<impl serde::Serialize for rpc::CoreNotification>::serialize::__AdjacentlyTagged","rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged<'__a>":"rpc::_IMPL_SERIALIZE_FOR_CoreRequest::<impl serde::Serialize for rpc::CoreRequest>::serialize::__AdjacentlyTagged","rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged<'__a>":"rpc::_IMPL_SERIALIZE_FOR_EditNotification::<impl serde::Serialize for rpc::EditNotification>::serialize::__AdjacentlyTagged","selection::Affinity":"selection::Affinity","selection::InsertDrift":"selection::InsertDrift","selection::SelRegion":"selection::SelRegion","selection::Selection":"selection::Selection","styles::Style":"styles::Style","styles::ThemeStyleMap":"styles::ThemeStyleMap","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field":"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Field","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor":"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__FieldVisitor","styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor<'de>":"styles::_IMPL_DESERIALIZE_FOR_Style::<impl serde::Deserialize<'de> for styles::Style>::deserialize::__Visitor","syntax::LanguageDefinition":"syntax::LanguageDefinition","syntax::LanguageId":"syntax::LanguageId","syntax::Languages":"syntax::Languages","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field":"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Field","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor":"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__FieldVisitor","syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor<'de>":"syntax::_IMPL_DESERIALIZE_FOR_LanguageDefinition::<impl serde::Deserialize<'de> for syntax::LanguageDefinition>::deserialize::__Visitor","syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor<'de>":"syntax::_IMPL_DESERIALIZE_FOR_LanguageId::<impl serde::Deserialize<'de> for syntax::LanguageId>::deserialize::__Visitor","tabs::BufferId":"tabs::BufferId","tabs::CoreState":"tabs::CoreState","tabs::Counter":"tabs::Counter","tabs::Iter<'a, I>":"tabs::Iter","tabs::ViewId":"tabs::ViewId","tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor<'de>":"tabs::_IMPL_DESERIALIZE_FOR_BufferId::<impl serde::Deserialize<'de> for tabs::BufferId>::deserialize::__Visitor","view::DragState":"view::DragState","view::FindProgress":"view::FindProgress","view::FindStatusChange":"view::FindStatusChange","view::Replace":"view::Replace","view::Size":"view::Size","view::View":"view::View","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field":"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Field","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor":"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__FieldVisitor","view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor<'de>":"view::_IMPL_DESERIALIZE_FOR_Replace::<impl serde::Deserialize<'de> for view::Replace>::deserialize::__Visitor","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field":"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Field","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor":"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__FieldVisitor","view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor<'de>":"view::_IMPL_DESERIALIZE_FOR_Size::<impl serde::Deserialize<'de> for view::Size>::deserialize::__Visitor","watcher::FileWatcher":"watcher::FileWatcher","watcher::WatchToken":"watcher::WatchToken","watcher::Watchee":"watcher::Watchee","watcher::WatcherState":"watcher::WatcherState","whitespace::Indentation":"whitespace::Indentation","whitespace::MixedIndentError":"whitespace::MixedIndentError","width_cache::CodepointMono":"width_cache::CodepointMono","width_cache::WidthBatchReq<'a>":"width_cache::WidthBatchReq","width_cache::WidthCache":"width_cache::WidthCache","width_cache::WidthCacheKey<'a>":"width_cache::WidthCacheKey","width_cache::WidthReq":"width_cache::WidthReq","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field":"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Field","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor":"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__FieldVisitor","width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor<'de>":"width_cache::_IMPL_DESERIALIZE_FOR_WidthReq::<impl serde::Deserialize<'de> for width_cache::WidthReq>::deserialize::__Visitor","word_boundaries::WordBoundary":"word_boundaries::WordBoundary","word_boundaries::WordCursor<'a>":"word_boundaries::WordCursor","word_boundaries::WordProperty":"word_boundaries::WordProperty"}}