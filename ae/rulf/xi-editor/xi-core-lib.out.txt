-----------------
unicode/src/lib.rs linebreak_property
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+linebreak_property(p0);
+crate::linebreak_property(p0);
+crate::linebreak_property(p0);
-----------------
unicode/src/lib.rs linebreak_property_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+linebreak_property_str(&p0, p1);
+crate::linebreak_property_str(&p0, p1);
+crate::linebreak_property_str(&p0, p1);
-----------------
unicode/src/lib.rs is_in_asc_list
deps:{"is_in_asc_list":{"T":["core::marker::Sized","core::cmp::PartialOrd"]}}
candidates:{"is_in_asc_list":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // [T]
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+is_in_asc_list(p0, p1, p2, p3);
+crate::is_in_asc_list(p0, p1, p2, p3);
+crate::is_in_asc_list(p0, p1, p2, p3);
-----------------
unicode/src/lib.rs is_variation_selector
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_variation_selector(p0);
+crate::is_variation_selector(p0);
+crate::is_variation_selector(p0);
-----------------
unicode/src/lib.rs is_keycap_base
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_keycap_base(p0);
+crate::is_keycap_base(p0);
+crate::is_keycap_base(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_regional_indicator_symbol
deps:{"EmojiExt::is_regional_indicator_symbol":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_regional_indicator_symbol":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_regional_indicator_symbol();
+EmojiExt::is_regional_indicator_symbol(p0);
+crate::EmojiExt::is_regional_indicator_symbol(p0);
+crate::EmojiExt::is_regional_indicator_symbol(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_emoji_modifier
deps:{"EmojiExt::is_emoji_modifier":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_emoji_modifier":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_emoji_modifier();
+EmojiExt::is_emoji_modifier(p0);
+crate::EmojiExt::is_emoji_modifier(p0);
+crate::EmojiExt::is_emoji_modifier(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_emoji_combining_enclosing_keycap
deps:{"EmojiExt::is_emoji_combining_enclosing_keycap":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_emoji_combining_enclosing_keycap":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_emoji_combining_enclosing_keycap();
+EmojiExt::is_emoji_combining_enclosing_keycap(p0);
+crate::EmojiExt::is_emoji_combining_enclosing_keycap(p0);
+crate::EmojiExt::is_emoji_combining_enclosing_keycap(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_emoji
deps:{"EmojiExt::is_emoji":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_emoji":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_emoji();
+EmojiExt::is_emoji(p0);
+crate::EmojiExt::is_emoji(p0);
+crate::EmojiExt::is_emoji(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_emoji_modifier_base
deps:{"EmojiExt::is_emoji_modifier_base":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_emoji_modifier_base":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_emoji_modifier_base();
+EmojiExt::is_emoji_modifier_base(p0);
+crate::EmojiExt::is_emoji_modifier_base(p0);
+crate::EmojiExt::is_emoji_modifier_base(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_tag_spec_char
deps:{"EmojiExt::is_tag_spec_char":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_tag_spec_char":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_tag_spec_char();
+EmojiExt::is_tag_spec_char(p0);
+crate::EmojiExt::is_tag_spec_char(p0);
+crate::EmojiExt::is_tag_spec_char(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_emoji_cancel_tag
deps:{"EmojiExt::is_emoji_cancel_tag":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_emoji_cancel_tag":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_emoji_cancel_tag();
+EmojiExt::is_emoji_cancel_tag(p0);
+crate::EmojiExt::is_emoji_cancel_tag(p0);
+crate::EmojiExt::is_emoji_cancel_tag(p0);
-----------------
unicode/src/lib.rs EmojiExt::is_zwj
deps:{"EmojiExt::is_zwj":{"Self":["EmojiExt"]}}
candidates:{"EmojiExt::is_zwj":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_zwj();
+EmojiExt::is_zwj(p0);
+crate::EmojiExt::is_zwj(p0);
+crate::EmojiExt::is_zwj(p0);
-----------------
unicode/src/lib.rs <LineBreakIterator<'a> as core::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // LineBreakIterator<'a>
+p0.clone();
+<LineBreakIterator<'a> as core::clone::Clone>::clone(p0);
+crate::<LineBreakIterator<'a> as core::clone::Clone>::clone(p0);
+<LineBreakIterator<'a>>::clone(p0);
-----------------
unicode/src/lib.rs <LineBreakIterator<'a> as core::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // LineBreakIterator<'a>
+p0.next();
+<LineBreakIterator<'a> as core::iter::Iterator>::next(p0);
+crate::<LineBreakIterator<'a> as core::iter::Iterator>::next(p0);
+<LineBreakIterator<'a>>::next(p0);
-----------------
unicode/src/lib.rs LineBreakIterator::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+LineBreakIterator::<'a>::new(&p0);
+crate::LineBreakIterator::<'a>::new(&p0);
+<LineBreakIterator<'a>>::new(&p0);
-----------------
unicode/src/lib.rs <LineBreakLeafIter as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // LineBreakLeafIter
+p0.clone();
+<LineBreakLeafIter as core::clone::Clone>::clone(p0);
+crate::<LineBreakLeafIter as core::clone::Clone>::clone(p0);
+<LineBreakLeafIter>::clone(p0);
-----------------
unicode/src/lib.rs <LineBreakLeafIter as core::default::Default>::default
deps:{}
candidates:{}
+<LineBreakLeafIter as core::default::Default>::default();
+crate::<LineBreakLeafIter as core::default::Default>::default();
+<LineBreakLeafIter>::default();
-----------------
unicode/src/lib.rs LineBreakLeafIter::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+LineBreakLeafIter::new(&p0, p1);
+crate::LineBreakLeafIter::new(&p0, p1);
+<LineBreakLeafIter>::new(&p0, p1);
-----------------
unicode/src/lib.rs LineBreakLeafIter::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // LineBreakLeafIter
let mut p1 = "sample"; // None+&str
+p0.next(&p1);
+LineBreakLeafIter::next(p0, &p1);
+crate::LineBreakLeafIter::next(p0, &p1);
+<LineBreakLeafIter>::next(p0, &p1);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_regional_indicator_symbol
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_regional_indicator_symbol();
+<char as EmojiExt>::is_regional_indicator_symbol(p0);
+crate::<char as EmojiExt>::is_regional_indicator_symbol(p0);
+<char>::is_regional_indicator_symbol(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_emoji_modifier
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_emoji_modifier();
+<char as EmojiExt>::is_emoji_modifier(p0);
+crate::<char as EmojiExt>::is_emoji_modifier(p0);
+<char>::is_emoji_modifier(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_emoji_combining_enclosing_keycap
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_emoji_combining_enclosing_keycap();
+<char as EmojiExt>::is_emoji_combining_enclosing_keycap(p0);
+crate::<char as EmojiExt>::is_emoji_combining_enclosing_keycap(p0);
+<char>::is_emoji_combining_enclosing_keycap(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_emoji
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_emoji();
+<char as EmojiExt>::is_emoji(p0);
+crate::<char as EmojiExt>::is_emoji(p0);
+<char>::is_emoji(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_emoji_modifier_base
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_emoji_modifier_base();
+<char as EmojiExt>::is_emoji_modifier_base(p0);
+crate::<char as EmojiExt>::is_emoji_modifier_base(p0);
+<char>::is_emoji_modifier_base(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_tag_spec_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_tag_spec_char();
+<char as EmojiExt>::is_tag_spec_char(p0);
+crate::<char as EmojiExt>::is_tag_spec_char(p0);
+<char>::is_tag_spec_char(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_emoji_cancel_tag
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_emoji_cancel_tag();
+<char as EmojiExt>::is_emoji_cancel_tag(p0);
+crate::<char as EmojiExt>::is_emoji_cancel_tag(p0);
+<char>::is_emoji_cancel_tag(p0);
-----------------
unicode/src/lib.rs <char as EmojiExt>::is_zwj
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_zwj();
+<char as EmojiExt>::is_zwj(p0);
+crate::<char as EmojiExt>::is_zwj(p0);
+<char>::is_zwj(p0);
-----------------
rope/src/compare.rs compare::sse_compare_mask
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::sse_compare_mask(p0, p1);
+crate::compare::sse_compare_mask(p0, p1);
+crate::compare::sse_compare_mask(p0, p1);
-----------------
rope/src/compare.rs compare::avx_compare_mask
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::avx_compare_mask(p0, p1);
+crate::compare::avx_compare_mask(p0, p1);
+crate::compare::avx_compare_mask(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx(p0, p1);
+crate::compare::ne_idx(p0, p1);
+crate::compare::ne_idx(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev(p0, p1);
+crate::compare::ne_idx_rev(p0, p1);
+crate::compare::ne_idx_rev(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_avx
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_avx(p0, p1);
+crate::compare::ne_idx_avx(p0, p1);
+crate::compare::ne_idx_avx(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_sse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_sse(p0, p1);
+crate::compare::ne_idx_sse(p0, p1);
+crate::compare::ne_idx_sse(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev_sse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev_sse(p0, p1);
+crate::compare::ne_idx_rev_sse(p0, p1);
+crate::compare::ne_idx_rev_sse(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_fallback
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_fallback(p0, p1);
+crate::compare::ne_idx_fallback(p0, p1);
+crate::compare::ne_idx_fallback(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev_fallback
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev_fallback(p0, p1);
+crate::compare::ne_idx_rev_fallback(p0, p1);
+crate::compare::ne_idx_rev_fallback(p0, p1);
-----------------
rope/src/diff.rs diff::expand_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
let mut p4 = 0usize; // None+usize
+diff::expand_match(p0, p1, p2, p3, p4);
+crate::diff::expand_match(p0, p1, p2, p3, p4);
+crate::diff::expand_match(p0, p1, p2, p3, p4);
-----------------
rope/src/diff.rs diff::longest_increasing_region_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(usize, usize)]
+diff::longest_increasing_region_set(p0);
+crate::diff::longest_increasing_region_set(p0);
+crate::diff::longest_increasing_region_set(p0);
-----------------
rope/src/diff.rs diff::non_ws_offset
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+diff::non_ws_offset(&p0);
+crate::diff::non_ws_offset(&p0);
+crate::diff::non_ws_offset(&p0);
-----------------
rope/src/diff.rs diff::make_line_hashes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+diff::make_line_hashes(p0, p1);
+crate::diff::make_line_hashes(p0, p1);
+crate::diff::make_line_hashes(p0, p1);
-----------------
rope/src/engine.rs engine::default_session
deps:{}
candidates:{}
+engine::default_session();
+crate::engine::default_session();
+crate::engine::default_session();
-----------------
rope/src/engine.rs engine::initial_revision_counter
deps:{}
candidates:{}
+engine::initial_revision_counter();
+crate::engine::initial_revision_counter();
+crate::engine::initial_revision_counter();
-----------------
rope/src/engine.rs engine::shuffle_tombstones
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::shuffle_tombstones(p0, p1, p2, p3);
+crate::engine::shuffle_tombstones(p0, p1, p2, p3);
+crate::engine::shuffle_tombstones(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::shuffle
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::shuffle(p0, p1, p2, p3);
+crate::engine::shuffle(p0, p1, p2, p3);
+crate::engine::shuffle(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::find_base_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
+engine::find_base_index(p0, p1);
+crate::engine::find_base_index(p0, p1);
+crate::engine::find_base_index(p0, p1);
-----------------
rope/src/engine.rs engine::find_common
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
+engine::find_common(p0, p1);
+crate::engine::find_common(p0, p1);
+crate::engine::find_common(p0, p1);
-----------------
rope/src/engine.rs engine::rearrange
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<engine::RevId>
let mut p2 = 0usize; // None+usize
+engine::rearrange(p0, p1, p2);
+crate::engine::rearrange(p0, p1, p2);
+crate::engine::rearrange(p0, p1, p2);
-----------------
rope/src/engine.rs engine::compute_deltas
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::compute_deltas(p0, p1, p2, p3);
+crate::engine::compute_deltas(p0, p1, p2, p3);
+crate::engine::compute_deltas(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::compute_transforms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<engine::Revision>
+engine::compute_transforms(p0);
+crate::engine::compute_transforms(p0);
+crate::engine::compute_transforms(p0);
-----------------
rope/src/engine.rs engine::rebase
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<(engine::FullPriority, multiset::Subset)>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<engine::DeltaOp>
let mut p2 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p3 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p4 = MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p5 = 0usize; // None+usize
+engine::rebase(p0, p1, p2, p3, p4, p5);
+crate::engine::rebase(p0, p1, p2, p3, p4, p5);
+crate::engine::rebase(p0, p1, p2, p3, p4, p5);
-----------------
rope/src/find.rs find::find
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p3 = "sample"; // None+&str
let mut p4 = MaybeUninit::uninit().assume_init(); // std::option::Option<&regex::Regex>
+find::find(p0, p1, p2, &p3, p4);
+crate::find::find(p0, p1, p2, &p3, p4);
+crate::find::find(p0, p1, p2, &p3, p4);
-----------------
rope/src/find.rs find::find_progress
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
let mut p5 = MaybeUninit::uninit().assume_init(); // std::option::Option<&regex::Regex>
+find::find_progress(p0, p1, p2, &p3, p4, p5);
+crate::find::find_progress(p0, p1, p2, &p3, p4, p5);
+crate::find::find_progress(p0, p1, p2, &p3, p4, p5);
-----------------
rope/src/find.rs find::find_progress_iter
deps:{"find::find_progress_iter":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["std::marker::Sized","std::ops::Fn"],"impl Fn(&str) -> Option<usize>":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"find::find_progress_iter":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"],"impl Fn(&str) -> Option<usize>":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = MaybeUninit::uninit().assume_init(); // impl Fn(&str) -> Option<usize>
let mut p4 = MaybeUninit::uninit().assume_init(); // impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>
let mut p5 = 0usize; // None+usize
+find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
+crate::find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
+crate::find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
-----------------
rope/src/find.rs find::find_core
deps:{"find::find_core":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["std::ops::Fn","std::marker::Sized"],"impl Fn(&str) -> Option<usize>":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"find::find_core":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"],"impl Fn(&str) -> Option<usize>":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = MaybeUninit::uninit().assume_init(); // impl Fn(&str) -> Option<usize>
let mut p4 = MaybeUninit::uninit().assume_init(); // impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>
+find::find_core(p0, p1, &p2, p3, p4);
+crate::find::find_core(p0, p1, &p2, p3, p4);
+crate::find::find_core(p0, p1, &p2, p3, p4);
-----------------
rope/src/find.rs find::compare_cursor_str
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
+find::compare_cursor_str(p0, p1, &p2);
+crate::find::compare_cursor_str(p0, p1, &p2);
+crate::find::compare_cursor_str(p0, p1, &p2);
-----------------
rope/src/find.rs find::compare_cursor_str_casei
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
+find::compare_cursor_str_casei(p0, p1, &p2);
+crate::find::compare_cursor_str_casei(p0, p1, &p2);
+crate::find::compare_cursor_str_casei(p0, p1, &p2);
-----------------
rope/src/find.rs find::compare_cursor_regex
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = & MaybeUninit::uninit().assume_init(); // regex::Regex
+find::compare_cursor_regex(p0, p1, &p2, p3);
+crate::find::compare_cursor_regex(p0, p1, &p2, p3);
+crate::find::compare_cursor_regex(p0, p1, &p2, p3);
-----------------
rope/src/find.rs find::is_multiline_regex
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+find::is_multiline_regex(&p0);
+crate::find::is_multiline_regex(&p0);
+crate::find::is_multiline_regex(&p0);
-----------------
rope/src/find.rs find::scan_lowercase
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = "sample"; // None+&str
+find::scan_lowercase(p0, &p1);
+crate::find::scan_lowercase(p0, &p1);
+crate::find::scan_lowercase(p0, &p1);
-----------------
rope/src/rope.rs rope::len_utf8_from_first_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+rope::len_utf8_from_first_byte(p0);
+crate::rope::len_utf8_from_first_byte(p0);
+crate::rope::len_utf8_from_first_byte(p0);
-----------------
rope/src/rope.rs rope::count_newlines
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::count_newlines(&p0);
+crate::rope::count_newlines(&p0);
+crate::rope::count_newlines(&p0);
-----------------
rope/src/rope.rs rope::count_utf16_code_units
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::count_utf16_code_units(&p0);
+crate::rope::count_utf16_code_units(&p0);
+crate::rope::count_utf16_code_units(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split_for_bulk
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::find_leaf_split_for_bulk(&p0);
+crate::rope::find_leaf_split_for_bulk(&p0);
+crate::rope::find_leaf_split_for_bulk(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split_for_merge
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::find_leaf_split_for_merge(&p0);
+crate::rope::find_leaf_split_for_merge(&p0);
+crate::rope::find_leaf_split_for_merge(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+rope::find_leaf_split(&p0, p1);
+crate::rope::find_leaf_split(&p0, p1);
+crate::rope::find_leaf_split(&p0, p1);
-----------------
rope/src/rope.rs rope::cow_append
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
let mut p1 = "sample"; // None+&str
+rope::cow_append(p0, &p1);
+crate::rope::cow_append(p0, &p1);
+crate::rope::cow_append(p0, &p1);
-----------------
rope/src/diff.rs diff::Diff::compute_delta
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"diff::Diff::compute_delta":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["diff::Diff"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"diff::Diff::compute_delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"],"Self":["diff::LineHashDiff"]},"spans::Span":{"T":["engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","multiset::ZipSegment","breaks::BreaksInfo","delta::DeltaElement","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::InsertDelta","tree::Node","tree::NodeVal","breaks::BreaksMetric","engine::DeltaOp","interval::Interval","breaks::BreaksLeaf","tree::NodeBody","multiset::Segment","engine::RevId","multiset::Subset","diff::DiffOp","rope::BaseMetric","spans::SpansInfo","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffBuilder","spans::Span","delta::Delta","engine::FullPriority","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","delta::DeltaElement","interval::Interval","multiset::Segment","breaks::BreaksLeaf","engine::DeltaOp","engine::Contents","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","rope::RopeInfo","rope::LinesMetric","spans::SpansLeaf","delta::Delta","breaks::BreaksMetric","multiset::Subset","engine::Error","breaks::BreaksBaseMetric","spans::Span","rope::BaseMetric","delta::InsertDelta","engine::FullPriority","diff::DiffOp","tree::NodeVal","multiset::ZipSegment","engine::RevId","tree::NodeBody","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","find::CaseMatching","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["engine::FullPriority","tree::NodeVal","delta::DeltaElement","multiset::Segment","breaks::BreaksLeaf","multiset::CountMatcher","rope::RopeInfo","engine::RevId","breaks::BreaksMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","diff::DiffBuilder","engine::Contents","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","delta::Delta","tree::Node","rope::LinesMetric","find::CaseMatching","spans::Span","multiset::Subset","spans::SpansInfo","diff::DiffOp","rope::BaseMetric","engine::DeltaOp","spans::SpansLeaf","engine::Error","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+diff::Diff::compute_delta(p0, p1);
+crate::diff::Diff::compute_delta(p0, p1);
+crate::diff::Diff::compute_delta(p0, p1);
-----------------
rope/src/interval.rs interval::IntervalBounds::into_interval
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"interval::IntervalBounds::into_interval":{"Self":["interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"interval::IntervalBounds::into_interval":{"Self":["<T as interval::IntervalBounds>","std::ops::RangeFrom","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+interval::IntervalBounds::into_interval(p0, p1);
+crate::interval::IntervalBounds::into_interval(p0, p1);
+crate::interval::IntervalBounds::into_interval(p0, p1);
-----------------
rope/src/tree.rs tree::NodeInfo::accumulate
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeInfo::accumulate":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","diff::DiffOp","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","find::CaseMatching","rope::RopeInfo","tree::NodeBody","delta::InsertDelta","rope::LinesMetric","engine::DeltaOp","multiset::ZipSegment","interval::Interval","multiset::Subset","rope::BaseMetric","engine::RevId","delta::Delta","tree::Node","diff::DiffBuilder","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","breaks::BreaksInfo","tree::NodeVal","spans::SpansLeaf","delta::DeltaElement","engine::Contents","engine::FullPriority","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","multiset::Segment","spans::SpansInfo"]},"spans::SpansInfo":{"T":["engine::FullPriority","spans::Span","multiset::Segment","interval::Interval","diff::DiffOp","rope::BaseMetric","breaks::BreaksLeaf","delta::Delta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","rope::LinesMetric","tree::NodeBody","engine::DeltaOp","breaks::BreaksInfo","breaks::BreaksMetric","multiset::ZipSegment","spans::SpansInfo","multiset::Subset","spans::SpansLeaf","engine::Error","tree::NodeVal","tree::Node","rope::RopeInfo","find::CaseMatching","engine::Contents","delta::InsertDelta","delta::DeltaElement","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","diff::DiffBuilder","multiset::Segment","rope::BaseMetric","tree::Node","diff::DiffOp","rope::LinesMetric","multiset::Subset","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","breaks::BreaksMetric","tree::NodeBody","delta::InsertDelta","spans::SpansLeaf","engine::RevId","spans::SpansInfo","spans::Span","tree::NodeVal","multiset::CountMatcher","delta::Delta","engine::Contents","rope::Utf16CodeUnitsMetric","engine::Error","rope::RopeInfo","breaks::BreaksInfo","find::CaseMatching","engine::FullPriority","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeInfo::accumulate":{"Self":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.accumulate(p1);
+tree::NodeInfo::accumulate(p0, p1);
+crate::tree::NodeInfo::accumulate(p0, p1);
+crate::tree::NodeInfo::accumulate(p0, p1);
-----------------
rope/src/tree.rs tree::NodeInfo::compute_info
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeInfo::compute_info":{"Self":["tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::Subset","spans::SpansLeaf","find::CaseMatching","rope::RopeInfo","tree::Node","diff::DiffOp","delta::InsertDelta","tree::NodeBody","interval::Interval","multiset::Segment","delta::Delta","engine::Contents","spans::Span","breaks::BreaksBaseMetric","spans::SpansInfo","engine::RevId","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","multiset::CountMatcher","tree::NodeVal","engine::DeltaOp","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksLeaf","rope::BaseMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","delta::DeltaElement","multiset::ZipSegment"]},"spans::SpansInfo":{"T":["multiset::Segment","rope::LinesMetric","breaks::BreaksMetric","diff::DiffOp","breaks::BreaksLeaf","tree::Node","engine::Error","delta::DeltaElement","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpansLeaf","spans::Span","multiset::ZipSegment","find::CaseMatching","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","tree::NodeVal","tree::NodeBody","delta::InsertDelta","interval::Interval","rope::RopeInfo","engine::DeltaOp","engine::RevId","spans::SpansInfo","multiset::Subset","delta::Delta","engine::Contents","engine::FullPriority"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","delta::DeltaElement","tree::NodeBody","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","engine::RevId","diff::DiffBuilder","engine::Error","diff::DiffOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","multiset::Subset","interval::Interval","rope::BaseMetric","multiset::CountMatcher","spans::SpansInfo","delta::Delta","multiset::Segment","engine::Contents","rope::LinesMetric","delta::InsertDelta","rope::RopeInfo","engine::FullPriority","spans::Span","engine::DeltaOp","tree::NodeVal","breaks::BreaksBaseMetric","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeInfo::compute_info":{"Self":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <Self as tree::NodeInfo>::L
+tree::NodeInfo::compute_info(p0);
+crate::tree::NodeInfo::compute_info(p0);
+crate::tree::NodeInfo::compute_info(p0);
-----------------
rope/src/tree.rs tree::NodeInfo::identity
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeInfo::identity":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","engine::Contents","multiset::Subset","rope::RopeInfo","multiset::ZipSegment","engine::Error","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","rope::BaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","rope::Utf16CodeUnitsMetric","delta::Delta","spans::SpansInfo","find::CaseMatching","interval::Interval","tree::Node","rope::LinesMetric","engine::DeltaOp","tree::NodeBody","multiset::CountMatcher","delta::InsertDelta","delta::DeltaElement","diff::DiffBuilder","tree::NodeVal","diff::DiffOp","spans::SpansLeaf","breaks::BreaksBaseMetric","spans::Span","multiset::Segment"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","delta::Delta","breaks::BreaksLeaf","engine::Contents","delta::DeltaElement","breaks::BreaksInfo","engine::RevId","multiset::CountMatcher","engine::FullPriority","tree::NodeBody","breaks::BreaksBaseMetric","breaks::BreaksMetric","tree::NodeVal","rope::RopeInfo","engine::DeltaOp","delta::InsertDelta","tree::Node","diff::DiffOp","spans::SpansLeaf","find::CaseMatching","multiset::ZipSegment","engine::Error","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","rope::LinesMetric","rope::BaseMetric","interval::Interval","spans::SpansInfo","diff::DiffBuilder","spans::Span"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","breaks::BreaksInfo","multiset::CountMatcher","rope::BaseMetric","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksLeaf","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","delta::InsertDelta","breaks::BreaksMetric","rope::RopeInfo","find::CaseMatching","engine::FullPriority","engine::Error","diff::DiffOp","spans::Span","breaks::BreaksBaseMetric","rope::LinesMetric","delta::DeltaElement","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansInfo","delta::Delta","tree::Node","engine::RevId","engine::Contents","multiset::Segment","interval::Interval","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeInfo::identity":{"Self":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
+tree::NodeInfo::identity();
+crate::tree::NodeInfo::identity();
+crate::tree::NodeInfo::identity();
-----------------
trace/src/sys_pid.rs sys_pid::current_pid
deps:{}
candidates:{}
+sys_pid::current_pid();
+crate::sys_pid::current_pid();
+crate::sys_pid::current_pid();
-----------------
trace/src/sys_tid.rs sys_tid::current_tid
deps:{}
candidates:{}
+sys_tid::current_tid();
+crate::sys_tid::current_tid();
+crate::sys_tid::current_tid();
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::serialize
deps:{"chrome_trace_dump::serialize":{"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"chrome_trace_dump::serialize":{"W":["std::io::StderrLock<'_>","std::io::buffered::linewritershim::LineWriterShim<'a, W>","&std::process::ChildStdin","std::io::StdoutLock<'_>","std::io::impls::<impl std::io::Write for &mut W>","std::io::Stderr","std::io::stdio::StderrRaw","std::collections::VecDeque<u8, A>","std::io::Cursor<std::boxed::Box<[u8], A>>","&std::net::TcpStream","std::vec::Vec<u8, A>","&std::fs::File","std::io::Cursor<std::vec::Vec<u8, A>>","std::io::BorrowedCursor<'a>","std::io::BufWriter<W>","std::io::Stdout","std::io::stdio::StdoutRaw","&'a std::os::unix::net::UnixStream","&std::io::Stderr","&std::io::Sink","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stderr","std::io::LineWriter<W>","std::io::Cursor<&mut [u8]>","std::io::Cursor<[u8; N]>","std::boxed::Box<W>","std::process::ChildStdin","std::sys::unix::stdio::Stdout","std::io::Sink","std::net::TcpStream","std::fs::File","std::io::Cursor<&mut std::vec::Vec<u8, A>>","&std::io::Stdout"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::vec::Vec<Sample>
let mut p1 = MaybeUninit::uninit().assume_init(); // W
+chrome_trace_dump::serialize(p0, p1);
+crate::chrome_trace_dump::serialize(p0, p1);
+crate::chrome_trace_dump::serialize(p0, p1);
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::to_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::vec::Vec<Sample>
+chrome_trace_dump::to_value(p0);
+crate::chrome_trace_dump::to_value(p0);
+crate::chrome_trace_dump::to_value(p0);
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::decode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_json::Value
+chrome_trace_dump::decode(p0);
+crate::chrome_trace_dump::decode(p0);
+crate::chrome_trace_dump::decode(p0);
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::deserialize
deps:{"chrome_trace_dump::deserialize":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"chrome_trace_dump::deserialize":{"R":["std::io::Stdin","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::BufReader<R>","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::process::ChildStdout","&std::fs::File","std::fs::File","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::io::stdio::StdinRaw","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::process::ChildStderr","std::boxed::Box<R>","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+chrome_trace_dump::deserialize(p0);
+crate::chrome_trace_dump::deserialize(p0);
+crate::chrome_trace_dump::deserialize(p0);
-----------------
trace/src/lib.rs ns_to_us
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+ns_to_us(p0);
+crate::ns_to_us(p0);
+crate::ns_to_us(p0);
-----------------
trace/src/lib.rs serialize_event_type
deps:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serialize_event_type":{"S":["std::marker::Sized","serde::Serializer"]}}
candidates:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serialize_event_type":{"S":["serde_json::ser::MapKeySerializer<'a, W, F>","serde::private::ser::content::ContentSerializer<E>","<&'a mut serde_json::Serializer<W, F> as serde::Serializer>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::TaggedSerializer<S>","serde_json::value::ser::MapKeySerializer","serde_json::value::Serializer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleEventType
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+serialize_event_type(p0, p1);
+crate::serialize_event_type(p0, p1);
+crate::serialize_event_type(p0, p1);
-----------------
trace/src/lib.rs deserialize_event_type
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"deserialize_event_type":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"deserialize_event_type":{"D":["serde::de::value::I64Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::F64Deserializer<E>","serde_json::de::MapKey<'a, R>","&'de serde_json::Value","serde::de::value::StringDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::CharDeserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::I16Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde_json::Number","serde::de::value::U8Deserializer<E>","&'a serde_json::Number","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>","serde_json::value::de::SeqDeserializer","serde::de::value::UnitDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde_json::Value","serde::de::value::U128Deserializer<E>","serde::de::value::F32Deserializer<E>","serde_json::value::de::MapDeserializer","serde::de::value::I32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I8Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U64Deserializer<E>","serde::de::value::I128Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+deserialize_event_type(p0);
+crate::deserialize_event_type(p0);
+crate::deserialize_event_type(p0);
-----------------
trace/src/lib.rs to_cow_str
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"to_cow_str":{"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"to_cow_str":{"S":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
+to_cow_str(p0);
+crate::to_cow_str(p0);
+crate::to_cow_str(p0);
-----------------
trace/src/lib.rs exe_name
deps:{}
candidates:{}
+exe_name();
+crate::exe_name();
+crate::exe_name();
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs <TRACE as lazy_static::__Deref>::deref::__static_ref_initialize
deps:{}
candidates:{}
+<TRACE as lazy_static::__Deref>::deref::__static_ref_initialize();
+crate::<TRACE as lazy_static::__Deref>::deref::__static_ref_initialize();
+<TRACE>::deref::__static_ref_initialize();
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs <TRACE as lazy_static::__Deref>::deref::__stability
deps:{}
candidates:{}
+<TRACE as lazy_static::__Deref>::deref::__stability();
+crate::<TRACE as lazy_static::__Deref>::deref::__stability();
+<TRACE>::deref::__stability();
-----------------
trace/src/lib.rs enable_tracing
deps:{}
candidates:{}
+enable_tracing();
+crate::enable_tracing();
+crate::enable_tracing();
-----------------
trace/src/lib.rs enable_tracing_with_config
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // Config
+enable_tracing_with_config(p0);
+crate::enable_tracing_with_config(p0);
+crate::enable_tracing_with_config(p0);
-----------------
trace/src/lib.rs disable_tracing
deps:{}
candidates:{}
+disable_tracing();
+crate::disable_tracing();
+crate::disable_tracing();
-----------------
trace/src/lib.rs is_enabled
deps:{}
candidates:{}
+is_enabled();
+crate::is_enabled();
+crate::is_enabled();
-----------------
trace/src/lib.rs trace
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"trace":{"C":["std::convert::Into","std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"trace":{"C":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"S":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+trace(p0, p1);
+crate::trace(p0, p1);
+crate::trace(p0, p1);
-----------------
trace/src/lib.rs trace_payload
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"trace_payload":{"C":["std::convert::Into","std::marker::Sized"],"P":["std::convert::Into","std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"trace_payload":{"C":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"],"P":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"S":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // P
+trace_payload(p0, p1, p2);
+crate::trace_payload(p0, p1, p2);
+crate::trace_payload(p0, p1, p2);
-----------------
trace/src/lib.rs trace_block
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"trace_block":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"trace_block":{"C":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"S":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+trace_block(p0, p1);
+crate::trace_block(p0, p1);
+crate::trace_block(p0, p1);
-----------------
trace/src/lib.rs trace_block_payload
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"trace_block_payload":{"C":["std::convert::Into","std::marker::Sized"],"P":["std::convert::Into","std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"trace_block_payload":{"C":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"],"P":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"],"S":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // P
+trace_block_payload(p0, p1, p2);
+crate::trace_block_payload(p0, p1, p2);
+crate::trace_block_payload(p0, p1, p2);
-----------------
trace/src/lib.rs trace_closure
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"trace_closure":{"C":["std::convert::Into","std::marker::Sized"],"F":["std::ops::FnOnce","std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"trace_closure":{"C":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"],"F":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>"],"R":["RUG_ANY"],"S":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+trace_closure(p0, p1, p2);
+crate::trace_closure(p0, p1, p2);
+crate::trace_closure(p0, p1, p2);
-----------------
trace/src/lib.rs trace_closure_payload
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"trace_closure_payload":{"C":["std::marker::Sized","std::convert::Into"],"F":["std::marker::Sized","std::ops::FnOnce"],"P":["std::convert::Into","std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"trace_closure_payload":{"C":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"],"P":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"R":["RUG_ANY"],"S":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // F
let mut p3 = MaybeUninit::uninit().assume_init(); // P
+trace_closure_payload(p0, p1, p2, p3);
+crate::trace_closure_payload(p0, p1, p2, p3);
+crate::trace_closure_payload(p0, p1, p2, p3);
-----------------
trace/src/lib.rs samples_len
deps:{}
candidates:{}
+samples_len();
+crate::samples_len();
+crate::samples_len();
-----------------
trace/src/lib.rs samples_cloned_unsorted
deps:{}
candidates:{}
+samples_cloned_unsorted();
+crate::samples_cloned_unsorted();
+crate::samples_cloned_unsorted();
-----------------
trace/src/lib.rs samples_cloned_sorted
deps:{}
candidates:{}
+samples_cloned_sorted();
+crate::samples_cloned_sorted();
+crate::samples_cloned_sorted();
-----------------
trace/src/lib.rs save
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"save":{"P":["std::convert::AsRef","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"save":{"P":["core::num::dec2flt::common::AsciiStr<'a>","std::slice::Iter<'_, T>","std::vec::Drain<'a, T, A>","std::ffi::CString","std::borrow::Cow<'_, std::ffi::OsStr>","std::ffi::CStr","std::rc::Rc<T>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::slice::IterMut<'_, T>","<&T as std::convert::AsRef<U>>","std::borrow::Cow<'_, T>","std::vec::IntoIter<T, A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
let mut p1 = true; // None+bool
+save(p0, p1);
+crate::save(p0, p1);
+crate::save(p0, p1);
-----------------
trace/src/lib.rs StringArrayEq::arr_eq
deps:{"<&A as std::alloc::Allocator>":{},"StringArrayEq::arr_eq":{"Self":["StringArrayEq"]},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"StringArrayEq::arr_eq":{"Self":["std::vec::Vec"]},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Rhs
+p0.arr_eq(p1);
+StringArrayEq::arr_eq(p0, p1);
+crate::StringArrayEq::arr_eq(p0, p1);
+crate::StringArrayEq::arr_eq(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone
deps:{"<fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{}}
candidates:{"<fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone":{"T":["SampleArgs","Config","std::clone::impls::<impl std::clone::Clone for &T>","fixed_lifo_deque::FixedLifoDeque","Sample","chrome_trace_dump::ChromeTraceArrayEntries","CategoriesT","SampleEventType","MetadataType"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::copy_impls::<impl std::marker::Copy for &T>","SampleEventType"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.clone();
+<fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone(p0);
+crate::<fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::clone(p0);
-----------------
rope/src/tree.rs tree::NodeInfo::interval
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeInfo::interval":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::Contents","engine::DeltaOp","delta::Delta","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","spans::SpansLeaf","tree::Node","tree::NodeBody","multiset::ZipSegment","interval::Interval","tree::NodeVal","spans::SpansInfo","rope::RopeInfo","engine::Error","spans::Span","find::CaseMatching","multiset::CountMatcher","engine::RevId","breaks::BreaksMetric","diff::DiffBuilder","breaks::BreaksInfo","engine::FullPriority","multiset::Subset","diff::DiffOp","breaks::BreaksBaseMetric","delta::DeltaElement","multiset::Segment","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","rope::BaseMetric"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","breaks::BreaksLeaf","tree::NodeVal","multiset::Segment","engine::RevId","spans::SpansInfo","engine::DeltaOp","engine::FullPriority","breaks::BreaksInfo","multiset::Subset","multiset::CountMatcher","find::CaseMatching","breaks::BreaksBaseMetric","tree::NodeBody","rope::RopeInfo","engine::Error","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","tree::Node","rope::BaseMetric","interval::Interval","multiset::ZipSegment","spans::SpansLeaf","delta::InsertDelta","diff::DiffBuilder","delta::Delta","delta::DeltaElement","engine::Contents","rope::Utf16CodeUnitsMetric","spans::Span"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","rope::LinesMetric","engine::DeltaOp","engine::Contents","rope::BaseMetric","engine::Error","delta::InsertDelta","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","spans::SpansLeaf","multiset::Subset","rope::Utf16CodeUnitsMetric","spans::Span","multiset::ZipSegment","tree::NodeVal","engine::RevId","breaks::BreaksLeaf","tree::Node","multiset::Segment","delta::DeltaElement","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","engine::FullPriority","multiset::CountMatcher","breaks::BreaksBaseMetric","interval::Interval","delta::Delta","breaks::BreaksInfo","diff::DiffBuilder","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeInfo::interval":{"Self":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.interval(p1);
+tree::NodeInfo::interval(p0, p1);
+crate::tree::NodeInfo::interval(p0, p1);
+crate::tree::NodeInfo::interval(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt":{"T":["chrome_trace_dump::Error","fixed_lifo_deque::FixedLifoDeque","CategoriesT","<*mut T as std::fmt::Debug>","SampleEventType","SampleArgs","Sample","chrome_trace_dump::ChromeTraceArrayEntries","MetadataType","<&mut T as std::fmt::Debug>"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","SampleEventType"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::fmt(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::new
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::new":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::new":{"T":["RUG_ANY"]}}
+fixed_lifo_deque::FixedLifoDeque::<T>::new();
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::new();
+<fixed_lifo_deque::FixedLifoDeque<T>>::new();
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::with_limit
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::with_limit":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::with_limit":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+fixed_lifo_deque::FixedLifoDeque::<T>::with_limit(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::with_limit(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::with_limit(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.reset_limit(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::reset_limit(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::limit
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::limit":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::limit":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.limit();
+fixed_lifo_deque::FixedLifoDeque::<T>::limit(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::limit(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::limit(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::get
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::get":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::get":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::get(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::get(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::get(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::get_mut
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::get_mut":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::get_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::get_mut(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::get_mut(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::get_mut(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::swap
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.swap(p1, p2);
+fixed_lifo_deque::FixedLifoDeque::<T>::swap(p0, p1, p2);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::swap(p0, p1, p2);
+<fixed_lifo_deque::FixedLifoDeque<T>>::swap(p0, p1, p2);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::capacity
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::capacity":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::capacity":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.capacity();
+fixed_lifo_deque::FixedLifoDeque::<T>::capacity(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::capacity(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::capacity(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::iter
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::iter":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.iter();
+fixed_lifo_deque::FixedLifoDeque::<T>::iter(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::iter(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::iter(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.iter_mut();
+fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::iter_mut(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::as_slices
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::as_slices":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::as_slices":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.as_slices();
+fixed_lifo_deque::FixedLifoDeque::<T>::as_slices(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::as_slices(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::as_slices(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.as_mut_slices();
+fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::as_mut_slices(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::len
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::len":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.len();
+fixed_lifo_deque::FixedLifoDeque::<T>::len(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::len(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::len(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::is_empty
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::is_empty":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.is_empty();
+fixed_lifo_deque::FixedLifoDeque::<T>::is_empty(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::is_empty(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::is_empty(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::drain
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::drain":{"R":["std::ops::RangeBounds","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::drain":{"R":["std::ops::RangeInclusive<&T>","std::ops::Range<&T>","std::ops::RangeToInclusive<T>","std::ops::RangeTo<&T>","(std::collections::Bound<T>, std::collections::Bound<T>)","std::ops::RangeFrom<T>","std::ops::RangeInclusive<T>","(std::collections::Bound<&'a T>, std::collections::Bound<&'a T>)","std::ops::Range<T>","std::ops::RangeToInclusive<&T>","std::ops::RangeTo<T>","std::ops::RangeFrom<&T>","std::ops::RangeFull"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // R
+p0.drain(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::drain(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::drain(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::drain(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::clear
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::clear":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::clear":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.clear();
+fixed_lifo_deque::FixedLifoDeque::<T>::clear(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::clear(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::clear(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::contains
deps:{"<*const T as std::fmt::Debug>":{},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"fixed_lifo_deque::FixedLifoDeque::<T>::contains":{"T":["std::cmp::PartialEq","std::marker::Sized"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"fixed_lifo_deque::FixedLifoDeque":{"T":["SampleEventType","std::marker::copy_impls::<impl std::marker::Copy for &T>"]},"fixed_lifo_deque::FixedLifoDeque::<T>::contains":{"T":["SampleArgs","MetadataType","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","fixed_lifo_deque::FixedLifoDeque","SampleEventType","Sample","CategoriesT"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.contains(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::contains(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::contains(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::contains(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::front
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::front":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::front":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.front();
+fixed_lifo_deque::FixedLifoDeque::<T>::front(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::front(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::front(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::front_mut
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::front_mut":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::front_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.front_mut();
+fixed_lifo_deque::FixedLifoDeque::<T>::front_mut(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::front_mut(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::front_mut(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::back
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::back":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::back":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.back();
+fixed_lifo_deque::FixedLifoDeque::<T>::back(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::back(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::back(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::back_mut
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::back_mut":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::back_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.back_mut();
+fixed_lifo_deque::FixedLifoDeque::<T>::back_mut(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::back_mut(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::back_mut(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.drop_excess_for_inserting(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::drop_excess_for_inserting(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::pop_front
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::pop_front":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::pop_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.pop_front();
+fixed_lifo_deque::FixedLifoDeque::<T>::pop_front(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::pop_front(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::pop_front(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::push_back
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::push_back":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::push_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.push_back(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::push_back(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::push_back(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::push_back(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::pop_back
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::pop_back":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::pop_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.pop_back();
+fixed_lifo_deque::FixedLifoDeque::<T>::pop_back(p0);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::pop_back(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::pop_back(p0);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.swap_remove_back(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::swap_remove_back(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.swap_remove_front(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::swap_remove_front(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::remove
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::remove":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::remove":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::remove(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::remove(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::remove(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::split_off
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::split_off":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::split_off":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
+p0.split_off(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::split_off(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::split_off(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::split_off(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::append
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::append":{"T":["std::marker::Sized"]}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::append":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::collections::VecDeque<T>
+p0.append(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::append(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::append(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::append(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::retain
deps:{"fixed_lifo_deque::FixedLifoDeque::<T>::retain":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"fixed_lifo_deque::FixedLifoDeque::<T>::retain":{"F":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.retain(p1);
+fixed_lifo_deque::FixedLifoDeque::<T>::retain(p0, p1);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::retain(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::retain(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs fixed_lifo_deque::FixedLifoDeque::<T>::resize
deps:{"<*const T as std::fmt::Debug>":{},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::clone::Clone"]},"fixed_lifo_deque::FixedLifoDeque::<T>::resize":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","SampleEventType"]},"fixed_lifo_deque::FixedLifoDeque::<T>::resize":{"T":["chrome_trace_dump::ChromeTraceArrayEntries","SampleEventType","std::clone::impls::<impl std::clone::Clone for *mut T>","CategoriesT","fixed_lifo_deque::FixedLifoDeque","SampleArgs","MetadataType","Sample","std::clone::impls::<impl std::clone::Clone for *const T>","Config"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.resize(p1, p2);
+fixed_lifo_deque::FixedLifoDeque::<T>::resize(p0, p1, p2);
+crate::fixed_lifo_deque::FixedLifoDeque::<T>::resize(p0, p1, p2);
+<fixed_lifo_deque::FixedLifoDeque<T>>::resize(p0, p1, p2);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq
deps:{"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug"]},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq":{"A":["fixed_lifo_deque::FixedLifoDeque","CategoriesT","Sample","SampleEventType","MetadataType","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","SampleArgs"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["SampleEventType","<*mut T as std::fmt::Debug>"]},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
+p0.eq(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::eq(p0, p1);
-----------------
rope/src/tree.rs tree::Leaf::len
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::len":{"Self":["std::clone::Clone","tree::Leaf","std::marker::Sized","std::default::Default"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::InsertDelta","engine::Error","rope::LinesMetric","spans::SpansInfo","spans::Span","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","diff::DiffBuilder","engine::RevId","delta::Delta","interval::Interval","multiset::CountMatcher","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","tree::Node","delta::DeltaElement","breaks::BreaksBaseMetric","diff::DiffOp","engine::Contents","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::Subset","find::CaseMatching","multiset::ZipSegment","breaks::BreaksMetric","multiset::Segment","spans::SpansLeaf","rope::BaseMetric","rope::RopeInfo"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","tree::Node","breaks::BreaksBaseMetric","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","spans::Span","diff::DiffBuilder","diff::DiffOp","rope::RopeInfo","rope::BaseMetric","spans::SpansInfo","multiset::Segment","tree::NodeVal","tree::NodeBody","find::CaseMatching","engine::RevId","interval::Interval","rope::LinesMetric","engine::FullPriority","engine::DeltaOp","engine::Error","breaks::BreaksLeaf","multiset::Subset","delta::DeltaElement","engine::Contents","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","delta::DeltaElement","spans::SpansLeaf","engine::Contents","diff::DiffBuilder","engine::DeltaOp","engine::RevId","multiset::Segment","delta::Delta","interval::Interval","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","engine::FullPriority","breaks::BreaksInfo","engine::Error","breaks::BreaksBaseMetric","multiset::CountMatcher","rope::RopeInfo","tree::NodeBody","delta::InsertDelta","spans::Span","rope::BaseMetric","spans::SpansInfo","diff::DiffOp","find::CaseMatching","breaks::BreaksLeaf","tree::Node","breaks::BreaksMetric","multiset::Subset","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::len":{"Self":["std::string::String","breaks::BreaksLeaf","spans::SpansLeaf"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+tree::Leaf::len(p0);
+crate::tree::Leaf::len(p0);
+crate::tree::Leaf::len(p0);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp
deps:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp":{"A":["std::marker::Sized","std::cmp::PartialOrd"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","Sample","fixed_lifo_deque::FixedLifoDeque","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["SampleEventType","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
+p0.partial_cmp(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::partial_cmp(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp
deps:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp":{"A":["std::marker::Sized","std::cmp::Ord"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp":{"A":["std::cmp::impls::<impl std::cmp::Ord for &mut A>","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","fixed_lifo_deque::FixedLifoDeque","Sample"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["SampleEventType","<&T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
+p0.cmp(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::cmp(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash":{"A":["std::marker::Sized","std::hash::Hash"],"H":["std::marker::Sized","std::hash::Hasher"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash":{"A":["fixed_lifo_deque::FixedLifoDeque","Sample","std::hash::impls::<impl std::hash::Hash for *const T>"],"H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["SampleEventType","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::hash(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index
deps:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index":{"A":["std::marker::Sized"]}}
candidates:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index":{"A":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::index(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut
deps:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut":{"A":["std::marker::Sized"]}}
candidates:{"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut":{"A":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = 0usize; // None+usize
+p0.index_mut(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::index_mut(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter
deps:{"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.into_iter();
+<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<fixed_lifo_deque::FixedLifoDeque<T>>::into_iter(p0);
-----------------
trace/src/fixed_lifo_deque.rs <&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.into_iter();
+<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a fixed_lifo_deque::FixedLifoDeque<T>>::into_iter(p0);
-----------------
trace/src/fixed_lifo_deque.rs <&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
+p0.into_iter();
+<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut fixed_lifo_deque::FixedLifoDeque<T>>::into_iter(p0);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend
deps:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend":{"A":["std::marker::Sized"],"T":["std::marker::Sized","std::iter::IntoIterator"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
candidates:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::slice::ChunksExact<'a, T>","std::iter::IntersperseWith<I, G>","std::collections::hash_map::IntoIter<K, V>","std::path::Ancestors<'a>","std::slice::RSplitN<'a, T, P>","std::env::Vars","std::iter::adapters::flatten::FlattenCompat<I, U>","std::slice::EscapeAscii<'a>","std::sys::unix::os::SplitPaths<'a>","std::iter::FlatMap<I, U, F>","std::iter::FilterMap<I, F>","std::slice::ArrayChunks<'a, T, N>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::vec_deque::IterMut<'a, T>","std::collections::hash_set::Difference<'a, T, S>","std::slice::GroupByMut<'a, T, P>","std::str::RSplit<'a, P>","std::path::Components<'a>","std::slice::RChunks<'a, T>","std::iter::Successors<T, F>","std::slice::Windows<'a, T>","std::result::Iter<'a, T>","std::str::SplitWhitespace<'a>","std::sync::mpsc::Iter<'a, T>","std::iter::Fuse<I>","std::collections::btree_set::SymmetricDifference<'a, T>","std::slice::SplitInclusive<'a, T, P>","std::collections::btree_map::IntoValues<K, V, A>","std::os::unix::net::Incoming<'a>","std::iter::Enumerate<I>","std::collections::linked_list::Iter<'a, T>","std::iter::Filter<I, P>","std::ops::Range<A>","std::str::RSplitN<'a, P>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::btree_map::IterMut<'a, K, V>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::FromFn<F>","std::collections::btree_map::RangeMut<'a, K, V>","std::collections::btree_set::Range<'a, T>","std::iter::Scan<I, St, F>","std::iter::ArrayChunks<I, N>","std::collections::binary_heap::IntoIter<T>","std::collections::vec_deque::IntoIter<T, A>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::SkipWhile<I, P>","std::iter::Skip<I>","std::str::LinesAny<'a>","std::iter::StepBy<I>","std::collections::linked_list::IntoIter<T>","std::collections::btree_map::Iter<'a, K, V>","std::str::EscapeUnicode<'a>","std::sys::unix::process::process_common::CommandArgs<'a>","std::slice::ChunksExactMut<'a, T>","std::slice::RChunksExact<'a, T>","std::iter::Repeat<A>","std::sys::unix::args::Args","std::iter::Map<I, F>","std::collections::hash_set::Drain<'a, K>","std::sync::mpsc::IntoIter<T>","std::collections::btree_map::ValuesMut<'a, K, V>","std::io::Split<B>","std::char::EscapeDefault","std::io::Bytes<R>","std::sync::mpsc::TryIter<'a, T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::boxed::Box<I, A>","std::slice::SplitMut<'a, T, P>","std::collections::hash_map::Keys<'a, K, V>","std::slice::SplitNMut<'a, T, P>","std::str::Split<'a, P>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::Rev<I>","std::ops::RangeInclusive<A>","std::char::EscapeUnicode","std::option::IterMut<'a, A>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::str::SplitInclusive<'a, P>","std::str::EscapeDebug<'a>","std::result::IntoIter<T>","std::iter::Cloned<I>","std::iter::RepeatN<A>","std::iter::MapWhile<I, P>","std::process::CommandEnvs<'a>","std::iter::Zip<A, B>","std::option::Iter<'a, A>","std::collections::btree_map::Keys<'a, K, V>","std::str::SplitAsciiWhitespace<'a>","std::collections::btree_map::Values<'a, K, V>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::ops::index_range::IndexRange","std::sys_common::net::LookupHost","std::char::DecodeUtf16<I>","std::iter::Copied<I>","std::slice::RSplit<'a, T, P>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::TakeWhile<I, P>","std::ops::RangeFrom<A>","std::str::RMatches<'a, P>","std::collections::hash_set::Union<'a, T, S>","std::slice::Iter<'a, T>","std::str::Chars<'a>","<&mut I as std::iter::Iterator>","core::error::Source<'a>","std::iter::Cycle<I>","std::env::ArgsOs","std::env::SplitPaths<'a>","std::env::VarsOs","std::iter::OnceWith<F>","std::net::IntoIncoming","std::iter::Flatten<I>","std::iter::RepeatWith<F>","std::collections::hash_map::Iter<'a, K, V>","std::collections::hash_set::Intersection<'a, T, S>","std::os::unix::net::Messages<'a>","std::str::EscapeDefault<'a>","std::char::ToLowercase","std::path::Iter<'a>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::hash_map::IterMut<'a, K, V>","std::slice::IterMut<'a, T>","std::collections::hash_map::IntoValues<K, V>","std::collections::hash_map::Drain<'a, K, V>","std::collections::linked_list::IterMut<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::os::unix::net::ScmRights<'a>","std::sys::unix::os::Env","std::collections::btree_set::IntoIter<T, A>","std::slice::ArrayWindows<'a, T, N>","std::collections::binary_heap::Drain<'_, T>","std::collections::btree_map::Range<'a, K, V>","std::slice::Split<'a, T, P>","std::collections::hash_map::IntoKeys<K, V>","std::collections::hash_set::Iter<'a, K>","std::fs::ReadDir","std::iter::ByRefSized<'_, I>","std::slice::GroupBy<'a, T, P>","std::string::Drain<'_>","std::slice::RChunksMut<'a, T>","std::str::SplitN<'a, P>","std::slice::ChunksMut<'a, T>","std::str::Utf8Chunks<'a>","std::iter::Intersperse<I>","std::net::Incoming<'a>","std::collections::btree_set::Iter<'a, T>","std::str::EncodeUtf16<'a>","std::ascii::EscapeDefault","std::vec::Drain<'_, T, A>","std::slice::ArrayChunksMut<'a, T, N>","std::io::Lines<B>","std::slice::RSplitNMut<'a, T, P>","std::option::IntoIter<A>","std::str::CharIndices<'a>","std::vec::Splice<'_, I, A>","std::iter::Empty<T>","std::str::Lines<'a>","core::slice::iter::GenericSplitN<I>","std::slice::SplitN<'a, T, P>","std::char::CaseMappingIter","std::slice::RSplitMut<'a, T, P>","std::collections::binary_heap::Iter<'a, T>","std::iter::Take<I>","std::iter::Chain<A, B>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::vec_deque::Iter<'a, T>","std::collections::binary_heap::IntoIterSorted<T>","std::slice::RChunksExactMut<'a, T>","std::env::Args","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_set::Difference<'a, T, A>","std::str::SplitTerminator<'a, P>","std::iter::Peekable<I>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::Chunks<'a, T>","std::process::CommandArgs<'a>","std::collections::btree_set::Union<'a, T>","std::str::Bytes<'_>","std::collections::hash_set::IntoIter<K>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::str::RSplitTerminator<'a, P>","std::iter::Once<T>","std::array::IntoIter<T, N>","std::os::unix::net::ScmCredentials<'a>","std::option::Item<A>","std::char::ToUppercase","std::vec::DrainFilter<'_, T, F, A>","std::str::RMatchIndices<'a, P>","std::sys_common::wstr::WStrUnits<'_>","std::result::IterMut<'a, T>","std::char::EscapeDebug","std::str::MatchIndices<'a, P>","std::str::Matches<'a, P>","std::iter::Inspect<I, F>","std::vec::IntoIter<T, A>","std::sys::unix::fs::ReadDir"]},"<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend":{"A":["RUG_ANY"],"T":["fixed_lifo_deque::FixedLifoDeque","<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["<*mut T as std::fmt::Debug>","SampleEventType"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<A>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<A>>::extend(p0, p1);
-----------------
trace/src/fixed_lifo_deque.rs <fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend
'a
deps:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<*const T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend":{"I":["std::marker::Sized","std::iter::IntoIterator"],"T":["std::marker::Copy","std::marker::Sized"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a serde_json::Map<std::string::String, serde_json::Value> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<*const T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::collections::vec_deque::Drain<'_, T, A>","std::collections::btree_set::Union<'a, T>","std::collections::vec_deque::Iter<'a, T>","std::str::RSplitTerminator<'a, P>","std::collections::hash_set::Drain<'a, K>","std::slice::SplitMut<'a, T, P>","std::collections::linked_list::IntoIter<T>","std::str::RMatches<'a, P>","std::iter::Intersperse<I>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_set::IntoIter<T, A>","std::slice::ArrayChunksMut<'a, T, N>","std::iter::Cloned<I>","std::collections::vec_deque::IntoIter<T, A>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::path::Iter<'a>","std::process::CommandArgs<'a>","std::str::EscapeDebug<'a>","std::path::Components<'a>","std::str::RSplit<'a, P>","std::collections::btree_set::Range<'a, T>","std::str::SplitInclusive<'a, P>","std::char::CaseMappingIter","std::ops::RangeInclusive<A>","std::iter::Zip<A, B>","std::fs::ReadDir","std::collections::hash_map::IntoKeys<K, V>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::ArrayChunks<I, N>","std::iter::Successors<T, F>","std::collections::hash_map::Keys<'a, K, V>","std::env::SplitPaths<'a>","std::char::EscapeUnicode","std::str::Chars<'a>","std::iter::ByRefSized<'_, I>","std::collections::hash_set::IntoIter<K>","std::sync::mpsc::IntoIter<T>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::Once<T>","std::slice::Chunks<'a, T>","std::slice::GroupByMut<'a, T, P>","std::ops::Range<A>","std::str::SplitTerminator<'a, P>","std::sys_common::net::LookupHost","std::sys_common::wstr::WStrUnits<'_>","std::collections::hash_map::Values<'a, K, V>","std::env::Vars","std::str::SplitWhitespace<'a>","std::collections::hash_map::IterMut<'a, K, V>","std::collections::btree_set::Difference<'a, T, A>","std::char::DecodeUtf16<I>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::binary_heap::IntoIter<T>","std::collections::hash_set::Difference<'a, T, S>","std::collections::btree_map::IterMut<'a, K, V>","std::io::Split<B>","std::collections::btree_map::Values<'a, K, V>","std::sync::mpsc::Iter<'a, T>","std::collections::btree_map::RangeMut<'a, K, V>","std::str::RSplitN<'a, P>","std::vec::DrainFilter<'_, T, F, A>","std::net::Incoming<'a>","std::iter::adapters::GenericShunt<'_, I, R>","core::slice::iter::GenericSplitN<I>","std::ascii::EscapeDefault","std::iter::Inspect<I, F>","std::slice::ChunksMut<'a, T>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::RepeatWith<F>","std::slice::Iter<'a, T>","std::char::EscapeDefault","std::iter::Peekable<I>","std::iter::SkipWhile<I, P>","std::collections::btree_set::SymmetricDifference<'a, T>","std::iter::Scan<I, St, F>","std::iter::TakeWhile<I, P>","std::slice::ChunksExactMut<'a, T>","std::option::IterMut<'a, A>","std::collections::linked_list::Iter<'a, T>","std::char::ToLowercase","std::slice::RSplitN<'a, T, P>","core::error::Source<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::slice::Windows<'a, T>","std::iter::Cycle<I>","std::iter::FromFn<F>","std::slice::ArrayChunks<'a, T, N>","std::collections::btree_map::ValuesMut<'a, K, V>","std::env::Args","std::collections::btree_map::Iter<'a, K, V>","std::iter::Rev<I>","std::collections::hash_map::Drain<'a, K, V>","std::sys::unix::os::Env","std::str::Utf8Chunks<'a>","std::io::Bytes<R>","std::str::SplitN<'a, P>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::btree_map::IntoKeys<K, V, A>","std::path::Ancestors<'a>","std::str::Matches<'a, P>","std::slice::RChunksMut<'a, T>","std::collections::hash_set::Intersection<'a, T, S>","std::result::Iter<'a, T>","std::collections::binary_heap::Drain<'_, T>","std::string::Drain<'_>","std::str::CharIndices<'a>","std::slice::Split<'a, T, P>","std::slice::RChunksExactMut<'a, T>","std::iter::MapWhile<I, P>","std::iter::Skip<I>","std::iter::RepeatN<A>","std::iter::FlatMap<I, U, F>","std::slice::SplitInclusiveMut<'a, T, P>","std::iter::IntersperseWith<I, G>","std::os::unix::net::Incoming<'a>","std::iter::Filter<I, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::slice::SplitN<'a, T, P>","std::result::IterMut<'a, T>","std::result::IntoIter<T>","std::slice::SplitNMut<'a, T, P>","std::sys::unix::args::Args","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::str::SplitAsciiWhitespace<'a>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::ArrayWindows<'a, T, N>","std::env::ArgsOs","std::option::Item<A>","std::collections::hash_set::Union<'a, T, S>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::Iter<'a, K, V>","std::array::IntoIter<T, N>","std::option::Iter<'a, A>","std::iter::StepBy<I>","std::str::EscapeDefault<'a>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_set::Iter<'a, T>","std::str::Split<'a, P>","std::slice::SplitInclusive<'a, T, P>","std::iter::Chain<A, B>","std::slice::GroupBy<'a, T, P>","std::str::Bytes<'_>","std::vec::Splice<'_, I, A>","std::slice::RChunks<'a, T>","std::iter::Fuse<I>","std::net::IntoIncoming","std::io::Lines<B>","std::iter::Map<I, F>","std::slice::RSplit<'a, T, P>","std::vec::Drain<'_, T, A>","std::slice::RSplitNMut<'a, T, P>","std::sys::unix::os::SplitPaths<'a>","std::str::EncodeUtf16<'a>","std::collections::vec_deque::IterMut<'a, T>","std::iter::Copied<I>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::RChunksExact<'a, T>","std::iter::Flatten<I>","std::slice::ChunksExact<'a, T>","std::option::IntoIter<A>","std::collections::btree_map::Range<'a, K, V>","<&mut I as std::iter::Iterator>","std::str::RMatchIndices<'a, P>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::env::VarsOs","std::slice::IterMut<'a, T>","std::str::MatchIndices<'a, P>","std::ops::RangeFrom<A>","std::collections::linked_list::IterMut<'a, T>","std::iter::Take<I>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::process::CommandEnvs<'a>","std::iter::FilterMap<I, F>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::iter::Enumerate<I>","std::str::EscapeUnicode<'a>","std::iter::OnceWith<F>","std::collections::hash_map::IntoValues<K, V>","std::iter::Repeat<A>","std::os::unix::net::ScmRights<'a>","std::collections::hash_set::Iter<'a, K>","std::collections::btree_map::Keys<'a, K, V>","std::str::Lines<'a>","std::iter::Empty<T>","std::char::ToUppercase","std::sys::unix::fs::ReadDir","std::collections::binary_heap::Iter<'a, T>","std::os::unix::net::Messages<'a>","std::ops::index_range::IndexRange","std::vec::IntoIter<T, A>","std::collections::hash_map::IntoIter<K, V>","std::boxed::Box<I, A>","std::char::EscapeDebug","std::str::LinesAny<'a>","std::slice::EscapeAscii<'a>","std::os::unix::net::ScmCredentials<'a>"]},"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend":{"I":["<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","fixed_lifo_deque::FixedLifoDeque","<&'a std::result::Result<T, E> as std::iter::IntoIterator>"],"T":["SampleEventType","Config","std::marker::copy_impls::<impl std::marker::Copy for &T>","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"fixed_lifo_deque::FixedLifoDeque":{"T":["<&T as std::fmt::Debug>","SampleEventType"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fixed_lifo_deque::FixedLifoDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+crate::<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+<fixed_lifo_deque::FixedLifoDeque<T>>::extend(p0, p1);
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // chrome_trace_dump::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<chrome_trace_dump::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<chrome_trace_dump::Error as std::fmt::Debug>::fmt(p0, p1);
+<chrome_trace_dump::Error>::fmt(p0, p1);
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::io::Error
+<chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from(p0);
+crate::<chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from(p0);
+<chrome_trace_dump::Error>::from(p0);
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_json::Error
+<chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from(p0);
+crate::<chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from(p0);
+<chrome_trace_dump::Error>::from(p0);
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::Error as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<chrome_trace_dump::Error as std::convert::From<std::string::String>>::from(p0);
+crate::<chrome_trace_dump::Error as std::convert::From<std::string::String>>::from(p0);
+<chrome_trace_dump::Error>::from(p0);
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::Error::already_exists
deps:{}
candidates:{}
+chrome_trace_dump::Error::already_exists();
+crate::chrome_trace_dump::Error::already_exists();
+<chrome_trace_dump::Error>::already_exists();
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::ChromeTraceArrayEntries as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // chrome_trace_dump::ChromeTraceArrayEntries
+p0.clone();
+<chrome_trace_dump::ChromeTraceArrayEntries as std::clone::Clone>::clone(p0);
+crate::<chrome_trace_dump::ChromeTraceArrayEntries as std::clone::Clone>::clone(p0);
+<chrome_trace_dump::ChromeTraceArrayEntries>::clone(p0);
-----------------
trace/src/chrome_trace_dump.rs <chrome_trace_dump::ChromeTraceArrayEntries as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // chrome_trace_dump::ChromeTraceArrayEntries
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<chrome_trace_dump::ChromeTraceArrayEntries as std::fmt::Debug>::fmt(p0, p1);
+crate::<chrome_trace_dump::ChromeTraceArrayEntries as std::fmt::Debug>::fmt(p0, p1);
+<chrome_trace_dump::ChromeTraceArrayEntries>::fmt(p0, p1);
-----------------
trace/src/chrome_trace_dump.rs chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize":{"__D":["serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::I16Deserializer<E>","serde::de::value::F64Deserializer<E>","&'de serde_json::Value","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U32Deserializer<E>","serde_json::value::de::MapDeserializer","serde::de::value::UsizeDeserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde_json::value::de::SeqDeserializer","serde::private::de::StrDeserializer<'a, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::I64Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::U8Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::SeqDeserializer<I, E>","serde_json::de::MapKey<'a, R>","serde::de::value::I8Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::UnitDeserializer<E>","serde_json::Value","serde::de::value::U128Deserializer<E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U16Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","&'a serde_json::Number","serde::de::value::IsizeDeserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::CharDeserializer<E>","serde_json::Number","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::StringDeserializer<E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::StrDeserializer<'a, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize(p0);
+crate::chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize(p0);
+<chrome_trace_dump::ChromeTraceArrayEntries>::deserialize(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // CategoriesT
+p0.clone();
+<CategoriesT as std::clone::Clone>::clone(p0);
+crate::<CategoriesT as std::clone::Clone>::clone(p0);
+<CategoriesT>::clone(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // CategoriesT
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<CategoriesT as std::fmt::Debug>::fmt(p0, p1);
+crate::<CategoriesT as std::fmt::Debug>::fmt(p0, p1);
+<CategoriesT>::fmt(p0, p1);
-----------------
trace/src/lib.rs <std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::vec::Vec<std::string::String>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
+p0.arr_eq(p1);
+<std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq(p0, p1);
+crate::<std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq(p0, p1);
+<std::vec::Vec<std::string::String>>::arr_eq(p0, p1);
-----------------
trace/src/lib.rs <&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq
deps:{}
candidates:{}
let mut p0 = & ["a"].as_mut_slice(); // None+&'static [&'static str]
let mut p1 = & std::string::String::new(); // None+std::vec::Vec<std::string::String>
+p0.arr_eq(p1);
+<&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq(p0, p1);
+crate::<&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq(p0, p1);
+<&'static [&'static str]>::arr_eq(p0, p1);
-----------------
trace/src/lib.rs <CategoriesT as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // CategoriesT
let mut p1 = & MaybeUninit::uninit().assume_init(); // CategoriesT
+p0.eq(p1);
+<CategoriesT as std::cmp::PartialEq>::eq(p0, p1);
+crate::<CategoriesT as std::cmp::PartialEq>::eq(p0, p1);
+<CategoriesT>::eq(p0, p1);
-----------------
trace/src/lib.rs <CategoriesT as serde::Serialize>::serialize
deps:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"<CategoriesT as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"<CategoriesT as serde::Serialize>::serialize":{"S":["serde::private::ser::TaggedSerializer<S>","serde_json::value::ser::MapKeySerializer","serde_json::ser::MapKeySerializer<'a, W, F>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde_json::value::Serializer","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // CategoriesT
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<CategoriesT as serde::Serialize>::serialize(p0, p1);
+crate::<CategoriesT as serde::Serialize>::serialize(p0, p1);
+<CategoriesT>::serialize(p0, p1);
-----------------
rope/src/tree.rs tree::Leaf::is_ok_child
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::is_ok_child":{"Self":["tree::Leaf","std::default::Default","std::marker::Sized","std::clone::Clone"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::InsertDelta","engine::RevId","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","multiset::ZipSegment","rope::RopeInfo","multiset::Subset","find::CaseMatching","tree::NodeBody","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Contents","engine::FullPriority","multiset::CountMatcher","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","spans::SpansInfo","engine::Error","spans::SpansLeaf","diff::DiffOp","rope::LinesMetric","rope::BaseMetric","multiset::Segment","spans::Span","engine::DeltaOp","tree::Node","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["engine::FullPriority","breaks::BreaksBaseMetric","delta::InsertDelta","tree::NodeBody","find::CaseMatching","multiset::ZipSegment","delta::Delta","engine::DeltaOp","multiset::CountMatcher","tree::NodeVal","spans::SpansInfo","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","diff::DiffOp","rope::LinesMetric","rope::Utf16CodeUnitsMetric","interval::Interval","engine::Contents","breaks::BreaksLeaf","spans::Span","rope::BaseMetric","diff::DiffBuilder","tree::Node","engine::RevId","multiset::Subset","breaks::BreaksMetric","rope::RopeInfo","engine::Error","breaks::BreaksInfo","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","tree::NodeVal","multiset::Subset","multiset::CountMatcher","diff::DiffBuilder","multiset::ZipSegment","engine::Contents","breaks::BreaksLeaf","rope::LinesMetric","engine::DeltaOp","diff::DiffOp","tree::Node","delta::InsertDelta","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","breaks::BreaksInfo","rope::RopeInfo","delta::DeltaElement","spans::SpansInfo","spans::SpansLeaf","delta::Delta","engine::Error","engine::RevId","rope::Utf16CodeUnitsMetric","engine::FullPriority","interval::Interval","tree::NodeBody","breaks::BreaksBaseMetric","multiset::Segment","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::is_ok_child":{"Self":["std::string::String","breaks::BreaksLeaf","spans::SpansLeaf"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_ok_child();
+tree::Leaf::is_ok_child(p0);
+crate::tree::Leaf::is_ok_child(p0);
+crate::tree::Leaf::is_ok_child(p0);
-----------------
trace/src/lib.rs <CategoriesT as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<CategoriesT as serde::Deserialize<'de>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<CategoriesT as serde::Deserialize<'de>>::deserialize":{"D":["serde_json::value::de::MapDeserializer","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U64Deserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::I64Deserializer<E>","serde_json::Number","serde::de::value::BoolDeserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::CharDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::I32Deserializer<E>","serde::de::value::F64Deserializer<E>","serde_json::Value","serde::private::de::content::SeqDeserializer<'de, E>","&'a serde_json::Number","serde::de::value::I16Deserializer<E>","serde::de::value::StringDeserializer<E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::U128Deserializer<E>","serde_json::value::de::SeqDeserializer","serde::de::value::MapAccessDeserializer<A>","serde_json::de::MapKey<'a, R>","&'de serde_json::Value","serde::de::value::U32Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::StrDeserializer<'a, E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde::de::value::F32Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::U8Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::private::de::StrDeserializer<'a, E>","serde::private::de::BytesDeserializer<'a, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::IsizeDeserializer<E>","serde::de::value::UnitDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<CategoriesT as serde::Deserialize<'de>>::deserialize(p0);
+crate::<CategoriesT as serde::Deserialize<'de>>::deserialize(p0);
+<CategoriesT>::deserialize(p0);
-----------------
trace/src/lib.rs <<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor>::expecting(p0, p1);
-----------------
trace/src/lib.rs <<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde_json::Error","serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor>::visit_str(p0, &p1);
-----------------
trace/src/lib.rs CategoriesT::join
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // CategoriesT
let mut p1 = "sample"; // None+&str
+p0.join(&p1);
+CategoriesT::join(p0, &p1);
+crate::CategoriesT::join(p0, &p1);
+<CategoriesT>::join(p0, &p1);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 0]
+<CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 1]
+<CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 2]
+<CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 3]
+<CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 4]
+<CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 5]
+<CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 6]
+<CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 7]
+<CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 8]
+<CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 9]
+<CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from
deps:{}
candidates:{}
let mut p0 = & ["a";1]; // None+[&'static str; 10]
+<CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from(p0);
+crate::<CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::vec::Vec<std::string::String>
+<CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from(p0);
+crate::<CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from(p0);
+<CategoriesT>::from(p0);
-----------------
trace/src/lib.rs <Config as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Config
+p0.clone();
+<Config as std::clone::Clone>::clone(p0);
+crate::<Config as std::clone::Clone>::clone(p0);
+<Config>::clone(p0);
-----------------
trace/src/lib.rs Config::with_limit_bytes
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+Config::with_limit_bytes(p0);
+crate::Config::with_limit_bytes(p0);
+<Config>::with_limit_bytes(p0);
-----------------
trace/src/lib.rs Config::with_limit_count
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+Config::with_limit_count(p0);
+crate::Config::with_limit_count(p0);
+<Config>::with_limit_count(p0);
-----------------
trace/src/lib.rs Config::default
deps:{}
candidates:{}
+Config::default();
+crate::Config::default();
+<Config>::default();
-----------------
trace/src/lib.rs Config::max_size_in_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // Config
+p0.max_size_in_bytes();
+Config::max_size_in_bytes(p0);
+crate::Config::max_size_in_bytes(p0);
+<Config>::max_size_in_bytes(p0);
-----------------
trace/src/lib.rs Config::max_samples
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // Config
+p0.max_samples();
+Config::max_samples(p0);
+crate::Config::max_samples(p0);
+<Config>::max_samples(p0);
-----------------
trace/src/lib.rs <SampleEventType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleEventType
+p0.clone();
+<SampleEventType as std::clone::Clone>::clone(p0);
+crate::<SampleEventType as std::clone::Clone>::clone(p0);
+<SampleEventType>::clone(p0);
-----------------
trace/src/lib.rs <SampleEventType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleEventType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<SampleEventType as std::fmt::Debug>::fmt(p0, p1);
+crate::<SampleEventType as std::fmt::Debug>::fmt(p0, p1);
+<SampleEventType>::fmt(p0, p1);
-----------------
trace/src/lib.rs <SampleEventType as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleEventType
let mut p1 = & MaybeUninit::uninit().assume_init(); // SampleEventType
+p0.eq(p1);
+<SampleEventType as std::cmp::PartialEq>::eq(p0, p1);
+crate::<SampleEventType as std::cmp::PartialEq>::eq(p0, p1);
+<SampleEventType>::eq(p0, p1);
-----------------
trace/src/lib.rs <SampleEventType as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleEventType
+p0.assert_receiver_is_total_eq();
+<SampleEventType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<SampleEventType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<SampleEventType>::assert_receiver_is_total_eq(p0);
-----------------
trace/src/lib.rs SampleEventType::into_chrome_id
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // SampleEventType
+p0.into_chrome_id();
+SampleEventType::into_chrome_id(p0);
+crate::SampleEventType::into_chrome_id(p0);
+<SampleEventType>::into_chrome_id(p0);
-----------------
trace/src/lib.rs SampleEventType::from_chrome_id
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+SampleEventType::from_chrome_id(p0);
+crate::SampleEventType::from_chrome_id(p0);
+<SampleEventType>::from_chrome_id(p0);
-----------------
trace/src/lib.rs <MetadataType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // MetadataType
+p0.clone();
+<MetadataType as std::clone::Clone>::clone(p0);
+crate::<MetadataType as std::clone::Clone>::clone(p0);
+<MetadataType>::clone(p0);
-----------------
trace/src/lib.rs <MetadataType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // MetadataType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<MetadataType as std::fmt::Debug>::fmt(p0, p1);
+crate::<MetadataType as std::fmt::Debug>::fmt(p0, p1);
+<MetadataType>::fmt(p0, p1);
-----------------
trace/src/lib.rs <MetadataType as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // MetadataType
let mut p1 = & MaybeUninit::uninit().assume_init(); // MetadataType
+p0.eq(p1);
+<MetadataType as std::cmp::PartialEq>::eq(p0, p1);
+crate::<MetadataType as std::cmp::PartialEq>::eq(p0, p1);
+<MetadataType>::eq(p0, p1);
-----------------
trace/src/lib.rs <MetadataType as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // MetadataType
+p0.assert_receiver_is_total_eq();
+<MetadataType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<MetadataType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<MetadataType>::assert_receiver_is_total_eq(p0);
-----------------
trace/src/lib.rs MetadataType::sample_name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // MetadataType
+p0.sample_name();
+MetadataType::sample_name(p0);
+crate::MetadataType::sample_name(p0);
+<MetadataType>::sample_name(p0);
-----------------
trace/src/lib.rs MetadataType::consume
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // MetadataType
+p0.consume();
+MetadataType::consume(p0);
+crate::MetadataType::consume(p0);
+<MetadataType>::consume(p0);
-----------------
trace/src/lib.rs _IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize
deps:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"_IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"_IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize":{"__S":["serde_json::value::Serializer","serde_json::value::ser::MapKeySerializer","serde::private::ser::content::ContentSerializer<E>","serde_json::ser::MapKeySerializer<'a, W, F>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::TaggedSerializer<S>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleArgs
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+_IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize(p0, p1);
+crate::_IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize(p0, p1);
+<SampleArgs>::serialize(p0, p1);
-----------------
trace/src/lib.rs _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize":{"__D":["serde::de::value::SeqAccessDeserializer<A>","serde::de::value::F64Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde_json::de::MapKey<'a, R>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U32Deserializer<E>","&'a serde_json::Number","serde::private::de::content::ContentDeserializer<'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::IsizeDeserializer<E>","serde_json::Value","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::U128Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::CharDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::U8Deserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde_json::value::de::MapDeserializer","serde::de::value::CowStrDeserializer<'a, E>","&'de serde_json::Value","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::StringDeserializer<E>","serde_json::Number","serde::de::value::UnitDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde_json::value::de::SeqDeserializer","serde::de::value::StrDeserializer<'a, E>","serde::de::value::I8Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::I32Deserializer<E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::BoolDeserializer<E>","serde::private::de::StrDeserializer<'a, E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize(p0);
+crate::_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize(p0);
+<SampleArgs>::deserialize(p0);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error","serde_json::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error","serde_json::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error","serde_json::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::BytesDeserializer<'a, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::I128Deserializer<E>","serde::de::value::UsizeDeserializer<E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde_json::Number","serde::de::value::I16Deserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::I64Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::I32Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::F32Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde_json::Value","serde::de::value::U8Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde_json::value::de::MapDeserializer","serde::de::value::MapAccessDeserializer<A>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::BoolDeserializer<E>","serde::de::value::CharDeserializer<E>","serde_json::de::MapKey<'a, R>","serde::de::value::StringDeserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::private::de::content::MapDeserializer<'de, E>","&'de serde_json::Value","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde::de::value::UnitDeserializer<E>","serde_json::value::de::SeqDeserializer","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I8Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","&'a serde_json::Number","serde::private::de::StrDeserializer<'a, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field>::deserialize(p0);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde_json::value::de::SeqDeserializer","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::PairVisitor<A, B, E>","serde_json::de::SeqAccess<'a, R>","serde::private::de::content::SeqDeserializer<'de, E>","<&'a mut A as serde::de::SeqAccess<'de>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde_json::de::MapAccess<'a, R>","serde_json::value::de::MapRefDeserializer<'de>","serde::private::de::FlatStructAccess<'a, 'de, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde_json::value::de::MapDeserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
trace/src/lib.rs <SampleArgs as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleArgs
+p0.clone();
+<SampleArgs as std::clone::Clone>::clone(p0);
+crate::<SampleArgs as std::clone::Clone>::clone(p0);
+<SampleArgs>::clone(p0);
-----------------
trace/src/lib.rs <SampleArgs as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleArgs
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<SampleArgs as std::fmt::Debug>::fmt(p0, p1);
+crate::<SampleArgs as std::fmt::Debug>::fmt(p0, p1);
+<SampleArgs>::fmt(p0, p1);
-----------------
trace/src/lib.rs <SampleArgs as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SampleArgs
let mut p1 = & MaybeUninit::uninit().assume_init(); // SampleArgs
+p0.eq(p1);
+<SampleArgs as std::cmp::PartialEq>::eq(p0, p1);
+crate::<SampleArgs as std::cmp::PartialEq>::eq(p0, p1);
+<SampleArgs>::eq(p0, p1);
-----------------
trace/src/lib.rs _IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize
deps:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize":{"__S":["serde_json::ser::MapKeySerializer<'a, W, F>","<&'a mut serde_json::Serializer<W, F> as serde::Serializer>","serde_json::value::ser::MapKeySerializer","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde_json::value::Serializer","serde::private::ser::TaggedSerializer<S>","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize(p0, p1);
+crate::_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize(p0, p1);
+<Sample>::serialize(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize
'__a
deps:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize":{"__S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<&'a mut serde_json::Serializer<W, F> as serde::Serializer>":{},"<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize":{"__S":["serde::private::ser::FlatMapSerializer<'a, M>","serde_json::value::Serializer","serde_json::ser::MapKeySerializer<'a, W, F>","serde::private::ser::TaggedSerializer<S>","serde::private::ser::content::ContentSerializer<E>","serde_json::value::ser::MapKeySerializer","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // _IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a>
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize(p0, p1);
+crate::<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize(p0, p1);
+<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a>>::serialize(p0, p1);
-----------------
trace/src/lib.rs _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize":{"__D":["serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I128Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::I32Deserializer<E>","serde_json::Value","serde::de::value::MapAccessDeserializer<A>","serde::de::value::F64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::CharDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::StringDeserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I64Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::UnitDeserializer<E>","&'a serde_json::Number","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U64Deserializer<E>","serde_json::Number","serde::de::value::U128Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde_json::value::de::MapDeserializer","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde_json::de::MapKey<'a, R>","serde::de::value::I8Deserializer<E>","serde_json::value::de::SeqDeserializer","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::UsizeDeserializer<E>","&'de serde_json::Value","serde::de::value::F32Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize(p0);
+crate::_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize(p0);
+<Sample>::deserialize(p0);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error","serde_json::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error","serde_json::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde_json::Error","serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::UnitDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde_json::de::MapKey<'a, R>","serde::de::value::U128Deserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I64Deserializer<E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::F32Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::I16Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde_json::Number","serde::de::value::F64Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I8Deserializer<E>","&'a serde_json::Number","serde::de::value::IsizeDeserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::U16Deserializer<E>","serde_json::value::de::MapDeserializer","serde::de::value::MapAccessDeserializer<A>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::StringDeserializer<E>","serde_json::Value","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U64Deserializer<E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::BoolDeserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::CharDeserializer<E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","&'de serde_json::Value","serde::private::de::BytesDeserializer<'a, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde_json::value::de::SeqDeserializer","serde::de::value::SeqDeserializer<I, E>","serde::de::value::UsizeDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field>::deserialize(p0);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde_json::value::de::SeqDeserializer","serde::de::value::MapDeserializer<'de, I, E>","serde_json::de::SeqAccess<'a, R>","<&'a mut A as serde::de::SeqAccess<'de>>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
trace/src/lib.rs <<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":{"__D":["serde::private::de::StrDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde_json::de::MapKey<'a, R>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde_json::Number","serde::de::value::U8Deserializer<E>","&'de serde_json::Value","serde::de::value::UnitDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde_json::value::de::SeqDeserializer","serde::de::value::I16Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::SeqDeserializer<I, E>","&'a serde_json::Number","serde_json::value::de::MapDeserializer","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::I8Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::F32Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U128Deserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde_json::Value","serde::de::value::I128Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::I64Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::StringDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::CharDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::de::value::U64Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize(p0);
+crate::<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize(p0);
+<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de>>::deserialize(p0);
-----------------
trace/src/lib.rs <_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::MapAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde_json::de::MapAccess<'a, R>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde_json::value::de::MapDeserializer","serde::private::de::FlatStructAccess<'a, 'de, E>","serde_json::value::de::MapRefDeserializer<'de>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // _IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
trace/src/lib.rs <<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>":{},"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::PairDeserializer<A, B, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::U16Deserializer<E>","serde_json::Number","serde::de::value::U64Deserializer<E>","serde::de::value::I16Deserializer<E>","serde_json::value::de::MapRefDeserializer<'de>","serde::de::value::UnitDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::F32Deserializer<E>","&'a serde_json::Number","<&'a mut serde_json::Deserializer<R> as serde::Deserializer<'de>>","serde::private::de::content::ContentDeserializer<'de, E>","serde_json::value::de::MapKeyDeserializer<'de>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde_json::value::de::SeqDeserializer","serde::de::value::StringDeserializer<E>","serde_json::de::MapKey<'a, R>","serde::de::value::CharDeserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::BoolDeserializer<E>","serde_json::Value","&'de serde_json::Value","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde_json::value::de::MapDeserializer","serde::de::value::I8Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde_json::value::de::BorrowedCowStrDeserializer<'de>","serde::de::value::UsizeDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde_json::value::de::SeqRefDeserializer<'de>","serde::de::value::U128Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::I32Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::StrDeserializer<'a, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize(p0);
+crate::<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize(p0);
+<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de>>::deserialize(p0);
-----------------
trace/src/lib.rs <Sample as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
+p0.clone();
+<Sample as std::clone::Clone>::clone(p0);
+crate::<Sample as std::clone::Clone>::clone(p0);
+<Sample>::clone(p0);
-----------------
trace/src/lib.rs <Sample as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Sample as std::fmt::Debug>::fmt(p0, p1);
+crate::<Sample as std::fmt::Debug>::fmt(p0, p1);
+<Sample>::fmt(p0, p1);
-----------------
trace/src/lib.rs Sample::thread_name
deps:{}
candidates:{}
+Sample::thread_name();
+crate::Sample::thread_name();
+<Sample>::thread_name();
-----------------
trace/src/lib.rs Sample::new_duration_marker
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Sample::new_duration_marker":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Sample::new_duration_marker":{"C":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"],"S":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::borrow::Cow<'static, str>>
let mut p3 = MaybeUninit::uninit().assume_init(); // SampleEventType
+Sample::new_duration_marker(p0, p1, p2, p3);
+crate::Sample::new_duration_marker(p0, p1, p2, p3);
+<Sample>::new_duration_marker(p0, p1, p2, p3);
-----------------
trace/src/lib.rs Sample::new_duration
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Sample::new_duration":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Sample::new_duration":{"C":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"S":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::borrow::Cow<'static, str>>
let mut p3 = 0u64; // None+u64
let mut p4 = 0u64; // None+u64
+Sample::new_duration(p0, p1, p2, p3, p4);
+crate::Sample::new_duration(p0, p1, p2, p3, p4);
+<Sample>::new_duration(p0, p1, p2, p3, p4);
-----------------
trace/src/lib.rs Sample::new_instant
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Sample::new_instant":{"C":["std::convert::Into","std::marker::Sized"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Sample::new_instant":{"C":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected"],"S":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::borrow::Cow<'static, str>>
+Sample::new_instant(p0, p1, p2);
+crate::Sample::new_instant(p0, p1, p2);
+<Sample>::new_instant(p0, p1, p2);
-----------------
trace/src/lib.rs Sample::new_metadata
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = MaybeUninit::uninit().assume_init(); // MetadataType
let mut p2 = 0u64; // None+u64
+Sample::new_metadata(p0, p1, p2);
+crate::Sample::new_metadata(p0, p1, p2);
+<Sample>::new_metadata(p0, p1, p2);
-----------------
trace/src/lib.rs <Sample as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = & MaybeUninit::uninit().assume_init(); // Sample
+p0.eq(p1);
+<Sample as std::cmp::PartialEq>::eq(p0, p1);
+crate::<Sample as std::cmp::PartialEq>::eq(p0, p1);
+<Sample>::eq(p0, p1);
-----------------
trace/src/lib.rs <Sample as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = & MaybeUninit::uninit().assume_init(); // Sample
+p0.partial_cmp(p1);
+<Sample as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<Sample as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<Sample>::partial_cmp(p0, p1);
-----------------
trace/src/lib.rs <Sample as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = & MaybeUninit::uninit().assume_init(); // Sample
+p0.cmp(p1);
+<Sample as std::cmp::Ord>::cmp(p0, p1);
+crate::<Sample as std::cmp::Ord>::cmp(p0, p1);
+<Sample>::cmp(p0, p1);
-----------------
trace/src/lib.rs <Sample as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<Sample as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<Sample as std::hash::Hash>::hash":{"H":["std::hash::SipHasher","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Sample
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<Sample as std::hash::Hash>::hash(p0, p1);
+crate::<Sample as std::hash::Hash>::hash(p0, p1);
+<Sample>::hash(p0, p1);
-----------------
trace/src/lib.rs SampleGuard::<'a>::new_disabled
'a
deps:{}
candidates:{}
+SampleGuard::<'a>::new_disabled();
+crate::SampleGuard::<'a>::new_disabled();
+<SampleGuard<'a>>::new_disabled();
-----------------
trace/src/lib.rs SampleGuard::<'a>::new
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"SampleGuard::<'a>::new":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"SampleGuard::<'a>::new":{"C":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"S":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::borrow::Cow<'static, str>>
+SampleGuard::<'a>::new(p0, p1, p2, p3);
+crate::SampleGuard::<'a>::new(p0, p1, p2, p3);
+<SampleGuard<'a>>::new(p0, p1, p2, p3);
-----------------
trace/src/lib.rs <SampleGuard<'a> as std::ops::Drop>::drop
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SampleGuard<'a>
+p0.drop();
+<SampleGuard<'a> as std::ops::Drop>::drop(p0);
+crate::<SampleGuard<'a> as std::ops::Drop>::drop(p0);
+<SampleGuard<'a>>::drop(p0);
-----------------
trace/src/lib.rs Trace::disabled
deps:{}
candidates:{}
+Trace::disabled();
+crate::Trace::disabled();
+<Trace>::disabled();
-----------------
trace/src/lib.rs Trace::enabled
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // Config
+Trace::enabled(p0);
+crate::Trace::enabled(p0);
+<Trace>::enabled(p0);
-----------------
trace/src/lib.rs Trace::disable
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.disable();
+Trace::disable(p0);
+crate::Trace::disable(p0);
+<Trace>::disable(p0);
-----------------
trace/src/lib.rs Trace::enable
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.enable();
+Trace::enable(p0);
+crate::Trace::enable(p0);
+<Trace>::enable(p0);
-----------------
trace/src/lib.rs Trace::enable_config
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // Config
+p0.enable_config(p1);
+Trace::enable_config(p0, p1);
+crate::Trace::enable_config(p0, p1);
+<Trace>::enable_config(p0, p1);
-----------------
trace/src/lib.rs Trace::get_samples_count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.get_samples_count();
+Trace::get_samples_count(p0);
+crate::Trace::get_samples_count(p0);
+<Trace>::get_samples_count(p0);
-----------------
trace/src/lib.rs Trace::get_samples_limit
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.get_samples_limit();
+Trace::get_samples_limit(p0);
+crate::Trace::get_samples_limit(p0);
+<Trace>::get_samples_limit(p0);
-----------------
trace/src/lib.rs Trace::record
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // Sample
+p0.record(p1);
+Trace::record(p0, p1);
+crate::Trace::record(p0, p1);
+<Trace>::record(p0, p1);
-----------------
trace/src/lib.rs Trace::is_enabled
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.is_enabled();
+Trace::is_enabled(p0);
+crate::Trace::is_enabled(p0);
+<Trace>::is_enabled(p0);
-----------------
trace/src/lib.rs Trace::instant
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::instant":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::instant":{"C":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"],"S":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
+p0.instant(p1, p2);
+Trace::instant(p0, p1, p2);
+crate::Trace::instant(p0, p1, p2);
+<Trace>::instant(p0, p1, p2);
-----------------
trace/src/lib.rs Trace::instant_payload
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::instant_payload":{"C":["std::convert::Into","std::marker::Sized"],"P":["std::marker::Sized","std::convert::Into"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::instant_payload":{"C":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"P":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"S":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // P
+p0.instant_payload(p1, p2, p3);
+Trace::instant_payload(p0, p1, p2, p3);
+crate::Trace::instant_payload(p0, p1, p2, p3);
+<Trace>::instant_payload(p0, p1, p2, p3);
-----------------
trace/src/lib.rs Trace::block
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::block":{"C":["std::marker::Sized","std::convert::Into"],"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::block":{"C":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"],"S":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
+p0.block(p1, p2);
+Trace::block(p0, p1, p2);
+crate::Trace::block(p0, p1, p2);
+<Trace>::block(p0, p1, p2);
-----------------
trace/src/lib.rs Trace::block_payload
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::block_payload":{"C":["std::marker::Sized","std::convert::Into"],"P":["std::marker::Sized","std::convert::Into"],"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::block_payload":{"C":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"],"P":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"S":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // P
+p0.block_payload(p1, p2, p3);
+Trace::block_payload(p0, p1, p2, p3);
+crate::Trace::block_payload(p0, p1, p2, p3);
+<Trace>::block_payload(p0, p1, p2, p3);
-----------------
trace/src/lib.rs Trace::closure
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::closure":{"C":["std::marker::Sized","std::convert::Into"],"F":["std::marker::Sized","std::ops::FnOnce"],"R":["std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::closure":{"C":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"],"F":["core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"],"R":["RUG_ANY"],"S":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // F
+p0.closure(p1, p2, p3);
+Trace::closure(p0, p1, p2, p3);
+crate::Trace::closure(p0, p1, p2, p3);
+<Trace>::closure(p0, p1, p2, p3);
-----------------
trace/src/lib.rs Trace::closure_payload
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"Trace::closure_payload":{"C":["std::convert::Into","std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnOnce"],"P":["std::marker::Sized","std::convert::Into"],"R":["std::marker::Sized"],"S":["std::convert::Into","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"Trace::closure_payload":{"C":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"F":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"],"P":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"R":["RUG_ANY"],"S":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // S
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // F
let mut p4 = MaybeUninit::uninit().assume_init(); // P
+p0.closure_payload(p1, p2, p3, p4);
+Trace::closure_payload(p0, p1, p2, p3, p4);
+crate::Trace::closure_payload(p0, p1, p2, p3, p4);
+<Trace>::closure_payload(p0, p1, p2, p3, p4);
-----------------
trace/src/lib.rs Trace::samples_cloned_unsorted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.samples_cloned_unsorted();
+Trace::samples_cloned_unsorted(p0);
+crate::Trace::samples_cloned_unsorted(p0);
+<Trace>::samples_cloned_unsorted(p0);
-----------------
trace/src/lib.rs Trace::samples_cloned_sorted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
+p0.samples_cloned_sorted();
+Trace::samples_cloned_sorted(p0);
+crate::Trace::samples_cloned_sorted(p0);
+<Trace>::samples_cloned_sorted(p0);
-----------------
trace/src/lib.rs Trace::save
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"Trace::save":{"P":["std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"Trace::save":{"P":["std::boxed::Box<T, A>","<&T as std::convert::AsRef<U>>","std::borrow::Cow<'_, T>","core::num::dec2flt::common::AsciiStr<'a>","std::vec::Drain<'a, T, A>","std::ffi::CString","std::ffi::CStr","std::borrow::Cow<'_, std::ffi::OsStr>","std::sync::Arc<T>","std::rc::Rc<T>","<&mut T as std::convert::AsRef<U>>","std::slice::Iter<'_, T>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Trace
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = true; // None+bool
+p0.save(p1, p2);
+Trace::save(p0, p1, p2);
+crate::Trace::save(p0, p1, p2);
+<Trace>::save(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs <TRACE as lazy_static::__Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // TRACE
+p0.deref();
+<TRACE as lazy_static::__Deref>::deref(p0);
+crate::<TRACE as lazy_static::__Deref>::deref(p0);
+<TRACE>::deref(p0);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs <TRACE as lazy_static::LazyStatic>::initialize
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // TRACE
+<TRACE as lazy_static::LazyStatic>::initialize(p0);
+crate::<TRACE as lazy_static::LazyStatic>::initialize(p0);
+<TRACE>::initialize(p0);
-----------------
trace/src/sys_pid.rs sys_pid::current_pid::getpid
deps:{}
candidates:{}
-----------------
rope/src/tree.rs tree::Leaf::push_maybe_split
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::push_maybe_split":{"Self":["std::marker::Sized","tree::Leaf","std::default::Default","std::clone::Clone"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::BaseMetric","rope::RopeInfo","spans::Span","tree::NodeVal","tree::NodeBody","engine::Contents","engine::Error","multiset::CountMatcher","diff::DiffOp","multiset::Subset","delta::Delta","interval::Interval","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","engine::DeltaOp","spans::SpansLeaf","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","find::CaseMatching","rope::LinesMetric","breaks::BreaksBaseMetric","spans::SpansInfo","engine::FullPriority","delta::DeltaElement","engine::RevId","multiset::Segment","breaks::BreaksMetric","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["engine::Contents","rope::RopeInfo","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","multiset::Segment","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","find::CaseMatching","engine::FullPriority","multiset::CountMatcher","interval::Interval","tree::NodeVal","delta::InsertDelta","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Error","delta::Delta","engine::DeltaOp","engine::RevId","rope::BaseMetric","tree::Node","rope::LinesMetric","diff::DiffOp","spans::Span","breaks::BreaksInfo","spans::SpansLeaf","multiset::Subset","spans::SpansInfo","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","engine::Contents","engine::RevId","breaks::BreaksInfo","engine::FullPriority","multiset::ZipSegment","breaks::BreaksLeaf","engine::Error","rope::RopeInfo","multiset::Segment","tree::Node","interval::Interval","tree::NodeBody","multiset::Subset","spans::SpansInfo","breaks::BreaksBaseMetric","rope::BaseMetric","tree::NodeVal","engine::DeltaOp","spans::SpansLeaf","find::CaseMatching","delta::Delta","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","delta::DeltaElement","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","diff::DiffOp","spans::Span","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::push_maybe_split":{"Self":["breaks::BreaksLeaf","spans::SpansLeaf","std::string::String"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+tree::Leaf::push_maybe_split(p0, p1, p2);
+crate::tree::Leaf::push_maybe_split(p0, p1, p2);
+crate::tree::Leaf::push_maybe_split(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Leaf::subseq
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::subseq":{"Self":["std::default::Default","std::clone::Clone","tree::Leaf","std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["tree::Node","tree::NodeBody","breaks::BreaksBaseMetric","delta::InsertDelta","rope::RopeInfo","breaks::BreaksInfo","delta::DeltaElement","engine::Contents","delta::Delta","engine::FullPriority","spans::Span","breaks::BreaksLeaf","diff::DiffOp","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","rope::LinesMetric","engine::DeltaOp","find::CaseMatching","tree::NodeVal","breaks::BreaksMetric","engine::RevId","spans::SpansLeaf","engine::Error","multiset::ZipSegment","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::Segment","spans::SpansInfo"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","multiset::Segment","spans::SpansLeaf","tree::Node","diff::DiffOp","engine::Error","breaks::BreaksBaseMetric","multiset::ZipSegment","delta::Delta","rope::RopeInfo","spans::Span","engine::RevId","engine::FullPriority","multiset::Subset","engine::Contents","delta::InsertDelta","interval::Interval","tree::NodeVal","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","breaks::BreaksMetric","breaks::BreaksInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","delta::DeltaElement","rope::LinesMetric","rope::BaseMetric","tree::NodeBody","spans::SpansInfo","find::CaseMatching"]},"spans::SpansLeaf":{"T":["breaks::BreaksLeaf","diff::DiffBuilder","multiset::Segment","tree::NodeBody","delta::Delta","rope::LinesMetric","engine::FullPriority","engine::RevId","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","engine::DeltaOp","spans::SpansLeaf","spans::SpansInfo","engine::Error","breaks::BreaksMetric","multiset::Subset","rope::RopeInfo","breaks::BreaksBaseMetric","interval::Interval","tree::NodeVal","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","tree::Node","multiset::ZipSegment","find::CaseMatching","spans::Span","multiset::CountMatcher","engine::Contents","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::subseq":{"Self":["spans::SpansLeaf","breaks::BreaksLeaf"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.subseq(p1);
+tree::Leaf::subseq(p0, p1);
+crate::tree::Leaf::subseq(p0, p1);
+crate::tree::Leaf::subseq(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::measure
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::measure":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["interval::Interval","engine::FullPriority","multiset::Segment","tree::Node","rope::LinesMetric","spans::Span","engine::Contents","breaks::BreaksMetric","engine::RevId","delta::Delta","breaks::BreaksInfo","tree::NodeVal","breaks::BreaksLeaf","engine::Error","diff::DiffOp","rope::BaseMetric","multiset::Subset","breaks::BreaksBaseMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","multiset::CountMatcher","find::CaseMatching","spans::SpansInfo","engine::DeltaOp","multiset::ZipSegment","spans::SpansLeaf","diff::DiffBuilder","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","delta::InsertDelta"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::NodeVal","spans::SpansInfo","find::CaseMatching","delta::Delta","engine::RevId","breaks::BreaksMetric","interval::Interval","spans::Span","multiset::Subset","rope::BaseMetric","breaks::BreaksBaseMetric","delta::DeltaElement","delta::InsertDelta","spans::SpansLeaf","tree::Node","engine::FullPriority","engine::Contents","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","multiset::Segment","engine::Error","multiset::ZipSegment","tree::NodeBody","breaks::BreaksInfo","diff::DiffBuilder","rope::RopeInfo","multiset::CountMatcher","diff::DiffOp"]},"spans::SpansLeaf":{"T":["engine::RevId","multiset::Subset","tree::NodeBody","multiset::ZipSegment","spans::Span","interval::Interval","multiset::CountMatcher","engine::Error","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","rope::BaseMetric","delta::DeltaElement","delta::InsertDelta","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","breaks::BreaksInfo","engine::DeltaOp","breaks::BreaksMetric","diff::DiffBuilder","spans::SpansInfo","delta::Delta","find::CaseMatching","rope::RopeInfo","breaks::BreaksBaseMetric","engine::Contents","multiset::Segment","rope::Utf16CodeUnitsMetric","tree::Node","spans::SpansLeaf","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::measure":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"Self":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // N
let mut p1 = 0usize; // None+usize
+tree::Metric::measure(p0, p1);
+crate::tree::Metric::measure(p0, p1);
+crate::tree::Metric::measure(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::to_base_units
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::to_base_units":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","rope::Utf16CodeUnitsMetric","rope::RopeInfo","tree::Node","find::CaseMatching","diff::DiffOp","multiset::Subset","spans::SpansLeaf","engine::Error","multiset::CountMatcher","breaks::BreaksBaseMetric","breaks::BreaksLeaf","engine::FullPriority","delta::InsertDelta","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","delta::DeltaElement","engine::Contents","multiset::Segment","delta::Delta","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","engine::RevId","breaks::BreaksMetric","tree::NodeVal","multiset::ZipSegment","breaks::BreaksInfo","diff::DiffBuilder","rope::LinesMetric","spans::SpansInfo"]},"spans::SpansInfo":{"T":["tree::Node","tree::NodeBody","spans::SpansInfo","multiset::ZipSegment","engine::FullPriority","delta::DeltaElement","multiset::Segment","tree::NodeVal","breaks::BreaksMetric","diff::DiffBuilder","spans::Span","rope::Utf16CodeUnitsMetric","rope::LinesMetric","diff::DiffOp","rope::RopeInfo","breaks::BreaksLeaf","find::CaseMatching","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::RevId","engine::Error","engine::Contents","multiset::Subset","rope::BaseMetric","engine::DeltaOp","spans::SpansLeaf","delta::InsertDelta","breaks::BreaksInfo","delta::Delta"]},"spans::SpansLeaf":{"T":["spans::Span","delta::Delta","breaks::BreaksLeaf","interval::Interval","engine::Contents","breaks::BreaksMetric","diff::DiffBuilder","multiset::CountMatcher","rope::RopeInfo","breaks::BreaksBaseMetric","multiset::Segment","tree::NodeVal","spans::SpansLeaf","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","tree::NodeBody","diff::DiffOp","spans::SpansInfo","rope::Utf16CodeUnitsMetric","engine::DeltaOp","engine::FullPriority","rope::BaseMetric","engine::RevId","find::CaseMatching","tree::Node","rope::LinesMetric","breaks::BreaksInfo","engine::Error","delta::InsertDelta","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::to_base_units":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"Self":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::LinesMetric","rope::BaseMetric","breaks::BreaksMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::to_base_units(p0, p1);
+crate::tree::Metric::to_base_units(p0, p1);
+crate::tree::Metric::to_base_units(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::from_base_units
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::from_base_units":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","tree::Node","breaks::BreaksMetric","delta::DeltaElement","tree::NodeBody","spans::SpansLeaf","breaks::BreaksBaseMetric","rope::RopeInfo","tree::NodeVal","multiset::Subset","engine::RevId","rope::LinesMetric","interval::Interval","engine::DeltaOp","rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::Contents","delta::Delta","multiset::ZipSegment","breaks::BreaksLeaf","diff::DiffOp","engine::FullPriority","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","find::CaseMatching","spans::SpansInfo","rope::BaseMetric","diff::DiffBuilder","breaks::BreaksInfo","multiset::Segment"]},"spans::SpansInfo":{"T":["multiset::Subset","multiset::ZipSegment","tree::Node","breaks::BreaksLeaf","delta::Delta","engine::DeltaOp","rope::BaseMetric","rope::RopeInfo","rope::Utf16CodeUnitsMetric","engine::FullPriority","spans::Span","breaks::BreaksInfo","engine::RevId","breaks::BreaksBaseMetric","diff::DiffOp","delta::InsertDelta","interval::Interval","breaks::BreaksMetric","find::CaseMatching","delta::DeltaElement","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","engine::Error","tree::NodeVal","engine::Contents","multiset::CountMatcher","tree::NodeBody","diff::DiffBuilder","rope::LinesMetric","multiset::Segment"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","multiset::CountMatcher","engine::Error","delta::DeltaElement","multiset::Subset","rope::LinesMetric","delta::Delta","spans::SpansLeaf","tree::Node","engine::Contents","diff::DiffBuilder","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","rope::Utf16CodeUnitsMetric","spans::Span","breaks::BreaksInfo","breaks::BreaksBaseMetric","tree::NodeBody","spans::SpansInfo","multiset::ZipSegment","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","find::CaseMatching","breaks::BreaksLeaf","engine::FullPriority","rope::BaseMetric","multiset::Segment","diff::DiffOp","breaks::BreaksMetric","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::from_base_units":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"Self":["breaks::BreaksBaseMetric","rope::BaseMetric","rope::LinesMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::from_base_units(p0, p1);
+crate::tree::Metric::from_base_units(p0, p1);
+crate::tree::Metric::from_base_units(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::is_boundary
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::is_boundary":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","engine::Error","multiset::Subset","rope::BaseMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","diff::DiffBuilder","delta::DeltaElement","engine::FullPriority","delta::InsertDelta","rope::LinesMetric","spans::SpansLeaf","spans::Span","rope::RopeInfo","delta::Delta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","multiset::Segment","find::CaseMatching","engine::RevId","tree::NodeBody","multiset::CountMatcher","interval::Interval","spans::SpansInfo","engine::DeltaOp","tree::Node","breaks::BreaksMetric","tree::NodeVal","diff::DiffOp"]},"spans::SpansInfo":{"T":["delta::Delta","diff::DiffOp","breaks::BreaksMetric","breaks::BreaksInfo","spans::SpansInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","breaks::BreaksBaseMetric","engine::DeltaOp","tree::NodeVal","engine::Contents","breaks::BreaksLeaf","interval::Interval","diff::DiffBuilder","multiset::ZipSegment","find::CaseMatching","delta::InsertDelta","multiset::Subset","rope::RopeInfo","tree::Node","multiset::Segment","spans::SpansLeaf","engine::RevId","tree::NodeBody","multiset::CountMatcher","rope::LinesMetric","engine::FullPriority","delta::DeltaElement","spans::Span","rope::Utf16CodeUnitsMetric"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","rope::LinesMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","breaks::BreaksMetric","tree::Node","multiset::Subset","rope::Utf16CodeUnitsMetric","multiset::Segment","tree::NodeBody","engine::DeltaOp","breaks::BreaksLeaf","delta::InsertDelta","find::CaseMatching","breaks::BreaksInfo","spans::Span","engine::Error","breaks::BreaksBaseMetric","tree::NodeVal","interval::Interval","spans::SpansLeaf","engine::RevId","diff::DiffOp","engine::Contents","multiset::ZipSegment","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","engine::FullPriority","diff::DiffBuilder","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::is_boundary":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"Self":["rope::BaseMetric","rope::LinesMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::is_boundary(p0, p1);
+crate::tree::Metric::is_boundary(p0, p1);
+crate::tree::Metric::is_boundary(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::prev
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::prev":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::Span","multiset::CountMatcher","diff::DiffOp","interval::Interval","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","tree::NodeBody","rope::Utf16CodeUnitsMetric","rope::BaseMetric","multiset::Subset","delta::InsertDelta","breaks::BreaksLeaf","breaks::BreaksBaseMetric","delta::Delta","tree::Node","diff::DiffBuilder","engine::Error","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","rope::LinesMetric","spans::SpansInfo","engine::FullPriority","find::CaseMatching","breaks::BreaksInfo","breaks::BreaksMetric","spans::SpansLeaf","delta::DeltaElement","multiset::Segment","engine::RevId","tree::NodeVal"]},"spans::SpansInfo":{"T":["multiset::Subset","breaks::BreaksBaseMetric","multiset::CountMatcher","delta::InsertDelta","tree::NodeVal","rope::LinesMetric","find::CaseMatching","engine::FullPriority","tree::NodeBody","spans::SpansInfo","spans::SpansLeaf","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","engine::DeltaOp","engine::RevId","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::Contents","breaks::BreaksInfo","spans::Span","breaks::BreaksLeaf","rope::BaseMetric","interval::Interval","breaks::BreaksMetric","delta::Delta","diff::DiffBuilder","engine::Error","rope::RopeInfo","diff::DiffOp","tree::Node"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","breaks::BreaksLeaf","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksInfo","breaks::BreaksBaseMetric","rope::LinesMetric","find::CaseMatching","engine::DeltaOp","delta::InsertDelta","tree::NodeBody","multiset::CountMatcher","rope::RopeInfo","interval::Interval","engine::FullPriority","engine::Contents","tree::NodeVal","tree::Node","multiset::Subset","engine::Error","diff::DiffOp","multiset::Segment","spans::Span","rope::Utf16CodeUnitsMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","multiset::ZipSegment","spans::SpansInfo","breaks::BreaksMetric","delta::DeltaElement"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::prev":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"],"Self":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::prev(p0, p1);
+crate::tree::Metric::prev(p0, p1);
+crate::tree::Metric::prev(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::next
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::next":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::Error","multiset::ZipSegment","diff::DiffOp","breaks::BreaksMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::FullPriority","engine::RevId","rope::BaseMetric","rope::RopeInfo","rope::LinesMetric","interval::Interval","delta::DeltaElement","tree::NodeBody","spans::SpansInfo","find::CaseMatching","delta::Delta","multiset::Segment","multiset::Subset","engine::DeltaOp","breaks::BreaksInfo","spans::SpansLeaf","tree::NodeVal","rope::Utf16CodeUnitsMetric","tree::Node","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","delta::DeltaElement","rope::LinesMetric","diff::DiffOp","spans::SpansLeaf","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","tree::NodeBody","engine::DeltaOp","tree::Node","rope::RopeInfo","breaks::BreaksInfo","multiset::ZipSegment","interval::Interval","engine::Error","spans::Span","diff::DiffBuilder","delta::Delta","breaks::BreaksBaseMetric","multiset::CountMatcher","engine::Contents","tree::NodeVal","engine::FullPriority","spans::SpansInfo","engine::RevId","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::Subset","multiset::Segment","find::CaseMatching"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","spans::SpansInfo","engine::Error","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","delta::InsertDelta","tree::NodeBody","delta::Delta","tree::NodeVal","rope::BaseMetric","tree::Node","breaks::BreaksBaseMetric","spans::Span","multiset::ZipSegment","breaks::BreaksLeaf","interval::Interval","spans::SpansLeaf","multiset::Subset","breaks::BreaksInfo","multiset::CountMatcher","engine::Contents","rope::Utf16CodeUnitsMetric","rope::LinesMetric","multiset::Segment","delta::DeltaElement","find::CaseMatching","engine::RevId","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::next":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"Self":["rope::LinesMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric","breaks::BreaksMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::next(p0, p1);
+crate::tree::Metric::next(p0, p1);
+crate::tree::Metric::next(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::can_fragment
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::can_fragment":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::RopeInfo","breaks::BreaksInfo","engine::DeltaOp","delta::DeltaElement","diff::DiffOp","breaks::BreaksBaseMetric","tree::Node","multiset::CountMatcher","interval::Interval","breaks::BreaksLeaf","multiset::ZipSegment","engine::RevId","engine::FullPriority","rope::LinesMetric","engine::Contents","spans::SpansLeaf","tree::NodeVal","spans::SpansInfo","multiset::Subset","find::CaseMatching","multiset::Segment","engine::Error","tree::NodeBody","rope::Utf16CodeUnitsMetric","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","breaks::BreaksMetric","delta::InsertDelta","diff::DiffBuilder","spans::Span"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","diff::DiffOp","delta::Delta","engine::DeltaOp","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::Span","tree::NodeVal","find::CaseMatching","engine::Error","multiset::Segment","spans::SpansLeaf","multiset::ZipSegment","tree::NodeBody","engine::FullPriority","engine::RevId","interval::Interval","diff::DiffBuilder","delta::DeltaElement","breaks::BreaksInfo","rope::LinesMetric","breaks::BreaksBaseMetric","tree::Node","rope::RopeInfo","engine::Contents","rope::BaseMetric","spans::SpansInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","multiset::Subset"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","breaks::BreaksInfo","tree::NodeVal","rope::BaseMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","tree::Node","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","diff::DiffBuilder","find::CaseMatching","spans::SpansInfo","multiset::Segment","multiset::ZipSegment","engine::Error","delta::Delta","delta::InsertDelta","multiset::CountMatcher","interval::Interval","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::Contents","breaks::BreaksMetric","multiset::Subset","tree::NodeBody","engine::FullPriority","breaks::BreaksBaseMetric","rope::RopeInfo","spans::SpansLeaf","spans::Span"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::can_fragment":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"Self":["breaks::BreaksBaseMetric","rope::LinesMetric","breaks::BreaksMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
+tree::Metric::can_fragment();
+crate::tree::Metric::can_fragment();
+crate::tree::Metric::can_fragment();
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.clone();
+<breaks::BreaksLeaf as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksLeaf as std::clone::Clone>::clone(p0);
+<breaks::BreaksLeaf>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<breaks::BreaksLeaf as std::fmt::Debug>::fmt(p0, p1);
+crate::<breaks::BreaksLeaf as std::fmt::Debug>::fmt(p0, p1);
+<breaks::BreaksLeaf>::fmt(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::default::Default>::default
deps:{}
candidates:{}
+<breaks::BreaksLeaf as std::default::Default>::default();
+crate::<breaks::BreaksLeaf as std::default::Default>::default();
+<breaks::BreaksLeaf>::default();
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.eq(p1);
+<breaks::BreaksLeaf as std::cmp::PartialEq>::eq(p0, p1);
+crate::<breaks::BreaksLeaf as std::cmp::PartialEq>::eq(p0, p1);
+<breaks::BreaksLeaf>::eq(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.assert_receiver_is_total_eq();
+<breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<breaks::BreaksLeaf>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
+p0.clone();
+<breaks::BreaksInfo as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksInfo as std::clone::Clone>::clone(p0);
+<breaks::BreaksInfo>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<breaks::BreaksInfo as std::fmt::Debug>::fmt(p0, p1);
+crate::<breaks::BreaksInfo as std::fmt::Debug>::fmt(p0, p1);
+<breaks::BreaksInfo>::fmt(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.len();
+<breaks::BreaksLeaf as tree::Leaf>::len(p0);
+crate::<breaks::BreaksLeaf as tree::Leaf>::len(p0);
+<breaks::BreaksLeaf>::len(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::is_ok_child
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.is_ok_child();
+<breaks::BreaksLeaf as tree::Leaf>::is_ok_child(p0);
+crate::<breaks::BreaksLeaf as tree::Leaf>::is_ok_child(p0);
+<breaks::BreaksLeaf>::is_ok_child(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::push_maybe_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split(p0, p1, p2);
+crate::<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split(p0, p1, p2);
+<breaks::BreaksLeaf>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as tree::NodeInfo>::accumulate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
+p0.accumulate(p1);
+<breaks::BreaksInfo as tree::NodeInfo>::accumulate(p0, p1);
+crate::<breaks::BreaksInfo as tree::NodeInfo>::accumulate(p0, p1);
+<breaks::BreaksInfo>::accumulate(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as tree::NodeInfo>::compute_info
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+<breaks::BreaksInfo as tree::NodeInfo>::compute_info(p0);
+crate::<breaks::BreaksInfo as tree::NodeInfo>::compute_info(p0);
+<breaks::BreaksInfo>::compute_info(p0);
-----------------
rope/src/breaks.rs breaks::BreaksLeaf::get_data_cloned
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.get_data_cloned();
+breaks::BreaksLeaf::get_data_cloned(p0);
+crate::breaks::BreaksLeaf::get_data_cloned(p0);
+<breaks::BreaksLeaf>::get_data_cloned(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksMetric
+p0.clone();
+<breaks::BreaksMetric as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksMetric as std::clone::Clone>::clone(p0);
+<breaks::BreaksMetric>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+<breaks::BreaksMetric>::measure(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+<breaks::BreaksMetric>::to_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+<breaks::BreaksMetric>::from_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+<breaks::BreaksMetric>::is_boundary(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+<breaks::BreaksMetric>::prev(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+<breaks::BreaksMetric>::next(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment
deps:{}
candidates:{}
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+<breaks::BreaksMetric>::can_fragment();
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksBaseMetric
+p0.clone();
+<breaks::BreaksBaseMetric as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksBaseMetric as std::clone::Clone>::clone(p0);
+<breaks::BreaksBaseMetric>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+<breaks::BreaksBaseMetric>::measure(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+<breaks::BreaksBaseMetric>::to_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+<breaks::BreaksBaseMetric>::from_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+<breaks::BreaksBaseMetric>::is_boundary(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+<breaks::BreaksBaseMetric>::prev(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+<breaks::BreaksBaseMetric>::next(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment
deps:{}
candidates:{}
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+<breaks::BreaksBaseMetric>::can_fragment();
-----------------
rope/src/breaks.rs breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
+crate::breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
+<tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
-----------------
rope/src/breaks.rs <breaks::BreakBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<breaks::BreakBuilder as std::default::Default>::default();
+crate::<breaks::BreakBuilder as std::default::Default>::default();
+<breaks::BreakBuilder>::default();
-----------------
rope/src/breaks.rs breaks::BreakBuilder::new
deps:{}
candidates:{}
+breaks::BreakBuilder::new();
+crate::breaks::BreakBuilder::new();
+<breaks::BreakBuilder>::new();
-----------------
rope/src/breaks.rs breaks::BreakBuilder::add_break
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
let mut p1 = 0usize; // None+usize
+p0.add_break(p1);
+breaks::BreakBuilder::add_break(p0, p1);
+crate::breaks::BreakBuilder::add_break(p0, p1);
+<breaks::BreakBuilder>::add_break(p0, p1);
-----------------
rope/src/breaks.rs breaks::BreakBuilder::add_no_break
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
let mut p1 = 0usize; // None+usize
+p0.add_no_break(p1);
+breaks::BreakBuilder::add_no_break(p0, p1);
+crate::breaks::BreakBuilder::add_no_break(p0, p1);
+<breaks::BreakBuilder>::add_no_break(p0, p1);
-----------------
rope/src/breaks.rs breaks::BreakBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
+p0.build();
+breaks::BreakBuilder::build(p0);
+crate::breaks::BreakBuilder::build(p0);
+<breaks::BreakBuilder>::build(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+compare::RopeScanner::<'a>::new(p0, p1);
+crate::compare::RopeScanner::<'a>::new(p0, p1);
+<compare::RopeScanner<'a>>::new(p0, p1);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_ne_char_back
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"compare::RopeScanner::<'a>::find_ne_char_back":{"T":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"compare::RopeScanner::<'a>::find_ne_char_back":{"T":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.find_ne_char_back(p1, p2, p3);
+compare::RopeScanner::<'a>::find_ne_char_back(p0, p1, p2, p3);
+crate::compare::RopeScanner::<'a>::find_ne_char_back(p0, p1, p2, p3);
+<compare::RopeScanner<'a>>::find_ne_char_back(p0, p1, p2, p3);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_ne_char
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"compare::RopeScanner::<'a>::find_ne_char":{"T":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"compare::RopeScanner::<'a>::find_ne_char":{"T":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.find_ne_char(p1, p2, p3);
+compare::RopeScanner::<'a>::find_ne_char(p0, p1, p2, p3);
+crate::compare::RopeScanner::<'a>::find_ne_char(p0, p1, p2, p3);
+<compare::RopeScanner<'a>>::find_ne_char(p0, p1, p2, p3);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_min_diff_range
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.find_min_diff_range();
+compare::RopeScanner::<'a>::find_min_diff_range(p0);
+crate::compare::RopeScanner::<'a>::find_min_diff_range(p0);
+<compare::RopeScanner<'a>>::find_min_diff_range(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::load_prev_chunk
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.load_prev_chunk();
+compare::RopeScanner::<'a>::load_prev_chunk(p0);
+crate::compare::RopeScanner::<'a>::load_prev_chunk(p0);
+<compare::RopeScanner<'a>>::load_prev_chunk(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::load_next_chunk
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.load_next_chunk();
+compare::RopeScanner::<'a>::load_next_chunk(p0);
+crate::compare::RopeScanner::<'a>::load_next_chunk(p0);
+<compare::RopeScanner<'a>>::load_next_chunk(p0);
-----------------
rope/src/delta.rs <delta::DeltaElement<N> as std::clone::Clone>::clone
deps:{"<delta::DeltaElement<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<delta::DeltaElement<N> as std::clone::Clone>::clone":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","breaks::BreaksInfo","engine::Contents","breaks::BreaksBaseMetric","engine::Error","engine::DeltaOp","multiset::Segment","multiset::Subset","diff::DiffBuilder","delta::Delta","delta::InsertDelta","delta::DeltaElement","rope::Utf16CodeUnitsMetric","engine::FullPriority","spans::SpansLeaf","diff::DiffOp","breaks::BreaksMetric","tree::NodeVal","interval::Interval","rope::LinesMetric","tree::NodeBody","find::CaseMatching","breaks::BreaksLeaf","rope::RopeInfo","spans::SpansInfo","engine::RevId","multiset::ZipSegment","rope::BaseMetric","tree::Node","spans::Span"]},"spans::SpansInfo":{"T":["delta::Delta","rope::BaseMetric","engine::RevId","breaks::BreaksInfo","rope::LinesMetric","diff::DiffBuilder","tree::Node","multiset::Subset","spans::SpansInfo","engine::Contents","rope::RopeInfo","breaks::BreaksBaseMetric","multiset::Segment","breaks::BreaksLeaf","spans::Span","diff::DiffOp","engine::DeltaOp","spans::SpansLeaf","engine::Error","tree::NodeBody","delta::InsertDelta","interval::Interval","engine::FullPriority","delta::DeltaElement","find::CaseMatching","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","multiset::ZipSegment","tree::NodeVal"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","engine::FullPriority","multiset::CountMatcher","breaks::BreaksMetric","diff::DiffOp","engine::Contents","tree::NodeVal","breaks::BreaksBaseMetric","engine::DeltaOp","rope::RopeInfo","tree::Node","multiset::Subset","rope::Utf16CodeUnitsMetric","delta::Delta","spans::SpansLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","engine::RevId","rope::LinesMetric","tree::NodeBody","interval::Interval","diff::DiffBuilder","breaks::BreaksLeaf","multiset::Segment","spans::Span","find::CaseMatching","spans::SpansInfo","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaElement<N>
+p0.clone();
+<delta::DeltaElement<N> as std::clone::Clone>::clone(p0);
+crate::<delta::DeltaElement<N> as std::clone::Clone>::clone(p0);
+<delta::DeltaElement<N>>::clone(p0);
-----------------
rope/src/delta.rs <delta::Delta<N> as std::clone::Clone>::clone
deps:{"<delta::Delta<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<delta::Delta<N> as std::clone::Clone>::clone":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["find::CaseMatching","delta::Delta","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","interval::Interval","engine::DeltaOp","multiset::Subset","spans::SpansInfo","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","breaks::BreaksBaseMetric","diff::DiffOp","diff::DiffBuilder","engine::Contents","engine::Error","delta::InsertDelta","rope::LinesMetric","spans::SpansLeaf","engine::FullPriority","rope::RopeInfo","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","engine::RevId","multiset::ZipSegment","multiset::Segment","spans::Span","rope::BaseMetric","tree::NodeVal"]},"spans::SpansInfo":{"T":["rope::RopeInfo","breaks::BreaksInfo","delta::Delta","spans::Span","diff::DiffOp","spans::SpansLeaf","multiset::Subset","rope::Utf16CodeUnitsMetric","tree::Node","tree::NodeBody","breaks::BreaksMetric","find::CaseMatching","delta::DeltaElement","spans::SpansInfo","breaks::BreaksLeaf","tree::NodeVal","multiset::Segment","breaks::BreaksBaseMetric","engine::DeltaOp","multiset::ZipSegment","engine::RevId","rope::BaseMetric","diff::DiffBuilder","multiset::CountMatcher","rope::LinesMetric","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","engine::Error","interval::Interval","engine::Contents"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","find::CaseMatching","tree::Node","diff::DiffOp","engine::Contents","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","breaks::BreaksLeaf","spans::SpansInfo","breaks::BreaksBaseMetric","engine::Error","diff::DiffBuilder","multiset::Segment","tree::NodeVal","engine::FullPriority","delta::InsertDelta","rope::BaseMetric","spans::Span","multiset::Subset","breaks::BreaksMetric","tree::NodeBody","interval::Interval","delta::DeltaElement","engine::RevId","delta::Delta","engine::DeltaOp","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.clone();
+<delta::Delta<N> as std::clone::Clone>::clone(p0);
+crate::<delta::Delta<N> as std::clone::Clone>::clone(p0);
+<delta::Delta<N>>::clone(p0);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::clone::Clone>::clone
deps:{"<delta::InsertDelta<N> as std::clone::Clone>::clone":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<delta::InsertDelta<N> as std::clone::Clone>::clone":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","spans::Span","rope::RopeInfo","breaks::BreaksMetric","diff::DiffOp","rope::BaseMetric","breaks::BreaksBaseMetric","spans::SpansLeaf","spans::SpansInfo","engine::DeltaOp","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","breaks::BreaksInfo","diff::DiffBuilder","find::CaseMatching","engine::FullPriority","multiset::ZipSegment","rope::LinesMetric","multiset::Subset","tree::NodeVal","delta::InsertDelta","delta::DeltaElement","delta::Delta","engine::Contents","tree::Node","rope::Utf16CodeUnitsMetric","engine::RevId","multiset::Segment","interval::Interval","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["spans::Span","tree::NodeVal","breaks::BreaksLeaf","delta::DeltaElement","multiset::Subset","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","rope::LinesMetric","delta::InsertDelta","rope::Utf16CodeUnitsMetric","multiset::Segment","diff::DiffBuilder","tree::NodeBody","multiset::CountMatcher","delta::Delta","rope::BaseMetric","spans::SpansInfo","engine::Error","breaks::BreaksInfo","tree::Node","diff::DiffOp","engine::FullPriority","engine::RevId","multiset::ZipSegment","breaks::BreaksBaseMetric","find::CaseMatching","rope::RopeInfo","engine::DeltaOp","interval::Interval","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["breaks::BreaksLeaf","engine::DeltaOp","delta::InsertDelta","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","delta::DeltaElement","multiset::Segment","spans::SpansLeaf","tree::Node","tree::NodeBody","engine::RevId","rope::RopeInfo","delta::Delta","breaks::BreaksInfo","rope::BaseMetric","multiset::Subset","multiset::ZipSegment","tree::NodeVal","engine::Contents","engine::FullPriority","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","interval::Interval","spans::SpansInfo","breaks::BreaksMetric","diff::DiffOp","engine::Error","breaks::BreaksBaseMetric","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.clone();
+<delta::InsertDelta<N> as std::clone::Clone>::clone(p0);
+crate::<delta::InsertDelta<N> as std::clone::Clone>::clone(p0);
+<delta::InsertDelta<N>>::clone(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::simple_edit
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::Delta::<N>::simple_edit":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::simple_edit":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"],"T":["std::ops::RangeFull","std::ops::RangeFrom","<T as interval::IntervalBounds>"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::Error","delta::Delta","multiset::ZipSegment","spans::SpansInfo","find::CaseMatching","tree::NodeBody","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::CountMatcher","diff::DiffOp","delta::InsertDelta","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","delta::DeltaElement","diff::DiffBuilder","engine::DeltaOp","engine::FullPriority","rope::Utf16CodeUnitsMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","multiset::Segment","multiset::Subset","interval::Interval","rope::RopeInfo","tree::Node","breaks::BreaksInfo","engine::Contents","rope::LinesMetric","breaks::BreaksLeaf","engine::RevId"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","spans::Span","diff::DiffOp","multiset::Subset","multiset::Segment","tree::NodeVal","breaks::BreaksLeaf","tree::NodeBody","find::CaseMatching","rope::RopeInfo","delta::InsertDelta","delta::DeltaElement","interval::Interval","rope::BaseMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","engine::Error","breaks::BreaksInfo","rope::LinesMetric","engine::Contents","engine::DeltaOp","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","engine::FullPriority","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksMetric","spans::SpansInfo","engine::RevId","delta::Delta"]},"spans::SpansLeaf":{"T":["diff::DiffOp","engine::Contents","breaks::BreaksBaseMetric","breaks::BreaksLeaf","interval::Interval","tree::Node","rope::Utf16CodeUnitsMetric","multiset::Segment","breaks::BreaksMetric","multiset::CountMatcher","rope::BaseMetric","delta::InsertDelta","multiset::ZipSegment","spans::SpansInfo","engine::FullPriority","diff::DiffBuilder","tree::NodeVal","tree::NodeBody","engine::RevId","breaks::BreaksInfo","delta::DeltaElement","engine::DeltaOp","rope::LinesMetric","spans::SpansLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","spans::Span","find::CaseMatching","rope::RopeInfo","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p2 = 0usize; // None+usize
+delta::Delta::<N>::simple_edit(p0, p1, p2);
+crate::delta::Delta::<N>::simple_edit(p0, p1, p2);
+<delta::Delta<N>>::simple_edit(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Delta::<N>::as_simple_insert
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::Delta::<N>::as_simple_insert":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta::<N>::as_simple_insert":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::DeltaOp","tree::Node","breaks::BreaksMetric","rope::RopeInfo","engine::Contents","delta::DeltaElement","rope::LinesMetric","multiset::CountMatcher","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","engine::Error","engine::FullPriority","interval::Interval","breaks::BreaksLeaf","diff::DiffOp","diff::DiffBuilder","spans::Span","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","breaks::BreaksBaseMetric","delta::Delta","find::CaseMatching","tree::NodeBody","engine::RevId","rope::Utf16CodeUnitsMetric","tree::NodeVal","spans::SpansLeaf","multiset::Segment","breaks::BreaksInfo","multiset::Subset"]},"spans::SpansInfo":{"T":["engine::Contents","rope::LinesMetric","multiset::Subset","spans::SpansInfo","rope::RopeInfo","tree::NodeVal","engine::FullPriority","tree::NodeBody","engine::DeltaOp","multiset::ZipSegment","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","delta::DeltaElement","diff::DiffOp","spans::Span","spans::SpansLeaf","engine::RevId","rope::BaseMetric","delta::Delta","interval::Interval","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","multiset::Segment","multiset::CountMatcher","delta::InsertDelta","find::CaseMatching","breaks::BreaksInfo","breaks::BreaksBaseMetric","tree::Node","engine::Error","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["engine::Contents","delta::InsertDelta","rope::RopeInfo","rope::LinesMetric","engine::FullPriority","multiset::Segment","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::RevId","engine::Error","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","delta::DeltaElement","tree::NodeBody","diff::DiffOp","breaks::BreaksBaseMetric","multiset::Subset","breaks::BreaksInfo","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffBuilder","engine::DeltaOp","spans::SpansLeaf","rope::BaseMetric","tree::Node","spans::Span","tree::NodeVal","find::CaseMatching","multiset::ZipSegment","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.as_simple_insert();
+delta::Delta::<N>::as_simple_insert(p0);
+crate::delta::Delta::<N>::as_simple_insert(p0);
+<delta::Delta<N>>::as_simple_insert(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::is_simple_delete
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta::<N>::is_simple_delete":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::is_simple_delete":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","diff::DiffOp","rope::BaseMetric","tree::Node","delta::DeltaElement","multiset::Segment","multiset::CountMatcher","delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::FullPriority","rope::LinesMetric","engine::Contents","spans::SpansLeaf","spans::Span","diff::DiffBuilder","spans::SpansInfo","tree::NodeVal","engine::Error","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksBaseMetric","delta::Delta","engine::DeltaOp","tree::NodeBody","breaks::BreaksMetric","multiset::ZipSegment","find::CaseMatching","breaks::BreaksLeaf","multiset::Subset"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","interval::Interval","breaks::BreaksLeaf","engine::Error","rope::LinesMetric","rope::RopeInfo","rope::BaseMetric","find::CaseMatching","engine::FullPriority","breaks::BreaksBaseMetric","tree::NodeVal","multiset::Segment","delta::Delta","multiset::CountMatcher","multiset::ZipSegment","diff::DiffBuilder","engine::DeltaOp","engine::RevId","breaks::BreaksMetric","delta::InsertDelta","spans::Span","tree::Node","engine::Contents","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","multiset::Subset","spans::SpansLeaf","tree::NodeBody","rope::Utf16CodeUnitsMetric","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","rope::RopeInfo","spans::SpansInfo","breaks::BreaksMetric","engine::DeltaOp","engine::RevId","multiset::Segment","breaks::BreaksInfo","multiset::CountMatcher","rope::BaseMetric","engine::FullPriority","rope::LinesMetric","find::CaseMatching","tree::NodeBody","breaks::BreaksLeaf","spans::Span","multiset::Subset","breaks::BreaksBaseMetric","engine::Error","diff::DiffBuilder","multiset::ZipSegment","delta::Delta","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","tree::Node","tree::NodeVal","delta::InsertDelta","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.is_simple_delete();
+delta::Delta::<N>::is_simple_delete(p0);
+crate::delta::Delta::<N>::is_simple_delete(p0);
+<delta::Delta<N>>::is_simple_delete(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::is_identity
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta::<N>::is_identity":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::is_identity":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::Subset","breaks::BreaksMetric","engine::FullPriority","multiset::CountMatcher","engine::Error","spans::SpansInfo","engine::RevId","tree::NodeVal","multiset::ZipSegment","rope::BaseMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","multiset::Segment","interval::Interval","breaks::BreaksLeaf","rope::LinesMetric","rope::Utf16CodeUnitsMetric","delta::InsertDelta","rope::RopeInfo","delta::Delta","diff::DiffBuilder","engine::Contents","tree::Node","find::CaseMatching","breaks::BreaksBaseMetric","tree::NodeBody","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","delta::DeltaElement","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["tree::NodeBody","multiset::Subset","delta::InsertDelta","breaks::BreaksInfo","breaks::BreaksLeaf","find::CaseMatching","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","engine::RevId","multiset::CountMatcher","spans::SpansLeaf","spans::Span","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::Node","diff::DiffBuilder","rope::RopeInfo","spans::SpansInfo","breaks::BreaksMetric","engine::DeltaOp","engine::FullPriority","delta::DeltaElement","engine::Error","interval::Interval","diff::DiffOp","breaks::BreaksBaseMetric","delta::Delta","multiset::Segment","tree::NodeVal"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","delta::InsertDelta","engine::Error","delta::DeltaElement","rope::Utf16CodeUnitsMetric","spans::SpansInfo","multiset::Segment","breaks::BreaksBaseMetric","delta::Delta","engine::Contents","tree::Node","spans::Span","multiset::Subset","spans::SpansLeaf","rope::LinesMetric","tree::NodeVal","diff::DiffBuilder","breaks::BreaksInfo","multiset::ZipSegment","find::CaseMatching","multiset::CountMatcher","breaks::BreaksMetric","rope::BaseMetric","interval::Interval","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","tree::NodeBody","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.is_identity();
+delta::Delta::<N>::is_identity(p0);
+crate::delta::Delta::<N>::is_identity(p0);
+<delta::Delta<N>>::is_identity(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::apply
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::Delta::<N>::apply":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::apply":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::LinesMetric","tree::NodeVal","find::CaseMatching","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","breaks::BreaksMetric","tree::Node","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","multiset::CountMatcher","breaks::BreaksInfo","rope::RopeInfo","engine::Error","spans::Span","rope::BaseMetric","diff::DiffOp","delta::InsertDelta","multiset::Segment","engine::DeltaOp","spans::SpansInfo","engine::Contents","interval::Interval","multiset::ZipSegment","tree::NodeBody","diff::DiffBuilder","multiset::Subset","breaks::BreaksLeaf","delta::DeltaElement","breaks::BreaksBaseMetric","engine::RevId"]},"spans::SpansInfo":{"T":["delta::DeltaElement","delta::InsertDelta","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric","spans::Span","multiset::Segment","multiset::CountMatcher","tree::Node","diff::DiffOp","spans::SpansInfo","breaks::BreaksMetric","delta::Delta","engine::Error","breaks::BreaksBaseMetric","multiset::Subset","engine::DeltaOp","interval::Interval","spans::SpansLeaf","diff::DiffBuilder","multiset::ZipSegment","find::CaseMatching","breaks::BreaksLeaf","tree::NodeBody","engine::Contents","breaks::BreaksInfo","tree::NodeVal","rope::RopeInfo","engine::RevId"]},"spans::SpansLeaf":{"T":["rope::LinesMetric","breaks::BreaksInfo","multiset::Subset","breaks::BreaksBaseMetric","breaks::BreaksLeaf","rope::RopeInfo","multiset::Segment","delta::Delta","engine::FullPriority","breaks::BreaksMetric","tree::NodeBody","find::CaseMatching","multiset::CountMatcher","engine::DeltaOp","spans::Span","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","spans::SpansInfo","diff::DiffBuilder","engine::RevId","rope::Utf16CodeUnitsMetric","delta::InsertDelta","delta::DeltaElement","engine::Contents","engine::Error","tree::NodeVal","interval::Interval","spans::SpansLeaf","multiset::ZipSegment","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.apply(p1);
+delta::Delta::<N>::apply(p0, p1);
+crate::delta::Delta::<N>::apply(p0, p1);
+<delta::Delta<N>>::apply(p0, p1);
-----------------
rope/src/delta.rs delta::Delta::<N>::factor
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::Delta::<N>::factor":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::factor":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["find::CaseMatching","tree::Node","engine::Contents","multiset::ZipSegment","tree::NodeVal","breaks::BreaksLeaf","engine::FullPriority","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","tree::NodeBody","spans::SpansLeaf","rope::BaseMetric","delta::DeltaElement","multiset::CountMatcher","spans::Span","interval::Interval","breaks::BreaksBaseMetric","diff::DiffOp","multiset::Segment","rope::Utf16CodeUnitsMetric","spans::SpansInfo","delta::Delta","rope::LinesMetric","delta::InsertDelta","engine::RevId","engine::Error","engine::DeltaOp","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["multiset::Segment","delta::Delta","rope::RopeInfo","rope::BaseMetric","rope::Utf16CodeUnitsMetric","tree::NodeBody","breaks::BreaksLeaf","multiset::ZipSegment","spans::SpansLeaf","diff::DiffBuilder","delta::InsertDelta","breaks::BreaksBaseMetric","engine::DeltaOp","find::CaseMatching","interval::Interval","tree::NodeVal","breaks::BreaksMetric","engine::Contents","rope::LinesMetric","delta::DeltaElement","engine::RevId","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","engine::FullPriority","diff::DiffOp","engine::Error","spans::Span","multiset::Subset","spans::SpansInfo","tree::Node"]},"spans::SpansLeaf":{"T":["tree::Node","tree::NodeVal","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","rope::LinesMetric","breaks::BreaksLeaf","multiset::ZipSegment","rope::BaseMetric","interval::Interval","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Error","multiset::Subset","diff::DiffBuilder","delta::DeltaElement","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","delta::Delta","spans::Span","engine::RevId","multiset::CountMatcher","tree::NodeBody","multiset::Segment","find::CaseMatching","engine::Contents","spans::SpansLeaf","engine::DeltaOp","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.factor();
+delta::Delta::<N>::factor(p0);
+crate::delta::Delta::<N>::factor(p0);
+<delta::Delta<N>>::factor(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::synthesize
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta::<N>::synthesize":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta::<N>::synthesize":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::ZipSegment","tree::NodeBody","tree::NodeVal","interval::Interval","spans::SpansInfo","find::CaseMatching","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::DeltaOp","spans::Span","breaks::BreaksMetric","engine::RevId","rope::RopeInfo","engine::FullPriority","breaks::BreaksBaseMetric","tree::Node","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","rope::LinesMetric","multiset::CountMatcher","breaks::BreaksLeaf","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","engine::Contents","rope::BaseMetric","diff::DiffBuilder","breaks::BreaksInfo","multiset::Subset","delta::InsertDelta","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","rope::RopeInfo","delta::DeltaElement","interval::Interval","breaks::BreaksInfo","delta::Delta","engine::Contents","engine::FullPriority","find::CaseMatching","engine::DeltaOp","spans::SpansInfo","tree::NodeVal","spans::Span","multiset::Segment","rope::LinesMetric","engine::RevId","multiset::ZipSegment","breaks::BreaksLeaf","delta::InsertDelta","breaks::BreaksBaseMetric","diff::DiffOp","diff::DiffBuilder","engine::Error","tree::Node","tree::NodeBody","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","rope::BaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","multiset::Subset","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","diff::DiffOp","delta::DeltaElement","multiset::CountMatcher","spans::Span","engine::DeltaOp","engine::FullPriority","breaks::BreaksLeaf","multiset::ZipSegment","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","breaks::BreaksInfo","engine::Contents","tree::NodeVal","breaks::BreaksBaseMetric","find::CaseMatching","spans::SpansLeaf","multiset::Segment","engine::RevId","interval::Interval","tree::Node","delta::Delta","rope::BaseMetric","rope::RopeInfo","spans::SpansInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+delta::Delta::<N>::synthesize(p0, p1, p2);
+crate::delta::Delta::<N>::synthesize(p0, p1, p2);
+<delta::Delta<N>>::synthesize(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Delta::<N>::summary
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::Delta::<N>::summary":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::Delta::<N>::summary":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","spans::SpansInfo","engine::RevId","delta::Delta","diff::DiffBuilder","multiset::ZipSegment","tree::Node","multiset::Subset","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","engine::DeltaOp","multiset::CountMatcher","delta::DeltaElement","engine::FullPriority","tree::NodeVal","diff::DiffOp","breaks::BreaksLeaf","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","engine::Contents","engine::Error","rope::LinesMetric","interval::Interval","breaks::BreaksBaseMetric","spans::Span","delta::InsertDelta","tree::NodeBody","rope::BaseMetric","find::CaseMatching","rope::RopeInfo"]},"spans::SpansInfo":{"T":["tree::NodeVal","engine::DeltaOp","find::CaseMatching","tree::NodeBody","rope::RopeInfo","diff::DiffBuilder","breaks::BreaksMetric","rope::BaseMetric","engine::RevId","diff::DiffOp","spans::SpansInfo","breaks::BreaksLeaf","rope::LinesMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","multiset::Segment","breaks::BreaksInfo","delta::Delta","delta::DeltaElement","delta::InsertDelta","multiset::ZipSegment","interval::Interval","engine::Contents","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::Error","tree::Node","rope::Utf16CodeUnitsMetric","multiset::Subset","engine::FullPriority"]},"spans::SpansLeaf":{"T":["find::CaseMatching","interval::Interval","spans::SpansLeaf","tree::Node","rope::LinesMetric","multiset::CountMatcher","engine::FullPriority","engine::RevId","engine::Error","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","delta::DeltaElement","tree::NodeBody","spans::Span","multiset::Subset","diff::DiffOp","engine::Contents","multiset::Segment","rope::BaseMetric","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","spans::SpansInfo","multiset::ZipSegment","engine::DeltaOp","delta::InsertDelta","delta::Delta","breaks::BreaksInfo","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.summary();
+delta::Delta::<N>::summary(p0);
+crate::delta::Delta::<N>::summary(p0);
+<delta::Delta<N>>::summary(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::new_document_len
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::Delta::<N>::new_document_len":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::new_document_len":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","diff::DiffOp","spans::SpansLeaf","delta::Delta","engine::Error","rope::BaseMetric","tree::NodeVal","engine::FullPriority","breaks::BreaksLeaf","spans::Span","engine::RevId","multiset::CountMatcher","engine::Contents","interval::Interval","rope::LinesMetric","breaks::BreaksBaseMetric","delta::DeltaElement","delta::InsertDelta","engine::DeltaOp","breaks::BreaksInfo","find::CaseMatching","tree::Node","rope::RopeInfo","multiset::Subset","spans::SpansInfo","multiset::Segment"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","rope::RopeInfo","tree::Node","tree::NodeBody","engine::DeltaOp","delta::InsertDelta","breaks::BreaksLeaf","delta::Delta","rope::BaseMetric","diff::DiffBuilder","multiset::Segment","breaks::BreaksBaseMetric","rope::LinesMetric","multiset::CountMatcher","spans::Span","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","spans::SpansInfo","delta::DeltaElement","engine::Error","find::CaseMatching","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","engine::Contents","diff::DiffOp","multiset::Subset","tree::NodeVal","interval::Interval","breaks::BreaksInfo","engine::FullPriority"]},"spans::SpansLeaf":{"T":["diff::DiffOp","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","breaks::BreaksMetric","engine::FullPriority","engine::RevId","tree::Node","delta::InsertDelta","tree::NodeBody","interval::Interval","multiset::ZipSegment","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","engine::Contents","delta::DeltaElement","engine::DeltaOp","multiset::Subset","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksLeaf","tree::NodeVal","rope::LinesMetric","multiset::Segment","spans::SpansInfo","delta::Delta","engine::Error","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.new_document_len();
+delta::Delta::<N>::new_document_len(p0);
+crate::delta::Delta::<N>::new_document_len(p0);
+<delta::Delta<N>>::new_document_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::total_element_len
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta::<N>::total_element_len":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::total_element_len":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","tree::NodeVal","engine::RevId","engine::Contents","engine::Error","find::CaseMatching","diff::DiffBuilder","multiset::ZipSegment","delta::DeltaElement","rope::BaseMetric","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","breaks::BreaksMetric","spans::SpansLeaf","diff::DiffOp","delta::Delta","engine::FullPriority","interval::Interval","breaks::BreaksLeaf","engine::DeltaOp","spans::Span","rope::Utf16CodeUnitsMetric","delta::InsertDelta","spans::SpansInfo","tree::NodeBody","rope::LinesMetric","rope::RopeInfo","multiset::Segment","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","multiset::CountMatcher","breaks::BreaksInfo","tree::NodeVal","engine::Error","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::RopeInfo","rope::LinesMetric","delta::Delta","engine::Contents","spans::SpansInfo","engine::RevId","engine::DeltaOp","multiset::ZipSegment","rope::BaseMetric","spans::Span","delta::InsertDelta","diff::DiffOp","interval::Interval","diff::DiffBuilder","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","find::CaseMatching","tree::Node","multiset::Subset","multiset::Segment","engine::FullPriority","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::FullPriority","multiset::ZipSegment","engine::RevId","diff::DiffOp","tree::NodeBody","find::CaseMatching","breaks::BreaksBaseMetric","diff::DiffBuilder","spans::SpansInfo","delta::Delta","rope::BaseMetric","interval::Interval","spans::SpansLeaf","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksMetric","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","engine::DeltaOp","engine::Contents","rope::LinesMetric","breaks::BreaksLeaf","multiset::Segment","multiset::Subset","spans::Span","engine::Error","tree::Node","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [delta::DeltaElement<N>]
+delta::Delta::<N>::total_element_len(p0);
+crate::delta::Delta::<N>::total_element_len(p0);
+<delta::Delta<N>>::total_element_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::inserts_len
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta::<N>::inserts_len":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta::<N>::inserts_len":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["interval::Interval","delta::DeltaElement","tree::NodeVal","engine::DeltaOp","diff::DiffBuilder","tree::Node","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","tree::NodeBody","delta::Delta","spans::Span","spans::SpansLeaf","breaks::BreaksLeaf","rope::BaseMetric","spans::SpansInfo","find::CaseMatching","multiset::Subset","diff::DiffOp","rope::RopeInfo","breaks::BreaksBaseMetric","rope::LinesMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric","multiset::Segment","breaks::BreaksInfo","breaks::BreaksMetric","engine::Error","engine::Contents","multiset::ZipSegment"]},"spans::SpansInfo":{"T":["rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","find::CaseMatching","delta::DeltaElement","engine::Contents","breaks::BreaksLeaf","multiset::ZipSegment","diff::DiffOp","multiset::Segment","interval::Interval","diff::DiffBuilder","delta::InsertDelta","spans::SpansLeaf","breaks::BreaksInfo","spans::SpansInfo","rope::LinesMetric","engine::DeltaOp","engine::RevId","breaks::BreaksMetric","tree::NodeVal","multiset::CountMatcher","spans::Span","engine::FullPriority","delta::Delta","engine::Error","rope::RopeInfo","multiset::Subset","tree::NodeBody","tree::Node"]},"spans::SpansLeaf":{"T":["delta::Delta","interval::Interval","multiset::Segment","spans::Span","diff::DiffOp","engine::Error","engine::Contents","engine::FullPriority","multiset::CountMatcher","delta::InsertDelta","spans::SpansInfo","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","spans::SpansLeaf","breaks::BreaksBaseMetric","find::CaseMatching","rope::LinesMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::Subset","multiset::ZipSegment","tree::NodeBody","rope::BaseMetric","breaks::BreaksLeaf","tree::Node","breaks::BreaksInfo","diff::DiffBuilder","delta::DeltaElement","engine::RevId"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.inserts_len();
+delta::Delta::<N>::inserts_len(p0);
+crate::delta::Delta::<N>::inserts_len(p0);
+<delta::Delta<N>>::inserts_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::iter_inserts
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::iter_inserts":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::iter_inserts":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffBuilder","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","engine::DeltaOp","rope::BaseMetric","tree::NodeVal","tree::Node","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","delta::DeltaElement","interval::Interval","breaks::BreaksLeaf","engine::FullPriority","multiset::Segment","multiset::Subset","breaks::BreaksInfo","delta::Delta","rope::Utf16CodeUnitsMetric","engine::Error","diff::DiffOp","multiset::CountMatcher","engine::RevId","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","spans::SpansLeaf","engine::Contents","find::CaseMatching","rope::LinesMetric","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["tree::Node","spans::SpansLeaf","multiset::ZipSegment","rope::RopeInfo","engine::RevId","delta::DeltaElement","diff::DiffOp","multiset::CountMatcher","interval::Interval","breaks::BreaksMetric","delta::Delta","engine::Contents","spans::Span","spans::SpansInfo","multiset::Segment","breaks::BreaksInfo","engine::DeltaOp","tree::NodeBody","multiset::Subset","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksLeaf","engine::FullPriority","rope::LinesMetric","breaks::BreaksBaseMetric","diff::DiffBuilder","tree::NodeVal"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","engine::DeltaOp","tree::NodeBody","find::CaseMatching","breaks::BreaksMetric","diff::DiffOp","engine::FullPriority","engine::Contents","multiset::Segment","delta::Delta","spans::SpansLeaf","multiset::Subset","diff::DiffBuilder","spans::Span","delta::DeltaElement","tree::NodeVal","engine::Error","multiset::ZipSegment","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksBaseMetric","engine::RevId","rope::RopeInfo","tree::Node","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksLeaf","breaks::BreaksInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.iter_inserts();
+delta::Delta::<N>::iter_inserts(p0);
+crate::delta::Delta::<N>::iter_inserts(p0);
+<delta::Delta<N>>::iter_inserts(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::iter_deletions
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::iter_deletions":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::iter_deletions":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::BaseMetric","diff::DiffBuilder","rope::RopeInfo","engine::DeltaOp","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","delta::DeltaElement","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","spans::SpansInfo","engine::RevId","multiset::CountMatcher","engine::Contents","tree::Node","spans::Span","interval::Interval","breaks::BreaksInfo","engine::FullPriority","rope::LinesMetric","tree::NodeVal","find::CaseMatching","breaks::BreaksBaseMetric","engine::Error","breaks::BreaksLeaf","tree::NodeBody","delta::Delta","multiset::Subset","multiset::Segment","delta::InsertDelta"]},"spans::SpansInfo":{"T":["multiset::ZipSegment","interval::Interval","rope::RopeInfo","tree::NodeVal","rope::BaseMetric","delta::DeltaElement","breaks::BreaksBaseMetric","multiset::CountMatcher","rope::LinesMetric","diff::DiffOp","engine::RevId","breaks::BreaksInfo","diff::DiffBuilder","spans::SpansInfo","engine::FullPriority","breaks::BreaksMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","spans::SpansLeaf","engine::Contents","spans::Span","engine::DeltaOp","breaks::BreaksLeaf","tree::Node","engine::Error","delta::Delta","find::CaseMatching","rope::Utf16CodeUnitsMetric","multiset::Subset","multiset::Segment"]},"spans::SpansLeaf":{"T":["spans::Span","diff::DiffOp","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::FullPriority","spans::SpansInfo","interval::Interval","engine::DeltaOp","delta::DeltaElement","tree::NodeBody","multiset::CountMatcher","rope::RopeInfo","engine::RevId","multiset::Segment","breaks::BreaksLeaf","engine::Contents","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","spans::SpansLeaf","delta::InsertDelta","breaks::BreaksInfo","rope::LinesMetric","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","find::CaseMatching","rope::BaseMetric","multiset::Subset","engine::Error","delta::Delta","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.iter_deletions();
+delta::Delta::<N>::iter_deletions(p0);
+crate::delta::Delta::<N>::iter_deletions(p0);
+<delta::Delta<N>>::iter_deletions(p0);
-----------------
rope/src/delta.rs <delta::Delta<N> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::Delta<N> as std::fmt::Debug>::fmt":{"N":["tree::NodeInfo","std::marker::Sized"],"tree::Node<N>":["std::fmt::Debug"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::Spans":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::Delta<N> as std::fmt::Debug>::fmt":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"tree::Node<N>":["spans::Spans","multiset::CountMatcher","engine::Contents","engine::Error","diff::DiffBuilder","multiset::Segment","engine::RevId","<&mut T as std::fmt::Debug>","breaks::BreaksLeaf","multiset::Subset","engine::Revision","engine::DeltaOp","rope::Rope","delta::DeltaRegion","delta::Delta","delta::InsertDelta","diff::DiffOp","multiset::ZipSegment","engine::Engine","breaks::BreaksInfo","interval::Interval"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::Contents","rope::BaseMetric","breaks::BreaksMetric","tree::Node","breaks::BreaksBaseMetric","multiset::Subset","tree::NodeVal","breaks::BreaksLeaf","multiset::ZipSegment","multiset::Segment","engine::Error","diff::DiffOp","delta::Delta","rope::RopeInfo","find::CaseMatching","delta::DeltaElement","rope::LinesMetric","breaks::BreaksInfo","spans::SpansInfo","diff::DiffBuilder","spans::SpansLeaf","interval::Interval","engine::RevId","delta::InsertDelta","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","spans::Span","engine::DeltaOp","tree::NodeBody","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::Spans":{"T":["multiset::ZipSegment","engine::Error","multiset::CountMatcher","engine::Contents","breaks::BreaksLeaf","delta::InsertDelta","engine::DeltaOp","multiset::Subset","delta::Delta","interval::Interval","diff::DiffBuilder","breaks::BreaksInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","multiset::Segment"]},"spans::SpansInfo":{"T":["tree::Node","breaks::BreaksInfo","engine::Error","multiset::ZipSegment","tree::NodeBody","delta::Delta","rope::Utf16CodeUnitsMetric","engine::Contents","rope::LinesMetric","rope::BaseMetric","spans::SpansInfo","multiset::CountMatcher","diff::DiffBuilder","multiset::Segment","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","find::CaseMatching","multiset::Subset","delta::DeltaElement","engine::DeltaOp","breaks::BreaksBaseMetric","breaks::BreaksLeaf","tree::NodeVal","breaks::BreaksMetric","engine::RevId","interval::Interval","engine::FullPriority","spans::SpansLeaf","delta::InsertDelta","diff::DiffOp"]},"spans::SpansLeaf":{"T":["tree::NodeVal","delta::DeltaElement","breaks::BreaksLeaf","spans::Span","engine::DeltaOp","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","rope::BaseMetric","spans::SpansInfo","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","delta::InsertDelta","interval::Interval","tree::NodeBody","diff::DiffOp","multiset::Subset","multiset::ZipSegment","rope::LinesMetric","find::CaseMatching","engine::RevId","tree::Node","rope::RopeInfo","multiset::CountMatcher","engine::Error","breaks::BreaksBaseMetric","multiset::Segment","engine::FullPriority","breaks::BreaksMetric","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::Delta<N> as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::Delta<N> as std::fmt::Debug>::fmt(p0, p1);
+<delta::Delta<N>>::fmt(p0, p1);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":{"N":["tree::NodeInfo","std::marker::Sized"],"tree::Node<N>":["std::fmt::Debug"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::Spans":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"],"tree::Node<N>":["multiset::CountMatcher","interval::Interval","diff::DiffBuilder","<*mut T as std::fmt::Debug>","breaks::BreaksInfo","delta::InsertDelta","spans::Spans","engine::DeltaOp","multiset::Subset","delta::Delta","engine::Engine","multiset::ZipSegment","engine::Error","delta::DeltaRegion","multiset::Segment","rope::Rope","engine::Contents","diff::DiffOp","breaks::BreaksLeaf","engine::Revision","engine::RevId"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","delta::DeltaElement","delta::InsertDelta","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","interval::Interval","engine::RevId","delta::Delta","spans::SpansLeaf","multiset::Subset","spans::SpansInfo","rope::BaseMetric","diff::DiffBuilder","spans::Span","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Error","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","breaks::BreaksLeaf","multiset::CountMatcher","multiset::Segment","rope::LinesMetric","engine::Contents","engine::DeltaOp","rope::RopeInfo","diff::DiffOp","find::CaseMatching","tree::Node"]},"spans::Spans":{"T":["delta::InsertDelta","engine::RevId","multiset::Segment","engine::Error","multiset::ZipSegment","multiset::Subset","breaks::BreaksInfo","multiset::CountMatcher","diff::DiffBuilder","delta::Delta","breaks::BreaksLeaf","engine::DeltaOp","<*const T as std::fmt::Debug>","diff::DiffOp","engine::Contents","interval::Interval"]},"spans::SpansInfo":{"T":["engine::Error","tree::Node","breaks::BreaksLeaf","multiset::CountMatcher","tree::NodeVal","rope::LinesMetric","engine::FullPriority","engine::Contents","rope::Utf16CodeUnitsMetric","spans::SpansInfo","multiset::ZipSegment","engine::DeltaOp","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment","breaks::BreaksBaseMetric","spans::Span","delta::DeltaElement","interval::Interval","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksMetric","multiset::Subset","delta::InsertDelta","tree::NodeBody","engine::RevId","rope::BaseMetric","diff::DiffOp","rope::RopeInfo","find::CaseMatching","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","tree::Node","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::LinesMetric","multiset::Subset","engine::Contents","multiset::CountMatcher","multiset::Segment","spans::Span","diff::DiffBuilder","spans::SpansLeaf","rope::BaseMetric","delta::DeltaElement","find::CaseMatching","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","rope::RopeInfo","engine::Error","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","tree::NodeBody","breaks::BreaksLeaf","engine::RevId","engine::FullPriority","spans::SpansInfo","engine::DeltaOp","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::InsertDelta<N> as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::InsertDelta<N> as std::fmt::Debug>::fmt(p0, p1);
+<delta::InsertDelta<N>>::fmt(p0, p1);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::transform_expand
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta::<N>::transform_expand":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta::<N>::transform_expand":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","delta::InsertDelta","diff::DiffBuilder","multiset::Subset","rope::LinesMetric","tree::NodeVal","engine::FullPriority","find::CaseMatching","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","breaks::BreaksMetric","spans::SpansInfo","rope::RopeInfo","engine::DeltaOp","spans::SpansLeaf","diff::DiffOp","rope::BaseMetric","delta::DeltaElement","breaks::BreaksInfo","engine::RevId","tree::NodeBody","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","rope::Utf16CodeUnitsMetric","tree::Node","multiset::Segment","multiset::CountMatcher","interval::Interval","breaks::BreaksLeaf","multiset::ZipSegment"]},"spans::SpansInfo":{"T":["diff::DiffOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","breaks::BreaksInfo","engine::RevId","multiset::Segment","breaks::BreaksMetric","engine::FullPriority","interval::Interval","spans::Span","find::CaseMatching","tree::NodeVal","delta::Delta","multiset::Subset","diff::DiffBuilder","spans::SpansLeaf","multiset::ZipSegment","engine::Contents","delta::InsertDelta","rope::LinesMetric","rope::RopeInfo","tree::Node","spans::SpansInfo","engine::DeltaOp","tree::NodeBody","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","engine::Error","delta::DeltaElement","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","engine::RevId","spans::SpansInfo","multiset::CountMatcher","interval::Interval","rope::BaseMetric","delta::DeltaElement","find::CaseMatching","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","spans::Span","spans::SpansLeaf","engine::DeltaOp","rope::RopeInfo","tree::Node","engine::Error","diff::DiffOp","multiset::Segment","breaks::BreaksInfo","rope::LinesMetric","tree::NodeVal","tree::NodeBody","delta::Delta","multiset::ZipSegment","multiset::Subset","breaks::BreaksMetric","engine::Contents","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = true; // None+bool
+p0.transform_expand(p1, p2);
+delta::InsertDelta::<N>::transform_expand(p0, p1, p2);
+crate::delta::InsertDelta::<N>::transform_expand(p0, p1, p2);
+<delta::InsertDelta<N>>::transform_expand(p0, p1, p2);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::transform_shrink
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta::<N>::transform_shrink":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta::<N>::transform_shrink":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::ZipSegment","engine::RevId","diff::DiffBuilder","spans::SpansLeaf","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","rope::BaseMetric","diff::DiffOp","engine::DeltaOp","engine::FullPriority","rope::LinesMetric","rope::Utf16CodeUnitsMetric","engine::Contents","breaks::BreaksBaseMetric","tree::NodeBody","engine::Error","find::CaseMatching","multiset::Segment","tree::NodeVal","multiset::CountMatcher","breaks::BreaksMetric","spans::Span","breaks::BreaksInfo","delta::Delta","interval::Interval","tree::Node","rope::RopeInfo","delta::DeltaElement","spans::SpansInfo","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","delta::InsertDelta","multiset::Subset","engine::FullPriority","tree::Node","rope::Utf16CodeUnitsMetric","multiset::Segment","multiset::CountMatcher","engine::Contents","rope::LinesMetric","diff::DiffBuilder","tree::NodeBody","delta::DeltaElement","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","spans::Span","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::DeltaOp","breaks::BreaksInfo","find::CaseMatching","diff::DiffOp","engine::RevId","rope::RopeInfo","delta::Delta","multiset::ZipSegment","tree::NodeVal","rope::BaseMetric","interval::Interval","engine::Error"]},"spans::SpansLeaf":{"T":["tree::Node","engine::Error","rope::LinesMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","spans::SpansLeaf","rope::RopeInfo","spans::SpansInfo","rope::Utf16CodeUnitsMetric","rope::BaseMetric","spans::Span","tree::NodeVal","engine::RevId","diff::DiffOp","multiset::ZipSegment","diff::DiffBuilder","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","delta::InsertDelta","delta::DeltaElement","breaks::BreaksMetric","engine::FullPriority","breaks::BreaksBaseMetric","breaks::BreaksLeaf","find::CaseMatching","engine::DeltaOp","breaks::BreaksInfo","engine::Contents","multiset::CountMatcher","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_shrink(p1);
+delta::InsertDelta::<N>::transform_shrink(p0, p1);
+crate::delta::InsertDelta::<N>::transform_shrink(p0, p1);
+<delta::InsertDelta<N>>::transform_shrink(p0, p1);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::inserted_subset
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta::<N>::inserted_subset":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta::<N>::inserted_subset":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::DeltaOp","multiset::Subset","diff::DiffBuilder","multiset::CountMatcher","rope::LinesMetric","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","diff::DiffOp","tree::Node","breaks::BreaksInfo","engine::FullPriority","spans::SpansLeaf","rope::RopeInfo","tree::NodeVal","spans::Span","engine::RevId","delta::InsertDelta","breaks::BreaksBaseMetric","interval::Interval","delta::DeltaElement","breaks::BreaksLeaf","spans::SpansInfo","rope::BaseMetric","engine::Contents","breaks::BreaksMetric","tree::NodeBody","multiset::Segment"]},"spans::SpansInfo":{"T":["tree::Node","diff::DiffBuilder","tree::NodeBody","spans::SpansInfo","breaks::BreaksMetric","engine::Contents","diff::DiffOp","interval::Interval","multiset::ZipSegment","breaks::BreaksInfo","engine::Error","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::Segment","tree::NodeVal","delta::InsertDelta","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","delta::DeltaElement","engine::RevId","rope::LinesMetric","rope::RopeInfo","spans::Span","multiset::Subset","multiset::CountMatcher","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","find::CaseMatching","engine::FullPriority"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","interval::Interval","multiset::Subset","diff::DiffOp","delta::InsertDelta","breaks::BreaksBaseMetric","multiset::ZipSegment","multiset::CountMatcher","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","delta::DeltaElement","engine::DeltaOp","spans::SpansLeaf","tree::NodeVal","diff::DiffBuilder","multiset::Segment","breaks::BreaksMetric","rope::RopeInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksInfo","engine::FullPriority","spans::Span","engine::RevId","rope::BaseMetric","tree::Node","breaks::BreaksLeaf","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.inserted_subset();
+delta::InsertDelta::<N>::inserted_subset(p0);
+crate::delta::InsertDelta::<N>::inserted_subset(p0);
+<delta::InsertDelta<N>>::inserted_subset(p0);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::ops::Deref>::deref
deps:{"<delta::InsertDelta<N> as std::ops::Deref>::deref":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<delta::InsertDelta<N> as std::ops::Deref>::deref":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","breaks::BreaksInfo","tree::NodeVal","delta::Delta","engine::RevId","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","spans::SpansInfo","multiset::Segment","rope::RopeInfo","spans::SpansLeaf","breaks::BreaksLeaf","tree::Node","delta::DeltaElement","multiset::Subset","spans::Span","engine::DeltaOp","engine::Error","breaks::BreaksMetric","diff::DiffBuilder","rope::BaseMetric","find::CaseMatching","engine::Contents","interval::Interval","diff::DiffOp","tree::NodeBody"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::Contents","multiset::Subset","multiset::ZipSegment","breaks::BreaksLeaf","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","tree::NodeVal","rope::LinesMetric","tree::Node","interval::Interval","rope::RopeInfo","engine::FullPriority","breaks::BreaksBaseMetric","engine::RevId","delta::DeltaElement","delta::Delta","spans::Span","diff::DiffBuilder","multiset::CountMatcher","spans::SpansLeaf","engine::Error","tree::NodeBody","find::CaseMatching","diff::DiffOp","breaks::BreaksMetric","spans::SpansInfo","engine::DeltaOp","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["multiset::Subset","rope::Utf16CodeUnitsMetric","rope::LinesMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","spans::SpansInfo","diff::DiffBuilder","engine::RevId","diff::DiffOp","engine::FullPriority","delta::DeltaElement","breaks::BreaksMetric","delta::Delta","rope::BaseMetric","tree::NodeVal","delta::InsertDelta","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","multiset::Segment","spans::Span","find::CaseMatching","breaks::BreaksLeaf","multiset::ZipSegment","spans::SpansLeaf","tree::NodeBody","breaks::BreaksBaseMetric","rope::RopeInfo","engine::Contents","engine::Error","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.deref();
+<delta::InsertDelta<N> as std::ops::Deref>::deref(p0);
+crate::<delta::InsertDelta<N> as std::ops::Deref>::deref(p0);
+<delta::InsertDelta<N>>::deref(p0);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::new
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Transformer::<'a, N>::new":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Transformer::<'a, N>::new":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["tree::Node","breaks::BreaksLeaf","diff::DiffBuilder","interval::Interval","multiset::ZipSegment","engine::Error","rope::BaseMetric","rope::RopeInfo","engine::RevId","rope::Utf16CodeUnitsMetric","tree::NodeBody","breaks::BreaksBaseMetric","rope::LinesMetric","breaks::BreaksInfo","multiset::Subset","delta::InsertDelta","diff::DiffOp","find::CaseMatching","engine::Contents","multiset::Segment","delta::DeltaElement","breaks::BreaksMetric","spans::SpansLeaf","spans::Span","spans::SpansInfo","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp"]},"spans::SpansInfo":{"T":["engine::FullPriority","spans::SpansInfo","multiset::Subset","engine::Contents","delta::DeltaElement","delta::Delta","rope::RopeInfo","engine::Error","breaks::BreaksInfo","find::CaseMatching","multiset::Segment","rope::BaseMetric","breaks::BreaksMetric","tree::NodeVal","engine::DeltaOp","interval::Interval","breaks::BreaksLeaf","spans::SpansLeaf","delta::InsertDelta","rope::LinesMetric","tree::Node","tree::NodeBody","multiset::ZipSegment","engine::RevId","diff::DiffBuilder","breaks::BreaksBaseMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","spans::Span","rope::Utf16CodeUnitsMetric"]},"spans::SpansLeaf":{"T":["tree::NodeVal","diff::DiffOp","tree::Node","engine::Contents","multiset::ZipSegment","tree::NodeBody","multiset::CountMatcher","breaks::BreaksLeaf","breaks::BreaksMetric","multiset::Subset","engine::RevId","delta::Delta","rope::LinesMetric","spans::Span","engine::Error","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","delta::DeltaElement","rope::BaseMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","multiset::Segment","delta::InsertDelta","breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","spans::SpansLeaf","engine::DeltaOp","engine::FullPriority","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+delta::Transformer::<'a, N>::new(p0);
+crate::delta::Transformer::<'a, N>::new(p0);
+<delta::Transformer<'a, N>>::new(p0);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::transform
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Transformer::<'a, N>::transform":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Transformer::<'a, N>::transform":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["diff::DiffBuilder","engine::FullPriority","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","engine::RevId","diff::DiffOp","rope::BaseMetric","delta::InsertDelta","breaks::BreaksLeaf","find::CaseMatching","rope::Utf16CodeUnitsMetric","spans::Span","tree::NodeBody","spans::SpansInfo","engine::Error","breaks::BreaksBaseMetric","tree::Node","spans::SpansLeaf","tree::NodeVal","delta::Delta","multiset::Segment","breaks::BreaksInfo","multiset::Subset","engine::Contents","multiset::ZipSegment","multiset::CountMatcher","interval::Interval","rope::LinesMetric","engine::DeltaOp"]},"spans::SpansInfo":{"T":["engine::Contents","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","rope::RopeInfo","diff::DiffOp","tree::Node","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","breaks::BreaksInfo","spans::SpansInfo","multiset::Segment","diff::DiffBuilder","breaks::BreaksMetric","delta::InsertDelta","engine::RevId","delta::Delta","multiset::ZipSegment","rope::BaseMetric","rope::LinesMetric","find::CaseMatching","engine::FullPriority","spans::Span","multiset::Subset","breaks::BreaksBaseMetric","breaks::BreaksLeaf","engine::DeltaOp","delta::DeltaElement","tree::NodeBody","engine::Error","interval::Interval"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","rope::RopeInfo","diff::DiffBuilder","delta::Delta","delta::InsertDelta","multiset::Segment","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp","spans::Span","breaks::BreaksMetric","breaks::BreaksLeaf","delta::DeltaElement","engine::DeltaOp","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","tree::NodeBody","interval::Interval","multiset::Subset","rope::LinesMetric","tree::NodeVal","engine::FullPriority","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::RevId","breaks::BreaksInfo","spans::SpansInfo","find::CaseMatching","engine::Contents","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'a, N>
let mut p1 = 0usize; // None+usize
let mut p2 = true; // None+bool
+p0.transform(p1, p2);
+delta::Transformer::<'a, N>::transform(p0, p1, p2);
+crate::delta::Transformer::<'a, N>::transform(p0, p1, p2);
+<delta::Transformer<'a, N>>::transform(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::interval_untouched
'a
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::Transformer::<'a, N>::interval_untouched":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["interval::IntervalBounds","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Transformer::<'a, N>::interval_untouched":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"spans::Span":{"T":["delta::InsertDelta","tree::Node","multiset::ZipSegment","spans::Span","breaks::BreaksLeaf","find::CaseMatching","diff::DiffBuilder","engine::FullPriority","delta::DeltaElement","engine::DeltaOp","engine::Contents","multiset::Subset","engine::Error","rope::BaseMetric","tree::NodeVal","rope::LinesMetric","breaks::BreaksMetric","multiset::Segment","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","breaks::BreaksInfo","diff::DiffOp","tree::NodeBody","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","spans::SpansInfo","breaks::BreaksBaseMetric","engine::RevId","rope::RopeInfo"]},"spans::SpansInfo":{"T":["multiset::Segment","multiset::CountMatcher","delta::InsertDelta","multiset::Subset","spans::SpansInfo","tree::NodeBody","engine::Contents","tree::NodeVal","multiset::ZipSegment","engine::FullPriority","rope::LinesMetric","breaks::BreaksLeaf","breaks::BreaksMetric","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::DeltaOp","tree::Node","rope::RopeInfo","engine::Error","engine::RevId","rope::BaseMetric","delta::Delta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","diff::DiffBuilder","spans::SpansLeaf","delta::DeltaElement","spans::Span","find::CaseMatching","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["multiset::Subset","delta::InsertDelta","rope::RopeInfo","delta::Delta","multiset::Segment","tree::Node","engine::RevId","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","diff::DiffOp","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","engine::Error","breaks::BreaksMetric","tree::NodeVal","engine::DeltaOp","interval::Interval","tree::NodeBody","rope::Utf16CodeUnitsMetric","rope::BaseMetric","breaks::BreaksBaseMetric","engine::FullPriority","engine::Contents","diff::DiffBuilder","spans::SpansLeaf","multiset::CountMatcher","spans::Span","breaks::BreaksInfo","breaks::BreaksLeaf","find::CaseMatching"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'a, N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.interval_untouched(p1);
+delta::Transformer::<'a, N>::interval_untouched(p0, p1);
+crate::delta::Transformer::<'a, N>::interval_untouched(p0, p1);
+<delta::Transformer<'a, N>>::interval_untouched(p0, p1);
-----------------
rope/src/delta.rs delta::Builder::<N>::new
deps:{"delta::Builder::<N>::new":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Builder::<N>::new":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["rope::LinesMetric","rope::BaseMetric","engine::Contents","engine::Error","breaks::BreaksMetric","engine::DeltaOp","spans::SpansLeaf","delta::Delta","multiset::ZipSegment","engine::FullPriority","tree::NodeVal","multiset::Subset","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","engine::RevId","tree::Node","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","find::CaseMatching","breaks::BreaksBaseMetric","delta::DeltaElement","multiset::CountMatcher","diff::DiffOp","diff::DiffBuilder","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","spans::Span","interval::Interval","breaks::BreaksInfo","spans::SpansInfo"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","interval::Interval","rope::LinesMetric","multiset::ZipSegment","find::CaseMatching","breaks::BreaksLeaf","spans::Span","breaks::BreaksInfo","spans::SpansLeaf","rope::BaseMetric","engine::Error","delta::InsertDelta","breaks::BreaksBaseMetric","tree::Node","tree::NodeVal","diff::DiffBuilder","multiset::Segment","engine::FullPriority","tree::NodeBody","multiset::CountMatcher","spans::SpansInfo","multiset::Subset","engine::DeltaOp","engine::RevId","rope::RopeInfo","breaks::BreaksMetric","delta::Delta","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::Contents"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","delta::InsertDelta","tree::Node","tree::NodeBody","rope::LinesMetric","breaks::BreaksInfo","rope::RopeInfo","find::CaseMatching","engine::RevId","multiset::Segment","engine::Error","tree::NodeVal","diff::DiffBuilder","multiset::CountMatcher","interval::Interval","spans::Span","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","breaks::BreaksMetric","multiset::Subset","delta::DeltaElement","diff::DiffOp","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","engine::Contents","engine::FullPriority","spans::SpansInfo","multiset::ZipSegment","delta::Delta","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = 0usize; // None+usize
+delta::Builder::<N>::new(p0);
+crate::delta::Builder::<N>::new(p0);
+<delta::Builder<N>>::new(p0);
-----------------
rope/src/delta.rs delta::Builder::<N>::delete
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Builder::<N>::delete":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Builder::<N>::delete":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"],"T":["std::ops::RangeFrom","std::ops::RangeFull","<T as interval::IntervalBounds>"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","delta::Delta","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","tree::Node","find::CaseMatching","breaks::BreaksMetric","diff::DiffBuilder","rope::RopeInfo","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","interval::Interval","delta::DeltaElement","tree::NodeVal","engine::DeltaOp","rope::BaseMetric","breaks::BreaksLeaf","tree::NodeBody","engine::Error","spans::Span","delta::InsertDelta","diff::DiffOp","engine::FullPriority","spans::SpansLeaf","multiset::Subset","multiset::Segment","rope::LinesMetric","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["diff::DiffOp","multiset::ZipSegment","engine::Error","tree::NodeBody","diff::DiffBuilder","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","interval::Interval","engine::Contents","multiset::Subset","engine::RevId","spans::SpansLeaf","multiset::CountMatcher","engine::FullPriority","rope::RopeInfo","breaks::BreaksMetric","multiset::Segment","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::Span","breaks::BreaksBaseMetric","spans::SpansInfo","delta::Delta","delta::DeltaElement","delta::InsertDelta","rope::LinesMetric","find::CaseMatching","breaks::BreaksInfo","engine::DeltaOp","tree::Node"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","delta::InsertDelta","rope::LinesMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksMetric","breaks::BreaksBaseMetric","tree::Node","rope::RopeInfo","tree::NodeVal","spans::SpansLeaf","multiset::Segment","multiset::Subset","breaks::BreaksLeaf","diff::DiffOp","engine::FullPriority","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansInfo","diff::DiffBuilder","interval::Interval","breaks::BreaksInfo","delta::Delta","tree::NodeBody","engine::DeltaOp","delta::DeltaElement","engine::Error","spans::Span"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Builder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.delete(p1);
+delta::Builder::<N>::delete(p0, p1);
+crate::delta::Builder::<N>::delete(p0, p1);
+<delta::Builder<N>>::delete(p0, p1);
-----------------
rope/src/delta.rs delta::Builder::<N>::replace
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Builder::<N>::replace":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Builder::<N>::replace":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"T":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","tree::NodeBody","delta::DeltaElement","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","engine::FullPriority","engine::Error","multiset::Segment","diff::DiffBuilder","find::CaseMatching","multiset::CountMatcher","spans::SpansLeaf","engine::RevId","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::Subset","breaks::BreaksInfo","engine::Contents","tree::Node","diff::DiffOp","spans::Span","rope::BaseMetric","rope::LinesMetric","spans::SpansInfo","rope::RopeInfo","interval::Interval","engine::DeltaOp","multiset::ZipSegment","breaks::BreaksMetric","tree::NodeVal"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::Error","multiset::CountMatcher","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","engine::DeltaOp","interval::Interval","rope::RopeInfo","delta::Delta","delta::DeltaElement","engine::RevId","spans::SpansInfo","spans::Span","breaks::BreaksMetric","diff::DiffOp","breaks::BreaksInfo","multiset::Subset","multiset::ZipSegment","delta::InsertDelta","find::CaseMatching","tree::Node","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::Contents","rope::BaseMetric","breaks::BreaksLeaf","diff::DiffBuilder","rope::LinesMetric","tree::NodeBody"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","engine::DeltaOp","rope::BaseMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","find::CaseMatching","spans::SpansInfo","delta::DeltaElement","rope::RopeInfo","multiset::CountMatcher","interval::Interval","tree::NodeBody","tree::Node","breaks::BreaksInfo","multiset::Subset","spans::Span","spans::SpansLeaf","tree::NodeVal","engine::FullPriority","engine::RevId","engine::Error","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","breaks::BreaksMetric","rope::LinesMetric","multiset::Segment","engine::Contents","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Builder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.replace(p1, p2);
+delta::Builder::<N>::replace(p0, p1, p2);
+crate::delta::Builder::<N>::replace(p0, p1, p2);
+<delta::Builder<N>>::replace(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Builder::<N>::is_empty
deps:{"delta::Builder::<N>::is_empty":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Builder::<N>::is_empty":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffBuilder","spans::SpansLeaf","delta::Delta","delta::InsertDelta","breaks::BreaksInfo","engine::Error","delta::DeltaElement","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","rope::RopeInfo","spans::SpansInfo","multiset::Segment","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","rope::LinesMetric","tree::NodeBody","engine::DeltaOp","find::CaseMatching","multiset::CountMatcher","engine::RevId","breaks::BreaksBaseMetric","spans::Span","tree::NodeVal","multiset::ZipSegment","diff::DiffOp","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","tree::Node","breaks::BreaksMetric","engine::FullPriority"]},"spans::SpansInfo":{"T":["delta::InsertDelta","engine::DeltaOp","tree::NodeVal","engine::FullPriority","multiset::CountMatcher","breaks::BreaksMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","engine::RevId","delta::DeltaElement","breaks::BreaksInfo","multiset::Segment","tree::NodeBody","spans::Span","delta::Delta","tree::Node","interval::Interval","multiset::ZipSegment","diff::DiffOp","rope::RopeInfo","rope::LinesMetric","multiset::Subset","breaks::BreaksBaseMetric","find::CaseMatching","engine::Error","breaks::BreaksLeaf","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","rope::BaseMetric","engine::Contents"]},"spans::SpansLeaf":{"T":["delta::Delta","rope::RopeInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","spans::SpansLeaf","tree::NodeVal","multiset::ZipSegment","find::CaseMatching","interval::Interval","breaks::BreaksBaseMetric","spans::Span","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","engine::Contents","spans::SpansInfo","diff::DiffOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","tree::NodeBody","engine::RevId","breaks::BreaksMetric","tree::Node","engine::Error","rope::BaseMetric","engine::DeltaOp","engine::FullPriority","diff::DiffBuilder","delta::DeltaElement","multiset::CountMatcher","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Builder<N>
+p0.is_empty();
+delta::Builder::<N>::is_empty(p0);
+crate::delta::Builder::<N>::is_empty(p0);
+<delta::Builder<N>>::is_empty(p0);
-----------------
rope/src/delta.rs delta::Builder::<N>::build
deps:{"delta::Builder::<N>::build":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Builder::<N>::build":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["find::CaseMatching","tree::NodeBody","engine::Error","multiset::Subset","multiset::ZipSegment","rope::LinesMetric","tree::NodeVal","delta::Delta","engine::RevId","spans::SpansInfo","breaks::BreaksLeaf","breaks::BreaksMetric","engine::DeltaOp","diff::DiffBuilder","interval::Interval","engine::FullPriority","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","delta::DeltaElement","diff::DiffOp","delta::InsertDelta","rope::BaseMetric","engine::Contents","multiset::CountMatcher","breaks::BreaksInfo","spans::SpansLeaf","tree::Node","rope::RopeInfo","multiset::Segment"]},"spans::SpansInfo":{"T":["engine::RevId","engine::FullPriority","breaks::BreaksBaseMetric","delta::Delta","rope::RopeInfo","interval::Interval","engine::DeltaOp","rope::LinesMetric","multiset::Subset","breaks::BreaksInfo","multiset::Segment","multiset::ZipSegment","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","tree::NodeVal","spans::SpansLeaf","tree::NodeBody","find::CaseMatching","diff::DiffOp","spans::SpansInfo","multiset::CountMatcher","spans::Span","rope::Utf16CodeUnitsMetric","engine::Contents","delta::InsertDelta","diff::DiffBuilder","breaks::BreaksLeaf","engine::Error","rope::BaseMetric","tree::Node"]},"spans::SpansLeaf":{"T":["multiset::Subset","engine::FullPriority","find::CaseMatching","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","rope::RopeInfo","rope::LinesMetric","tree::NodeBody","diff::DiffOp","tree::Node","rope::BaseMetric","interval::Interval","multiset::Segment","spans::SpansLeaf","engine::RevId","multiset::CountMatcher","delta::DeltaElement","spans::Span","breaks::BreaksMetric","diff::DiffBuilder","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","delta::InsertDelta","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","engine::Contents","breaks::BreaksLeaf","engine::DeltaOp","spans::SpansInfo","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // delta::Builder<N>
+p0.build();
+delta::Builder::<N>::build(p0);
+crate::delta::Builder::<N>::build(p0);
+<delta::Builder<N>>::build(p0);
-----------------
rope/src/delta.rs <delta::DeltaRegion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::DeltaRegion as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::DeltaRegion as std::fmt::Debug>::fmt(p0, p1);
+<delta::DeltaRegion>::fmt(p0, p1);
-----------------
rope/src/delta.rs <delta::DeltaRegion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
let mut p1 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
+p0.eq(p1);
+<delta::DeltaRegion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<delta::DeltaRegion as std::cmp::PartialEq>::eq(p0, p1);
+<delta::DeltaRegion>::eq(p0, p1);
-----------------
rope/src/delta.rs delta::DeltaRegion::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+delta::DeltaRegion::new(p0, p1, p2);
+crate::delta::DeltaRegion::new(p0, p1, p2);
+<delta::DeltaRegion>::new(p0, p1, p2);
-----------------
rope/src/delta.rs <delta::InsertsIter<'a, N> as std::iter::Iterator>::next
'a
deps:{"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::BaseMetric","spans::SpansLeaf","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::SpansInfo","rope::RopeInfo","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","multiset::Subset","multiset::ZipSegment","engine::Contents","tree::Node","engine::FullPriority","delta::Delta","breaks::BreaksInfo","diff::DiffBuilder","multiset::CountMatcher","engine::DeltaOp","breaks::BreaksMetric","engine::RevId","delta::InsertDelta","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","tree::NodeBody","diff::DiffOp","find::CaseMatching","delta::DeltaElement","interval::Interval","tree::NodeVal","rope::LinesMetric"]},"spans::SpansInfo":{"T":["interval::Interval","spans::SpansLeaf","find::CaseMatching","spans::Span","engine::DeltaOp","tree::NodeBody","engine::Error","tree::NodeVal","rope::RopeInfo","diff::DiffOp","engine::FullPriority","breaks::BreaksMetric","multiset::CountMatcher","rope::LinesMetric","multiset::Subset","rope::BaseMetric","engine::RevId","breaks::BreaksInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","delta::DeltaElement","breaks::BreaksBaseMetric","delta::Delta","delta::InsertDelta","multiset::Segment","multiset::ZipSegment","tree::Node","engine::Contents"]},"spans::SpansLeaf":{"T":["multiset::Subset","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","interval::Interval","diff::DiffBuilder","engine::DeltaOp","spans::Span","spans::SpansInfo","rope::BaseMetric","multiset::ZipSegment","rope::RopeInfo","delta::InsertDelta","engine::Contents","rope::LinesMetric","tree::NodeBody","multiset::Segment","engine::RevId","multiset::CountMatcher","breaks::BreaksLeaf","breaks::BreaksMetric","find::CaseMatching","tree::NodeVal","engine::FullPriority","breaks::BreaksInfo","delta::Delta","spans::SpansLeaf","delta::DeltaElement","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::InsertsIter<'a, N>
+p0.next();
+<delta::InsertsIter<'a, N> as std::iter::Iterator>::next(p0);
+crate::<delta::InsertsIter<'a, N> as std::iter::Iterator>::next(p0);
+<delta::InsertsIter<'a, N>>::next(p0);
-----------------
rope/src/delta.rs <delta::DeletionsIter<'a, N> as std::iter::Iterator>::next
'a
deps:{"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::RopeInfo","tree::NodeBody","tree::NodeVal","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","delta::InsertDelta","find::CaseMatching","engine::DeltaOp","spans::SpansLeaf","breaks::BreaksInfo","multiset::CountMatcher","delta::DeltaElement","multiset::ZipSegment","delta::Delta","interval::Interval","engine::RevId","diff::DiffBuilder","spans::Span","rope::Utf16CodeUnitsMetric","multiset::Subset","diff::DiffOp","multiset::Segment","spans::SpansInfo","engine::FullPriority","engine::Contents","breaks::BreaksLeaf","tree::Node","rope::BaseMetric"]},"spans::SpansInfo":{"T":["diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksBaseMetric","multiset::CountMatcher","tree::Node","delta::InsertDelta","rope::RopeInfo","engine::RevId","engine::Contents","multiset::Subset","delta::Delta","tree::NodeVal","breaks::BreaksLeaf","diff::DiffOp","delta::DeltaElement","spans::SpansInfo","find::CaseMatching","engine::Error","multiset::ZipSegment","interval::Interval","spans::Span","engine::FullPriority","multiset::Segment","rope::BaseMetric","tree::NodeBody","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","diff::DiffOp","delta::DeltaElement","engine::Error","delta::Delta","tree::NodeVal","delta::InsertDelta","multiset::Subset","engine::Contents","spans::SpansLeaf","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","tree::Node","multiset::Segment","rope::LinesMetric","breaks::BreaksLeaf","breaks::BreaksBaseMetric","rope::BaseMetric","tree::NodeBody","engine::DeltaOp","spans::SpansInfo","find::CaseMatching","breaks::BreaksMetric","engine::RevId","engine::FullPriority","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::DeletionsIter<'a, N>
+p0.next();
+<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next(p0);
+crate::<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next(p0);
+<delta::DeletionsIter<'a, N>>::next(p0);
-----------------
rope/src/diff.rs <diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta(p0, p1);
+crate::<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta(p0, p1);
+<diff::LineHashDiff>::compute_delta(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<diff::DiffOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<diff::DiffOp as std::fmt::Debug>::fmt(p0, p1);
+<diff::DiffOp>::fmt(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffOp
+p0.clone();
+<diff::DiffOp as std::clone::Clone>::clone(p0);
+crate::<diff::DiffOp as std::clone::Clone>::clone(p0);
+<diff::DiffOp>::clone(p0);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<diff::DiffBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<diff::DiffBuilder as std::fmt::Debug>::fmt(p0, p1);
+<diff::DiffBuilder>::fmt(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
+p0.clone();
+<diff::DiffBuilder as std::clone::Clone>::clone(p0);
+crate::<diff::DiffBuilder as std::clone::Clone>::clone(p0);
+<diff::DiffBuilder>::clone(p0);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<diff::DiffBuilder as std::default::Default>::default();
+crate::<diff::DiffBuilder as std::default::Default>::default();
+<diff::DiffBuilder>::default();
-----------------
rope/src/diff.rs diff::DiffBuilder::copy
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+p0.copy(p1, p2, p3);
+diff::DiffBuilder::copy(p0, p1, p2, p3);
+crate::diff::DiffBuilder::copy(p0, p1, p2, p3);
+<diff::DiffBuilder>::copy(p0, p1, p2, p3);
-----------------
rope/src/diff.rs diff::DiffBuilder::to_delta
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+p0.to_delta(p1, p2);
+diff::DiffBuilder::to_delta(p0, p1, p2);
+crate::diff::DiffBuilder::to_delta(p0, p1, p2);
+<diff::DiffBuilder>::to_delta(p0, p1, p2);
-----------------
rope/src/engine.rs engine::_IMPL_SERIALIZE_FOR_Engine::<impl serde::Serialize for engine::Engine>::serialize
deps:{"engine::_IMPL_SERIALIZE_FOR_Engine::<impl serde::Serialize for engine::Engine>::serialize":{"__S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"engine::_IMPL_SERIALIZE_FOR_Engine::<impl serde::Serialize for engine::Engine>::serialize":{"__S":["serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::TaggedSerializer<S>","serde::private::ser::content::ContentSerializer<E>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+engine::_IMPL_SERIALIZE_FOR_Engine::<impl serde::Serialize for engine::Engine>::serialize(p0, p1);
+crate::engine::_IMPL_SERIALIZE_FOR_Engine::<impl serde::Serialize for engine::Engine>::serialize(p0, p1);
+<engine::Engine>::serialize(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize
'de
deps:{"engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize":{"__D":["serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::U16Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::StringDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::F32Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::I32Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::MapAccessDeserializer<A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize(p0);
+crate::engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize(p0);
+<engine::Engine>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::I16Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::F32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::F64Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::CharDeserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::U8Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::I128Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["std::marker::Sized","serde::de::SeqAccess"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::private::de::FlatStructAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::FlatMapAccess<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Engine::<impl serde::Deserialize<'de> for engine::Engine>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/engine.rs <engine::Engine as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Engine as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Engine as std::fmt::Debug>::fmt(p0, p1);
+<engine::Engine>::fmt(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_SERIALIZE_FOR_RevId::<impl serde::Serialize for engine::RevId>::serialize
deps:{"engine::_IMPL_SERIALIZE_FOR_RevId::<impl serde::Serialize for engine::RevId>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"engine::_IMPL_SERIALIZE_FOR_RevId::<impl serde::Serialize for engine::RevId>::serialize":{"__S":["serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::TaggedSerializer<S>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+engine::_IMPL_SERIALIZE_FOR_RevId::<impl serde::Serialize for engine::RevId>::serialize(p0, p1);
+crate::engine::_IMPL_SERIALIZE_FOR_RevId::<impl serde::Serialize for engine::RevId>::serialize(p0, p1);
+<engine::RevId>::serialize(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize
'de
deps:{"engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize":{"__D":["serde::de::value::CharDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::StrDeserializer<'a, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I128Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::U128Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U8Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::F32Deserializer<E>","serde::de::value::StrDeserializer<'a, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize(p0);
+crate::engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize(p0);
+<engine::RevId>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::U128Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::CharDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::F64Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U64Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::StringDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::I32Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::I16Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::UsizeDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::PairVisitor<A, B, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::FlatStructAccess<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_RevId::<impl serde::Deserialize<'de> for engine::RevId>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::RevId as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::RevId as std::fmt::Debug>::fmt(p0, p1);
+<engine::RevId>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.clone();
+<engine::RevId as std::clone::Clone>::clone(p0);
+crate::<engine::RevId as std::clone::Clone>::clone(p0);
+<engine::RevId>::clone(p0);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.partial_cmp(p1);
+<engine::RevId as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<engine::RevId as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<engine::RevId>::partial_cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.cmp(p1);
+<engine::RevId as std::cmp::Ord>::cmp(p0, p1);
+crate::<engine::RevId as std::cmp::Ord>::cmp(p0, p1);
+<engine::RevId>::cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.eq(p1);
+<engine::RevId as std::cmp::PartialEq>::eq(p0, p1);
+crate::<engine::RevId as std::cmp::PartialEq>::eq(p0, p1);
+<engine::RevId>::eq(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.assert_receiver_is_total_eq();
+<engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<engine::RevId>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/engine.rs <engine::RevId as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<engine::RevId as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<engine::RevId as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<engine::RevId as std::hash::Hash>::hash(p0, p1);
+crate::<engine::RevId as std::hash::Hash>::hash(p0, p1);
+<engine::RevId>::hash(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_SERIALIZE_FOR_Revision::<impl serde::Serialize for engine::Revision>::serialize
deps:{"engine::_IMPL_SERIALIZE_FOR_Revision::<impl serde::Serialize for engine::Revision>::serialize":{"__S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"engine::_IMPL_SERIALIZE_FOR_Revision::<impl serde::Serialize for engine::Revision>::serialize":{"__S":["serde::private::ser::TaggedSerializer<S>","serde::private::ser::content::ContentSerializer<E>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Revision
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+engine::_IMPL_SERIALIZE_FOR_Revision::<impl serde::Serialize for engine::Revision>::serialize(p0, p1);
+crate::engine::_IMPL_SERIALIZE_FOR_Revision::<impl serde::Serialize for engine::Revision>::serialize(p0, p1);
+<engine::Revision>::serialize(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize
'de
deps:{"engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize":{"__D":["serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I64Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::StringDeserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::I16Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::I8Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::F32Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::BorrowedStrDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize(p0);
+crate::engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize(p0);
+<engine::Revision>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::SeqDeserializer<I, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::F32Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::I8Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I16Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::I32Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::BoolDeserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::U64Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U128Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::PairVisitor<A, B, E>","serde::de::value::SeqDeserializer<I, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::MapAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::FlatStructAccess<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Revision::<impl serde::Deserialize<'de> for engine::Revision>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/engine.rs <engine::Revision as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Revision
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Revision as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Revision as std::fmt::Debug>::fmt(p0, p1);
+<engine::Revision>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
+p0.clone();
+<engine::Error as std::clone::Clone>::clone(p0);
+crate::<engine::Error as std::clone::Clone>::clone(p0);
+<engine::Error>::clone(p0);
-----------------
rope/src/engine.rs <engine::FullPriority as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.clone();
+<engine::FullPriority as std::clone::Clone>::clone(p0);
+crate::<engine::FullPriority as std::clone::Clone>::clone(p0);
+<engine::FullPriority>::clone(p0);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.partial_cmp(p1);
+<engine::FullPriority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<engine::FullPriority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<engine::FullPriority>::partial_cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.cmp(p1);
+<engine::FullPriority as std::cmp::Ord>::cmp(p0, p1);
+crate::<engine::FullPriority as std::cmp::Ord>::cmp(p0, p1);
+<engine::FullPriority>::cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.eq(p1);
+<engine::FullPriority as std::cmp::PartialEq>::eq(p0, p1);
+crate::<engine::FullPriority as std::cmp::PartialEq>::eq(p0, p1);
+<engine::FullPriority>::eq(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.assert_receiver_is_total_eq();
+<engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<engine::FullPriority>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/engine.rs engine::_IMPL_SERIALIZE_FOR_Contents::<impl serde::Serialize for engine::Contents>::serialize
deps:{"engine::_IMPL_SERIALIZE_FOR_Contents::<impl serde::Serialize for engine::Contents>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"engine::_IMPL_SERIALIZE_FOR_Contents::<impl serde::Serialize for engine::Contents>::serialize":{"__S":["serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::TaggedSerializer<S>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Contents
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+engine::_IMPL_SERIALIZE_FOR_Contents::<impl serde::Serialize for engine::Contents>::serialize(p0, p1);
+crate::engine::_IMPL_SERIALIZE_FOR_Contents::<impl serde::Serialize for engine::Contents>::serialize(p0, p1);
+<engine::Contents>::serialize(p0, p1);
-----------------
rope/src/engine.rs engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize
'de
deps:{"engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize":{"__D":["serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::I8Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::U128Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::BoolDeserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::CharDeserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::I16Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::UsizeDeserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I64Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize(p0);
+crate::engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize(p0);
+<engine::Contents>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::UsizeDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::F32Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::I64Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::I128Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::U8Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::U16Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::I32Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::BoolDeserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::U128Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::CharDeserializer<E>","serde::de::value::F64Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum
'de
deps:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":{"__A":["std::marker::Sized","serde::de::EnumAccess"]}}
candidates:{"<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":{"__A":["serde::de::value::MapAccessDeserializer<A>","serde::de::value::StringDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::EnumDeserializer<'de, E>","serde::private::de::content::EnumRefDeserializer<'a, 'de, E>","serde::de::value::StrDeserializer<'a, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_enum(p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum(p0, p1);
+crate::<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum(p0, p1);
+<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de>>::visit_enum(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::UnitDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U64Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::CharDeserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::F32Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U8Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I16Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::PairVisitor<A, B, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["<&'a mut A as serde::de::MapAccess<'de>>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::FlatStructAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::U16Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::F64Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U64Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::I32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Field>::deserialize(p0);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["<&'a mut A as serde::de::SeqAccess<'de>>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::MapDeserializer<'de, I, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/engine.rs <<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::FlatStructAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<engine::_IMPL_DESERIALIZE_FOR_Contents::<impl serde::Deserialize<'de> for engine::Contents>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/engine.rs <engine::Contents as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Contents
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Contents as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Contents as std::fmt::Debug>::fmt(p0, p1);
+<engine::Contents>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Contents as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Contents
+p0.clone();
+<engine::Contents as std::clone::Clone>::clone(p0);
+crate::<engine::Contents as std::clone::Clone>::clone(p0);
+<engine::Contents>::clone(p0);
-----------------
rope/src/engine.rs engine::RevId::token
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.token();
+engine::RevId::token(p0);
+crate::engine::RevId::token(p0);
+<engine::RevId>::token(p0);
-----------------
rope/src/engine.rs engine::RevId::session_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.session_id();
+engine::RevId::session_id(p0);
+crate::engine::RevId::session_id(p0);
+<engine::RevId>::session_id(p0);
-----------------
rope/src/engine.rs engine::Engine::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+engine::Engine::new(p0);
+crate::engine::Engine::new(p0);
+<engine::Engine>::new(p0);
-----------------
rope/src/engine.rs engine::Engine::empty
deps:{}
candidates:{}
+engine::Engine::empty();
+crate::engine::Engine::empty();
+<engine::Engine>::empty();
-----------------
rope/src/engine.rs engine::Engine::next_rev_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.next_rev_id();
+engine::Engine::next_rev_id(p0);
+crate::engine::Engine::next_rev_id(p0);
+<engine::Engine>::next_rev_id(p0);
-----------------
rope/src/engine.rs engine::Engine::find_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.find_rev(p1);
+engine::Engine::find_rev(p0, p1);
+crate::engine::Engine::find_rev(p0, p1);
+<engine::Engine>::find_rev(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::find_rev_token
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.find_rev_token(p1);
+engine::Engine::find_rev_token(p0, p1);
+crate::engine::Engine::find_rev_token(p0, p1);
+<engine::Engine>::find_rev_token(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_union_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.deletes_from_union_for_index(p1);
+engine::Engine::deletes_from_union_for_index(p0, p1);
+crate::engine::Engine::deletes_from_union_for_index(p0, p1);
+<engine::Engine>::deletes_from_union_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_union_before_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = true; // None+bool
+p0.deletes_from_union_before_index(p1, p2);
+engine::Engine::deletes_from_union_before_index(p0, p1, p2);
+crate::engine::Engine::deletes_from_union_before_index(p0, p1, p2);
+<engine::Engine>::deletes_from_union_before_index(p0, p1, p2);
-----------------
rope/src/engine.rs engine::Engine::rev_content_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.rev_content_for_index(p1);
+engine::Engine::rev_content_for_index(p0, p1);
+crate::engine::Engine::rev_content_for_index(p0, p1);
+<engine::Engine>::rev_content_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_cur_union_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.deletes_from_cur_union_for_index(p1);
+engine::Engine::deletes_from_cur_union_for_index(p0, p1);
+crate::engine::Engine::deletes_from_cur_union_for_index(p0, p1);
+<engine::Engine>::deletes_from_cur_union_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::max_undo_group_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.max_undo_group_id();
+engine::Engine::max_undo_group_id(p0);
+crate::engine::Engine::max_undo_group_id(p0);
+<engine::Engine>::max_undo_group_id(p0);
-----------------
rope/src/engine.rs engine::Engine::get_head_rev_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.get_head_rev_id();
+engine::Engine::get_head_rev_id(p0);
+crate::engine::Engine::get_head_rev_id(p0);
+<engine::Engine>::get_head_rev_id(p0);
-----------------
rope/src/engine.rs engine::Engine::get_head
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.get_head();
+engine::Engine::get_head(p0);
+crate::engine::Engine::get_head(p0);
+<engine::Engine>::get_head(p0);
-----------------
rope/src/engine.rs engine::Engine::get_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.get_rev(p1);
+engine::Engine::get_rev(p0, p1);
+crate::engine::Engine::get_rev(p0, p1);
+<engine::Engine>::get_rev(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::try_delta_rev_head
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.try_delta_rev_head(p1);
+engine::Engine::try_delta_rev_head(p0, p1);
+crate::engine::Engine::try_delta_rev_head(p0, p1);
+<engine::Engine>::try_delta_rev_head(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::mk_new_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.mk_new_rev(p1, p2, p3, p4);
+engine::Engine::mk_new_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::mk_new_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::mk_new_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::edit_rev
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.edit_rev(p1, p2, p3, p4);
+engine::Engine::edit_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::edit_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::edit_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::try_edit_rev
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.try_edit_rev(p1, p2, p3, p4);
+engine::Engine::try_edit_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::try_edit_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::try_edit_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::empty_subset_before_first_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.empty_subset_before_first_rev();
+engine::Engine::empty_subset_before_first_rev(p0);
+crate::engine::Engine::empty_subset_before_first_rev(p0);
+<engine::Engine>::empty_subset_before_first_rev(p0);
-----------------
rope/src/engine.rs engine::Engine::find_first_undo_candidate_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.find_first_undo_candidate_index(p1);
+engine::Engine::find_first_undo_candidate_index(p0, p1);
+crate::engine::Engine::find_first_undo_candidate_index(p0, p1);
+<engine::Engine>::find_first_undo_candidate_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::compute_undo
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.compute_undo(p1);
+engine::Engine::compute_undo(p0, p1);
+crate::engine::Engine::compute_undo(p0, p1);
+<engine::Engine>::compute_undo(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::undo
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.undo(p1);
+engine::Engine::undo(p0, p1);
+crate::engine::Engine::undo(p0, p1);
+<engine::Engine>::undo(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::is_equivalent_revision
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p2 = MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.is_equivalent_revision(p1, p2);
+engine::Engine::is_equivalent_revision(p0, p1, p2);
+crate::engine::Engine::is_equivalent_revision(p0, p1, p2);
+<engine::Engine>::is_equivalent_revision(p0, p1, p2);
-----------------
rope/src/engine.rs engine::Engine::gc
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.gc(p1);
+engine::Engine::gc(p0, p1);
+crate::engine::Engine::gc(p0, p1);
+<engine::Engine>::gc(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::merge
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.merge(p1);
+engine::Engine::merge(p0, p1);
+crate::engine::Engine::merge(p0, p1);
+<engine::Engine>::merge(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::set_session_id
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // (u64, u32)
+p0.set_session_id(p1);
+engine::Engine::set_session_id(p0, p1);
+crate::engine::Engine::set_session_id(p0, p1);
+<engine::Engine>::set_session_id(p0, p1);
-----------------
rope/src/engine.rs <engine::DeltaOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::DeltaOp
+p0.clone();
+<engine::DeltaOp as std::clone::Clone>::clone(p0);
+crate::<engine::DeltaOp as std::clone::Clone>::clone(p0);
+<engine::DeltaOp>::clone(p0);
-----------------
rope/src/engine.rs <engine::DeltaOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::DeltaOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::DeltaOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::DeltaOp as std::fmt::Debug>::fmt(p0, p1);
+<engine::DeltaOp>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<engine::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<engine::Error as std::fmt::Display>::fmt(p0, p1);
+<engine::Error>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Error as std::fmt::Debug>::fmt(p0, p1);
+<engine::Error>::fmt(p0, p1);
-----------------
rope/src/find.rs <find::CaseMatching as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
+p0.clone();
+<find::CaseMatching as std::clone::Clone>::clone(p0);
+crate::<find::CaseMatching as std::clone::Clone>::clone(p0);
+<find::CaseMatching>::clone(p0);
-----------------
rope/src/find.rs <find::CaseMatching as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p1 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
+p0.eq(p1);
+<find::CaseMatching as std::cmp::PartialEq>::eq(p0, p1);
+crate::<find::CaseMatching as std::cmp::PartialEq>::eq(p0, p1);
+<find::CaseMatching>::eq(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.clone();
+<interval::Interval as std::clone::Clone>::clone(p0);
+crate::<interval::Interval as std::clone::Clone>::clone(p0);
+<interval::Interval>::clone(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.eq(p1);
+<interval::Interval as std::cmp::PartialEq>::eq(p0, p1);
+crate::<interval::Interval as std::cmp::PartialEq>::eq(p0, p1);
+<interval::Interval>::eq(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.assert_receiver_is_total_eq();
+<interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<interval::Interval>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/interval.rs interval::Interval::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new(p0, p1);
+crate::interval::Interval::new(p0, p1);
+<interval::Interval>::new(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_closed_open
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_closed_open(p0, p1);
+crate::interval::Interval::new_closed_open(p0, p1);
+<interval::Interval>::new_closed_open(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_open_closed
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_open_closed(p0, p1);
+crate::interval::Interval::new_open_closed(p0, p1);
+<interval::Interval>::new_open_closed(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_closed_closed
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_closed_closed(p0, p1);
+crate::interval::Interval::new_closed_closed(p0, p1);
+<interval::Interval>::new_closed_closed(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_open_open
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_open_open(p0, p1);
+crate::interval::Interval::new_open_open(p0, p1);
+<interval::Interval>::new_open_open(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.start();
+interval::Interval::start(p0);
+crate::interval::Interval::start(p0);
+<interval::Interval>::start(p0);
-----------------
rope/src/interval.rs interval::Interval::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.end();
+interval::Interval::end(p0);
+crate::interval::Interval::end(p0);
+<interval::Interval>::end(p0);
-----------------
rope/src/interval.rs interval::Interval::start_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.start_end();
+interval::Interval::start_end(p0);
+crate::interval::Interval::start_end(p0);
+<interval::Interval>::start_end(p0);
-----------------
rope/src/interval.rs interval::Interval::is_before
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.is_before(p1);
+interval::Interval::is_before(p0, p1);
+crate::interval::Interval::is_before(p0, p1);
+<interval::Interval>::is_before(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.contains(p1);
+interval::Interval::contains(p0, p1);
+crate::interval::Interval::contains(p0, p1);
+<interval::Interval>::contains(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::is_after
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.is_after(p1);
+interval::Interval::is_after(p0, p1);
+crate::interval::Interval::is_after(p0, p1);
+<interval::Interval>::is_after(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.is_empty();
+interval::Interval::is_empty(p0);
+crate::interval::Interval::is_empty(p0);
+<interval::Interval>::is_empty(p0);
-----------------
rope/src/interval.rs interval::Interval::intersect
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.intersect(p1);
+interval::Interval::intersect(p0, p1);
+crate::interval::Interval::intersect(p0, p1);
+<interval::Interval>::intersect(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.union(p1);
+interval::Interval::union(p0, p1);
+crate::interval::Interval::union(p0, p1);
+<interval::Interval>::union(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.prefix(p1);
+interval::Interval::prefix(p0, p1);
+crate::interval::Interval::prefix(p0, p1);
+<interval::Interval>::prefix(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.suffix(p1);
+interval::Interval::suffix(p0, p1);
+crate::interval::Interval::suffix(p0, p1);
+<interval::Interval>::suffix(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::translate
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.translate(p1);
+interval::Interval::translate(p0, p1);
+crate::interval::Interval::translate(p0, p1);
+<interval::Interval>::translate(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::translate_neg
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.translate_neg(p1);
+interval::Interval::translate_neg(p0, p1);
+crate::interval::Interval::translate_neg(p0, p1);
+<interval::Interval>::translate_neg(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.size();
+interval::Interval::size(p0);
+crate::interval::Interval::size(p0);
+<interval::Interval>::size(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<interval::Interval as std::fmt::Display>::fmt(p0, p1);
+crate::<interval::Interval as std::fmt::Display>::fmt(p0, p1);
+<interval::Interval>::fmt(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<interval::Interval as std::fmt::Debug>::fmt(p0, p1);
+crate::<interval::Interval as std::fmt::Debug>::fmt(p0, p1);
+<interval::Interval>::fmt(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::Range<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <T as interval::IntervalBounds>::into_interval
deps:{"<T as interval::IntervalBounds>::into_interval":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>::into_interval":{"T":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<T as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<T as interval::IntervalBounds>::into_interval(p0, p1);
+<T>::into_interval(p0, p1);
-----------------
rope/src/interval.rs <std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval(p0, p1);
+<std::ops::RangeFrom<usize>>::into_interval(p0, p1);
-----------------
rope/src/interval.rs <std::ops::RangeFull as interval::IntervalBounds>::into_interval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<std::ops::RangeFull as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<std::ops::RangeFull as interval::IntervalBounds>::into_interval(p0, p1);
+<std::ops::RangeFull>::into_interval(p0, p1);
-----------------
rope/src/multiset.rs multiset::_IMPL_SERIALIZE_FOR_Segment::<impl serde::Serialize for multiset::Segment>::serialize
deps:{"multiset::_IMPL_SERIALIZE_FOR_Segment::<impl serde::Serialize for multiset::Segment>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"multiset::_IMPL_SERIALIZE_FOR_Segment::<impl serde::Serialize for multiset::Segment>::serialize":{"__S":["serde::private::ser::content::ContentSerializer<E>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::TaggedSerializer<S>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+multiset::_IMPL_SERIALIZE_FOR_Segment::<impl serde::Serialize for multiset::Segment>::serialize(p0, p1);
+crate::multiset::_IMPL_SERIALIZE_FOR_Segment::<impl serde::Serialize for multiset::Segment>::serialize(p0, p1);
+<multiset::Segment>::serialize(p0, p1);
-----------------
rope/src/multiset.rs multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize
'de
deps:{"multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize":{"__D":["serde::de::value::CharDeserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::F64Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I16Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::private::de::StrDeserializer<'a, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::F32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::UsizeDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize(p0);
+crate::multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize(p0);
+<multiset::Segment>::deserialize(p0);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::U8Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::I64Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::I16Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::U128Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::I128Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::F64Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::StringDeserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I32Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::I8Deserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::UsizeDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::CharDeserializer<E>","serde::de::value::IsizeDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["std::marker::Sized","serde::de::SeqAccess"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::FlatStructAccess<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Segment::<impl serde::Deserialize<'de> for multiset::Segment>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Segment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.clone();
+<multiset::Segment as std::clone::Clone>::clone(p0);
+crate::<multiset::Segment as std::clone::Clone>::clone(p0);
+<multiset::Segment>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::Segment as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.eq(p1);
+<multiset::Segment as std::cmp::PartialEq>::eq(p0, p1);
+crate::<multiset::Segment as std::cmp::PartialEq>::eq(p0, p1);
+<multiset::Segment>::eq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.assert_receiver_is_total_eq();
+<multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<multiset::Segment>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/multiset.rs <multiset::Segment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::Segment as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::Segment as std::fmt::Debug>::fmt(p0, p1);
+<multiset::Segment>::fmt(p0, p1);
-----------------
rope/src/multiset.rs multiset::_IMPL_SERIALIZE_FOR_Subset::<impl serde::Serialize for multiset::Subset>::serialize
deps:{"multiset::_IMPL_SERIALIZE_FOR_Subset::<impl serde::Serialize for multiset::Subset>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"multiset::_IMPL_SERIALIZE_FOR_Subset::<impl serde::Serialize for multiset::Subset>::serialize":{"__S":["serde::private::ser::TaggedSerializer<S>","serde::private::ser::content::ContentSerializer<E>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+multiset::_IMPL_SERIALIZE_FOR_Subset::<impl serde::Serialize for multiset::Subset>::serialize(p0, p1);
+crate::multiset::_IMPL_SERIALIZE_FOR_Subset::<impl serde::Serialize for multiset::Subset>::serialize(p0, p1);
+<multiset::Subset>::serialize(p0, p1);
-----------------
rope/src/multiset.rs multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize
'de
deps:{"multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize":{"__D":["serde::de::value::F32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::IsizeDeserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U128Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::I8Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::CharDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize(p0);
+crate::multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize(p0);
+<multiset::Subset>::deserialize(p0);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::U32Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::I16Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::U128Deserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::StringDeserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::I64Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::CharDeserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["std::marker::Sized","serde::de::SeqAccess"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::de::MapAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::private::de::FlatStructAccess<'a, 'de, E>","serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::MapDeserializer<'de, E>","<&'a mut A as serde::de::MapAccess<'de>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<multiset::_IMPL_DESERIALIZE_FOR_Subset::<impl serde::Deserialize<'de> for multiset::Subset>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.clone();
+<multiset::Subset as std::clone::Clone>::clone(p0);
+crate::<multiset::Subset as std::clone::Clone>::clone(p0);
+<multiset::Subset>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::Subset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.eq(p1);
+<multiset::Subset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<multiset::Subset as std::cmp::PartialEq>::eq(p0, p1);
+<multiset::Subset>::eq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.assert_receiver_is_total_eq();
+<multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<multiset::Subset>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/multiset.rs <multiset::SubsetBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<multiset::SubsetBuilder as std::default::Default>::default();
+crate::<multiset::SubsetBuilder as std::default::Default>::default();
+<multiset::SubsetBuilder>::default();
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::new
deps:{}
candidates:{}
+multiset::SubsetBuilder::new();
+crate::multiset::SubsetBuilder::new();
+<multiset::SubsetBuilder>::new();
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::pad_to_len
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
+p0.pad_to_len(p1);
+multiset::SubsetBuilder::pad_to_len(p0, p1);
+crate::multiset::SubsetBuilder::pad_to_len(p0, p1);
+<multiset::SubsetBuilder>::pad_to_len(p0, p1);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::add_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+p0.add_range(p1, p2, p3);
+multiset::SubsetBuilder::add_range(p0, p1, p2, p3);
+crate::multiset::SubsetBuilder::add_range(p0, p1, p2, p3);
+<multiset::SubsetBuilder>::add_range(p0, p1, p2, p3);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::push_segment
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.push_segment(p1, p2);
+multiset::SubsetBuilder::push_segment(p0, p1, p2);
+crate::multiset::SubsetBuilder::push_segment(p0, p1, p2);
+<multiset::SubsetBuilder>::push_segment(p0, p1, p2);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
+p0.build();
+multiset::SubsetBuilder::build(p0);
+crate::multiset::SubsetBuilder::build(p0);
+<multiset::SubsetBuilder>::build(p0);
-----------------
rope/src/multiset.rs <multiset::CountMatcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.clone();
+<multiset::CountMatcher as std::clone::Clone>::clone(p0);
+crate::<multiset::CountMatcher as std::clone::Clone>::clone(p0);
+<multiset::CountMatcher>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::CountMatcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::CountMatcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::CountMatcher as std::fmt::Debug>::fmt(p0, p1);
+<multiset::CountMatcher>::fmt(p0, p1);
-----------------
rope/src/multiset.rs multiset::CountMatcher::matches
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.matches(p1);
+multiset::CountMatcher::matches(p0, p1);
+crate::multiset::CountMatcher::matches(p0, p1);
+<multiset::CountMatcher>::matches(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+multiset::Subset::new(p0);
+crate::multiset::Subset::new(p0);
+<multiset::Subset>::new(p0);
-----------------
rope/src/multiset.rs multiset::Subset::delete_from_string
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = "sample"; // None+&str
+p0.delete_from_string(&p1);
+multiset::Subset::delete_from_string(p0, &p1);
+crate::multiset::Subset::delete_from_string(p0, &p1);
+<multiset::Subset>::delete_from_string(p0, &p1);
-----------------
rope/src/multiset.rs multiset::Subset::delete_from
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"multiset::Subset::delete_from":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"multiset::Subset::delete_from":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::Segment","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","breaks::BreaksBaseMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","engine::Error","multiset::CountMatcher","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","rope::BaseMetric","engine::RevId","tree::NodeBody","delta::DeltaElement","interval::Interval","engine::DeltaOp","rope::RopeInfo","delta::InsertDelta","rope::LinesMetric","diff::DiffOp","multiset::ZipSegment","breaks::BreaksInfo","spans::SpansLeaf","tree::NodeVal","diff::DiffBuilder","delta::Delta","engine::Contents","breaks::BreaksMetric","find::CaseMatching"]},"spans::SpansInfo":{"T":["diff::DiffOp","delta::InsertDelta","tree::NodeBody","tree::NodeVal","breaks::BreaksInfo","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","engine::RevId","multiset::CountMatcher","breaks::BreaksBaseMetric","interval::Interval","rope::RopeInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::SpansInfo","multiset::Segment","diff::DiffBuilder","engine::Error","delta::Delta","multiset::Subset","delta::DeltaElement","engine::Contents","engine::FullPriority","find::CaseMatching","rope::BaseMetric","multiset::ZipSegment","engine::DeltaOp","rope::LinesMetric","spans::Span","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","multiset::ZipSegment","tree::NodeVal","spans::SpansLeaf","spans::SpansInfo","multiset::Subset","delta::DeltaElement","rope::RopeInfo","diff::DiffBuilder","tree::Node","engine::RevId","engine::Error","interval::Interval","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","engine::Contents","rope::BaseMetric","breaks::BreaksLeaf","rope::LinesMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::Segment","breaks::BreaksBaseMetric","tree::NodeBody","engine::FullPriority","delta::Delta","engine::DeltaOp","spans::Span","delta::InsertDelta","find::CaseMatching","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.delete_from(p1);
+multiset::Subset::delete_from(p0, p1);
+crate::multiset::Subset::delete_from(p0, p1);
+<multiset::Subset>::delete_from(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::len_after_delete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.len_after_delete();
+multiset::Subset::len_after_delete(p0);
+crate::multiset::Subset::len_after_delete(p0);
+<multiset::Subset>::len_after_delete(p0);
-----------------
rope/src/multiset.rs multiset::Subset::count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.count(p1);
+multiset::Subset::count(p0, p1);
+crate::multiset::Subset::count(p0, p1);
+<multiset::Subset>::count(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.len();
+multiset::Subset::len(p0);
+crate::multiset::Subset::len(p0);
+<multiset::Subset>::len(p0);
-----------------
rope/src/multiset.rs multiset::Subset::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.is_empty();
+multiset::Subset::is_empty(p0);
+crate::multiset::Subset::is_empty(p0);
+<multiset::Subset>::is_empty(p0);
-----------------
rope/src/multiset.rs multiset::Subset::union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.union(p1);
+multiset::Subset::union(p0, p1);
+crate::multiset::Subset::union(p0, p1);
+<multiset::Subset>::union(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::subtract
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.subtract(p1);
+multiset::Subset::subtract(p0, p1);
+crate::multiset::Subset::subtract(p0, p1);
+<multiset::Subset>::subtract(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::bitxor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.bitxor(p1);
+multiset::Subset::bitxor(p0, p1);
+crate::multiset::Subset::bitxor(p0, p1);
+<multiset::Subset>::bitxor(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = true; // None+bool
+p0.transform(p1, p2);
+multiset::Subset::transform(p0, p1, p2);
+crate::multiset::Subset::transform(p0, p1, p2);
+<multiset::Subset>::transform(p0, p1, p2);
-----------------
rope/src/multiset.rs multiset::Subset::transform_expand
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_expand(p1);
+multiset::Subset::transform_expand(p0, p1);
+crate::multiset::Subset::transform_expand(p0, p1);
+<multiset::Subset>::transform_expand(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform_union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_union(p1);
+multiset::Subset::transform_union(p0, p1);
+crate::multiset::Subset::transform_union(p0, p1);
+<multiset::Subset>::transform_union(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform_shrink
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_shrink(p1);
+multiset::Subset::transform_shrink(p0, p1);
+crate::multiset::Subset::transform_shrink(p0, p1);
+<multiset::Subset>::transform_shrink(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::range_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.range_iter(p1);
+multiset::Subset::range_iter(p0, p1);
+crate::multiset::Subset::range_iter(p0, p1);
+<multiset::Subset>::range_iter(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::complement_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.complement_iter();
+multiset::Subset::complement_iter(p0);
+crate::multiset::Subset::complement_iter(p0);
+<multiset::Subset>::complement_iter(p0);
-----------------
rope/src/multiset.rs multiset::Subset::zip
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.zip(p1);
+multiset::Subset::zip(p0, p1);
+crate::multiset::Subset::zip(p0, p1);
+<multiset::Subset>::zip(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::complement
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.complement();
+multiset::Subset::complement(p0);
+crate::multiset::Subset::complement(p0);
+<multiset::Subset>::complement(p0);
-----------------
rope/src/multiset.rs multiset::Subset::mapper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.mapper(p1);
+multiset::Subset::mapper(p0, p1);
+crate::multiset::Subset::mapper(p0, p1);
+<multiset::Subset>::mapper(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::Subset as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::Subset as std::fmt::Debug>::fmt(p0, p1);
+<multiset::Subset>::fmt(p0, p1);
-----------------
rope/src/multiset.rs <multiset::RangeIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::RangeIter<'a>
+p0.next();
+<multiset::RangeIter<'a> as std::iter::Iterator>::next(p0);
+crate::<multiset::RangeIter<'a> as std::iter::Iterator>::next(p0);
+<multiset::RangeIter<'a>>::next(p0);
-----------------
rope/src/multiset.rs <multiset::ZipSegment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::ZipSegment
+p0.clone();
+<multiset::ZipSegment as std::clone::Clone>::clone(p0);
+crate::<multiset::ZipSegment as std::clone::Clone>::clone(p0);
+<multiset::ZipSegment>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::ZipSegment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::ZipSegment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::ZipSegment as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::ZipSegment as std::fmt::Debug>::fmt(p0, p1);
+<multiset::ZipSegment>::fmt(p0, p1);
-----------------
rope/src/multiset.rs <multiset::ZipIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::ZipIter<'a>
+p0.next();
+<multiset::ZipIter<'a> as std::iter::Iterator>::next(p0);
+crate::<multiset::ZipIter<'a> as std::iter::Iterator>::next(p0);
+<multiset::ZipIter<'a>>::next(p0);
-----------------
rope/src/multiset.rs multiset::Mapper::<'a>::doc_index_to_subset
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::Mapper<'a>
let mut p1 = 0usize; // None+usize
+p0.doc_index_to_subset(p1);
+multiset::Mapper::<'a>::doc_index_to_subset(p0, p1);
+crate::multiset::Mapper::<'a>::doc_index_to_subset(p0, p1);
+<multiset::Mapper<'a>>::doc_index_to_subset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::len
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.len();
+rope::<impl tree::Leaf for std::string::String>::len(p0);
+crate::rope::<impl tree::Leaf for std::string::String>::len(p0);
+<std::string::String>::len(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::is_ok_child
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.is_ok_child();
+rope::<impl tree::Leaf for std::string::String>::is_ok_child(p0);
+crate::rope::<impl tree::Leaf for std::string::String>::is_ok_child(p0);
+<std::string::String>::is_ok_child(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::push_maybe_split
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = & std::string::String::new(); // None+std::string::String
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+rope::<impl tree::Leaf for std::string::String>::push_maybe_split(p0, p1, p2);
+crate::rope::<impl tree::Leaf for std::string::String>::push_maybe_split(p0, p1, p2);
+<std::string::String>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/rope.rs <rope::RopeInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
+p0.clone();
+<rope::RopeInfo as std::clone::Clone>::clone(p0);
+crate::<rope::RopeInfo as std::clone::Clone>::clone(p0);
+<rope::RopeInfo>::clone(p0);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::accumulate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
+p0.accumulate(p1);
+<rope::RopeInfo as tree::NodeInfo>::accumulate(p0, p1);
+crate::<rope::RopeInfo as tree::NodeInfo>::accumulate(p0, p1);
+<rope::RopeInfo>::accumulate(p0, p1);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::compute_info
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<rope::RopeInfo as tree::NodeInfo>::compute_info(p0);
+crate::<rope::RopeInfo as tree::NodeInfo>::compute_info(p0);
+<rope::RopeInfo>::compute_info(p0);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::identity
deps:{}
candidates:{}
+<rope::RopeInfo as tree::NodeInfo>::identity();
+crate::<rope::RopeInfo as tree::NodeInfo>::identity();
+<rope::RopeInfo>::identity();
-----------------
rope/src/rope.rs <rope::BaseMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::BaseMetric
+p0.clone();
+<rope::BaseMetric as std::clone::Clone>::clone(p0);
+crate::<rope::BaseMetric as std::clone::Clone>::clone(p0);
+<rope::BaseMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::BaseMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::BaseMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::BaseMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::BaseMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::BaseMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::BaseMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::BaseMetric>::can_fragment();
-----------------
rope/src/rope.rs <rope::LinesMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::LinesMetric
+p0.clone();
+<rope::LinesMetric as std::clone::Clone>::clone(p0);
+crate::<rope::LinesMetric as std::clone::Clone>::clone(p0);
+<rope::LinesMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::LinesMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::LinesMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::LinesMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::LinesMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::LinesMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::LinesMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::LinesMetric>::can_fragment();
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::Utf16CodeUnitsMetric
+p0.clone();
+<rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone(p0);
+crate::<rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone(p0);
+<rope::Utf16CodeUnitsMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::Utf16CodeUnitsMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::Utf16CodeUnitsMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::Utf16CodeUnitsMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::Utf16CodeUnitsMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::Utf16CodeUnitsMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::Utf16CodeUnitsMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::Utf16CodeUnitsMetric>::can_fragment();
-----------------
rope/src/rope.rs rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str(&p0);
+crate::rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str(&p0);
+<tree::Node<rope::RopeInfo>>::from_str(&p0);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::edit_str
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":{"T":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = "sample"; // None+&str
+p0.edit_str(p1, &p2);
+rope::<impl tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
+<tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::slice
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice":{"T":["interval::IntervalBounds","std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice":{"T":["std::ops::RangeFull","<T as interval::IntervalBounds>","std::ops::RangeFrom"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.slice(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::slice(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::slice(p0, p1);
+<tree::Node<rope::RopeInfo>>::slice(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.is_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.prev_codepoint_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.next_codepoint_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.at_or_next_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.at_or_prev_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.prev_grapheme_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.next_grapheme_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.line_of_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.offset_of_line(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
+<tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":{"T":["interval::IntervalBounds","std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":{"T":["std::ops::RangeFull","std::ops::RangeFrom","<T as interval::IntervalBounds>"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.iter_chunks(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
+<tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::lines_raw
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":{"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.lines_raw(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
+<tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::lines
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines":{"T":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.lines(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::lines(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::lines(p0, p1);
+<tree::Node<rope::RopeInfo>>::lines(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::byte_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.byte_at(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
+<tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":{"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.slice_to_cow(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
+<tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
-----------------
rope/src/rope.rs <rope::ChunkIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::ChunkIter<'a>
+p0.next();
+<rope::ChunkIter<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::ChunkIter<'a> as std::iter::Iterator>::next(p0);
+<rope::ChunkIter<'a>>::next(p0);
-----------------
rope/src/rope.rs rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<rope::RopeInfo>
let mut p1 = "sample"; // None+&str
+p0.push_str(&p1);
+rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
+crate::rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
+<tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":{"T":["std::convert::AsRef","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":{"T":["std::vec::IntoIter<T, A>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::slice::IterMut<'_, T>","std::ffi::CString","<&T as std::convert::AsRef<U>>","std::sync::Arc<T>","std::borrow::Cow<'_, T>","std::slice::Iter<'_, T>","std::ffi::CStr","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","std::vec::Drain<'a, T, A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from(p0);
+crate::rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from(p0);
+<tree::Node<rope::RopeInfo>>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+crate::rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+<std::string::String>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+crate::rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+<std::string::String>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+crate::rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+<tree::Node<rope::RopeInfo>>::fmt(p0, p1);
-----------------
rope/src/rope.rs rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+crate::rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+<tree::Node<rope::RopeInfo>>::fmt(p0, p1);
-----------------
rope/src/rope.rs rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+p0.add(p1);
+rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add(p0, p1);
+crate::rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add(p0, p1);
+<tree::Node<rope::RopeInfo>>::add(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.prev_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.next_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.peek_next_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.next_grapheme();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.prev_grapheme();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
-----------------
rope/src/rope.rs <rope::LinesRaw<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'a>
+p0.next();
+<rope::LinesRaw<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::LinesRaw<'a> as std::iter::Iterator>::next(p0);
+<rope::LinesRaw<'a>>::next(p0);
-----------------
rope/src/rope.rs <rope::Lines<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::Lines<'a>
+p0.next();
+<rope::Lines<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::Lines<'a> as std::iter::Iterator>::next(p0);
+<rope::Lines<'a>>::next(p0);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Serialize for tree::Node<rope::RopeInfo>>::serialize
deps:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for tree::Node<rope::RopeInfo>>::serialize":{"S":["serde::Serializer","std::marker::Sized"]}}
candidates:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for tree::Node<rope::RopeInfo>>::serialize":{"S":["serde::private::ser::TaggedSerializer<S>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::content::ContentSerializer<E>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+serde_impls::<impl serde::Serialize for tree::Node<rope::RopeInfo>>::serialize(p0, p1);
+crate::serde_impls::<impl serde::Serialize for tree::Node<rope::RopeInfo>>::serialize(p0, p1);
+<tree::Node<rope::RopeInfo>>::serialize(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for tree::Node<rope::RopeInfo>>::deserialize
'de
deps:{"serde_impls::<impl serde::Deserialize<'de> for tree::Node<rope::RopeInfo>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"serde_impls::<impl serde::Deserialize<'de> for tree::Node<rope::RopeInfo>>::deserialize":{"D":["serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U128Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::U8Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::F64Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::I16Deserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::UnitDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+serde_impls::<impl serde::Deserialize<'de> for tree::Node<rope::RopeInfo>>::deserialize(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for tree::Node<rope::RopeInfo>>::deserialize(p0);
+<tree::Node<rope::RopeInfo>>::deserialize(p0);
-----------------
rope/src/serde_impls.rs <serde_impls::RopeVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::RopeVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<serde_impls::RopeVisitor>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::RopeVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::RopeVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<serde_impls::RopeVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<serde_impls::RopeVisitor>::visit_str(p0, &p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Serialize for delta::DeltaElement<rope::RopeInfo>>::serialize
deps:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for delta::DeltaElement<rope::RopeInfo>>::serialize":{"S":["std::marker::Sized","serde::Serializer"]}}
candidates:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for delta::DeltaElement<rope::RopeInfo>>::serialize":{"S":["serde::private::ser::TaggedSerializer<S>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::content::ContentSerializer<E>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaElement<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+serde_impls::<impl serde::Serialize for delta::DeltaElement<rope::RopeInfo>>::serialize(p0, p1);
+crate::serde_impls::<impl serde::Serialize for delta::DeltaElement<rope::RopeInfo>>::serialize(p0, p1);
+<delta::DeltaElement<rope::RopeInfo>>::serialize(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Serialize for delta::Delta<rope::RopeInfo>>::serialize
deps:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for delta::Delta<rope::RopeInfo>>::serialize":{"S":["serde::Serializer","std::marker::Sized"]}}
candidates:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Serialize for delta::Delta<rope::RopeInfo>>::serialize":{"S":["serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::TaggedSerializer<S>","serde::private::ser::FlatMapSerializer<'a, M>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+serde_impls::<impl serde::Serialize for delta::Delta<rope::RopeInfo>>::serialize(p0, p1);
+crate::serde_impls::<impl serde::Serialize for delta::Delta<rope::RopeInfo>>::serialize(p0, p1);
+<delta::Delta<rope::RopeInfo>>::serialize(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize
'de
deps:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize":{"D":["serde::de::value::CharDeserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::U128Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::UnitDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::I8Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::I64Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::SeqDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize(p0);
+<delta::Delta<rope::RopeInfo>>::deserialize(p0);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDeltaElement_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize
deps:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDeltaElement_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]}}
candidates:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDeltaElement_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize":{"__S":["serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::private::ser::content::ContentSerializer<E>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::TaggedSerializer<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDeltaElement_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize(p0, p1);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDeltaElement_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::serialize(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize
'de
deps:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize":{"__D":["serde::de::value::UsizeDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::F32Deserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::CharDeserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::F64Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::U128Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::I128Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I64Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::U16Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize(p0);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize(p0);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::F32Deserializer<E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::I64Deserializer<E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::StringDeserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::private::de::content::ContentDeserializer<'de, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::U8Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::UnitDeserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U32Deserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":{"__A":["std::marker::Sized","serde::de::EnumAccess"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum":{"__A":["serde::de::value::StrDeserializer<'a, E>","serde::de::value::U32Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::StringDeserializer<E>","serde::private::de::content::EnumRefDeserializer<'a, 'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::content::EnumDeserializer<'de, E>","serde::de::value::MapAccessDeserializer<A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_enum(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de>>::visit_enum(p0, p1);
-----------------
rope/src/serde_impls.rs <<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["std::marker::Sized","serde::de::SeqAccess"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDeltaElement_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_enum::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDelta_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize
deps:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDelta_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize":{"__S":["std::marker::Sized","serde::Serializer"]}}
candidates:{"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDelta_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize":{"__S":["serde::private::ser::TaggedSerializer<S>","serde::private::ser::FlatMapSerializer<'a, M>","serde::private::ser::content::ContentSerializer<E>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_
let mut p1 = MaybeUninit::uninit().assume_init(); // __S
+p0.serialize(p1);
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDelta_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize(p0, p1);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_SERIALIZE_FOR_RopeDelta_::<impl serde::Serialize for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::serialize(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize
'de
deps:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize":{"__D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize":{"__D":["serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::PairDeserializer<A, B, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::U32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::U16Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::IsizeDeserializer<E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::U64Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::StringDeserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::I16Deserializer<E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::I8Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::CharDeserializer<E>","serde::private::de::BytesDeserializer<'a, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::ContentDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize(p0);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize(p0);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor>::visit_u64(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor>::visit_str(p0, &p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":{"__E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__FieldVisitor>::visit_bytes(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize
'de
deps:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":{"__D":["serde::de::value::I128Deserializer<E>","serde::private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::I16Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::de::value::I32Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::private::de::StrDeserializer<'a, E>","serde::de::value::F64Deserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::private::de::content::ContentDeserializer<'de, E>","serde::de::value::U16Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>","serde::private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::CharDeserializer<E>","serde::private::de::content::SeqDeserializer<'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::private::de::BytesDeserializer<'a, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::SeqDeserializer<I, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // __D
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field as serde::Deserialize<'de>>::deserialize(p0);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Field>::deserialize(p0);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>>::expecting(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["std::marker::Sized","serde::de::SeqAccess"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":{"__A":["serde::private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::SeqAccess<'de>>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::PairVisitor<A, B, E>","serde::private::de::content::SeqDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_seq(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>>::visit_seq(p0, p1);
-----------------
rope/src/serde_impls.rs <serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":{"__A":["serde::private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::private::de::FlatMapAccess<'a, 'de, E>","serde::private::de::FlatStructAccess<'a, 'de, E>","serde::private::de::content::MapDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::private::de::content::MapRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // __A
+p0.visit_map(p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::_IMPL_DESERIALIZE_FOR_RopeDelta_::<impl serde::Deserialize<'de> for serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_>::deserialize::__Visitor<'de>>::visit_map(p0, p1);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_> for delta::DeltaElement<rope::RopeInfo>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_> for delta::DeltaElement<rope::RopeInfo>>::from(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDeltaElement_> for delta::DeltaElement<rope::RopeInfo>>::from(p0);
+<delta::DeltaElement<rope::RopeInfo>>::from(p0);
-----------------
rope/src/serde_impls.rs serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_> for delta::Delta<rope::RopeInfo>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_
+serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_> for delta::Delta<rope::RopeInfo>>::from(p0);
+crate::serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::<impl std::convert::From<serde_impls::<impl serde::Deserialize<'de> for delta::Delta<rope::RopeInfo>>::deserialize::RopeDelta_> for delta::Delta<rope::RopeInfo>>::from(p0);
+<delta::Delta<rope::RopeInfo>>::from(p0);
-----------------
rope/src/spans.rs <spans::Span<T> as std::clone::Clone>::clone
deps:{"<spans::Span<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<spans::Span<T> as std::clone::Clone>::clone":{"T":["engine::RevId","multiset::CountMatcher","diff::DiffOp","rope::BaseMetric","breaks::BreaksLeaf","tree::Node","diff::DiffBuilder","engine::Error","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","interval::Interval","multiset::Segment","rope::LinesMetric","spans::Span","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","tree::NodeBody","spans::SpansInfo","find::CaseMatching","multiset::Subset","tree::NodeVal","rope::RopeInfo","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::FullPriority","breaks::BreaksInfo","engine::Contents","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","engine::DeltaOp"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::BaseMetric","engine::Contents","spans::Span","rope::LinesMetric","diff::DiffOp","find::CaseMatching","multiset::Segment","delta::Delta","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","spans::SpansLeaf","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo","engine::DeltaOp","multiset::CountMatcher","engine::FullPriority","multiset::Subset","interval::Interval","tree::NodeVal","delta::DeltaElement","breaks::BreaksMetric","multiset::ZipSegment","tree::NodeBody","engine::RevId","breaks::BreaksBaseMetric","delta::InsertDelta","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["multiset::Subset","engine::Contents","engine::Error","multiset::CountMatcher","breaks::BreaksLeaf","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","spans::Span","interval::Interval","breaks::BreaksMetric","find::CaseMatching","breaks::BreaksBaseMetric","engine::RevId","multiset::Segment","engine::DeltaOp","delta::InsertDelta","tree::NodeBody","rope::RopeInfo","rope::BaseMetric","engine::FullPriority","multiset::ZipSegment","tree::Node","spans::SpansInfo","diff::DiffOp","delta::Delta","spans::SpansLeaf","tree::NodeVal","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["find::CaseMatching","delta::Delta","delta::InsertDelta","rope::LinesMetric","multiset::Subset","tree::NodeVal","tree::Node","spans::Span","diff::DiffOp","diff::DiffBuilder","engine::DeltaOp","rope::RopeInfo","interval::Interval","multiset::CountMatcher","breaks::BreaksInfo","multiset::Segment","delta::DeltaElement","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","engine::FullPriority","breaks::BreaksLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","engine::Contents","engine::RevId","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::Span<T>
+p0.clone();
+<spans::Span<T> as std::clone::Clone>::clone(p0);
+crate::<spans::Span<T> as std::clone::Clone>::clone(p0);
+<spans::Span<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as std::clone::Clone>::clone
deps:{"<spans::SpansLeaf<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<spans::SpansLeaf<T> as std::clone::Clone>::clone":{"T":["multiset::Segment","rope::Utf16CodeUnitsMetric","tree::NodeBody","multiset::ZipSegment","engine::RevId","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","breaks::BreaksLeaf","delta::Delta","breaks::BreaksMetric","delta::InsertDelta","tree::NodeVal","engine::DeltaOp","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::FullPriority","engine::Error","engine::Contents","interval::Interval","rope::RopeInfo","diff::DiffBuilder","tree::Node","spans::Span","spans::SpansLeaf","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffOp","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","delta::DeltaElement"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","rope::RopeInfo","engine::FullPriority","tree::NodeVal","spans::SpansInfo","delta::InsertDelta","breaks::BreaksInfo","multiset::CountMatcher","multiset::Subset","engine::RevId","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","spans::SpansLeaf","engine::Error","tree::Node","tree::NodeBody","diff::DiffBuilder","engine::DeltaOp","interval::Interval","rope::LinesMetric","multiset::Segment","breaks::BreaksLeaf","diff::DiffOp","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","breaks::BreaksMetric","delta::Delta","rope::BaseMetric","spans::Span","find::CaseMatching"]},"spans::SpansInfo":{"T":["engine::RevId","rope::BaseMetric","diff::DiffBuilder","engine::Error","engine::DeltaOp","engine::FullPriority","tree::NodeVal","spans::Span","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","spans::SpansInfo","rope::Utf16CodeUnitsMetric","interval::Interval","breaks::BreaksMetric","delta::InsertDelta","rope::RopeInfo","find::CaseMatching","engine::Contents","breaks::BreaksInfo","rope::LinesMetric","tree::NodeBody","spans::SpansLeaf","diff::DiffOp","multiset::Subset","delta::DeltaElement","multiset::ZipSegment","multiset::Segment","breaks::BreaksBaseMetric","tree::Node","breaks::BreaksLeaf"]},"spans::SpansLeaf":{"T":["find::CaseMatching","breaks::BreaksBaseMetric","engine::FullPriority","delta::DeltaElement","multiset::Subset","rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::ZipSegment","delta::Delta","tree::NodeVal","interval::Interval","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksInfo","diff::DiffOp","tree::Node","tree::NodeBody","engine::Error","breaks::BreaksMetric","spans::SpansLeaf","spans::SpansInfo","delta::InsertDelta","spans::Span","diff::DiffBuilder","rope::LinesMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","breaks::BreaksLeaf","engine::RevId","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.clone();
+<spans::SpansLeaf<T> as std::clone::Clone>::clone(p0);
+crate::<spans::SpansLeaf<T> as std::clone::Clone>::clone(p0);
+<spans::SpansLeaf<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as std::default::Default>::default
deps:{"<spans::SpansLeaf<T> as std::default::Default>::default":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<spans::SpansLeaf<T> as std::default::Default>::default":{"T":["delta::Delta","multiset::ZipSegment","rope::RopeInfo","breaks::BreaksBaseMetric","spans::SpansInfo","engine::Contents","tree::NodeVal","multiset::Subset","find::CaseMatching","delta::InsertDelta","rope::Utf16CodeUnitsMetric","rope::LinesMetric","multiset::CountMatcher","tree::Node","engine::FullPriority","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","diff::DiffBuilder","breaks::BreaksMetric","diff::DiffOp","breaks::BreaksLeaf","spans::SpansLeaf","spans::Span","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","engine::Error","engine::DeltaOp","multiset::Segment","interval::Interval","engine::RevId"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","delta::Delta","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","breaks::BreaksMetric","diff::DiffBuilder","engine::Contents","rope::LinesMetric","spans::Span","delta::DeltaElement","multiset::Subset","multiset::Segment","engine::Error","breaks::BreaksLeaf","rope::BaseMetric","engine::RevId","rope::RopeInfo","engine::DeltaOp","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","tree::NodeVal","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::FullPriority","find::CaseMatching","diff::DiffOp","tree::NodeBody","delta::InsertDelta","interval::Interval"]},"spans::SpansInfo":{"T":["interval::Interval","rope::Utf16CodeUnitsMetric","delta::DeltaElement","multiset::CountMatcher","spans::SpansLeaf","delta::InsertDelta","spans::SpansInfo","rope::RopeInfo","engine::Contents","spans::Span","engine::FullPriority","delta::Delta","engine::Error","rope::BaseMetric","engine::RevId","tree::NodeBody","breaks::BreaksInfo","multiset::ZipSegment","multiset::Subset","diff::DiffBuilder","find::CaseMatching","tree::NodeVal","tree::Node","breaks::BreaksBaseMetric","diff::DiffOp","engine::DeltaOp","breaks::BreaksMetric","multiset::Segment","rope::LinesMetric","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","tree::Node","diff::DiffBuilder","rope::BaseMetric","rope::LinesMetric","tree::NodeBody","spans::SpansInfo","find::CaseMatching","spans::SpansLeaf","breaks::BreaksInfo","engine::Contents","engine::RevId","multiset::Subset","engine::FullPriority","multiset::CountMatcher","multiset::Segment","interval::Interval","tree::NodeVal","rope::RopeInfo","breaks::BreaksMetric","engine::Error","rope::Utf16CodeUnitsMetric","spans::Span","delta::DeltaElement","delta::Delta","breaks::BreaksLeaf","engine::DeltaOp","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
+<spans::SpansLeaf<T> as std::default::Default>::default();
+crate::<spans::SpansLeaf<T> as std::default::Default>::default();
+<spans::SpansLeaf<T>>::default();
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as std::clone::Clone>::clone
deps:{"<spans::SpansInfo<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<spans::SpansInfo<T> as std::clone::Clone>::clone":{"T":["multiset::Segment","rope::LinesMetric","breaks::BreaksBaseMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","engine::FullPriority","multiset::CountMatcher","breaks::BreaksMetric","diff::DiffBuilder","breaks::BreaksInfo","engine::Error","multiset::ZipSegment","engine::RevId","delta::DeltaElement","rope::BaseMetric","rope::Utf16CodeUnitsMetric","tree::NodeVal","tree::NodeBody","spans::SpansLeaf","breaks::BreaksLeaf","spans::SpansInfo","spans::Span","multiset::Subset","engine::DeltaOp","delta::InsertDelta","tree::Node","engine::Contents","delta::Delta","interval::Interval","rope::RopeInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::FullPriority","delta::InsertDelta","tree::NodeBody","tree::Node","engine::Contents","spans::SpansInfo","multiset::ZipSegment","engine::DeltaOp","breaks::BreaksLeaf","rope::RopeInfo","multiset::Segment","spans::Span","interval::Interval","engine::RevId","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp","breaks::BreaksInfo","rope::LinesMetric","multiset::Subset","diff::DiffBuilder","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","tree::NodeVal","spans::SpansLeaf","multiset::CountMatcher","breaks::BreaksMetric","rope::BaseMetric"]},"spans::SpansInfo":{"T":["find::CaseMatching","multiset::CountMatcher","spans::Span","delta::Delta","rope::LinesMetric","breaks::BreaksLeaf","engine::FullPriority","breaks::BreaksBaseMetric","engine::Contents","engine::DeltaOp","rope::RopeInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","engine::Error","diff::DiffBuilder","multiset::Subset","engine::RevId","tree::Node","breaks::BreaksInfo","diff::DiffOp","rope::BaseMetric","delta::InsertDelta","tree::NodeVal","delta::DeltaElement","tree::NodeBody","rope::Utf16CodeUnitsMetric","interval::Interval","breaks::BreaksMetric","multiset::Segment","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","tree::Node","engine::Error","breaks::BreaksMetric","rope::RopeInfo","engine::DeltaOp","engine::RevId","spans::SpansLeaf","interval::Interval","diff::DiffOp","delta::Delta","engine::FullPriority","breaks::BreaksLeaf","delta::DeltaElement","find::CaseMatching","delta::InsertDelta","tree::NodeVal","multiset::Segment","breaks::BreaksInfo","breaks::BreaksBaseMetric","tree::NodeBody","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","spans::Span","spans::SpansInfo","multiset::CountMatcher","multiset::ZipSegment","multiset::Subset","rope::Utf16CodeUnitsMetric","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
+p0.clone();
+<spans::SpansInfo<T> as std::clone::Clone>::clone(p0);
+crate::<spans::SpansInfo<T> as std::clone::Clone>::clone(p0);
+<spans::SpansInfo<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::len
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::len":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::len":{"T":["breaks::BreaksLeaf","engine::Contents","rope::LinesMetric","engine::Error","spans::SpansLeaf","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","breaks::BreaksMetric","spans::SpansInfo","rope::Utf16CodeUnitsMetric","spans::Span","diff::DiffBuilder","delta::DeltaElement","rope::RopeInfo","tree::Node","diff::DiffOp","multiset::CountMatcher","tree::NodeBody","multiset::Subset","engine::DeltaOp","multiset::Segment","tree::NodeVal","engine::RevId","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","breaks::BreaksBaseMetric","find::CaseMatching","interval::Interval","delta::Delta","engine::FullPriority"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","engine::FullPriority","diff::DiffOp","delta::DeltaElement","tree::Node","breaks::BreaksBaseMetric","interval::Interval","breaks::BreaksInfo","multiset::Subset","spans::SpansInfo","multiset::CountMatcher","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","engine::RevId","engine::Contents","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","diff::DiffBuilder","multiset::ZipSegment","rope::BaseMetric","tree::NodeVal","rope::RopeInfo","engine::DeltaOp","multiset::Segment","rope::LinesMetric","spans::Span","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","engine::Error","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["delta::Delta","spans::SpansInfo","diff::DiffOp","interval::Interval","tree::Node","engine::Error","engine::Contents","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","tree::NodeVal","diff::DiffBuilder","engine::FullPriority","find::CaseMatching","spans::SpansLeaf","multiset::Segment","rope::RopeInfo","multiset::CountMatcher","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","tree::NodeBody","breaks::BreaksBaseMetric","delta::InsertDelta","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksLeaf","engine::RevId","multiset::Subset","engine::DeltaOp","rope::LinesMetric","spans::Span"]},"spans::SpansLeaf":{"T":["engine::RevId","breaks::BreaksMetric","delta::DeltaElement","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","breaks::BreaksInfo","interval::Interval","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","find::CaseMatching","engine::Contents","delta::Delta","rope::RopeInfo","multiset::Segment","rope::LinesMetric","engine::DeltaOp","engine::Error","diff::DiffOp","breaks::BreaksBaseMetric","spans::SpansLeaf","multiset::CountMatcher","tree::NodeBody","breaks::BreaksLeaf","delta::InsertDelta","engine::FullPriority","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","multiset::ZipSegment","rope::BaseMetric","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.len();
+<spans::SpansLeaf<T> as tree::Leaf>::len(p0);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::len(p0);
+<spans::SpansLeaf<T>>::len(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::is_ok_child
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":{"T":["rope::LinesMetric","breaks::BreaksMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","tree::NodeVal","delta::InsertDelta","spans::Span","engine::Error","diff::DiffBuilder","rope::RopeInfo","multiset::Subset","engine::FullPriority","engine::Contents","breaks::BreaksInfo","diff::DiffOp","delta::DeltaElement","delta::Delta","multiset::CountMatcher","spans::SpansLeaf","multiset::Segment","tree::Node","engine::RevId","interval::Interval","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","engine::DeltaOp","breaks::BreaksLeaf","find::CaseMatching","rope::BaseMetric","spans::SpansInfo","multiset::ZipSegment"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","engine::RevId","rope::Utf16CodeUnitsMetric","tree::NodeBody","rope::RopeInfo","interval::Interval","delta::DeltaElement","engine::DeltaOp","delta::InsertDelta","breaks::BreaksInfo","multiset::Subset","engine::Contents","spans::Span","rope::BaseMetric","breaks::BreaksLeaf","delta::Delta","rope::LinesMetric","diff::DiffBuilder","tree::NodeVal","multiset::ZipSegment","spans::SpansLeaf","spans::SpansInfo","diff::DiffOp","multiset::CountMatcher","engine::FullPriority","engine::Error","breaks::BreaksMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","tree::Node"]},"spans::SpansInfo":{"T":["tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","multiset::Subset","engine::RevId","spans::SpansInfo","delta::InsertDelta","rope::RopeInfo","rope::LinesMetric","engine::FullPriority","spans::SpansLeaf","diff::DiffOp","rope::BaseMetric","engine::Contents","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","tree::Node","multiset::ZipSegment","delta::Delta","engine::Error","multiset::Segment","breaks::BreaksMetric","engine::DeltaOp","breaks::BreaksBaseMetric","tree::NodeVal","delta::DeltaElement","find::CaseMatching","interval::Interval","breaks::BreaksInfo","multiset::CountMatcher","breaks::BreaksLeaf"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","interval::Interval","engine::RevId","breaks::BreaksInfo","engine::Error","multiset::Segment","multiset::Subset","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","diff::DiffBuilder","delta::DeltaElement","diff::DiffOp","rope::RopeInfo","multiset::CountMatcher","engine::Contents","breaks::BreaksBaseMetric","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::DeltaOp","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","tree::Node","delta::Delta","breaks::BreaksLeaf","find::CaseMatching","breaks::BreaksMetric","engine::FullPriority","delta::InsertDelta","rope::LinesMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.is_ok_child();
+<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child(p0);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child(p0);
+<spans::SpansLeaf<T>>::is_ok_child(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":{"T":["spans::SpansInfo","delta::InsertDelta","engine::DeltaOp","engine::Contents","multiset::Subset","find::CaseMatching","breaks::BreaksMetric","engine::FullPriority","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","breaks::BreaksLeaf","multiset::Segment","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","rope::LinesMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","tree::Node","delta::DeltaElement","multiset::CountMatcher","diff::DiffBuilder","spans::SpansLeaf","spans::Span","engine::Error","diff::DiffOp","tree::NodeBody","rope::RopeInfo","multiset::ZipSegment","delta::Delta","interval::Interval"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::Segment","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","diff::DiffOp","engine::DeltaOp","spans::SpansLeaf","engine::RevId","delta::DeltaElement","breaks::BreaksInfo","multiset::Subset","tree::NodeBody","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::Contents","engine::FullPriority","breaks::BreaksBaseMetric","find::CaseMatching","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","diff::DiffBuilder","rope::RopeInfo","tree::NodeVal","delta::InsertDelta","rope::LinesMetric","rope::BaseMetric","spans::Span","delta::Delta","interval::Interval","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["diff::DiffBuilder","rope::RopeInfo","rope::LinesMetric","engine::FullPriority","interval::Interval","multiset::Segment","multiset::Subset","tree::Node","breaks::BreaksInfo","breaks::BreaksLeaf","breaks::BreaksBaseMetric","spans::SpansLeaf","multiset::CountMatcher","diff::DiffOp","breaks::BreaksMetric","rope::BaseMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","engine::Error","delta::InsertDelta","engine::RevId","engine::Contents","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::DeltaElement","delta::Delta","spans::Span","spans::SpansInfo","tree::NodeBody","find::CaseMatching"]},"spans::SpansLeaf":{"T":["delta::Delta","spans::SpansLeaf","engine::FullPriority","tree::NodeVal","breaks::BreaksBaseMetric","delta::DeltaElement","breaks::BreaksLeaf","delta::InsertDelta","engine::Contents","interval::Interval","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","rope::LinesMetric","multiset::CountMatcher","engine::DeltaOp","engine::RevId","rope::BaseMetric","spans::SpansInfo","tree::NodeBody","breaks::BreaksInfo","multiset::Subset","spans::Span","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksMetric","diff::DiffBuilder","diff::DiffOp","find::CaseMatching","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split(p0, p1, p2);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split(p0, p1, p2);
+<spans::SpansLeaf<T>>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as tree::NodeInfo>::accumulate
deps:{"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":{"T":["delta::InsertDelta","breaks::BreaksMetric","multiset::ZipSegment","spans::SpansLeaf","breaks::BreaksInfo","delta::DeltaElement","breaks::BreaksLeaf","tree::NodeBody","engine::DeltaOp","multiset::Segment","rope::LinesMetric","diff::DiffOp","tree::Node","spans::Span","tree::NodeVal","engine::Contents","multiset::CountMatcher","engine::Error","engine::RevId","rope::Utf16CodeUnitsMetric","multiset::Subset","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","spans::SpansInfo","breaks::BreaksBaseMetric","find::CaseMatching","delta::Delta","diff::DiffBuilder","interval::Interval","rope::BaseMetric"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::Segment","engine::RevId","engine::Error","interval::Interval","multiset::Subset","rope::Utf16CodeUnitsMetric","engine::FullPriority","delta::DeltaElement","spans::Span","tree::Node","diff::DiffBuilder","diff::DiffOp","tree::NodeBody","tree::NodeVal","delta::InsertDelta","multiset::ZipSegment","breaks::BreaksLeaf","rope::BaseMetric","breaks::BreaksInfo","breaks::BreaksMetric","rope::LinesMetric","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","delta::Delta","engine::DeltaOp","find::CaseMatching","multiset::CountMatcher","breaks::BreaksBaseMetric","rope::RopeInfo","spans::SpansInfo"]},"spans::SpansInfo":{"T":["spans::Span","multiset::CountMatcher","delta::DeltaElement","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksMetric","multiset::ZipSegment","engine::Error","rope::RopeInfo","multiset::Subset","diff::DiffBuilder","multiset::Segment","engine::FullPriority","diff::DiffOp","tree::Node","tree::NodeBody","breaks::BreaksInfo","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","interval::Interval","spans::SpansLeaf","engine::RevId","engine::Contents","delta::Delta","engine::DeltaOp","tree::NodeVal","find::CaseMatching","spans::SpansInfo","breaks::BreaksLeaf","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["multiset::Subset","breaks::BreaksBaseMetric","engine::FullPriority","rope::LinesMetric","find::CaseMatching","interval::Interval","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksLeaf","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","diff::DiffOp","spans::SpansInfo","spans::Span","multiset::Segment","delta::Delta","breaks::BreaksInfo","engine::RevId","tree::NodeVal","breaks::BreaksMetric","engine::DeltaOp","multiset::CountMatcher","engine::Error","engine::Contents","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","rope::RopeInfo","delta::InsertDelta","tree::NodeBody","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
+p0.accumulate(p1);
+<spans::SpansInfo<T> as tree::NodeInfo>::accumulate(p0, p1);
+crate::<spans::SpansInfo<T> as tree::NodeInfo>::accumulate(p0, p1);
+<spans::SpansInfo<T>>::accumulate(p0, p1);
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as tree::NodeInfo>::compute_info
deps:{"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":{"T":["rope::Utf16CodeUnitsMetric","multiset::Subset","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","rope::BaseMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","delta::Delta","multiset::Segment","delta::DeltaElement","multiset::CountMatcher","spans::Span","engine::Error","breaks::BreaksMetric","engine::Contents","find::CaseMatching","tree::NodeBody","rope::RopeInfo","tree::NodeVal","tree::Node","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::RevId","multiset::ZipSegment","spans::SpansInfo","engine::FullPriority","diff::DiffOp","diff::DiffBuilder","interval::Interval","breaks::BreaksLeaf"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::DeltaOp","tree::Node","multiset::Segment","diff::DiffOp","delta::DeltaElement","diff::DiffBuilder","delta::InsertDelta","tree::NodeVal","rope::RopeInfo","breaks::BreaksMetric","rope::BaseMetric","spans::Span","multiset::ZipSegment","multiset::Subset","engine::FullPriority","breaks::BreaksLeaf","find::CaseMatching","rope::Utf16CodeUnitsMetric","tree::NodeBody","interval::Interval","multiset::CountMatcher","engine::Contents","rope::LinesMetric","breaks::BreaksInfo","delta::Delta","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::Error","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId"]},"spans::SpansInfo":{"T":["breaks::BreaksBaseMetric","rope::RopeInfo","engine::DeltaOp","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","engine::FullPriority","interval::Interval","spans::SpansInfo","tree::NodeBody","tree::NodeVal","engine::Error","rope::LinesMetric","multiset::Segment","breaks::BreaksLeaf","multiset::ZipSegment","delta::Delta","rope::BaseMetric","spans::Span","multiset::CountMatcher","find::CaseMatching","delta::DeltaElement","diff::DiffOp","multiset::Subset","engine::Contents","tree::Node","breaks::BreaksMetric","breaks::BreaksInfo","spans::SpansLeaf","delta::InsertDelta","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansLeaf":{"T":["find::CaseMatching","spans::SpansInfo","multiset::Segment","rope::LinesMetric","diff::DiffOp","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksInfo","tree::Node","rope::RopeInfo","engine::DeltaOp","interval::Interval","engine::Contents","engine::Error","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","multiset::Subset","engine::RevId","tree::NodeBody","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","delta::Delta","breaks::BreaksLeaf","breaks::BreaksMetric","spans::Span","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","engine::FullPriority","breaks::BreaksBaseMetric","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+<spans::SpansInfo<T> as tree::NodeInfo>::compute_info(p0);
+crate::<spans::SpansInfo<T> as tree::NodeInfo>::compute_info(p0);
+<spans::SpansInfo<T>>::compute_info(p0);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::new
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansBuilder::<T>::new":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::CountMatcher","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","diff::DiffBuilder","spans::Span","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksMetric","delta::Delta","diff::DiffOp","tree::NodeVal","breaks::BreaksLeaf","engine::RevId","engine::Error","rope::RopeInfo","multiset::Segment","spans::SpansInfo","delta::DeltaElement","tree::NodeBody","rope::LinesMetric","delta::InsertDelta","multiset::Subset","interval::Interval","breaks::BreaksInfo","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","breaks::BreaksBaseMetric","tree::Node"]},"spans::SpansBuilder::<T>::new":{"T":["engine::Error","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","breaks::BreaksInfo","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","diff::DiffBuilder","breaks::BreaksBaseMetric","interval::Interval","rope::RopeInfo","rope::BaseMetric","spans::SpansInfo","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","multiset::Segment","spans::SpansLeaf","multiset::Subset","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","engine::FullPriority","breaks::BreaksLeaf","rope::LinesMetric","diff::DiffOp","tree::Node","delta::DeltaElement","delta::Delta","tree::NodeVal","engine::RevId","engine::DeltaOp"]},"spans::SpansInfo":{"T":["engine::DeltaOp","spans::SpansInfo","multiset::Segment","rope::RopeInfo","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","breaks::BreaksLeaf","rope::BaseMetric","engine::FullPriority","rope::LinesMetric","delta::InsertDelta","breaks::BreaksBaseMetric","multiset::ZipSegment","tree::Node","engine::Error","tree::NodeBody","find::CaseMatching","tree::NodeVal","interval::Interval","delta::Delta","engine::RevId","delta::DeltaElement","spans::SpansLeaf","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","engine::Contents","diff::DiffOp","breaks::BreaksMetric","multiset::CountMatcher","multiset::Subset"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","engine::RevId","rope::RopeInfo","delta::Delta","spans::Span","multiset::ZipSegment","tree::NodeBody","rope::LinesMetric","engine::DeltaOp","tree::NodeVal","breaks::BreaksBaseMetric","multiset::Segment","multiset::Subset","breaks::BreaksLeaf","rope::BaseMetric","delta::DeltaElement","delta::InsertDelta","breaks::BreaksMetric","interval::Interval","diff::DiffBuilder","engine::Contents","spans::SpansInfo","spans::SpansLeaf","tree::Node","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = 0usize; // None+usize
+spans::SpansBuilder::<T>::new(p0);
+crate::spans::SpansBuilder::<T>::new(p0);
+<spans::SpansBuilder<T>>::new(p0);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::add_span
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansBuilder::<T>::add_span":{"IV":["interval::IntervalBounds","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::Delta","breaks::BreaksMetric","delta::InsertDelta","spans::SpansLeaf","diff::DiffBuilder","rope::LinesMetric","engine::DeltaOp","breaks::BreaksLeaf","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","rope::BaseMetric","delta::DeltaElement","engine::Contents","tree::NodeVal","multiset::Segment","spans::SpansInfo","rope::Utf16CodeUnitsMetric","find::CaseMatching","rope::RopeInfo","multiset::CountMatcher","interval::Interval","multiset::ZipSegment","diff::DiffOp","breaks::BreaksBaseMetric","breaks::BreaksInfo","tree::NodeBody","spans::Span","engine::FullPriority","multiset::Subset","engine::Error"]},"spans::SpansBuilder::<T>::add_span":{"IV":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"],"T":["tree::NodeBody","engine::DeltaOp","breaks::BreaksBaseMetric","rope::LinesMetric","multiset::ZipSegment","engine::Contents","spans::Span","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","tree::Node","engine::RevId","multiset::Subset","breaks::BreaksLeaf","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","engine::FullPriority","multiset::Segment","interval::Interval","delta::DeltaElement","engine::Error","find::CaseMatching","delta::Delta","spans::SpansInfo","breaks::BreaksMetric","multiset::CountMatcher","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksInfo","rope::RopeInfo"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","multiset::Subset","multiset::Segment","engine::Contents","delta::DeltaElement","spans::SpansInfo","multiset::CountMatcher","engine::Error","spans::Span","breaks::BreaksBaseMetric","tree::Node","delta::Delta","tree::NodeVal","engine::FullPriority","interval::Interval","rope::RopeInfo","multiset::ZipSegment","engine::DeltaOp","spans::SpansLeaf","breaks::BreaksInfo","engine::RevId","diff::DiffOp","diff::DiffBuilder","breaks::BreaksLeaf","find::CaseMatching","delta::InsertDelta","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::NodeBody","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansLeaf":{"T":["find::CaseMatching","interval::Interval","engine::DeltaOp","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","delta::Delta","spans::SpansLeaf","breaks::BreaksMetric","engine::Error","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","engine::FullPriority","spans::Span","rope::BaseMetric","tree::NodeVal","breaks::BreaksLeaf","multiset::Subset","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksBaseMetric","engine::RevId","multiset::ZipSegment","delta::DeltaElement","diff::DiffOp","engine::Contents","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","rope::LinesMetric","delta::InsertDelta","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansBuilder<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // IV
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.add_span(p1, p2);
+spans::SpansBuilder::<T>::add_span(p0, p1, p2);
+crate::spans::SpansBuilder::<T>::add_span(p0, p1, p2);
+<spans::SpansBuilder<T>>::add_span(p0, p1, p2);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::build
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansBuilder::<T>::build":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","rope::LinesMetric","tree::NodeVal","multiset::Subset","engine::DeltaOp","multiset::CountMatcher","spans::SpansInfo","engine::FullPriority","breaks::BreaksMetric","delta::DeltaElement","spans::Span","spans::SpansLeaf","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","breaks::BreaksBaseMetric","find::CaseMatching","rope::BaseMetric","breaks::BreaksInfo","tree::NodeBody","engine::Error","rope::RopeInfo","tree::Node","diff::DiffOp","multiset::Segment","delta::InsertDelta","breaks::BreaksLeaf"]},"spans::SpansBuilder::<T>::build":{"T":["rope::LinesMetric","multiset::Subset","rope::BaseMetric","engine::RevId","tree::NodeVal","diff::DiffBuilder","spans::Span","spans::SpansLeaf","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","rope::RopeInfo","interval::Interval","breaks::BreaksMetric","tree::Node","multiset::ZipSegment","delta::InsertDelta","engine::DeltaOp","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","delta::DeltaElement","find::CaseMatching","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksInfo","diff::DiffOp","breaks::BreaksBaseMetric","spans::SpansInfo","engine::Error","multiset::Segment","rope::Utf16CodeUnitsMetric"]},"spans::SpansInfo":{"T":["rope::LinesMetric","engine::Error","tree::Node","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","rope::RopeInfo","rope::BaseMetric","tree::NodeVal","tree::NodeBody","spans::SpansLeaf","diff::DiffOp","delta::Delta","delta::DeltaElement","rope::Utf16CodeUnitsMetric","spans::SpansInfo","engine::DeltaOp","find::CaseMatching","multiset::CountMatcher","breaks::BreaksInfo","engine::FullPriority","delta::InsertDelta","diff::DiffBuilder","multiset::Subset","breaks::BreaksMetric","multiset::Segment","breaks::BreaksLeaf","spans::Span","multiset::ZipSegment","engine::Contents","interval::Interval"]},"spans::SpansLeaf":{"T":["tree::NodeVal","tree::Node","engine::FullPriority","spans::SpansInfo","rope::LinesMetric","rope::RopeInfo","breaks::BreaksBaseMetric","breaks::BreaksMetric","multiset::Subset","breaks::BreaksLeaf","engine::Error","find::CaseMatching","spans::SpansLeaf","delta::InsertDelta","multiset::ZipSegment","delta::Delta","engine::DeltaOp","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::Contents","tree::NodeBody","breaks::BreaksInfo","diff::DiffOp","engine::RevId","multiset::CountMatcher","rope::BaseMetric","multiset::Segment","spans::Span"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // spans::SpansBuilder<T>
+p0.build();
+spans::SpansBuilder::<T>::build(p0);
+crate::spans::SpansBuilder::<T>::build(p0);
+<spans::SpansBuilder<T>>::build(p0);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::transform
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"T":["engine::Error","engine::RevId","rope::RopeInfo","tree::NodeBody","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","spans::Span","breaks::BreaksBaseMetric","spans::SpansInfo","diff::DiffOp","tree::Node","breaks::BreaksMetric","delta::Delta","diff::DiffBuilder","multiset::CountMatcher","interval::Interval","multiset::Subset","engine::DeltaOp","multiset::Segment","breaks::BreaksInfo","delta::InsertDelta","breaks::BreaksLeaf","find::CaseMatching","engine::FullPriority","spans::SpansLeaf","delta::DeltaElement","tree::NodeVal","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","multiset::ZipSegment"]},"spans::Span":{"T":["engine::DeltaOp","multiset::Subset","breaks::BreaksInfo","spans::SpansLeaf","delta::DeltaElement","engine::Contents","rope::BaseMetric","spans::SpansInfo","diff::DiffBuilder","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","multiset::ZipSegment","tree::NodeBody","engine::RevId","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","breaks::BreaksBaseMetric","find::CaseMatching","interval::Interval","tree::NodeVal","delta::Delta","engine::Error","multiset::Segment","diff::DiffOp","delta::InsertDelta","multiset::CountMatcher","rope::RopeInfo","engine::FullPriority","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","engine::FullPriority","diff::DiffBuilder","breaks::BreaksBaseMetric","multiset::ZipSegment","interval::Interval","spans::Span","diff::DiffOp","multiset::CountMatcher","breaks::BreaksLeaf","engine::Error","multiset::Segment","tree::Node","rope::BaseMetric","tree::NodeVal","delta::Delta","find::CaseMatching","delta::DeltaElement","multiset::Subset","engine::DeltaOp","breaks::BreaksInfo","rope::LinesMetric","rope::Utf16CodeUnitsMetric","tree::NodeBody","delta::InsertDelta","rope::RopeInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","breaks::BreaksMetric","engine::Contents"]},"spans::SpansLeaf":{"T":["engine::RevId","engine::DeltaOp","tree::NodeBody","tree::NodeVal","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","tree::Node","multiset::ZipSegment","engine::Contents","diff::DiffOp","interval::Interval","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksMetric","spans::SpansLeaf","find::CaseMatching","delta::Delta","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksLeaf","multiset::Subset","delta::DeltaElement","rope::BaseMetric","rope::RopeInfo","breaks::BreaksInfo","delta::InsertDelta","spans::Span","engine::FullPriority","spans::SpansInfo","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'_, N>
+p0.transform(p1, p2, p3);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
+<tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::merge
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":{"F":["std::ops::FnMut","std::marker::Sized"],"O":["std::marker::Sized","std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":{"F":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue"],"O":["breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Segment","breaks::BreaksInfo","rope::RopeInfo","delta::InsertDelta","rope::Utf16CodeUnitsMetric","spans::Span","multiset::Subset","breaks::BreaksLeaf","spans::SpansInfo","spans::SpansLeaf","engine::RevId","multiset::CountMatcher","find::CaseMatching","breaks::BreaksBaseMetric","interval::Interval","engine::FullPriority","diff::DiffOp","delta::DeltaElement","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","delta::Delta","diff::DiffBuilder","multiset::ZipSegment","rope::BaseMetric","tree::NodeBody","rope::LinesMetric","tree::NodeVal","tree::Node","engine::Error"],"T":["engine::RevId","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","find::CaseMatching","delta::InsertDelta","breaks::BreaksLeaf","multiset::Segment","delta::DeltaElement","diff::DiffBuilder","diff::DiffOp","spans::SpansLeaf","breaks::BreaksMetric","multiset::CountMatcher","spans::SpansInfo","multiset::ZipSegment","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","tree::NodeVal","spans::Span","tree::Node","engine::DeltaOp","rope::RopeInfo","engine::FullPriority","engine::Contents","engine::Error","rope::BaseMetric","rope::LinesMetric","breaks::BreaksInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","spans::Span","diff::DiffOp","tree::NodeBody","engine::Contents","engine::Error","spans::SpansLeaf","rope::BaseMetric","multiset::CountMatcher","delta::DeltaElement","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","tree::NodeVal","delta::InsertDelta","rope::Utf16CodeUnitsMetric","spans::SpansInfo","breaks::BreaksBaseMetric","interval::Interval","engine::DeltaOp","diff::DiffBuilder","breaks::BreaksInfo","delta::Delta","multiset::Subset","engine::FullPriority","multiset::Segment","breaks::BreaksLeaf","rope::RopeInfo","breaks::BreaksMetric","engine::RevId","tree::Node"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","multiset::Subset","spans::SpansInfo","delta::InsertDelta","multiset::CountMatcher","delta::DeltaElement","breaks::BreaksInfo","delta::Delta","diff::DiffBuilder","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","find::CaseMatching","breaks::BreaksLeaf","engine::Error","multiset::Segment","rope::LinesMetric","spans::Span","tree::Node","engine::DeltaOp","tree::NodeVal","rope::RopeInfo","rope::BaseMetric","interval::Interval","engine::Contents","diff::DiffOp","spans::SpansLeaf","engine::FullPriority","engine::RevId","tree::NodeBody"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","engine::Error","engine::DeltaOp","engine::RevId","multiset::ZipSegment","multiset::Subset","delta::InsertDelta","spans::SpansInfo","breaks::BreaksMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Segment","delta::DeltaElement","delta::Delta","diff::DiffOp","tree::NodeVal","spans::Span","engine::Contents","engine::FullPriority","breaks::BreaksLeaf","rope::LinesMetric","multiset::CountMatcher","tree::Node","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric","spans::SpansLeaf","rope::RopeInfo","breaks::BreaksInfo","find::CaseMatching","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+p0.merge(p1, p2);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
+<tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::iter
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","rope::RopeInfo","tree::Node","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::RevId","tree::NodeVal","breaks::BreaksLeaf","breaks::BreaksMetric","rope::LinesMetric","delta::InsertDelta","engine::FullPriority","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp","engine::Contents","multiset::CountMatcher","spans::Span","spans::SpansInfo","spans::SpansLeaf","multiset::Segment","diff::DiffBuilder","interval::Interval","breaks::BreaksInfo","multiset::ZipSegment","engine::DeltaOp","rope::BaseMetric","find::CaseMatching","delta::Delta"]},"spans::Span":{"T":["breaks::BreaksLeaf","engine::DeltaOp","tree::NodeBody","engine::RevId","find::CaseMatching","rope::BaseMetric","diff::DiffOp","rope::LinesMetric","diff::DiffBuilder","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","spans::Span","multiset::ZipSegment","spans::SpansInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","multiset::CountMatcher","tree::Node","breaks::BreaksInfo","delta::InsertDelta","engine::Error","breaks::BreaksBaseMetric","delta::DeltaElement","engine::Contents","tree::NodeVal","engine::FullPriority","interval::Interval","multiset::Subset","multiset::Segment","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","breaks::BreaksLeaf","rope::LinesMetric","breaks::BreaksInfo","tree::Node","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","rope::BaseMetric","breaks::BreaksMetric","multiset::Segment","tree::NodeBody","delta::InsertDelta","engine::Error","delta::DeltaElement","breaks::BreaksBaseMetric","spans::SpansLeaf","tree::NodeVal","engine::RevId","find::CaseMatching","rope::RopeInfo","interval::Interval","engine::FullPriority","diff::DiffOp","engine::DeltaOp","multiset::ZipSegment","spans::SpansInfo","engine::Contents","delta::Delta","rope::Utf16CodeUnitsMetric","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","spans::SpansInfo","diff::DiffBuilder","multiset::ZipSegment","rope::RopeInfo","engine::Error","spans::Span","delta::InsertDelta","multiset::CountMatcher","tree::NodeVal","multiset::Subset","delta::Delta","find::CaseMatching","engine::RevId","engine::FullPriority","tree::NodeBody","interval::Interval","tree::Node","engine::DeltaOp","breaks::BreaksBaseMetric","diff::DiffOp","breaks::BreaksInfo","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::SpansLeaf","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
+p0.iter();
+spans::<impl tree::Node<spans::SpansInfo<T>>>::iter(p0);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::iter(p0);
+<tree::Node<spans::SpansInfo<T>>>::iter(p0);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":{"M":["std::marker::Sized","tree::NodeInfo"],"T":["std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":{"M":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"T":["engine::DeltaOp","spans::SpansInfo","rope::LinesMetric","multiset::ZipSegment","tree::Node","multiset::Subset","engine::Contents","engine::Error","breaks::BreaksInfo","multiset::Segment","breaks::BreaksLeaf","breaks::BreaksMetric","rope::BaseMetric","delta::InsertDelta","spans::Span","diff::DiffOp","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","engine::FullPriority","spans::SpansLeaf","tree::NodeBody","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","delta::Delta","delta::DeltaElement","find::CaseMatching","tree::NodeVal","diff::DiffBuilder","breaks::BreaksBaseMetric","interval::Interval"]},"spans::Span":{"T":["spans::SpansInfo","breaks::BreaksMetric","rope::RopeInfo","multiset::CountMatcher","spans::Span","rope::BaseMetric","spans::SpansLeaf","engine::FullPriority","breaks::BreaksBaseMetric","breaks::BreaksLeaf","diff::DiffBuilder","engine::DeltaOp","engine::RevId","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","multiset::ZipSegment","diff::DiffOp","rope::LinesMetric","delta::InsertDelta","breaks::BreaksInfo","engine::Contents","find::CaseMatching","engine::Error","interval::Interval","delta::DeltaElement","rope::Utf16CodeUnitsMetric","delta::Delta","multiset::Segment","multiset::Subset"]},"spans::SpansInfo":{"T":["rope::BaseMetric","breaks::BreaksMetric","engine::RevId","diff::DiffOp","breaks::BreaksBaseMetric","delta::DeltaElement","breaks::BreaksInfo","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","find::CaseMatching","spans::SpansInfo","engine::Contents","delta::InsertDelta","diff::DiffBuilder","tree::Node","multiset::Subset","engine::Error","spans::SpansLeaf","tree::NodeVal","rope::RopeInfo","rope::LinesMetric","spans::Span","breaks::BreaksLeaf","tree::NodeBody","delta::Delta","engine::FullPriority","multiset::CountMatcher","interval::Interval","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","delta::DeltaElement","diff::DiffOp","multiset::ZipSegment","find::CaseMatching","spans::Span","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","engine::FullPriority","breaks::BreaksBaseMetric","interval::Interval","engine::Error","multiset::Segment","engine::RevId","delta::Delta","breaks::BreaksInfo","multiset::Subset","diff::DiffBuilder","tree::Node","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","rope::LinesMetric","delta::InsertDelta","breaks::BreaksLeaf","rope::BaseMetric","engine::DeltaOp","engine::Contents","rope::RopeInfo","tree::NodeVal","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = & MaybeUninit::uninit().assume_init(); // delta::Delta<M>
+p0.apply_shape(p1);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":{"T":["delta::InsertDelta","tree::NodeVal","engine::Error","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::DeltaOp","multiset::ZipSegment","engine::Contents","rope::RopeInfo","multiset::CountMatcher","multiset::Segment","rope::LinesMetric","tree::Node","multiset::Subset","spans::SpansLeaf","engine::FullPriority","tree::NodeBody","spans::Span","breaks::BreaksMetric","diff::DiffBuilder","find::CaseMatching","delta::DeltaElement","interval::Interval","diff::DiffOp","rope::BaseMetric","breaks::BreaksInfo","engine::RevId","rope::Utf16CodeUnitsMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","breaks::BreaksLeaf"]},"spans::Span":{"T":["delta::InsertDelta","engine::FullPriority","multiset::Subset","breaks::BreaksInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","spans::Span","rope::LinesMetric","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","multiset::Segment","engine::Error","multiset::ZipSegment","diff::DiffOp","tree::Node","multiset::CountMatcher","rope::BaseMetric","engine::Contents","breaks::BreaksMetric","tree::NodeBody","engine::DeltaOp","delta::Delta","rope::RopeInfo","engine::RevId","find::CaseMatching","diff::DiffBuilder","spans::SpansInfo","delta::DeltaElement","breaks::BreaksBaseMetric","tree::NodeVal"]},"spans::SpansInfo":{"T":["tree::NodeBody","tree::NodeVal","engine::Error","rope::Utf16CodeUnitsMetric","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","breaks::BreaksBaseMetric","engine::RevId","engine::Contents","spans::SpansInfo","multiset::Subset","breaks::BreaksMetric","engine::FullPriority","delta::DeltaElement","breaks::BreaksInfo","spans::Span","rope::RopeInfo","spans::SpansLeaf","diff::DiffBuilder","tree::Node","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","rope::BaseMetric","multiset::Segment","multiset::ZipSegment","delta::InsertDelta","breaks::BreaksLeaf","delta::Delta","diff::DiffOp"]},"spans::SpansLeaf":{"T":["tree::NodeBody","tree::Node","engine::RevId","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","rope::Utf16CodeUnitsMetric","engine::DeltaOp","interval::Interval","multiset::ZipSegment","rope::RopeInfo","delta::InsertDelta","diff::DiffBuilder","breaks::BreaksBaseMetric","delta::Delta","multiset::Segment","multiset::Subset","engine::FullPriority","spans::Span","delta::DeltaElement","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffOp","rope::BaseMetric","breaks::BreaksMetric","rope::LinesMetric","tree::NodeVal","breaks::BreaksInfo","spans::SpansInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.delete_after(p1);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
-----------------
rope/src/spans.rs spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":{"T":["diff::DiffBuilder","breaks::BreaksLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","multiset::Segment","engine::DeltaOp","multiset::Subset","multiset::CountMatcher","multiset::ZipSegment","engine::Contents","breaks::BreaksInfo","<&T as std::fmt::Debug>","engine::RevId","delta::Delta","diff::DiffOp","<*mut T as std::fmt::Debug>","interval::Interval"]},"spans::Span":{"T":["engine::DeltaOp","spans::Span","multiset::Subset","tree::NodeBody","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","interval::Interval","spans::SpansInfo","multiset::Segment","engine::Contents","engine::Error","breaks::BreaksLeaf","rope::BaseMetric","tree::NodeVal","rope::LinesMetric","diff::DiffBuilder","spans::SpansLeaf","delta::Delta","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","breaks::BreaksBaseMetric","tree::Node","find::CaseMatching","diff::DiffOp","delta::DeltaElement","multiset::ZipSegment","multiset::CountMatcher","engine::RevId","rope::RopeInfo"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","engine::Error","diff::DiffBuilder","tree::NodeVal","spans::Span","rope::RopeInfo","engine::FullPriority","multiset::Subset","interval::Interval","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","delta::Delta","diff::DiffOp","delta::DeltaElement","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","breaks::BreaksBaseMetric","spans::SpansLeaf","rope::LinesMetric","engine::RevId","spans::SpansInfo","rope::BaseMetric","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","multiset::ZipSegment","engine::Contents","find::CaseMatching","delta::InsertDelta"]},"spans::SpansLeaf":{"T":["diff::DiffOp","rope::RopeInfo","rope::BaseMetric","spans::SpansInfo","engine::RevId","delta::InsertDelta","rope::LinesMetric","spans::Span","engine::Contents","tree::NodeBody","engine::FullPriority","breaks::BreaksLeaf","multiset::CountMatcher","multiset::Subset","diff::DiffBuilder","delta::Delta","breaks::BreaksInfo","engine::Error","tree::NodeVal","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::Segment","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","spans::SpansLeaf","engine::DeltaOp","tree::Node","delta::DeltaElement","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
+crate::spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
-----------------
rope/src/spans.rs <spans::SpanIter<'a, T> as std::iter::Iterator>::next
'a
deps:{"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":{"T":["engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","tree::NodeVal","spans::SpansLeaf","multiset::CountMatcher","multiset::Subset","engine::Contents","multiset::Segment","diff::DiffOp","rope::BaseMetric","breaks::BreaksLeaf","multiset::ZipSegment","engine::FullPriority","delta::Delta","breaks::BreaksInfo","diff::DiffBuilder","spans::Span","interval::Interval","tree::NodeBody","rope::LinesMetric","engine::Error","delta::InsertDelta","rope::RopeInfo","find::CaseMatching","tree::Node","spans::SpansInfo","breaks::BreaksMetric","breaks::BreaksBaseMetric","delta::DeltaElement","engine::DeltaOp"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansInfo","engine::DeltaOp","breaks::BreaksLeaf","diff::DiffBuilder","engine::Contents","multiset::ZipSegment","interval::Interval","spans::Span","tree::NodeVal","multiset::Segment","engine::Error","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","multiset::Subset","tree::NodeBody","breaks::BreaksBaseMetric","spans::SpansLeaf","delta::Delta","delta::InsertDelta","find::CaseMatching","rope::BaseMetric","tree::Node","breaks::BreaksMetric","delta::DeltaElement","rope::Utf16CodeUnitsMetric","engine::RevId","rope::LinesMetric","diff::DiffOp","multiset::CountMatcher","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","rope::BaseMetric","find::CaseMatching","delta::InsertDelta","spans::SpansLeaf","tree::NodeBody","breaks::BreaksInfo","multiset::ZipSegment","delta::Delta","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::Subset","engine::RevId","engine::Error","interval::Interval","rope::LinesMetric","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","breaks::BreaksLeaf","tree::NodeVal","delta::DeltaElement","spans::SpansInfo","tree::Node","diff::DiffOp","spans::Span","breaks::BreaksBaseMetric","diff::DiffBuilder","multiset::Segment","breaks::BreaksMetric","rope::RopeInfo"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","spans::SpansInfo","delta::InsertDelta","multiset::Subset","breaks::BreaksInfo","engine::DeltaOp","find::CaseMatching","diff::DiffBuilder","diff::DiffOp","engine::RevId","delta::DeltaElement","rope::RopeInfo","multiset::CountMatcher","delta::Delta","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","engine::FullPriority","tree::NodeVal","multiset::ZipSegment","breaks::BreaksLeaf","tree::NodeBody","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","spans::Span","spans::SpansLeaf","rope::LinesMetric","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::Segment","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpanIter<'a, T>
+p0.next();
+<spans::SpanIter<'a, T> as std::iter::Iterator>::next(p0);
+crate::<spans::SpanIter<'a, T> as std::iter::Iterator>::next(p0);
+<spans::SpanIter<'a, T>>::next(p0);
-----------------
rope/src/tree.rs <tree::Node<N> as std::clone::Clone>::clone
deps:{"<tree::Node<N> as std::clone::Clone>::clone":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<tree::Node<N> as std::clone::Clone>::clone":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::DeltaOp","breaks::BreaksLeaf","delta::Delta","rope::Utf16CodeUnitsMetric","tree::NodeBody","multiset::Subset","delta::DeltaElement","tree::NodeVal","rope::RopeInfo","breaks::BreaksInfo","rope::LinesMetric","breaks::BreaksMetric","engine::Error","tree::Node","spans::SpansInfo","diff::DiffOp","interval::Interval","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","engine::RevId","multiset::Segment","find::CaseMatching","multiset::ZipSegment","engine::FullPriority","rope::BaseMetric","spans::SpansLeaf","diff::DiffBuilder","delta::InsertDelta","breaks::BreaksBaseMetric"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","spans::SpansInfo","engine::DeltaOp","spans::SpansLeaf","multiset::Subset","breaks::BreaksInfo","diff::DiffBuilder","tree::NodeVal","engine::RevId","engine::Contents","find::CaseMatching","multiset::CountMatcher","diff::DiffOp","interval::Interval","rope::RopeInfo","multiset::ZipSegment","tree::Node","breaks::BreaksLeaf","delta::InsertDelta","delta::DeltaElement","breaks::BreaksBaseMetric","spans::Span","rope::Utf16CodeUnitsMetric","engine::FullPriority","multiset::Segment","engine::Error","delta::Delta","rope::BaseMetric","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["delta::Delta","multiset::Subset","rope::BaseMetric","tree::NodeVal","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","diff::DiffBuilder","spans::SpansLeaf","diff::DiffOp","multiset::Segment","rope::RopeInfo","engine::Error","engine::FullPriority","engine::Contents","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::DeltaOp","interval::Interval","breaks::BreaksLeaf","breaks::BreaksBaseMetric","spans::SpansInfo","tree::Node","rope::LinesMetric","find::CaseMatching","multiset::ZipSegment","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","spans::Span","multiset::CountMatcher","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.clone();
+<tree::Node<N> as std::clone::Clone>::clone(p0);
+crate::<tree::Node<N> as std::clone::Clone>::clone(p0);
+<tree::Node<N>>::clone(p0);
-----------------
rope/src/tree.rs <tree::NodeBody<N> as std::clone::Clone>::clone
deps:{"<tree::NodeBody<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"<tree::NodeBody<N> as std::clone::Clone>::clone":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffOp","multiset::CountMatcher","multiset::Segment","multiset::Subset","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric","delta::InsertDelta","interval::Interval","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","tree::NodeBody","multiset::ZipSegment","tree::NodeVal","breaks::BreaksLeaf","breaks::BreaksMetric","delta::Delta","engine::FullPriority","tree::Node","delta::DeltaElement","spans::SpansInfo","find::CaseMatching","engine::RevId","diff::DiffBuilder","engine::DeltaOp","rope::BaseMetric","engine::Error","breaks::BreaksInfo","breaks::BreaksBaseMetric"]},"spans::SpansInfo":{"T":["tree::NodeVal","delta::DeltaElement","breaks::BreaksInfo","breaks::BreaksMetric","engine::FullPriority","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","interval::Interval","breaks::BreaksLeaf","diff::DiffBuilder","multiset::Segment","engine::RevId","delta::InsertDelta","engine::DeltaOp","rope::LinesMetric","spans::Span","rope::BaseMetric","tree::NodeBody","diff::DiffOp","multiset::ZipSegment","engine::Contents","rope::Utf16CodeUnitsMetric","rope::RopeInfo","spans::SpansInfo","engine::Error","spans::SpansLeaf","breaks::BreaksBaseMetric","find::CaseMatching","multiset::Subset","tree::Node"]},"spans::SpansLeaf":{"T":["find::CaseMatching","interval::Interval","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","multiset::Subset","spans::SpansInfo","tree::Node","engine::Contents","rope::LinesMetric","delta::DeltaElement","delta::Delta","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","tree::NodeBody","engine::Error","engine::DeltaOp","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric","breaks::BreaksLeaf","multiset::CountMatcher","spans::SpansLeaf","rope::RopeInfo","breaks::BreaksInfo","diff::DiffBuilder","spans::Span","tree::NodeVal","engine::FullPriority","engine::RevId","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::NodeBody<N>
+p0.clone();
+<tree::NodeBody<N> as std::clone::Clone>::clone(p0);
+crate::<tree::NodeBody<N> as std::clone::Clone>::clone(p0);
+<tree::NodeBody<N>>::clone(p0);
-----------------
rope/src/tree.rs <tree::NodeVal<N> as std::clone::Clone>::clone
deps:{"<tree::NodeVal<N> as std::clone::Clone>::clone":{"<N as tree::NodeInfo>::L":["std::clone::Clone"],"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<tree::NodeVal<N> as std::clone::Clone>::clone":{"<N as tree::NodeInfo>::L":["engine::Contents","breaks::BreaksInfo","breaks::BreaksMetric","rope::BaseMetric","multiset::CountMatcher","interval::Interval","diff::DiffOp","engine::DeltaOp","find::CaseMatching","delta::Delta","tree::NodeBody","tree::Node","multiset::Segment","rope::Utf16CodeUnitsMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","diff::DiffBuilder","breaks::BreaksLeaf","rope::LinesMetric","spans::SpansInfo","delta::InsertDelta","tree::NodeVal","engine::FullPriority","engine::Error","rope::RopeInfo","delta::DeltaElement","spans::SpansLeaf","engine::RevId","multiset::Subset","breaks::BreaksBaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["find::CaseMatching","interval::Interval","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","diff::DiffOp","breaks::BreaksLeaf","tree::NodeBody","diff::DiffBuilder","tree::NodeVal","breaks::BreaksInfo","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","engine::Error","delta::DeltaElement","multiset::ZipSegment","multiset::Subset","rope::Utf16CodeUnitsMetric","engine::DeltaOp","engine::Contents","delta::InsertDelta","multiset::CountMatcher","rope::RopeInfo","rope::BaseMetric","breaks::BreaksBaseMetric","engine::FullPriority","spans::SpansInfo","engine::RevId","spans::SpansLeaf","delta::Delta","tree::Node"]},"spans::SpansInfo":{"T":["breaks::BreaksBaseMetric","rope::LinesMetric","engine::Error","spans::SpansLeaf","spans::SpansInfo","tree::Node","multiset::CountMatcher","delta::InsertDelta","find::CaseMatching","engine::DeltaOp","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","rope::RopeInfo","engine::RevId","multiset::Segment","engine::FullPriority","delta::DeltaElement","diff::DiffOp","spans::Span","breaks::BreaksLeaf","delta::Delta","multiset::ZipSegment","breaks::BreaksInfo","tree::NodeVal","engine::Contents","interval::Interval","breaks::BreaksMetric","rope::BaseMetric","tree::NodeBody","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansLeaf":{"T":["interval::Interval","engine::Error","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","rope::RopeInfo","engine::Contents","multiset::Subset","breaks::BreaksBaseMetric","spans::SpansInfo","breaks::BreaksInfo","multiset::Segment","delta::InsertDelta","rope::BaseMetric","multiset::ZipSegment","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","tree::NodeBody","find::CaseMatching","multiset::CountMatcher","diff::DiffBuilder","rope::LinesMetric","tree::Node","tree::NodeVal","engine::FullPriority","breaks::BreaksMetric","engine::DeltaOp","breaks::BreaksLeaf","diff::DiffOp","delta::DeltaElement","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::NodeVal<N>
+p0.clone();
+<tree::NodeVal<N> as std::clone::Clone>::clone(p0);
+crate::<tree::NodeVal<N> as std::clone::Clone>::clone(p0);
+<tree::NodeVal<N>>::clone(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::from_leaf
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::from_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::Delta","diff::DiffBuilder","rope::LinesMetric","engine::Contents","multiset::ZipSegment","engine::RevId","diff::DiffOp","spans::Span","engine::DeltaOp","multiset::Segment","tree::Node","multiset::Subset","engine::Error","delta::InsertDelta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo","delta::DeltaElement","breaks::BreaksBaseMetric","engine::FullPriority","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","interval::Interval","rope::BaseMetric","breaks::BreaksMetric","tree::NodeBody","breaks::BreaksLeaf","find::CaseMatching"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","rope::LinesMetric","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","delta::Delta","find::CaseMatching","engine::DeltaOp","engine::Error","multiset::Subset","multiset::ZipSegment","interval::Interval","rope::RopeInfo","engine::FullPriority","spans::SpansLeaf","spans::Span","breaks::BreaksMetric","spans::SpansInfo","tree::NodeBody","engine::Contents","multiset::CountMatcher","tree::Node","delta::InsertDelta","rope::BaseMetric","delta::DeltaElement","engine::RevId","breaks::BreaksBaseMetric","diff::DiffOp","diff::DiffBuilder","multiset::Segment"]},"spans::SpansLeaf":{"T":["engine::FullPriority","multiset::Subset","tree::NodeVal","engine::DeltaOp","breaks::BreaksInfo","interval::Interval","find::CaseMatching","rope::RopeInfo","rope::BaseMetric","multiset::Segment","engine::Error","diff::DiffBuilder","tree::Node","delta::DeltaElement","multiset::ZipSegment","tree::NodeBody","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","delta::Delta","delta::InsertDelta","spans::Span","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffOp","spans::SpansInfo","breaks::BreaksBaseMetric","engine::Contents","engine::RevId","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::from_leaf":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
+tree::Node::<N>::from_leaf(p0);
+crate::tree::Node::<N>::from_leaf(p0);
+<tree::Node<N>>::from_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::from_nodes
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::Node::<N>::from_nodes":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","delta::InsertDelta","engine::FullPriority","diff::DiffBuilder","engine::Error","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","breaks::BreaksInfo","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","find::CaseMatching","breaks::BreaksMetric","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","tree::NodeVal","rope::LinesMetric","multiset::CountMatcher","multiset::ZipSegment","rope::RopeInfo","spans::SpansInfo","spans::Span","breaks::BreaksLeaf","delta::DeltaElement","delta::Delta","tree::Node","multiset::Subset","engine::RevId","diff::DiffOp","interval::Interval"]},"spans::SpansInfo":{"T":["multiset::Segment","multiset::ZipSegment","breaks::BreaksMetric","tree::NodeBody","engine::FullPriority","spans::Span","tree::NodeVal","find::CaseMatching","engine::Error","multiset::CountMatcher","rope::LinesMetric","engine::RevId","engine::DeltaOp","spans::SpansLeaf","delta::InsertDelta","delta::Delta","rope::RopeInfo","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","breaks::BreaksLeaf","delta::DeltaElement","tree::Node","spans::SpansInfo","rope::Utf16CodeUnitsMetric","rope::BaseMetric","diff::DiffBuilder","interval::Interval","breaks::BreaksInfo","diff::DiffOp","breaks::BreaksBaseMetric"]},"spans::SpansLeaf":{"T":["delta::Delta","breaks::BreaksMetric","multiset::CountMatcher","delta::DeltaElement","tree::Node","multiset::Segment","spans::SpansLeaf","breaks::BreaksInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","interval::Interval","rope::Utf16CodeUnitsMetric","rope::RopeInfo","diff::DiffBuilder","diff::DiffOp","breaks::BreaksBaseMetric","spans::Span","rope::LinesMetric","engine::Error","engine::DeltaOp","find::CaseMatching","engine::FullPriority","tree::NodeVal","rope::BaseMetric","delta::InsertDelta","multiset::ZipSegment","engine::Contents","engine::RevId","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::from_nodes":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<tree::Node<N>>
+tree::Node::<N>::from_nodes(p0);
+crate::tree::Node::<N>::from_nodes(p0);
+<tree::Node<N>>::from_nodes(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::len
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::Node::<N>::len":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","delta::Delta","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksBaseMetric","diff::DiffBuilder","tree::Node","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","rope::LinesMetric","diff::DiffOp","engine::DeltaOp","breaks::BreaksMetric","multiset::Segment","multiset::Subset","tree::NodeBody","delta::DeltaElement","spans::SpansInfo","engine::Contents","engine::FullPriority","engine::Error","find::CaseMatching","delta::InsertDelta","spans::SpansLeaf","rope::RopeInfo","tree::NodeVal","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansInfo":{"T":["multiset::Subset","delta::InsertDelta","tree::Node","engine::Contents","engine::DeltaOp","rope::BaseMetric","diff::DiffBuilder","find::CaseMatching","engine::FullPriority","breaks::BreaksBaseMetric","breaks::BreaksLeaf","spans::SpansLeaf","rope::RopeInfo","spans::Span","delta::Delta","engine::Error","rope::LinesMetric","multiset::ZipSegment","engine::RevId","interval::Interval","multiset::Segment","rope::Utf16CodeUnitsMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","diff::DiffOp","delta::DeltaElement","tree::NodeBody","multiset::CountMatcher","tree::NodeVal","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["interval::Interval","breaks::BreaksBaseMetric","multiset::Segment","spans::Span","spans::SpansLeaf","tree::NodeVal","delta::DeltaElement","spans::SpansInfo","engine::Error","find::CaseMatching","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","breaks::BreaksMetric","multiset::Subset","engine::RevId","engine::Contents","delta::Delta","engine::FullPriority","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","diff::DiffOp","rope::RopeInfo","diff::DiffBuilder","rope::LinesMetric","multiset::CountMatcher","engine::DeltaOp","tree::Node","multiset::ZipSegment","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::len":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.len();
+tree::Node::<N>::len(p0);
+crate::tree::Node::<N>::len(p0);
+<tree::Node<N>>::len(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::is_empty
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::Node::<N>::is_empty":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffOp","tree::NodeVal","engine::Error","delta::InsertDelta","spans::SpansLeaf","tree::Node","multiset::CountMatcher","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","interval::Interval","spans::SpansInfo","delta::Delta","engine::FullPriority","engine::DeltaOp","breaks::BreaksMetric","breaks::BreaksInfo","delta::DeltaElement","tree::NodeBody","rope::BaseMetric","breaks::BreaksBaseMetric","spans::Span","engine::RevId","multiset::Subset","diff::DiffBuilder","engine::Contents","multiset::Segment","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","breaks::BreaksMetric","diff::DiffOp","delta::InsertDelta","rope::Utf16CodeUnitsMetric","multiset::Segment","multiset::ZipSegment","breaks::BreaksBaseMetric","tree::NodeBody","engine::RevId","engine::Contents","rope::LinesMetric","spans::Span","engine::DeltaOp","delta::Delta","delta::DeltaElement","engine::Error","spans::SpansInfo","find::CaseMatching","diff::DiffBuilder","breaks::BreaksInfo","rope::BaseMetric","interval::Interval","rope::RopeInfo","tree::NodeVal","spans::SpansLeaf","multiset::CountMatcher","multiset::Subset","tree::Node","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::SpansLeaf":{"T":["delta::Delta","multiset::Subset","tree::NodeVal","interval::Interval","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","rope::LinesMetric","engine::RevId","breaks::BreaksInfo","spans::SpansInfo","diff::DiffOp","engine::FullPriority","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","spans::Span","tree::Node","engine::Error","spans::SpansLeaf","rope::RopeInfo","multiset::Segment","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","delta::DeltaElement","tree::NodeBody","engine::DeltaOp","diff::DiffBuilder","delta::InsertDelta","multiset::ZipSegment","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::is_empty":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_empty();
+tree::Node::<N>::is_empty(p0);
+crate::tree::Node::<N>::is_empty(p0);
+<tree::Node<N>>::is_empty(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::ptr_eq
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::Node::<N>::ptr_eq":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","delta::InsertDelta","spans::SpansInfo","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","multiset::ZipSegment","engine::Error","tree::Node","delta::DeltaElement","tree::NodeBody","spans::SpansLeaf","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","breaks::BreaksInfo","find::CaseMatching","breaks::BreaksLeaf","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","rope::LinesMetric","engine::Contents","multiset::Subset","multiset::Segment","interval::Interval","diff::DiffOp","diff::DiffBuilder","rope::RopeInfo","engine::FullPriority","breaks::BreaksBaseMetric","tree::NodeVal"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","engine::FullPriority","rope::LinesMetric","spans::Span","engine::Contents","multiset::CountMatcher","diff::DiffBuilder","engine::RevId","engine::Error","engine::DeltaOp","spans::SpansLeaf","rope::BaseMetric","rope::RopeInfo","delta::Delta","multiset::Subset","breaks::BreaksBaseMetric","find::CaseMatching","tree::NodeBody","diff::DiffOp","tree::Node","delta::InsertDelta","breaks::BreaksMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Segment","breaks::BreaksInfo","spans::SpansInfo","delta::DeltaElement","tree::NodeVal","breaks::BreaksLeaf","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","tree::NodeBody","delta::DeltaElement","diff::DiffBuilder","multiset::Segment","diff::DiffOp","delta::Delta","breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","spans::SpansLeaf","engine::DeltaOp","rope::BaseMetric","breaks::BreaksLeaf","multiset::CountMatcher","multiset::ZipSegment","multiset::Subset","rope::LinesMetric","engine::Contents","delta::InsertDelta","tree::Node","engine::FullPriority","rope::RopeInfo","engine::RevId","spans::SpansInfo","engine::Error","tree::NodeVal","spans::Span","find::CaseMatching","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::ptr_eq":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.ptr_eq(p1);
+tree::Node::<N>::ptr_eq(p0, p1);
+crate::tree::Node::<N>::ptr_eq(p0, p1);
+<tree::Node<N>>::ptr_eq(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::height
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::Node::<N>::height":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::InsertDelta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","multiset::Segment","spans::SpansInfo","delta::DeltaElement","engine::RevId","diff::DiffOp","rope::RopeInfo","diff::DiffBuilder","multiset::ZipSegment","rope::LinesMetric","interval::Interval","multiset::Subset","breaks::BreaksInfo","engine::Error","spans::SpansLeaf","engine::Contents","tree::NodeVal","tree::NodeBody","spans::Span","engine::FullPriority","breaks::BreaksMetric","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","find::CaseMatching","multiset::CountMatcher","delta::Delta"]},"spans::SpansInfo":{"T":["multiset::Segment","tree::NodeBody","engine::Error","delta::InsertDelta","engine::DeltaOp","delta::Delta","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::Contents","engine::FullPriority","tree::Node","multiset::CountMatcher","spans::Span","tree::NodeVal","rope::RopeInfo","multiset::Subset","diff::DiffOp","rope::BaseMetric","breaks::BreaksInfo","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","breaks::BreaksLeaf","multiset::ZipSegment","spans::SpansInfo","find::CaseMatching","rope::Utf16CodeUnitsMetric","delta::DeltaElement","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","diff::DiffOp","diff::DiffBuilder","breaks::BreaksInfo","rope::RopeInfo","engine::RevId","engine::DeltaOp","multiset::Segment","find::CaseMatching","delta::DeltaElement","tree::NodeBody","rope::LinesMetric","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","engine::FullPriority","tree::Node","multiset::CountMatcher","spans::Span","interval::Interval","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::SpansInfo","breaks::BreaksBaseMetric","breaks::BreaksLeaf","spans::SpansLeaf","engine::Error","delta::InsertDelta","multiset::Subset","engine::Contents","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::height":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.height();
+tree::Node::<N>::height(p0);
+crate::tree::Node::<N>::height(p0);
+<tree::Node<N>>::height(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::is_leaf
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::Node::<N>::is_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["tree::NodeBody","spans::SpansInfo","rope::LinesMetric","diff::DiffOp","spans::Span","engine::RevId","engine::Contents","engine::FullPriority","multiset::CountMatcher","spans::SpansLeaf","delta::InsertDelta","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksBaseMetric","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","multiset::Segment","interval::Interval","breaks::BreaksMetric","tree::Node","tree::NodeVal","breaks::BreaksLeaf","find::CaseMatching","breaks::BreaksInfo","multiset::Subset","rope::Utf16CodeUnitsMetric","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","engine::DeltaOp","rope::RopeInfo"]},"spans::SpansInfo":{"T":["engine::FullPriority","tree::Node","breaks::BreaksInfo","multiset::Subset","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","diff::DiffBuilder","engine::RevId","breaks::BreaksLeaf","interval::Interval","delta::Delta","multiset::ZipSegment","rope::BaseMetric","breaks::BreaksBaseMetric","engine::DeltaOp","spans::Span","delta::InsertDelta","engine::Contents","multiset::Segment","breaks::BreaksMetric","find::CaseMatching","tree::NodeBody","rope::Utf16CodeUnitsMetric","spans::SpansInfo","diff::DiffOp","rope::RopeInfo","spans::SpansLeaf","multiset::CountMatcher","delta::DeltaElement","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","tree::NodeBody","breaks::BreaksMetric","multiset::Segment","breaks::BreaksLeaf","delta::InsertDelta","spans::SpansLeaf","tree::NodeVal","rope::LinesMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher","delta::DeltaElement","rope::BaseMetric","find::CaseMatching","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","delta::Delta","engine::Error","breaks::BreaksInfo","diff::DiffBuilder","spans::Span","diff::DiffOp","tree::Node","interval::Interval","engine::RevId","spans::SpansInfo","rope::RopeInfo","multiset::ZipSegment","engine::FullPriority","engine::DeltaOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::is_leaf":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_leaf();
+tree::Node::<N>::is_leaf(p0);
+crate::tree::Node::<N>::is_leaf(p0);
+<tree::Node<N>>::is_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::interval
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::interval":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["tree::NodeVal","diff::DiffBuilder","engine::DeltaOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","engine::RevId","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksInfo","engine::FullPriority","find::CaseMatching","rope::LinesMetric","rope::RopeInfo","spans::SpansInfo","interval::Interval","engine::Error","breaks::BreaksBaseMetric","tree::NodeBody","delta::Delta","rope::Utf16CodeUnitsMetric","delta::InsertDelta","delta::DeltaElement","breaks::BreaksMetric","multiset::Subset","multiset::Segment","spans::SpansLeaf","diff::DiffOp","multiset::ZipSegment","spans::Span","tree::Node"]},"spans::SpansInfo":{"T":["engine::Error","delta::Delta","spans::SpansLeaf","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","delta::DeltaElement","spans::SpansInfo","multiset::Subset","multiset::Segment","multiset::CountMatcher","rope::LinesMetric","tree::NodeBody","breaks::BreaksMetric","diff::DiffBuilder","tree::Node","diff::DiffOp","find::CaseMatching","interval::Interval","breaks::BreaksBaseMetric","engine::DeltaOp","engine::Contents","breaks::BreaksLeaf","delta::InsertDelta","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","engine::RevId","breaks::BreaksInfo","spans::Span","tree::NodeVal","rope::RopeInfo"]},"spans::SpansLeaf":{"T":["engine::Contents","breaks::BreaksLeaf","breaks::BreaksInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","engine::DeltaOp","interval::Interval","spans::SpansLeaf","rope::LinesMetric","spans::Span","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","engine::FullPriority","rope::BaseMetric","multiset::Segment","tree::Node","engine::RevId","multiset::CountMatcher","diff::DiffBuilder","tree::NodeBody","delta::DeltaElement","rope::RopeInfo","delta::InsertDelta","find::CaseMatching","breaks::BreaksBaseMetric","tree::NodeVal","multiset::Subset","engine::Error","spans::SpansInfo","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::interval":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.interval();
+tree::Node::<N>::interval(p0);
+crate::tree::Node::<N>::interval(p0);
+<tree::Node<N>>::interval(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::get_children
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::Node::<N>::get_children":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["find::CaseMatching","tree::NodeVal","breaks::BreaksLeaf","engine::Contents","tree::Node","delta::DeltaElement","delta::InsertDelta","multiset::CountMatcher","engine::RevId","engine::FullPriority","rope::BaseMetric","spans::Span","rope::RopeInfo","spans::SpansLeaf","spans::SpansInfo","tree::NodeBody","delta::Delta","engine::Error","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","multiset::ZipSegment","breaks::BreaksMetric","multiset::Subset","breaks::BreaksBaseMetric","multiset::Segment","diff::DiffBuilder","rope::LinesMetric","interval::Interval","diff::DiffOp","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","delta::DeltaElement","delta::Delta","engine::Contents","tree::NodeBody","spans::Span","tree::Node","rope::RopeInfo","multiset::ZipSegment","rope::LinesMetric","diff::DiffOp","multiset::Segment","interval::Interval","delta::InsertDelta","breaks::BreaksBaseMetric","multiset::Subset","tree::NodeVal","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","spans::SpansInfo","engine::FullPriority","rope::BaseMetric","engine::Error","engine::RevId","breaks::BreaksLeaf","breaks::BreaksMetric","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","delta::DeltaElement","multiset::Segment","multiset::Subset","delta::Delta","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","tree::Node","multiset::ZipSegment","spans::Span","rope::LinesMetric","tree::NodeBody","breaks::BreaksMetric","multiset::CountMatcher","breaks::BreaksInfo","rope::RopeInfo","breaks::BreaksBaseMetric","engine::Error","engine::FullPriority","diff::DiffOp","engine::DeltaOp","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","spans::SpansInfo","interval::Interval","tree::NodeVal","spans::SpansLeaf","find::CaseMatching","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::get_children":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.get_children();
+tree::Node::<N>::get_children(p0);
+crate::tree::Node::<N>::get_children(p0);
+<tree::Node<N>>::get_children(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::get_leaf
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::get_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::Error","engine::RevId","find::CaseMatching","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::SpansInfo","engine::DeltaOp","breaks::BreaksInfo","tree::Node","multiset::CountMatcher","tree::NodeVal","diff::DiffOp","multiset::ZipSegment","engine::FullPriority","tree::NodeBody","delta::Delta","breaks::BreaksBaseMetric","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","delta::InsertDelta","multiset::Segment","rope::RopeInfo","spans::Span","interval::Interval","multiset::Subset","diff::DiffBuilder","rope::LinesMetric","delta::DeltaElement"]},"spans::SpansInfo":{"T":["multiset::Subset","engine::RevId","breaks::BreaksBaseMetric","engine::FullPriority","tree::NodeVal","delta::InsertDelta","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","engine::Contents","multiset::ZipSegment","diff::DiffBuilder","tree::Node","breaks::BreaksMetric","multiset::Segment","engine::DeltaOp","breaks::BreaksLeaf","spans::SpansInfo","delta::Delta","spans::SpansLeaf","spans::Span","rope::LinesMetric","find::CaseMatching","engine::Error","diff::DiffOp","rope::Utf16CodeUnitsMetric","rope::BaseMetric","delta::DeltaElement","breaks::BreaksInfo","multiset::CountMatcher","rope::RopeInfo"]},"spans::SpansLeaf":{"T":["tree::NodeVal","rope::BaseMetric","engine::Error","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","tree::NodeBody","diff::DiffOp","spans::SpansLeaf","spans::Span","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","engine::FullPriority","breaks::BreaksMetric","engine::Contents","find::CaseMatching","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksLeaf","rope::RopeInfo","interval::Interval","delta::Delta","spans::SpansInfo","tree::Node","multiset::Subset","breaks::BreaksInfo","multiset::Segment","delta::DeltaElement","delta::InsertDelta","rope::LinesMetric","engine::DeltaOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::get_leaf":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.get_leaf();
+tree::Node::<N>::get_leaf(p0);
+crate::tree::Node::<N>::get_leaf(p0);
+<tree::Node<N>>::get_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::with_leaf_mut
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::Node::<N>::with_leaf_mut":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized"],"impl FnOnce(&mut N::L) -> T":["std::marker::Sized","std::ops::FnOnce"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","engine::DeltaOp","diff::DiffOp","breaks::BreaksMetric","engine::Error","breaks::BreaksBaseMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansInfo","spans::SpansLeaf","engine::RevId","diff::DiffBuilder","rope::BaseMetric","tree::NodeVal","multiset::CountMatcher","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","rope::LinesMetric","delta::InsertDelta","multiset::Subset","breaks::BreaksLeaf","rope::RopeInfo","spans::Span","engine::FullPriority","engine::Contents","rope::Utf16CodeUnitsMetric","tree::NodeBody","multiset::Segment","multiset::ZipSegment","delta::Delta","find::CaseMatching"]},"spans::SpansInfo":{"T":["tree::NodeBody","engine::FullPriority","multiset::Subset","breaks::BreaksInfo","engine::RevId","delta::DeltaElement","engine::DeltaOp","diff::DiffOp","rope::LinesMetric","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","interval::Interval","diff::DiffBuilder","spans::SpansInfo","find::CaseMatching","breaks::BreaksBaseMetric","tree::Node","rope::RopeInfo","multiset::Segment","engine::Contents","rope::BaseMetric","delta::InsertDelta","delta::Delta","engine::Error","multiset::ZipSegment","multiset::CountMatcher","tree::NodeVal","spans::SpansLeaf","breaks::BreaksMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansLeaf":{"T":["multiset::Segment","spans::SpansLeaf","multiset::ZipSegment","interval::Interval","rope::LinesMetric","breaks::BreaksInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","breaks::BreaksBaseMetric","engine::Contents","rope::BaseMetric","engine::DeltaOp","find::CaseMatching","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::RevId","tree::Node","engine::Error","breaks::BreaksLeaf","tree::NodeVal","tree::NodeBody","diff::DiffBuilder","multiset::Subset","multiset::CountMatcher","spans::Span","engine::FullPriority","delta::DeltaElement","rope::RopeInfo","diff::DiffOp","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::with_leaf_mut":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"T":["RUG_ANY"],"impl FnOnce(&mut N::L) -> T":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut N::L) -> T
+p0.with_leaf_mut(p1);
+tree::Node::<N>::with_leaf_mut(p0, p1);
+crate::tree::Node::<N>::with_leaf_mut(p0, p1);
+<tree::Node<N>>::with_leaf_mut(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::is_ok_child
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::Node::<N>::is_ok_child":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::Span","rope::LinesMetric","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::Segment","breaks::BreaksInfo","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::Error","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","interval::Interval","engine::RevId","engine::Contents","engine::FullPriority","delta::Delta","tree::Node","breaks::BreaksLeaf","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","diff::DiffBuilder","spans::SpansLeaf","rope::RopeInfo","spans::SpansInfo","multiset::CountMatcher","delta::InsertDelta","delta::DeltaElement","diff::DiffOp","tree::NodeBody","find::CaseMatching"]},"spans::SpansInfo":{"T":["engine::Error","engine::DeltaOp","breaks::BreaksInfo","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","interval::Interval","spans::Span","tree::NodeBody","breaks::BreaksLeaf","rope::BaseMetric","breaks::BreaksMetric","spans::SpansLeaf","delta::DeltaElement","engine::FullPriority","tree::Node","multiset::ZipSegment","spans::SpansInfo","find::CaseMatching","delta::InsertDelta","multiset::Segment","multiset::Subset","engine::RevId","tree::NodeVal","engine::Contents","delta::Delta","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","diff::DiffBuilder","rope::RopeInfo","diff::DiffOp"]},"spans::SpansLeaf":{"T":["tree::NodeVal","spans::SpansLeaf","spans::Span","breaks::BreaksBaseMetric","multiset::Subset","diff::DiffBuilder","spans::SpansInfo","delta::Delta","engine::Error","multiset::ZipSegment","delta::InsertDelta","engine::DeltaOp","multiset::Segment","engine::RevId","tree::Node","rope::LinesMetric","engine::FullPriority","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","rope::BaseMetric","find::CaseMatching","engine::Contents","tree::NodeBody","breaks::BreaksLeaf","rope::RopeInfo","multiset::CountMatcher","interval::Interval","delta::DeltaElement","breaks::BreaksMetric","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::is_ok_child":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_ok_child();
+tree::Node::<N>::is_ok_child(p0);
+crate::tree::Node::<N>::is_ok_child(p0);
+<tree::Node<N>>::is_ok_child(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::merge_nodes
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::Node::<N>::merge_nodes":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","engine::FullPriority","multiset::CountMatcher","diff::DiffBuilder","spans::Span","interval::Interval","engine::Contents","breaks::BreaksLeaf","spans::SpansInfo","tree::NodeBody","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","delta::DeltaElement","multiset::Segment","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","engine::DeltaOp","engine::RevId","breaks::BreaksInfo","rope::RopeInfo","multiset::ZipSegment","multiset::Subset","rope::LinesMetric","tree::Node","breaks::BreaksBaseMetric","spans::SpansLeaf","diff::DiffOp","engine::Error"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","breaks::BreaksInfo","rope::BaseMetric","interval::Interval","engine::Contents","spans::SpansLeaf","delta::InsertDelta","diff::DiffOp","multiset::Subset","spans::Span","find::CaseMatching","tree::NodeVal","tree::Node","multiset::ZipSegment","tree::NodeBody","delta::Delta","rope::RopeInfo","diff::DiffBuilder","engine::DeltaOp","engine::Error","breaks::BreaksBaseMetric","rope::LinesMetric","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","multiset::Segment","multiset::CountMatcher","spans::SpansInfo","breaks::BreaksMetric","delta::DeltaElement","engine::RevId"]},"spans::SpansLeaf":{"T":["diff::DiffOp","breaks::BreaksLeaf","engine::FullPriority","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","rope::BaseMetric","spans::SpansInfo","rope::Utf16CodeUnitsMetric","delta::Delta","breaks::BreaksInfo","multiset::Segment","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","multiset::Subset","delta::DeltaElement","engine::RevId","spans::Span","diff::DiffBuilder","multiset::CountMatcher","tree::NodeVal","breaks::BreaksMetric","multiset::ZipSegment","engine::Error","find::CaseMatching","rope::RopeInfo","engine::DeltaOp","tree::Node","engine::Contents","delta::InsertDelta","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::merge_nodes":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [tree::Node<N>]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [tree::Node<N>]
+tree::Node::<N>::merge_nodes(p0, p1);
+crate::tree::Node::<N>::merge_nodes(p0, p1);
+<tree::Node<N>>::merge_nodes(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::merge_leaves
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::Node::<N>::merge_leaves":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","rope::LinesMetric","interval::Interval","spans::Span","engine::Contents","spans::SpansInfo","engine::DeltaOp","breaks::BreaksLeaf","delta::DeltaElement","diff::DiffBuilder","multiset::ZipSegment","diff::DiffOp","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","spans::SpansLeaf","delta::InsertDelta","tree::NodeVal","find::CaseMatching","multiset::Segment","engine::RevId","engine::FullPriority","tree::NodeBody","rope::BaseMetric","multiset::Subset","breaks::BreaksInfo","engine::Error","rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","delta::Delta","rope::LinesMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","delta::InsertDelta","spans::SpansLeaf","multiset::CountMatcher","tree::Node","breaks::BreaksMetric","engine::FullPriority","breaks::BreaksBaseMetric","rope::RopeInfo","engine::RevId","spans::Span","rope::BaseMetric","diff::DiffBuilder","engine::Error","engine::DeltaOp","spans::SpansInfo","engine::Contents","multiset::Segment","delta::DeltaElement","breaks::BreaksLeaf","diff::DiffOp","multiset::Subset","tree::NodeVal","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","interval::Interval"]},"spans::SpansLeaf":{"T":["spans::Span","find::CaseMatching","breaks::BreaksBaseMetric","rope::BaseMetric","rope::RopeInfo","multiset::ZipSegment","engine::Error","delta::Delta","interval::Interval","rope::Utf16CodeUnitsMetric","multiset::Segment","tree::NodeVal","engine::FullPriority","breaks::BreaksLeaf","multiset::CountMatcher","tree::NodeBody","multiset::Subset","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","delta::DeltaElement","engine::RevId","diff::DiffBuilder","engine::Contents","engine::DeltaOp","tree::Node","breaks::BreaksInfo","rope::LinesMetric","spans::SpansInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::merge_leaves":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+tree::Node::<N>::merge_leaves(p0, p1);
+crate::tree::Node::<N>::merge_leaves(p0, p1);
+<tree::Node<N>>::merge_leaves(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::concat
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::Node::<N>::concat":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","delta::Delta","breaks::BreaksBaseMetric","engine::DeltaOp","delta::InsertDelta","spans::Span","multiset::Subset","engine::Error","breaks::BreaksInfo","multiset::Segment","breaks::BreaksLeaf","delta::DeltaElement","tree::Node","rope::BaseMetric","diff::DiffOp","rope::RopeInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","engine::FullPriority","breaks::BreaksMetric","multiset::ZipSegment","find::CaseMatching","engine::Contents","rope::LinesMetric","engine::RevId","tree::NodeVal","tree::NodeBody","interval::Interval","rope::Utf16CodeUnitsMetric"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::Segment","find::CaseMatching","tree::NodeBody","spans::SpansInfo","rope::BaseMetric","diff::DiffBuilder","delta::Delta","breaks::BreaksMetric","multiset::Subset","engine::FullPriority","interval::Interval","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","engine::RevId","engine::Contents","rope::RopeInfo","engine::DeltaOp","multiset::CountMatcher","breaks::BreaksLeaf","delta::DeltaElement","engine::Error","rope::LinesMetric","breaks::BreaksBaseMetric","spans::SpansLeaf","tree::Node","spans::Span","breaks::BreaksInfo","diff::DiffOp"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","spans::SpansLeaf","multiset::Subset","tree::NodeBody","breaks::BreaksMetric","rope::BaseMetric","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","tree::Node","spans::Span","spans::SpansInfo","engine::DeltaOp","engine::Error","rope::RopeInfo","tree::NodeVal","multiset::Segment","breaks::BreaksLeaf","delta::DeltaElement","rope::LinesMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","breaks::BreaksBaseMetric","diff::DiffOp","multiset::CountMatcher","multiset::ZipSegment","find::CaseMatching","engine::FullPriority","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::concat":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+tree::Node::<N>::concat(p0, p1);
+crate::tree::Node::<N>::concat(p0, p1);
+<tree::Node<N>>::concat(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::measure
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::Node::<N>::measure":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","multiset::Subset","find::CaseMatching","breaks::BreaksLeaf","spans::SpansInfo","rope::LinesMetric","delta::InsertDelta","tree::NodeBody","tree::NodeVal","engine::RevId","delta::DeltaElement","breaks::BreaksBaseMetric","interval::Interval","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","engine::Contents","tree::Node","engine::FullPriority","multiset::ZipSegment","rope::RopeInfo","breaks::BreaksMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","diff::DiffBuilder","spans::Span","diff::DiffOp","spans::SpansLeaf","rope::BaseMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","tree::NodeVal","rope::Utf16CodeUnitsMetric","tree::NodeBody","spans::SpansLeaf","rope::RopeInfo","engine::Error","multiset::ZipSegment","interval::Interval","multiset::CountMatcher","breaks::BreaksBaseMetric","delta::Delta","engine::RevId","delta::InsertDelta","engine::FullPriority","multiset::Segment","breaks::BreaksLeaf","find::CaseMatching","spans::Span","spans::SpansInfo","rope::LinesMetric","diff::DiffBuilder","engine::DeltaOp","delta::DeltaElement","engine::Contents","diff::DiffOp","multiset::Subset","breaks::BreaksMetric","tree::Node","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["engine::Error","rope::BaseMetric","breaks::BreaksLeaf","engine::Contents","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","multiset::Subset","spans::Span","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","delta::InsertDelta","rope::RopeInfo","tree::Node","breaks::BreaksMetric","interval::Interval","diff::DiffOp","diff::DiffBuilder","engine::FullPriority","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::RevId","engine::DeltaOp","multiset::Segment","find::CaseMatching","delta::DeltaElement","tree::NodeBody","spans::SpansInfo","rope::LinesMetric","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::measure":{"M":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::LinesMetric"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.measure();
+tree::Node::<N>::measure(p0);
+crate::tree::Node::<N>::measure(p0);
+<tree::Node<N>>::measure(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::push_subseq
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::Node::<N>::push_subseq":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","delta::Delta","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","engine::Error","spans::SpansLeaf","tree::Node","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","engine::DeltaOp","delta::InsertDelta","delta::DeltaElement","multiset::Segment","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffOp","tree::NodeVal","interval::Interval","rope::BaseMetric","engine::RevId","spans::Span","spans::SpansInfo","rope::RopeInfo","diff::DiffBuilder","multiset::ZipSegment","engine::Contents","rope::LinesMetric","tree::NodeBody","engine::FullPriority"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","rope::LinesMetric","engine::RevId","interval::Interval","multiset::Segment","engine::Error","delta::DeltaElement","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","spans::SpansInfo","rope::Utf16CodeUnitsMetric","spans::Span","multiset::Subset","find::CaseMatching","breaks::BreaksInfo","tree::NodeVal","engine::FullPriority","engine::DeltaOp","diff::DiffBuilder","tree::Node","rope::RopeInfo","spans::SpansLeaf","multiset::CountMatcher","breaks::BreaksMetric","delta::Delta","breaks::BreaksBaseMetric","tree::NodeBody","engine::Contents","multiset::ZipSegment","delta::InsertDelta"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","spans::Span","find::CaseMatching","interval::Interval","engine::Error","rope::Utf16CodeUnitsMetric","multiset::Segment","tree::Node","multiset::Subset","breaks::BreaksLeaf","engine::RevId","breaks::BreaksInfo","tree::NodeBody","rope::RopeInfo","diff::DiffOp","multiset::ZipSegment","delta::DeltaElement","multiset::CountMatcher","delta::Delta","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","spans::SpansInfo","engine::FullPriority","engine::Contents","engine::DeltaOp","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksMetric","tree::NodeVal"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::push_subseq":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_subseq(p1, p2);
+tree::Node::<N>::push_subseq(p0, p1, p2);
+crate::tree::Node::<N>::push_subseq(p0, p1, p2);
+<tree::Node<N>>::push_subseq(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Node::<N>::subseq
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::Node::<N>::subseq":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized","interval::IntervalBounds"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","multiset::Segment","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","engine::Contents","multiset::Subset","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","rope::RopeInfo","find::CaseMatching","engine::Error","diff::DiffOp","interval::Interval","breaks::BreaksBaseMetric","tree::NodeBody","breaks::BreaksLeaf","multiset::ZipSegment","tree::NodeVal","delta::InsertDelta","rope::BaseMetric","delta::Delta","diff::DiffBuilder","rope::LinesMetric","spans::SpansInfo","engine::FullPriority","engine::DeltaOp","delta::DeltaElement","tree::Node","breaks::BreaksInfo","spans::Span"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","delta::Delta","breaks::BreaksInfo","spans::SpansLeaf","find::CaseMatching","engine::FullPriority","multiset::CountMatcher","spans::Span","multiset::Subset","engine::Error","breaks::BreaksBaseMetric","rope::LinesMetric","rope::RopeInfo","diff::DiffBuilder","multiset::ZipSegment","rope::BaseMetric","rope::Utf16CodeUnitsMetric","engine::RevId","tree::Node","breaks::BreaksLeaf","spans::SpansInfo","delta::InsertDelta","diff::DiffOp","interval::Interval","breaks::BreaksMetric","engine::DeltaOp","multiset::Segment","tree::NodeVal","tree::NodeBody","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["engine::RevId","breaks::BreaksMetric","multiset::Subset","delta::Delta","engine::Contents","multiset::ZipSegment","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo","interval::Interval","spans::Span","engine::DeltaOp","breaks::BreaksBaseMetric","rope::LinesMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","spans::SpansInfo","breaks::BreaksLeaf","multiset::Segment","delta::DeltaElement","engine::FullPriority","rope::BaseMetric","find::CaseMatching","delta::InsertDelta","tree::Node","diff::DiffOp","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","multiset::CountMatcher","tree::NodeVal"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::subseq":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"T":["std::ops::RangeFull","<T as interval::IntervalBounds>","std::ops::RangeFrom"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.subseq(p1);
+tree::Node::<N>::subseq(p0, p1);
+crate::tree::Node::<N>::subseq(p0, p1);
+<tree::Node<N>>::subseq(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::edit
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::Node::<N>::edit":{"IV":["std::marker::Sized","interval::IntervalBounds"],"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","std::convert::Into"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","spans::SpansInfo","delta::Delta","delta::DeltaElement","rope::RopeInfo","multiset::CountMatcher","rope::LinesMetric","interval::Interval","breaks::BreaksInfo","engine::FullPriority","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","multiset::Segment","tree::NodeBody","diff::DiffBuilder","spans::Span","engine::RevId","find::CaseMatching","spans::SpansLeaf","multiset::Subset","engine::Error","delta::InsertDelta","engine::Contents","rope::BaseMetric","tree::NodeVal","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","diff::DiffOp","tree::Node"]},"spans::SpansInfo":{"T":["engine::DeltaOp","diff::DiffBuilder","engine::FullPriority","multiset::Subset","rope::RopeInfo","breaks::BreaksMetric","breaks::BreaksLeaf","spans::SpansLeaf","breaks::BreaksBaseMetric","tree::NodeBody","tree::Node","engine::Contents","diff::DiffOp","delta::Delta","delta::DeltaElement","interval::Interval","multiset::ZipSegment","spans::Span","engine::RevId","rope::BaseMetric","engine::Error","delta::InsertDelta","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","tree::NodeVal","spans::SpansInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","multiset::CountMatcher","find::CaseMatching"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","delta::InsertDelta","engine::FullPriority","engine::Contents","diff::DiffBuilder","engine::DeltaOp","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","engine::RevId","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","breaks::BreaksBaseMetric","multiset::Segment","rope::RopeInfo","multiset::CountMatcher","find::CaseMatching","diff::DiffOp","multiset::Subset","delta::DeltaElement","rope::BaseMetric","spans::SpansInfo","breaks::BreaksInfo","tree::NodeVal","breaks::BreaksLeaf","tree::NodeBody","engine::Error","interval::Interval","rope::LinesMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::edit":{"IV":["std::ops::RangeFrom","std::ops::RangeFull","<T as interval::IntervalBounds>"],"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"],"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // IV
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.edit(p1, p2);
+tree::Node::<N>::edit(p0, p1, p2);
+crate::tree::Node::<N>::edit(p0, p1, p2);
+<tree::Node<N>>::edit(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Node::<N>::convert_metrics
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::Node::<N>::convert_metrics":{"M1":["std::marker::Sized","tree::Metric"],"M2":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","spans::Span","rope::LinesMetric","rope::RopeInfo","tree::NodeVal","engine::RevId","delta::DeltaElement","interval::Interval","breaks::BreaksInfo","engine::DeltaOp","multiset::Segment","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","diff::DiffOp","delta::InsertDelta","spans::SpansLeaf","find::CaseMatching","engine::Contents","diff::DiffBuilder","tree::Node","multiset::Subset","spans::SpansInfo","engine::Error","breaks::BreaksBaseMetric"]},"spans::SpansInfo":{"T":["engine::Error","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","spans::SpansInfo","breaks::BreaksInfo","delta::Delta","rope::BaseMetric","tree::NodeBody","breaks::BreaksLeaf","find::CaseMatching","tree::NodeVal","spans::Span","engine::DeltaOp","rope::LinesMetric","diff::DiffBuilder","delta::InsertDelta","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","multiset::Subset","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::FullPriority","tree::Node","engine::RevId","breaks::BreaksMetric","rope::RopeInfo","interval::Interval","spans::SpansLeaf","diff::DiffOp","engine::Contents"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::Subset","delta::InsertDelta","breaks::BreaksBaseMetric","tree::Node","engine::Error","breaks::BreaksLeaf","multiset::Segment","breaks::BreaksInfo","find::CaseMatching","engine::DeltaOp","multiset::ZipSegment","multiset::CountMatcher","tree::NodeVal","delta::Delta","engine::FullPriority","delta::DeltaElement","spans::SpansInfo","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","rope::RopeInfo","spans::SpansLeaf","spans::Span","rope::LinesMetric","breaks::BreaksMetric","tree::NodeBody","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::convert_metrics":{"M1":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"M2":["rope::BaseMetric","rope::LinesMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.convert_metrics(p1);
+tree::Node::<N>::convert_metrics(p0, p1);
+crate::tree::Node::<N>::convert_metrics(p0, p1);
+<tree::Node<N>>::convert_metrics(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::count
deps:{"tree::Node::<N>::count":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::DefaultMetric"]}}
candidates:{"tree::Node::<N>::count":{"M":["breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.count(p1);
+tree::Node::<N>::count(p0, p1);
+crate::tree::Node::<N>::count(p0, p1);
+<tree::Node<N>>::count(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::count_base_units
deps:{"tree::Node::<N>::count_base_units":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::DefaultMetric"]}}
candidates:{"tree::Node::<N>::count_base_units":{"M":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.count_base_units(p1);
+tree::Node::<N>::count_base_units(p0, p1);
+crate::tree::Node::<N>::count_base_units(p0, p1);
+<tree::Node<N>>::count_base_units(p0, p1);
-----------------
rope/src/tree.rs <tree::Node<N> as std::default::Default>::default
deps:{"<tree::Node<N> as std::default::Default>::default":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"<tree::Node<N> as std::default::Default>::default":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::DeltaOp","engine::Error","tree::Node","breaks::BreaksMetric","tree::NodeBody","delta::Delta","spans::SpansInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","spans::Span","engine::Contents","rope::BaseMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","delta::InsertDelta","find::CaseMatching","multiset::Segment","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","tree::NodeVal","rope::LinesMetric","engine::FullPriority","interval::Interval","delta::DeltaElement","rope::RopeInfo","engine::RevId","breaks::BreaksBaseMetric","multiset::ZipSegment","breaks::BreaksInfo","diff::DiffOp"]},"spans::SpansInfo":{"T":["spans::SpansInfo","breaks::BreaksMetric","multiset::ZipSegment","multiset::Subset","diff::DiffOp","tree::NodeVal","find::CaseMatching","breaks::BreaksLeaf","multiset::Segment","interval::Interval","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::FullPriority","rope::Utf16CodeUnitsMetric","tree::NodeBody","rope::BaseMetric","delta::Delta","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Error","tree::Node","delta::InsertDelta","engine::Contents","delta::DeltaElement","rope::LinesMetric","rope::RopeInfo","engine::RevId","breaks::BreaksInfo","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","breaks::BreaksInfo","multiset::Subset","spans::Span","engine::FullPriority","rope::LinesMetric","engine::Error","tree::NodeBody","spans::SpansLeaf","diff::DiffBuilder","breaks::BreaksLeaf","interval::Interval","multiset::Segment","multiset::ZipSegment","rope::RopeInfo","delta::InsertDelta","delta::DeltaElement","delta::Delta","tree::Node","spans::SpansInfo","breaks::BreaksMetric","engine::RevId","multiset::CountMatcher","rope::BaseMetric","diff::DiffOp","breaks::BreaksBaseMetric","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
+<tree::Node<N> as std::default::Default>::default();
+crate::<tree::Node<N> as std::default::Default>::default();
+<tree::Node<N>>::default();
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::new
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::TreeBuilder::<N>::new":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","engine::DeltaOp","diff::DiffOp","delta::Delta","interval::Interval","tree::NodeBody","rope::Utf16CodeUnitsMetric","tree::NodeVal","engine::FullPriority","spans::SpansLeaf","rope::LinesMetric","delta::InsertDelta","engine::Error","tree::Node","rope::BaseMetric","breaks::BreaksInfo","spans::Span","multiset::Segment","diff::DiffBuilder","breaks::BreaksMetric","engine::Contents","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksBaseMetric","find::CaseMatching","engine::RevId","spans::SpansInfo"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","multiset::Subset","tree::NodeVal","tree::Node","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","find::CaseMatching","tree::NodeBody","interval::Interval","breaks::BreaksInfo","spans::SpansLeaf","rope::LinesMetric","multiset::CountMatcher","engine::FullPriority","engine::Contents","engine::DeltaOp","breaks::BreaksLeaf","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksMetric","delta::Delta","diff::DiffOp","delta::DeltaElement","engine::RevId","spans::Span","engine::Error","delta::InsertDelta","multiset::Segment","rope::BaseMetric","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["engine::Contents","delta::Delta","breaks::BreaksMetric","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksBaseMetric","tree::NodeBody","delta::InsertDelta","rope::LinesMetric","breaks::BreaksInfo","tree::NodeVal","multiset::Segment","rope::RopeInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","delta::DeltaElement","breaks::BreaksLeaf","spans::SpansInfo","engine::DeltaOp","tree::Node","find::CaseMatching","spans::Span","interval::Interval","rope::Utf16CodeUnitsMetric","engine::RevId","spans::SpansLeaf","engine::Error","multiset::ZipSegment","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::TreeBuilder::<N>::new":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
+tree::TreeBuilder::<N>::new();
+crate::tree::TreeBuilder::<N>::new();
+<tree::TreeBuilder<N>>::new();
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::TreeBuilder::<N>::push":{"N":["tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","rope::LinesMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","multiset::Segment","spans::SpansInfo","engine::RevId","delta::Delta","rope::BaseMetric","engine::Error","tree::NodeBody","spans::SpansLeaf","breaks::BreaksMetric","engine::DeltaOp","breaks::BreaksInfo","rope::RopeInfo","spans::Span","engine::FullPriority","engine::Contents","breaks::BreaksBaseMetric","find::CaseMatching","interval::Interval","tree::NodeVal","multiset::CountMatcher","tree::Node","multiset::ZipSegment","diff::DiffOp","delta::DeltaElement","diff::DiffBuilder","multiset::Subset"]},"spans::SpansInfo":{"T":["rope::BaseMetric","engine::FullPriority","tree::Node","multiset::Segment","rope::RopeInfo","breaks::BreaksBaseMetric","multiset::ZipSegment","engine::Contents","spans::Span","multiset::CountMatcher","interval::Interval","tree::NodeVal","multiset::Subset","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","rope::LinesMetric","engine::Error","engine::RevId","breaks::BreaksInfo","delta::DeltaElement","delta::Delta","rope::Utf16CodeUnitsMetric","spans::SpansInfo","breaks::BreaksMetric","tree::NodeBody","delta::InsertDelta","breaks::BreaksLeaf","find::CaseMatching","engine::DeltaOp","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["engine::Contents","engine::RevId","delta::InsertDelta","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::Delta","multiset::Segment","tree::NodeVal","engine::DeltaOp","breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","tree::NodeBody","spans::Span","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","tree::Node","breaks::BreaksLeaf","rope::BaseMetric","multiset::Subset","engine::FullPriority","spans::SpansInfo","multiset::CountMatcher","diff::DiffOp","breaks::BreaksBaseMetric","find::CaseMatching","spans::SpansLeaf","engine::Error","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::TreeBuilder::<N>::push":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.push(p1);
+tree::TreeBuilder::<N>::push(p0, p1);
+crate::tree::TreeBuilder::<N>::push(p0, p1);
+<tree::TreeBuilder<N>>::push(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaves
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::cached::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"delta::DeletionsIter":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertsIter":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpanIter":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::TreeBuilder::<N>::push_leaves":{"N":["std::marker::Sized","tree::NodeInfo"],"impl IntoIterator<Item = N::L>":["std::marker::Sized","std::iter::IntoIterator"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::cached::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["delta::DeletionsIter","rope::LinesRaw","rope::ChunkIter","multiset::RangeIter","<&mut I as std::iter::Iterator>","tree::CursorIter","spans::SpanIter","multiset::ZipIter","rope::Lines","delta::InsertsIter"]},"delta::DeletionsIter":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertsIter":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","tree::NodeVal","engine::Contents","rope::BaseMetric","engine::Error","find::CaseMatching","multiset::Subset","multiset::CountMatcher","engine::FullPriority","tree::Node","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","diff::DiffOp","delta::InsertDelta","delta::DeltaElement","spans::SpansLeaf","interval::Interval","engine::RevId","spans::Span","rope::RopeInfo","diff::DiffBuilder","multiset::Segment","multiset::ZipSegment","engine::DeltaOp","rope::LinesMetric","delta::Delta","tree::NodeBody","breaks::BreaksBaseMetric","breaks::BreaksMetric"]},"spans::SpanIter":{"T":["diff::DiffOp","spans::Span","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::SpansInfo","multiset::CountMatcher","engine::DeltaOp","engine::FullPriority","breaks::BreaksBaseMetric","engine::Contents","multiset::Subset","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","multiset::Segment","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","breaks::BreaksInfo","delta::Delta","rope::RopeInfo","tree::NodeVal","diff::DiffBuilder","tree::Node","engine::Error","find::CaseMatching","spans::SpansLeaf","rope::BaseMetric","delta::DeltaElement","rope::LinesMetric","tree::NodeBody","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","engine::FullPriority","engine::RevId","tree::Node","tree::NodeBody","rope::RopeInfo","rope::BaseMetric","spans::Span","multiset::ZipSegment","tree::NodeVal","delta::DeltaElement","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::CountMatcher","diff::DiffBuilder","spans::SpansInfo","breaks::BreaksBaseMetric","multiset::Segment","breaks::BreaksLeaf","interval::Interval","find::CaseMatching","rope::LinesMetric","breaks::BreaksMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","multiset::Subset","delta::InsertDelta","spans::SpansLeaf","delta::Delta","engine::Error"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","engine::RevId","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","multiset::Segment","multiset::ZipSegment","engine::FullPriority","spans::SpansLeaf","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","delta::Delta","breaks::BreaksBaseMetric","tree::NodeVal","rope::RopeInfo","breaks::BreaksMetric","engine::Error","interval::Interval","delta::DeltaElement","rope::LinesMetric","multiset::Subset","engine::Contents","diff::DiffBuilder","spans::SpansInfo","breaks::BreaksInfo","spans::Span","breaks::BreaksLeaf","diff::DiffOp","multiset::CountMatcher","tree::NodeBody","find::CaseMatching"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter":{"M":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::LinesMetric","rope::BaseMetric"],"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::TreeBuilder::<N>::push_leaves":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"impl IntoIterator<Item = N::L>":["&'a std::path::Path","std::sync::mpsc::Receiver<T>","&'a std::path::PathBuf","std::result::Result<T, E>","std::collections::HashSet<T, S>","std::collections::BTreeMap<K, V, A>","std::collections::HashMap<K, V, S>","std::collections::LinkedList<T>","std::collections::BinaryHeap<T>","std::collections::BTreeSet<T, A>","std::collections::VecDeque<T, A>","std::vec::Vec<T, A>","&'a std::os::unix::net::UnixListener","<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","std::option::Option<T>","<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl IntoIterator<Item = N::L>
+p0.push_leaves(p1);
+tree::TreeBuilder::<N>::push_leaves(p0, p1);
+crate::tree::TreeBuilder::<N>::push_leaves(p0, p1);
+<tree::TreeBuilder<N>>::push_leaves(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaf
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::TreeBuilder::<N>::push_leaf":{"N":["tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansLeaf","diff::DiffBuilder","multiset::Subset","spans::SpansInfo","tree::NodeVal","engine::RevId","engine::DeltaOp","engine::FullPriority","tree::Node","delta::Delta","multiset::ZipSegment","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","breaks::BreaksLeaf","spans::Span","delta::DeltaElement","multiset::Segment","multiset::CountMatcher","rope::RopeInfo","tree::NodeBody","rope::Utf16CodeUnitsMetric","interval::Interval","breaks::BreaksBaseMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","engine::Contents","rope::BaseMetric"]},"spans::SpansInfo":{"T":["engine::Error","spans::SpansLeaf","engine::DeltaOp","rope::LinesMetric","diff::DiffBuilder","find::CaseMatching","multiset::Subset","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","diff::DiffOp","engine::RevId","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","tree::Node","breaks::BreaksLeaf","spans::Span","delta::Delta","engine::FullPriority","engine::Contents","tree::NodeVal","multiset::ZipSegment","spans::SpansInfo","rope::RopeInfo","tree::NodeBody","delta::DeltaElement","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksMetric","multiset::Segment","delta::InsertDelta"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","engine::Contents","find::CaseMatching","diff::DiffBuilder","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","tree::NodeVal","engine::FullPriority","diff::DiffOp","spans::Span","interval::Interval","multiset::Segment","rope::LinesMetric","breaks::BreaksInfo","multiset::CountMatcher","tree::NodeBody","spans::SpansInfo","spans::SpansLeaf","multiset::Subset","engine::Error","rope::BaseMetric","multiset::ZipSegment","delta::Delta","tree::Node","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","engine::RevId","breaks::BreaksLeaf","delta::DeltaElement","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::TreeBuilder::<N>::push_leaf":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
+p0.push_leaf(p1);
+tree::TreeBuilder::<N>::push_leaf(p0, p1);
+crate::tree::TreeBuilder::<N>::push_leaf(p0, p1);
+<tree::TreeBuilder<N>>::push_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaf_slice
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::TreeBuilder::<N>::push_leaf_slice":{"N":["tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::ZipSegment","breaks::BreaksLeaf","multiset::CountMatcher","engine::Contents","rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::Subset","engine::FullPriority","delta::Delta","tree::NodeBody","breaks::BreaksMetric","diff::DiffOp","rope::BaseMetric","engine::DeltaOp","spans::SpansLeaf","engine::Error","spans::SpansInfo","tree::Node","find::CaseMatching","engine::RevId","delta::InsertDelta","breaks::BreaksInfo","tree::NodeVal","interval::Interval","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","delta::DeltaElement","breaks::BreaksBaseMetric","spans::Span","rope::LinesMetric"]},"spans::SpansInfo":{"T":["multiset::Segment","engine::DeltaOp","rope::Utf16CodeUnitsMetric","tree::NodeBody","engine::RevId","breaks::BreaksInfo","diff::DiffOp","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::FullPriority","delta::InsertDelta","rope::LinesMetric","find::CaseMatching","delta::Delta","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksLeaf","multiset::ZipSegment","multiset::Subset","rope::RopeInfo","interval::Interval","tree::NodeVal","engine::Contents","engine::Error","breaks::BreaksMetric","spans::SpansInfo","tree::Node","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","delta::Delta","rope::BaseMetric","engine::Contents","breaks::BreaksBaseMetric","interval::Interval","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","spans::SpansInfo","diff::DiffOp","multiset::Segment","diff::DiffBuilder","tree::NodeBody","tree::NodeVal","engine::Error","delta::DeltaElement","rope::LinesMetric","engine::FullPriority","breaks::BreaksMetric","breaks::BreaksInfo","multiset::ZipSegment","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","engine::DeltaOp","multiset::Subset","tree::Node","engine::RevId","find::CaseMatching","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::TreeBuilder::<N>::push_leaf_slice":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_leaf_slice(p1, p2);
+tree::TreeBuilder::<N>::push_leaf_slice(p0, p1, p2);
+crate::tree::TreeBuilder::<N>::push_leaf_slice(p0, p1, p2);
+<tree::TreeBuilder<N>>::push_leaf_slice(p0, p1, p2);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::build
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::TreeBuilder::<N>::build":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","tree::NodeBody","multiset::Segment","diff::DiffBuilder","breaks::BreaksBaseMetric","multiset::Subset","delta::InsertDelta","engine::Error","delta::DeltaElement","breaks::BreaksMetric","find::CaseMatching","spans::SpansInfo","tree::Node","engine::RevId","rope::LinesMetric","interval::Interval","breaks::BreaksLeaf","delta::Delta","engine::Contents","rope::BaseMetric","engine::FullPriority","spans::Span","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","engine::DeltaOp","tree::NodeVal","rope::RopeInfo"]},"spans::SpansInfo":{"T":["multiset::ZipSegment","tree::NodeBody","multiset::Segment","delta::DeltaElement","find::CaseMatching","engine::DeltaOp","spans::SpansInfo","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","rope::RopeInfo","interval::Interval","diff::DiffBuilder","engine::Error","delta::Delta","spans::SpansLeaf","multiset::Subset","breaks::BreaksInfo","rope::BaseMetric","engine::Contents","breaks::BreaksBaseMetric","diff::DiffOp","engine::FullPriority","breaks::BreaksLeaf","tree::Node","breaks::BreaksMetric","spans::Span","delta::InsertDelta","engine::RevId","rope::Utf16CodeUnitsMetric","multiset::CountMatcher"]},"spans::SpansLeaf":{"T":["find::CaseMatching","diff::DiffOp","tree::NodeVal","multiset::ZipSegment","diff::DiffBuilder","rope::LinesMetric","tree::Node","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","engine::RevId","rope::BaseMetric","delta::DeltaElement","rope::RopeInfo","multiset::Subset","tree::NodeBody","breaks::BreaksInfo","breaks::BreaksMetric","breaks::BreaksLeaf","multiset::CountMatcher","engine::FullPriority","engine::Contents","spans::SpansInfo","delta::InsertDelta","interval::Interval","engine::Error","multiset::Segment","spans::SpansLeaf","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::TreeBuilder::<N>::build":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
+p0.build();
+tree::TreeBuilder::<N>::build(p0);
+crate::tree::TreeBuilder::<N>::build(p0);
+<tree::TreeBuilder<N>>::build(p0);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::pop
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::TreeBuilder::<N>::pop":{"N":["tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::Contents","tree::NodeBody","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","multiset::CountMatcher","rope::BaseMetric","diff::DiffOp","tree::Node","diff::DiffBuilder","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","engine::FullPriority","breaks::BreaksMetric","engine::Error","spans::SpansLeaf","delta::Delta","multiset::Subset","delta::InsertDelta","breaks::BreaksLeaf","engine::RevId","spans::SpansInfo","breaks::BreaksInfo","multiset::Segment","rope::LinesMetric","tree::NodeVal","interval::Interval","breaks::BreaksBaseMetric","find::CaseMatching","multiset::ZipSegment","rope::RopeInfo","delta::DeltaElement"]},"spans::SpansInfo":{"T":["rope::LinesMetric","multiset::ZipSegment","engine::FullPriority","spans::SpansLeaf","rope::RopeInfo","tree::NodeVal","tree::NodeBody","breaks::BreaksLeaf","delta::DeltaElement","engine::Error","breaks::BreaksBaseMetric","multiset::CountMatcher","spans::Span","rope::Utf16CodeUnitsMetric","rope::BaseMetric","tree::Node","engine::Contents","engine::RevId","delta::Delta","find::CaseMatching","breaks::BreaksInfo","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","engine::DeltaOp","interval::Interval","breaks::BreaksMetric","diff::DiffBuilder","multiset::Segment","multiset::Subset","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","breaks::BreaksBaseMetric","interval::Interval","rope::RopeInfo","multiset::Subset","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","tree::NodeVal","tree::Node","engine::Error","multiset::Segment","engine::FullPriority","breaks::BreaksInfo","rope::BaseMetric","tree::NodeBody","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","spans::SpansLeaf","delta::InsertDelta","delta::Delta","engine::Contents","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksLeaf","spans::Span","find::CaseMatching","engine::DeltaOp","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::TreeBuilder::<N>::pop":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
+p0.pop();
+tree::TreeBuilder::<N>::pop(p0);
+crate::tree::TreeBuilder::<N>::pop(p0);
+<tree::TreeBuilder<N>>::pop(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::new
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::new":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::DeltaOp","spans::Span","engine::FullPriority","breaks::BreaksInfo","delta::DeltaElement","multiset::Segment","rope::RopeInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","breaks::BreaksMetric","diff::DiffOp","engine::Error","engine::RevId","multiset::Subset","diff::DiffBuilder","breaks::BreaksBaseMetric","tree::Node","delta::InsertDelta","interval::Interval","rope::LinesMetric","multiset::CountMatcher","spans::SpansInfo","tree::NodeBody","tree::NodeVal","engine::Contents","delta::Delta","spans::SpansLeaf","multiset::ZipSegment","rope::BaseMetric","rope::Utf16CodeUnitsMetric"]},"spans::SpansInfo":{"T":["rope::RopeInfo","engine::DeltaOp","breaks::BreaksMetric","diff::DiffOp","multiset::Subset","delta::DeltaElement","interval::Interval","spans::Span","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","multiset::CountMatcher","spans::SpansLeaf","engine::FullPriority","spans::SpansInfo","tree::NodeVal","rope::BaseMetric","delta::Delta","multiset::ZipSegment","diff::DiffBuilder","breaks::BreaksBaseMetric","tree::NodeBody","multiset::Segment","rope::LinesMetric","engine::Contents","engine::Error","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","breaks::BreaksInfo","engine::RevId"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","engine::Error","engine::Contents","breaks::BreaksInfo","multiset::Subset","multiset::ZipSegment","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","delta::InsertDelta","tree::Node","diff::DiffBuilder","rope::LinesMetric","spans::SpansLeaf","engine::DeltaOp","spans::Span","multiset::Segment","breaks::BreaksLeaf","find::CaseMatching","tree::NodeVal","engine::FullPriority","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","tree::NodeBody","spans::SpansInfo","delta::DeltaElement","engine::RevId","breaks::BreaksMetric","delta::Delta","breaks::BreaksBaseMetric","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::new":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+tree::Cursor::<'a, N>::new(p0, p1);
+crate::tree::Cursor::<'a, N>::new(p0, p1);
+<tree::Cursor<'a, N>>::new(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::total_len
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::total_len":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","tree::NodeBody","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","engine::RevId","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","multiset::Subset","tree::NodeVal","rope::Utf16CodeUnitsMetric","rope::BaseMetric","engine::Contents","multiset::CountMatcher","spans::Span","engine::DeltaOp","multiset::Segment","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::Interval","breaks::BreaksMetric","multiset::ZipSegment","delta::DeltaElement","engine::Error","delta::Delta","rope::RopeInfo","engine::FullPriority","breaks::BreaksLeaf","diff::DiffBuilder","rope::LinesMetric","spans::SpansInfo"]},"spans::SpansInfo":{"T":["spans::Span","engine::FullPriority","delta::DeltaElement","multiset::Subset","breaks::BreaksLeaf","spans::SpansLeaf","breaks::BreaksInfo","delta::InsertDelta","multiset::ZipSegment","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","engine::Contents","spans::SpansInfo","rope::BaseMetric","tree::NodeBody","engine::Error","delta::Delta","find::CaseMatching","multiset::Segment","engine::DeltaOp","interval::Interval","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::LinesMetric","engine::RevId","rope::RopeInfo","multiset::CountMatcher","tree::NodeVal","rope::Utf16CodeUnitsMetric","tree::Node"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","spans::SpansInfo","breaks::BreaksLeaf","rope::BaseMetric","delta::DeltaElement","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","diff::DiffOp","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","tree::Node","diff::DiffBuilder","spans::SpansLeaf","spans::Span","multiset::CountMatcher","engine::DeltaOp","engine::RevId","tree::NodeVal","delta::InsertDelta","rope::LinesMetric","find::CaseMatching","tree::NodeBody","engine::FullPriority","engine::Contents","engine::Error","rope::RopeInfo","breaks::BreaksInfo","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::total_len":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.total_len();
+tree::Cursor::<'a, N>::total_len(p0);
+crate::tree::Cursor::<'a, N>::total_len(p0);
+<tree::Cursor<'a, N>>::total_len(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::root
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::root":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::DeltaElement","multiset::Subset","breaks::BreaksBaseMetric","tree::Node","interval::Interval","breaks::BreaksLeaf","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","spans::Span","find::CaseMatching","engine::Contents","rope::Utf16CodeUnitsMetric","engine::Error","spans::SpansInfo","diff::DiffOp","rope::BaseMetric","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksInfo","engine::FullPriority","tree::NodeVal","breaks::BreaksMetric","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","tree::NodeBody","rope::RopeInfo","delta::Delta","spans::SpansLeaf","diff::DiffBuilder","engine::RevId"]},"spans::SpansInfo":{"T":["find::CaseMatching","delta::Delta","spans::Span","rope::LinesMetric","breaks::BreaksMetric","engine::FullPriority","rope::BaseMetric","diff::DiffOp","delta::InsertDelta","tree::NodeBody","multiset::Segment","multiset::Subset","rope::RopeInfo","interval::Interval","engine::RevId","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","spans::SpansInfo","engine::DeltaOp","spans::SpansLeaf","multiset::ZipSegment","multiset::CountMatcher","tree::NodeVal","delta::DeltaElement","breaks::BreaksLeaf","engine::Contents","engine::Error","tree::Node","diff::DiffBuilder","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","spans::SpansInfo","engine::DeltaOp","multiset::Segment","engine::Error","delta::Delta","engine::Contents","rope::BaseMetric","breaks::BreaksInfo","delta::InsertDelta","tree::NodeBody","engine::RevId","tree::Node","spans::SpansLeaf","multiset::Subset","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","multiset::CountMatcher","diff::DiffBuilder","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","interval::Interval","spans::Span","diff::DiffOp","rope::LinesMetric","find::CaseMatching","rope::RopeInfo","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::root":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.root();
+tree::Cursor::<'a, N>::root(p0);
+crate::tree::Cursor::<'a, N>::root(p0);
+<tree::Cursor<'a, N>>::root(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::get_leaf
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::get_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","multiset::ZipSegment","engine::Contents","breaks::BreaksLeaf","spans::SpansLeaf","rope::RopeInfo","engine::Error","rope::LinesMetric","engine::RevId","multiset::CountMatcher","delta::DeltaElement","tree::NodeVal","engine::DeltaOp","tree::Node","diff::DiffOp","rope::BaseMetric","interval::Interval","breaks::BreaksBaseMetric","delta::Delta","find::CaseMatching","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","engine::FullPriority","breaks::BreaksMetric","spans::Span","diff::DiffBuilder","breaks::BreaksInfo","tree::NodeBody","multiset::Segment","spans::SpansInfo"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","find::CaseMatching","engine::Error","spans::SpansLeaf","spans::SpansInfo","multiset::CountMatcher","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","delta::DeltaElement","tree::NodeVal","diff::DiffOp","delta::InsertDelta","diff::DiffBuilder","rope::LinesMetric","engine::FullPriority","delta::Delta","interval::Interval","multiset::Subset","breaks::BreaksMetric","rope::RopeInfo","engine::Contents","multiset::ZipSegment","multiset::Segment","spans::Span","tree::NodeBody","rope::BaseMetric","rope::Utf16CodeUnitsMetric","engine::RevId","breaks::BreaksBaseMetric","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","interval::Interval","delta::Delta","engine::RevId","rope::RopeInfo","engine::Contents","rope::BaseMetric","breaks::BreaksMetric","delta::InsertDelta","multiset::ZipSegment","engine::Error","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","spans::Span","diff::DiffOp","breaks::BreaksInfo","delta::DeltaElement","breaks::BreaksLeaf","rope::LinesMetric","tree::NodeBody","multiset::CountMatcher","find::CaseMatching","tree::NodeVal","engine::DeltaOp","multiset::Subset","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::get_leaf":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.get_leaf();
+tree::Cursor::<'a, N>::get_leaf(p0);
+crate::tree::Cursor::<'a, N>::get_leaf(p0);
+<tree::Cursor<'a, N>>::get_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::set
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::set":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","breaks::BreaksLeaf","engine::RevId","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","multiset::Segment","engine::Error","rope::BaseMetric","engine::Contents","multiset::Subset","spans::Span","diff::DiffOp","multiset::CountMatcher","delta::DeltaElement","find::CaseMatching","rope::RopeInfo","tree::Node","breaks::BreaksBaseMetric","interval::Interval","delta::Delta","delta::InsertDelta","breaks::BreaksInfo","multiset::ZipSegment","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","engine::FullPriority","tree::NodeBody","diff::DiffBuilder"]},"spans::SpansInfo":{"T":["delta::InsertDelta","engine::Error","rope::BaseMetric","delta::DeltaElement","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::RevId","rope::LinesMetric","diff::DiffBuilder","diff::DiffOp","multiset::Subset","spans::SpansLeaf","tree::Node","multiset::CountMatcher","interval::Interval","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","engine::FullPriority","breaks::BreaksMetric","engine::Contents","breaks::BreaksLeaf","find::CaseMatching","spans::Span","rope::RopeInfo","delta::Delta","tree::NodeVal","tree::NodeBody","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["engine::RevId","breaks::BreaksMetric","breaks::BreaksInfo","tree::NodeVal","engine::Error","multiset::Segment","interval::Interval","engine::DeltaOp","spans::SpansInfo","diff::DiffOp","multiset::CountMatcher","delta::Delta","spans::SpansLeaf","tree::Node","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","rope::Utf16CodeUnitsMetric","engine::Contents","delta::DeltaElement","delta::InsertDelta","rope::LinesMetric","spans::Span","tree::NodeBody","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","engine::FullPriority","multiset::Subset","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::set":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.set(p1);
+tree::Cursor::<'a, N>::set(p0, p1);
+crate::tree::Cursor::<'a, N>::set(p0, p1);
+<tree::Cursor<'a, N>>::set(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::pos
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::pos":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["find::CaseMatching","engine::FullPriority","engine::Contents","engine::RevId","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","spans::Span","rope::LinesMetric","diff::DiffOp","engine::DeltaOp","tree::NodeVal","delta::DeltaElement","multiset::ZipSegment","multiset::Subset","tree::Node","tree::NodeBody","delta::Delta","breaks::BreaksMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksBaseMetric","rope::BaseMetric","interval::Interval","spans::SpansLeaf","spans::SpansInfo","delta::InsertDelta","multiset::Segment"]},"spans::SpansInfo":{"T":["multiset::ZipSegment","engine::RevId","engine::Contents","find::CaseMatching","rope::LinesMetric","engine::DeltaOp","rope::BaseMetric","tree::NodeBody","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","delta::DeltaElement","breaks::BreaksMetric","tree::Node","multiset::CountMatcher","spans::SpansInfo","breaks::BreaksLeaf","spans::SpansLeaf","delta::InsertDelta","spans::Span","diff::DiffOp","breaks::BreaksInfo","interval::Interval","engine::Error","tree::NodeVal","multiset::Subset","multiset::Segment","delta::Delta","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","rope::RopeInfo"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","multiset::Segment","interval::Interval","engine::RevId","breaks::BreaksLeaf","engine::FullPriority","find::CaseMatching","tree::NodeBody","tree::Node","multiset::Subset","multiset::CountMatcher","spans::SpansInfo","tree::NodeVal","spans::Span","breaks::BreaksMetric","breaks::BreaksInfo","delta::DeltaElement","rope::RopeInfo","rope::LinesMetric","diff::DiffOp","engine::DeltaOp","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","delta::InsertDelta","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","delta::Delta","engine::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::pos":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.pos();
+tree::Cursor::<'a, N>::pos(p0);
+crate::tree::Cursor::<'a, N>::pos(p0);
+<tree::Cursor<'a, N>>::pos(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::is_boundary
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::is_boundary":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["delta::DeltaElement","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","diff::DiffBuilder","spans::SpansInfo","breaks::BreaksBaseMetric","engine::Error","interval::Interval","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","rope::Utf16CodeUnitsMetric","rope::LinesMetric","spans::Span","engine::RevId","multiset::Segment","breaks::BreaksMetric","tree::NodeBody","rope::BaseMetric","breaks::BreaksInfo","find::CaseMatching","multiset::ZipSegment","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksLeaf","engine::FullPriority","engine::Contents","delta::InsertDelta","delta::Delta","multiset::Subset","tree::Node"]},"spans::SpansInfo":{"T":["delta::DeltaElement","tree::Node","rope::BaseMetric","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","breaks::BreaksMetric","multiset::ZipSegment","tree::NodeVal","engine::Contents","engine::RevId","rope::LinesMetric","breaks::BreaksLeaf","engine::Error","diff::DiffBuilder","multiset::Segment","delta::Delta","delta::InsertDelta","spans::Span","diff::DiffOp","tree::NodeBody","breaks::BreaksBaseMetric","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::FullPriority","breaks::BreaksInfo","rope::RopeInfo","find::CaseMatching","interval::Interval","spans::SpansInfo","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::Span","delta::Delta","engine::DeltaOp","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","delta::DeltaElement","tree::NodeVal","diff::DiffOp","diff::DiffBuilder","multiset::CountMatcher","tree::Node","multiset::ZipSegment","engine::Error","spans::SpansInfo","multiset::Segment","rope::LinesMetric","rope::RopeInfo","rope::BaseMetric","breaks::BreaksMetric","engine::RevId","multiset::Subset","breaks::BreaksBaseMetric","find::CaseMatching","spans::SpansLeaf","breaks::BreaksInfo","delta::InsertDelta","engine::FullPriority","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::is_boundary":{"M":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.is_boundary();
+tree::Cursor::<'a, N>::is_boundary(p0);
+crate::tree::Cursor::<'a, N>::is_boundary(p0);
+<tree::Cursor<'a, N>>::is_boundary(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::prev
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::Subset","rope::BaseMetric","tree::Node","interval::Interval","delta::DeltaElement","engine::Contents","engine::FullPriority","breaks::BreaksInfo","breaks::BreaksBaseMetric","find::CaseMatching","delta::InsertDelta","spans::Span","tree::NodeBody","multiset::Segment","breaks::BreaksMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","tree::NodeVal","rope::LinesMetric","engine::Error","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::DeltaOp","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","multiset::ZipSegment","delta::Delta","breaks::BreaksLeaf","spans::SpansLeaf","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["tree::NodeVal","multiset::Segment","breaks::BreaksLeaf","spans::SpansLeaf","tree::Node","multiset::ZipSegment","delta::Delta","engine::DeltaOp","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","rope::RopeInfo","multiset::Subset","engine::Error","find::CaseMatching","diff::DiffOp","delta::InsertDelta","diff::DiffBuilder","breaks::BreaksInfo","engine::RevId","rope::LinesMetric","rope::BaseMetric","interval::Interval","rope::Utf16CodeUnitsMetric","tree::NodeBody","multiset::CountMatcher","breaks::BreaksBaseMetric","breaks::BreaksMetric","spans::SpansInfo","delta::DeltaElement","engine::FullPriority"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","rope::BaseMetric","tree::NodeVal","engine::RevId","breaks::BreaksLeaf","find::CaseMatching","tree::Node","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","interval::Interval","engine::Error","multiset::Segment","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","engine::FullPriority","breaks::BreaksInfo","rope::LinesMetric","breaks::BreaksMetric","engine::Contents","multiset::ZipSegment","spans::SpansInfo","tree::NodeBody","spans::Span","delta::InsertDelta","spans::SpansLeaf","rope::RopeInfo","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev":{"M":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.prev();
+tree::Cursor::<'a, N>::prev(p0);
+crate::tree::Cursor::<'a, N>::prev(p0);
+<tree::Cursor<'a, N>>::prev(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::Subset","rope::BaseMetric","spans::SpansInfo","spans::SpansLeaf","find::CaseMatching","tree::Node","engine::Error","multiset::Segment","delta::InsertDelta","rope::RopeInfo","multiset::ZipSegment","rope::LinesMetric","breaks::BreaksMetric","interval::Interval","engine::RevId","spans::Span","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::CountMatcher","engine::Contents","tree::NodeBody","diff::DiffBuilder","engine::FullPriority","breaks::BreaksInfo","diff::DiffOp","breaks::BreaksBaseMetric","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::SpansInfo":{"T":["rope::LinesMetric","engine::DeltaOp","multiset::Segment","spans::Span","breaks::BreaksMetric","breaks::BreaksLeaf","rope::BaseMetric","engine::Contents","delta::InsertDelta","delta::Delta","multiset::CountMatcher","rope::RopeInfo","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp","tree::Node","diff::DiffBuilder","delta::DeltaElement","interval::Interval","spans::SpansInfo","spans::SpansLeaf","multiset::Subset","find::CaseMatching","engine::RevId","breaks::BreaksInfo","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","tree::NodeBody","engine::FullPriority","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["engine::Error","breaks::BreaksInfo","delta::DeltaElement","engine::FullPriority","multiset::Subset","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","spans::Span","multiset::Segment","spans::SpansInfo","delta::InsertDelta","rope::LinesMetric","tree::NodeBody","find::CaseMatching","engine::DeltaOp","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","diff::DiffOp","breaks::BreaksLeaf","rope::RopeInfo","tree::Node","rope::BaseMetric","multiset::ZipSegment","breaks::BreaksBaseMetric","diff::DiffBuilder","delta::Delta","engine::RevId","tree::NodeVal","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next":{"M":["breaks::BreaksMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next();
+tree::Cursor::<'a, N>::next(p0);
+crate::tree::Cursor::<'a, N>::next(p0);
+<tree::Cursor<'a, N>>::next(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::at_or_next
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_next":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["diff::DiffOp","find::CaseMatching","delta::DeltaElement","multiset::Segment","delta::InsertDelta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","engine::Contents","engine::DeltaOp","multiset::Subset","multiset::CountMatcher","spans::SpansInfo","tree::NodeVal","spans::Span","engine::Error","rope::BaseMetric","breaks::BreaksMetric","tree::NodeBody","multiset::ZipSegment","breaks::BreaksInfo","interval::Interval","engine::RevId","breaks::BreaksLeaf","rope::RopeInfo","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","diff::DiffBuilder","tree::Node","delta::Delta","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["spans::Span","engine::Contents","spans::SpansInfo","multiset::CountMatcher","diff::DiffBuilder","rope::LinesMetric","delta::DeltaElement","rope::Utf16CodeUnitsMetric","delta::InsertDelta","breaks::BreaksInfo","diff::DiffOp","rope::BaseMetric","multiset::ZipSegment","tree::NodeVal","tree::Node","engine::RevId","engine::FullPriority","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","breaks::BreaksBaseMetric","rope::RopeInfo","multiset::Segment","interval::Interval","multiset::Subset","breaks::BreaksMetric","spans::SpansLeaf","tree::NodeBody","breaks::BreaksLeaf","find::CaseMatching","engine::Error"]},"spans::SpansLeaf":{"T":["breaks::BreaksLeaf","spans::Span","engine::RevId","engine::FullPriority","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","tree::Node","tree::NodeBody","breaks::BreaksMetric","multiset::ZipSegment","multiset::Segment","rope::BaseMetric","spans::SpansLeaf","delta::DeltaElement","engine::DeltaOp","multiset::Subset","find::CaseMatching","engine::Error","rope::LinesMetric","breaks::BreaksBaseMetric","tree::NodeVal","delta::InsertDelta","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","interval::Interval","spans::SpansInfo","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_next":{"M":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric"],"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.at_or_next();
+tree::Cursor::<'a, N>::at_or_next(p0);
+crate::tree::Cursor::<'a, N>::at_or_next(p0);
+<tree::Cursor<'a, N>>::at_or_next(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::at_or_prev
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_prev":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","breaks::BreaksLeaf","multiset::ZipSegment","engine::DeltaOp","engine::Contents","breaks::BreaksMetric","spans::SpansInfo","engine::RevId","delta::InsertDelta","multiset::CountMatcher","engine::FullPriority","rope::RopeInfo","delta::DeltaElement","rope::LinesMetric","interval::Interval","tree::Node","rope::BaseMetric","tree::NodeVal","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","delta::Delta","tree::NodeBody","engine::Error","diff::DiffBuilder","breaks::BreaksInfo","diff::DiffOp","find::CaseMatching","multiset::Subset"]},"spans::SpansInfo":{"T":["engine::RevId","rope::LinesMetric","tree::Node","diff::DiffBuilder","rope::BaseMetric","interval::Interval","engine::FullPriority","delta::Delta","breaks::BreaksInfo","engine::Error","engine::DeltaOp","tree::NodeVal","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","spans::SpansLeaf","spans::SpansInfo","diff::DiffOp","spans::Span","delta::InsertDelta","find::CaseMatching","delta::DeltaElement","rope::RopeInfo","multiset::Segment","engine::Contents","breaks::BreaksLeaf","breaks::BreaksBaseMetric","tree::NodeBody","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","interval::Interval","spans::SpansLeaf","rope::LinesMetric","multiset::Subset","engine::DeltaOp","breaks::BreaksLeaf","rope::RopeInfo","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","diff::DiffOp","breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","delta::InsertDelta","delta::Delta","engine::RevId","find::CaseMatching","multiset::ZipSegment","tree::NodeVal","spans::SpansInfo","engine::FullPriority","engine::Error","diff::DiffBuilder","rope::BaseMetric","tree::Node","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","spans::Span","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_prev":{"M":["breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric","rope::LinesMetric"],"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.at_or_prev();
+tree::Cursor::<'a, N>::at_or_prev(p0);
+crate::tree::Cursor::<'a, N>::at_or_prev(p0);
+<tree::Cursor<'a, N>>::at_or_prev(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::iter
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::iter":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffBuilder","rope::BaseMetric","engine::Contents","spans::SpansLeaf","multiset::ZipSegment","engine::DeltaOp","breaks::BreaksLeaf","find::CaseMatching","tree::NodeBody","multiset::Segment","rope::LinesMetric","engine::FullPriority","spans::SpansInfo","tree::NodeVal","breaks::BreaksMetric","interval::Interval","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksBaseMetric","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","spans::Span","tree::Node","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","breaks::BreaksInfo","delta::InsertDelta","engine::RevId","diff::DiffOp","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["engine::Error","engine::DeltaOp","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","spans::Span","engine::FullPriority","tree::NodeBody","rope::RopeInfo","interval::Interval","multiset::CountMatcher","spans::SpansInfo","spans::SpansLeaf","breaks::BreaksInfo","breaks::BreaksMetric","breaks::BreaksLeaf","breaks::BreaksBaseMetric","rope::LinesMetric","delta::Delta","rope::BaseMetric","delta::InsertDelta","diff::DiffOp","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::DeltaElement","multiset::ZipSegment","diff::DiffBuilder","tree::Node","tree::NodeVal","multiset::Subset","engine::Contents"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","spans::SpansLeaf","delta::Delta","delta::DeltaElement","multiset::CountMatcher","engine::FullPriority","rope::RopeInfo","diff::DiffOp","engine::Contents","interval::Interval","diff::DiffBuilder","tree::NodeVal","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","breaks::BreaksMetric","engine::Error","engine::DeltaOp","rope::LinesMetric","find::CaseMatching","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","breaks::BreaksBaseMetric","rope::BaseMetric","breaks::BreaksLeaf","multiset::Segment","delta::InsertDelta","spans::SpansInfo","spans::Span","rope::Utf16CodeUnitsMetric","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::iter":{"M":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.iter();
+tree::Cursor::<'a, N>::iter(p0);
+crate::tree::Cursor::<'a, N>::iter(p0);
+<tree::Cursor<'a, N>>::iter(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::last_inside_leaf
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::last_inside_leaf":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansInfo","engine::RevId","rope::BaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","interval::Interval","tree::Node","engine::Error","find::CaseMatching","delta::Delta","rope::LinesMetric","breaks::BreaksLeaf","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","rope::Utf16CodeUnitsMetric","multiset::Segment","diff::DiffOp","multiset::CountMatcher","delta::InsertDelta","delta::DeltaElement","breaks::BreaksBaseMetric","engine::FullPriority","engine::DeltaOp","engine::Contents","multiset::ZipSegment","tree::NodeBody","breaks::BreaksInfo","rope::RopeInfo","spans::Span","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["diff::DiffBuilder","multiset::Subset","diff::DiffOp","delta::Delta","rope::LinesMetric","tree::NodeBody","breaks::BreaksLeaf","spans::Span","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","multiset::ZipSegment","tree::Node","breaks::BreaksBaseMetric","tree::NodeVal","interval::Interval","breaks::BreaksInfo","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksMetric","rope::RopeInfo","spans::SpansInfo","spans::SpansLeaf","engine::Contents","rope::Utf16CodeUnitsMetric","engine::FullPriority","delta::DeltaElement","engine::Error","multiset::Segment"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","delta::DeltaElement","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","multiset::Segment","diff::DiffOp","tree::NodeBody","breaks::BreaksInfo","interval::Interval","engine::FullPriority","engine::RevId","spans::SpansInfo","delta::InsertDelta","rope::BaseMetric","multiset::Subset","spans::SpansLeaf","rope::LinesMetric","engine::Error","engine::Contents","engine::DeltaOp","breaks::BreaksMetric","breaks::BreaksBaseMetric","tree::Node","spans::Span","breaks::BreaksLeaf","tree::NodeVal","delta::Delta","find::CaseMatching","diff::DiffBuilder","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::last_inside_leaf":{"M":["breaks::BreaksBaseMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksMetric"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.last_inside_leaf(p1);
+tree::Cursor::<'a, N>::last_inside_leaf(p0, p1);
+crate::tree::Cursor::<'a, N>::last_inside_leaf(p0, p1);
+<tree::Cursor<'a, N>>::last_inside_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next_inside_leaf
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_inside_leaf":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","rope::Utf16CodeUnitsMetric","spans::Span","interval::Interval","delta::Delta","engine::Error","engine::DeltaOp","rope::RopeInfo","spans::SpansLeaf","find::CaseMatching","breaks::BreaksMetric","engine::FullPriority","multiset::ZipSegment","tree::NodeVal","multiset::Segment","engine::Contents","delta::DeltaElement","tree::Node","breaks::BreaksBaseMetric","tree::NodeBody","delta::InsertDelta","breaks::BreaksLeaf","engine::RevId","diff::DiffOp","diff::DiffBuilder","breaks::BreaksInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","rope::LinesMetric","multiset::Subset"]},"spans::SpansInfo":{"T":["spans::Span","engine::RevId","tree::Node","tree::NodeBody","diff::DiffBuilder","interval::Interval","multiset::Segment","engine::Error","multiset::Subset","engine::FullPriority","multiset::CountMatcher","spans::SpansInfo","find::CaseMatching","engine::Contents","breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","rope::BaseMetric","multiset::ZipSegment","diff::DiffOp","delta::InsertDelta","delta::Delta","spans::SpansLeaf","breaks::BreaksLeaf","tree::NodeVal","rope::RopeInfo","rope::LinesMetric","delta::DeltaElement","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["multiset::Segment","rope::LinesMetric","breaks::BreaksBaseMetric","tree::NodeVal","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","engine::DeltaOp","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","interval::Interval","rope::BaseMetric","delta::DeltaElement","find::CaseMatching","multiset::ZipSegment","diff::DiffBuilder","engine::Contents","spans::SpansLeaf","delta::Delta","spans::Span","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","rope::RopeInfo","delta::InsertDelta","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","tree::Node","spans::SpansInfo","multiset::Subset","breaks::BreaksInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_inside_leaf":{"M":["rope::LinesMetric","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next_inside_leaf();
+tree::Cursor::<'a, N>::next_inside_leaf(p0);
+crate::tree::Cursor::<'a, N>::next_inside_leaf(p0);
+<tree::Cursor<'a, N>>::next_inside_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next_leaf
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::InsertDelta","spans::Span","diff::DiffBuilder","interval::Interval","spans::SpansLeaf","breaks::BreaksLeaf","rope::LinesMetric","diff::DiffOp","tree::NodeBody","rope::BaseMetric","tree::Node","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","engine::FullPriority","engine::RevId","find::CaseMatching","engine::Error","breaks::BreaksBaseMetric","spans::SpansInfo","multiset::ZipSegment","multiset::Subset","rope::Utf16CodeUnitsMetric","rope::RopeInfo","breaks::BreaksMetric","engine::DeltaOp","delta::Delta","multiset::Segment","tree::NodeVal"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","engine::DeltaOp","rope::RopeInfo","engine::FullPriority","multiset::ZipSegment","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","tree::Node","spans::SpansInfo","delta::InsertDelta","breaks::BreaksBaseMetric","interval::Interval","spans::Span","tree::NodeBody","diff::DiffOp","delta::Delta","rope::BaseMetric","engine::Contents","diff::DiffBuilder","engine::RevId","breaks::BreaksLeaf","tree::NodeVal","rope::LinesMetric","spans::SpansLeaf","find::CaseMatching","multiset::CountMatcher","multiset::Segment","multiset::Subset","rope::Utf16CodeUnitsMetric","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["rope::LinesMetric","breaks::BreaksBaseMetric","rope::RopeInfo","interval::Interval","engine::RevId","diff::DiffOp","find::CaseMatching","tree::NodeVal","tree::Node","engine::DeltaOp","spans::Span","multiset::Segment","delta::Delta","spans::SpansLeaf","engine::Contents","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","engine::FullPriority","multiset::Subset","breaks::BreaksMetric","rope::BaseMetric","diff::DiffBuilder","multiset::CountMatcher","breaks::BreaksInfo","multiset::ZipSegment","spans::SpansInfo","engine::Error","delta::InsertDelta","delta::DeltaElement","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_leaf":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next_leaf();
+tree::Cursor::<'a, N>::next_leaf(p0);
+crate::tree::Cursor::<'a, N>::next_leaf(p0);
+<tree::Cursor<'a, N>>::next_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::prev_leaf
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::DeltaElement","delta::Delta","breaks::BreaksBaseMetric","rope::RopeInfo","multiset::Subset","breaks::BreaksInfo","breaks::BreaksMetric","engine::Error","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","multiset::CountMatcher","diff::DiffBuilder","diff::DiffOp","engine::Contents","spans::Span","interval::Interval","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","find::CaseMatching","rope::BaseMetric","tree::NodeVal","delta::InsertDelta","rope::Utf16CodeUnitsMetric","tree::NodeBody","multiset::ZipSegment","breaks::BreaksLeaf","engine::RevId","spans::SpansLeaf","multiset::Segment","engine::FullPriority"]},"spans::SpansInfo":{"T":["tree::Node","rope::RopeInfo","rope::BaseMetric","engine::Contents","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksInfo","breaks::BreaksLeaf","interval::Interval","rope::LinesMetric","delta::InsertDelta","engine::Error","delta::DeltaElement","diff::DiffOp","tree::NodeVal","multiset::ZipSegment","multiset::Segment","tree::NodeBody","multiset::Subset","diff::DiffBuilder","engine::FullPriority","spans::Span","find::CaseMatching","multiset::CountMatcher","spans::SpansLeaf","engine::DeltaOp","engine::RevId","delta::Delta","spans::SpansInfo","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","breaks::BreaksLeaf","tree::Node","engine::FullPriority","rope::LinesMetric","engine::Contents","spans::Span","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","rope::RopeInfo","engine::RevId","diff::DiffBuilder","spans::SpansLeaf","multiset::Segment","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::DeltaElement","interval::Interval","multiset::Subset","rope::BaseMetric","tree::NodeVal","multiset::ZipSegment","breaks::BreaksBaseMetric","spans::SpansInfo","engine::Error","multiset::CountMatcher","engine::DeltaOp","delta::Delta","delta::InsertDelta","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev_leaf":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.prev_leaf();
+tree::Cursor::<'a, N>::prev_leaf(p0);
+crate::tree::Cursor::<'a, N>::prev_leaf(p0);
+<tree::Cursor<'a, N>>::prev_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::descend
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::DeltaOp","spans::SpansLeaf","multiset::ZipSegment","find::CaseMatching","breaks::BreaksMetric","spans::Span","engine::Error","engine::FullPriority","delta::InsertDelta","engine::RevId","multiset::Subset","delta::DeltaElement","rope::LinesMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","delta::Delta","rope::RopeInfo","tree::Node","diff::DiffBuilder","breaks::BreaksInfo","engine::Contents","rope::Utf16CodeUnitsMetric","rope::BaseMetric","interval::Interval","spans::SpansInfo","tree::NodeBody","tree::NodeVal","breaks::BreaksBaseMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp"]},"spans::SpansInfo":{"T":["delta::InsertDelta","spans::Span","tree::NodeBody","diff::DiffBuilder","spans::SpansInfo","rope::BaseMetric","engine::FullPriority","rope::RopeInfo","breaks::BreaksBaseMetric","breaks::BreaksMetric","engine::DeltaOp","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","engine::Contents","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","multiset::CountMatcher","engine::RevId","rope::LinesMetric","multiset::Subset","diff::DiffOp","delta::DeltaElement","engine::Error","multiset::Segment","interval::Interval","tree::Node","tree::NodeVal","delta::Delta","find::CaseMatching","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","diff::DiffOp","multiset::Segment","rope::LinesMetric","diff::DiffBuilder","engine::Contents","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","breaks::BreaksBaseMetric","tree::NodeVal","delta::DeltaElement","spans::SpansInfo","rope::BaseMetric","multiset::CountMatcher","multiset::ZipSegment","multiset::Subset","tree::NodeBody","rope::RopeInfo","interval::Interval","engine::FullPriority","find::CaseMatching","engine::DeltaOp","spans::SpansLeaf","delta::InsertDelta","spans::Span","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","breaks::BreaksLeaf","breaks::BreaksInfo","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.descend();
+tree::Cursor::<'a, N>::descend(p0);
+crate::tree::Cursor::<'a, N>::descend(p0);
+<tree::Cursor<'a, N>>::descend(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::measure_leaf
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::measure_leaf":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::Delta","find::CaseMatching","breaks::BreaksBaseMetric","spans::SpansInfo","rope::LinesMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","tree::Node","breaks::BreaksMetric","engine::Contents","tree::NodeBody","diff::DiffBuilder","multiset::Subset","rope::Utf16CodeUnitsMetric","engine::FullPriority","diff::DiffOp","engine::RevId","interval::Interval","engine::Error","delta::InsertDelta","tree::NodeVal","delta::DeltaElement","breaks::BreaksInfo","engine::DeltaOp","multiset::CountMatcher","spans::Span","rope::BaseMetric","breaks::BreaksLeaf","multiset::ZipSegment"]},"spans::SpansInfo":{"T":["tree::Node","breaks::BreaksBaseMetric","multiset::ZipSegment","breaks::BreaksLeaf","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksMetric","tree::NodeVal","multiset::CountMatcher","rope::BaseMetric","delta::DeltaElement","multiset::Subset","diff::DiffOp","engine::RevId","spans::Span","interval::Interval","delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::FullPriority","rope::RopeInfo","spans::SpansInfo","engine::Error","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","breaks::BreaksInfo","tree::NodeBody","spans::SpansLeaf","find::CaseMatching","engine::DeltaOp","engine::Contents"]},"spans::SpansLeaf":{"T":["engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","engine::DeltaOp","interval::Interval","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","rope::LinesMetric","delta::Delta","spans::Span","multiset::CountMatcher","multiset::Subset","engine::FullPriority","engine::Contents","find::CaseMatching","engine::Error","breaks::BreaksInfo","multiset::Segment","tree::Node","spans::SpansLeaf","diff::DiffBuilder","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::RopeInfo","multiset::ZipSegment","tree::NodeVal","delta::DeltaElement","spans::SpansInfo","tree::NodeBody","diff::DiffOp","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::measure_leaf":{"M":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksBaseMetric"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.measure_leaf(p1);
+tree::Cursor::<'a, N>::measure_leaf(p0, p1);
+crate::tree::Cursor::<'a, N>::measure_leaf(p0, p1);
+<tree::Cursor<'a, N>>::measure_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::descend_metric
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend_metric":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::RevId","find::CaseMatching","multiset::CountMatcher","diff::DiffOp","breaks::BreaksLeaf","spans::SpansLeaf","engine::FullPriority","diff::DiffBuilder","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","rope::Utf16CodeUnitsMetric","multiset::Segment","rope::BaseMetric","breaks::BreaksBaseMetric","spans::SpansInfo","tree::NodeVal","engine::Error","multiset::Subset","tree::NodeBody","breaks::BreaksInfo","tree::Node","rope::LinesMetric","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","engine::DeltaOp","interval::Interval","delta::Delta","spans::Span","delta::DeltaElement","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["delta::DeltaElement","rope::LinesMetric","breaks::BreaksBaseMetric","tree::NodeVal","tree::NodeBody","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","interval::Interval","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","spans::Span","rope::BaseMetric","engine::Contents","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksLeaf","diff::DiffBuilder","delta::Delta","spans::SpansInfo","breaks::BreaksMetric","delta::InsertDelta","multiset::Segment","multiset::Subset","engine::RevId","find::CaseMatching","engine::DeltaOp","engine::Error","tree::Node","rope::RopeInfo","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","multiset::ZipSegment","engine::Error","engine::FullPriority","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","tree::NodeVal","breaks::BreaksMetric","multiset::Segment","engine::RevId","breaks::BreaksInfo","engine::Contents","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffOp","rope::BaseMetric","delta::Delta","rope::LinesMetric","tree::Node","tree::NodeBody","rope::RopeInfo","find::CaseMatching","interval::Interval","spans::Span","delta::DeltaElement","delta::InsertDelta","multiset::Subset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend_metric":{"M":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksBaseMetric"],"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.descend_metric(p1);
+tree::Cursor::<'a, N>::descend_metric(p0, p1);
+crate::tree::Cursor::<'a, N>::descend_metric(p0, p1);
+<tree::Cursor<'a, N>>::descend_metric(p0, p1);
-----------------
rope/src/tree.rs <tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next
'c,'a
deps:{"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":{"M":["rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansLeaf","spans::SpansInfo","find::CaseMatching","delta::DeltaElement","engine::Error","engine::Contents","rope::Utf16CodeUnitsMetric","engine::FullPriority","tree::NodeVal","multiset::CountMatcher","spans::Span","multiset::ZipSegment","delta::Delta","rope::RopeInfo","engine::DeltaOp","breaks::BreaksInfo","rope::BaseMetric","tree::NodeBody","breaks::BreaksLeaf","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","multiset::Subset","multiset::Segment","delta::InsertDelta","rope::LinesMetric","engine::RevId","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksMetric","interval::Interval"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","diff::DiffOp","multiset::Segment","diff::DiffBuilder","engine::FullPriority","delta::DeltaElement","spans::SpansInfo","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksBaseMetric","tree::Node","engine::RevId","rope::Utf16CodeUnitsMetric","engine::Contents","multiset::CountMatcher","multiset::ZipSegment","find::CaseMatching","rope::RopeInfo","multiset::Subset","breaks::BreaksMetric","engine::DeltaOp","tree::NodeBody","rope::LinesMetric","delta::InsertDelta","breaks::BreaksInfo","spans::Span","engine::Error","interval::Interval","breaks::BreaksLeaf","delta::Delta"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","multiset::Subset","rope::RopeInfo","tree::Node","multiset::Segment","engine::Error","spans::Span","spans::SpansLeaf","tree::NodeVal","delta::Delta","breaks::BreaksBaseMetric","engine::Contents","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","spans::SpansInfo","interval::Interval","rope::LinesMetric","breaks::BreaksLeaf","diff::DiffBuilder","engine::DeltaOp","tree::NodeBody","engine::RevId","diff::DiffOp","engine::FullPriority","multiset::CountMatcher","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::CursorIter<'c, 'a, N, M>
+p0.next();
+<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next(p0);
+crate::<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next(p0);
+<tree::CursorIter<'c, 'a, N, M>>::next(p0);
-----------------
rope/src/tree.rs tree::CursorIter::<'c, 'a, N, M>::pos
'c,'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter::<'c, 'a, N, M>::pos":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::Span","interval::Interval","find::CaseMatching","spans::SpansInfo","multiset::ZipSegment","diff::DiffOp","tree::Node","breaks::BreaksLeaf","engine::Error","multiset::Segment","rope::RopeInfo","diff::DiffBuilder","multiset::Subset","engine::Contents","delta::Delta","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","tree::NodeVal","rope::BaseMetric","tree::NodeBody","multiset::CountMatcher","delta::DeltaElement","delta::InsertDelta","breaks::BreaksMetric","engine::DeltaOp","spans::SpansLeaf","breaks::BreaksBaseMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::SpansInfo":{"T":["delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","breaks::BreaksBaseMetric","spans::Span","spans::SpansLeaf","breaks::BreaksInfo","find::CaseMatching","engine::Contents","breaks::BreaksMetric","tree::Node","delta::DeltaElement","breaks::BreaksLeaf","rope::BaseMetric","rope::LinesMetric","diff::DiffBuilder","spans::SpansInfo","engine::RevId","delta::InsertDelta","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","interval::Interval","multiset::Subset","diff::DiffOp","engine::Error","tree::NodeVal","rope::RopeInfo","multiset::ZipSegment","engine::DeltaOp","tree::NodeBody","multiset::Segment"]},"spans::SpansLeaf":{"T":["tree::NodeVal","breaks::BreaksMetric","breaks::BreaksInfo","diff::DiffBuilder","tree::Node","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","spans::SpansLeaf","multiset::ZipSegment","rope::BaseMetric","breaks::BreaksBaseMetric","spans::Span","engine::RevId","tree::NodeBody","multiset::Subset","rope::LinesMetric","rope::RopeInfo","engine::Contents","delta::DeltaElement","engine::DeltaOp","delta::InsertDelta","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","multiset::Segment","delta::Delta","find::CaseMatching","engine::Error","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter::<'c, 'a, N, M>::pos":{"M":["rope::LinesMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::CursorIter<'c, 'a, N, M>
+p0.pos();
+tree::CursorIter::<'c, 'a, N, M>::pos(p0);
+crate::tree::CursorIter::<'c, 'a, N, M>::pos(p0);
+<tree::CursorIter<'c, 'a, N, M>>::pos(p0);