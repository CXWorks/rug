{"dependencies":{"<Error as std::fmt::Debug>::fmt":["Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","xi_rpc::Error"],"<base_cache::ChunkCache as Cache>::clear":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<base_cache::ChunkCache as Cache>::get_document":["DataSource","base_cache::ChunkCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<base_cache::ChunkCache as Cache>::get_line":["DataSource","base_cache::ChunkCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<base_cache::ChunkCache as Cache>::get_region":["DataSource","base_cache::ChunkCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId","xi_rope::interval::IntervalBounds"],"<base_cache::ChunkCache as Cache>::line_of_offset":["DataSource","base_cache::ChunkCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<base_cache::ChunkCache as Cache>::new":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<base_cache::ChunkCache as Cache>::offset_of_line":["DataSource","base_cache::ChunkCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<base_cache::ChunkCache as Cache>::update":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<base_cache::ChunkCache as std::clone::Clone>::clone":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<base_cache::ChunkCache as std::default::Default>::default":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<base_cache::ChunkCache as std::fmt::Debug>::fmt":["base_cache::ChunkCache","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"<core_proxy::CoreProxy as std::clone::Clone>::clone":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_notification":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_rpc::RpcCtx"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_request":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","xi_rpc::RpcCtx"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::idle":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_rpc::RpcCtx"],"<state_cache::StateCache<S> as Cache>::clear":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<state_cache::StateCache<S> as Cache>::get_document":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<state_cache::StateCache<S> as Cache>::get_line":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<state_cache::StateCache<S> as Cache>::get_region":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId","xi_rope::interval::IntervalBounds"],"<state_cache::StateCache<S> as Cache>::line_of_offset":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<state_cache::StateCache<S> as Cache>::new":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<state_cache::StateCache<S> as Cache>::offset_of_line":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"<state_cache::StateCache<S> as Cache>::update":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<state_cache::StateCache<S> as std::default::Default>::default":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"<view::FetchCtx as DataSource>::get_data":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId","xi_core::plugin_rpc::TextUnit"],"Cache::clear":[],"Cache::get_document":["DataSource","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"Cache::get_line":["DataSource","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"Cache::get_region":["DataSource","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId","xi_rope::interval::IntervalBounds"],"Cache::line_of_offset":["DataSource","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"Cache::new":[],"Cache::offset_of_line":["DataSource","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"Cache::update":["std::marker::Sized","std::option::Option"],"DataSource::get_data":["std::marker::Sized","std::result::Result","xi_core::plugin_rpc::TextUnit"],"Error":["Error","std::string::String","xi_rpc::Error"],"Plugin::config_changed":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::custom_command":["serde_json::Map","serde_json::Value","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::did_close":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::did_save":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::get_hover":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::idle":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::initialize":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid"],"Plugin::language_changed":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::new_view":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"Plugin::update":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::string::String","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"base_cache::ChunkCache":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"base_cache::ChunkCache::append_chunk":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_core::plugin_rpc::GetDataResponse"],"base_cache::ChunkCache::cached_offset_of_line":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"base_cache::ChunkCache::clear_up_to":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"base_cache::ChunkCache::recalculate_line_offsets":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"base_cache::ChunkCache::reset_chunk":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_core::plugin_rpc::GetDataResponse"],"base_cache::ChunkCache::should_clear":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"base_cache::ChunkCache::simple_delete":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"base_cache::ChunkCache::simple_insert":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_rope::tree::Node","xi_rope::tree::NodeInfo"],"base_cache::ChunkCache::update_chunk":["base_cache::ChunkCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"base_cache::newline_offsets":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"core_proxy::CoreProxy":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid"],"core_proxy::CoreProxy::add_status_item":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid","xi_core::ViewId"],"core_proxy::CoreProxy::display_hover":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","xi_core::PluginPid","xi_core::ViewId"],"core_proxy::CoreProxy::new":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid","xi_rpc::RpcCtx"],"core_proxy::CoreProxy::remove_status_item":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid","xi_core::ViewId"],"core_proxy::CoreProxy::schedule_idle":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid","xi_core::ViewId"],"core_proxy::CoreProxy::update_status_item":["core_proxy::CoreProxy","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","xi_core::PluginPid","xi_core::ViewId"],"dispatch::Dispatcher":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option"],"dispatch::Dispatcher::<'a, P>::do_close":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_collect_trace":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result"],"dispatch::Dispatcher::<'a, P>::do_config_changed":["Plugin","dispatch::Dispatcher","serde_json::Map","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_custom_command":["Plugin","dispatch::Dispatcher","serde_json::Value","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_did_save":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","std::path::PathBuf","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_get_hover":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_initialize":["Plugin","dispatch::Dispatcher","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","xi_core::PluginPid","xi_rpc::RpcCtx"],"dispatch::Dispatcher::<'a, P>::do_language_changed":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_core::LanguageId","xi_core::ViewId"],"dispatch::Dispatcher::<'a, P>::do_new_buffer":["Plugin","dispatch::Dispatcher","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","xi_rpc::RpcCtx"],"dispatch::Dispatcher::<'a, P>::do_shutdown":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option"],"dispatch::Dispatcher::<'a, P>::do_tracing_config":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option"],"dispatch::Dispatcher::<'a, P>::do_update":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","xi_core::plugin_rpc::PluginUpdate"],"dispatch::Dispatcher::<'a, P>::new":["Plugin","dispatch::Dispatcher","std::collections::HashMap","std::marker::Sized","std::option::Option"],"mainloop":["Plugin","std::marker::Sized","std::result::Result"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::close_frontier":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::find_offset":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_frontier":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_prev":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::reset":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::set":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::update_frontier":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"state_cache::CacheEntry":["state_cache::CacheEntry","std::marker::Sized","std::option::Option"],"state_cache::StateCache":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::choose_victim":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::clear_to_start":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::close_frontier":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::compute_gap":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::evict":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::find_line":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::find_offset":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::get":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::get_entry":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"state_cache::StateCache::<S>::get_frontier":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::get_prev":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::insert_entry":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::line_cache_simple_delete":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::line_cache_simple_insert":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::patchup_frontier":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::reset":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::set":["DataSource","base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::vec::Vec","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"state_cache::StateCache::<S>::truncate_cache":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::truncate_frontier":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::update_frontier":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"state_cache::StateCache::<S>::update_line_cache":["base_cache::ChunkCache","state_cache::StateCache","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","xi_rope::Delta","xi_rope::tree::NodeInfo"],"state_cache::count_newlines":[],"view::FetchCtx":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","view::FetchCtx","xi_core::PluginPid","xi_core::ViewId"],"view::View":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::add_scopes":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::add_status_item":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::edit":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::string::String","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId","xi_rope::Delta","xi_rope::tree::NodeInfo"],"view::View::<C>::get_buf_size":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_cache":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_config":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_document":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_id":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_language_id":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_line":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_path":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::get_region":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId","xi_rope::interval::IntervalBounds"],"view::View::<C>::line_of_offset":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::make_ctx":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::FetchCtx","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::new":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId","xi_core::plugin_rpc::PluginBufferInfo"],"view::View::<C>::offset_of_line":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::remove_status_item":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::request_is_pending":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::schedule_idle":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::set_language":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::update":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"],"view::View::<C>::update_annotations":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId","xi_core::annotations::AnnotationType","xi_core::plugin_rpc::DataSpan"],"view::View::<C>::update_spans":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId","xi_core::plugin_rpc::ScopeSpan"],"view::View::<C>::update_status_item":["serde_json::Map","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","view::View","xi_core::BufferConfig","xi_core::LanguageId","xi_core::PluginPid","xi_core::ViewId"]},"glob_path_import":{},"self_to_fn":{"Error":["Debug"],"base_cache::ChunkCache":["Clone","Debug","Default","impl Cache for ChunkCache {\n    fn new(buf_size: usize, rev: u64, num_lines: usize) -> Self {\n        let mut new = Self::default();\n        new.buf_size = buf_size;\n        new.num_lines = num_lines;\n        new.rev = rev;\n        new\n    }\n\n    /// Returns the line at `line_num` (zero-indexed). Returns an `Err(_)` if\n    /// there is a problem connecting to the peer, or if the requested line\n    /// is out of bounds.\n    ///\n    /// The `source` argument is some type that implements [`DataSource`]; in\n    /// the general case this is backed by the remote peer.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if `line_num` is greater than the total number of lines\n    /// in the document, or if there is a problem communicating with `source`.\n    ///\n    /// [`DataSource`]: trait.DataSource.html\n    fn get_line<DS>(&mut self, source: &DS, line_num: usize) -> Result<&str, Error>\n    where\n        DS: DataSource,\n    {\n        if line_num >= self.num_lines {\n            return Err(Error::BadRequest);\n        }\n\n        // if chunk does not include the start of this line, fetch and reset everything\n        if self.contents.is_empty()\n            || line_num < self.first_line\n            || (line_num == self.first_line && self.first_line_offset > 0)\n            || (line_num > self.first_line + self.line_offsets.len())\n        {\n            let resp = source.get_data(line_num, TextUnit::Line, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        // We now know that the start of this line is contained in self.contents.\n        let mut start_off = self.cached_offset_of_line(line_num).unwrap() - self.offset;\n\n        // Now we make sure we also contain the end of the line, fetching more\n        // of the document as necessary.\n        loop {\n            if let Some(end_off) = self.cached_offset_of_line(line_num + 1) {\n                return Ok(&self.contents[start_off..end_off - self.offset]);\n            }\n            // if we have a chunk and we're fetching more, discard unnecessary\n            // portion of our chunk.\n            if start_off != 0 {\n                self.clear_up_to(start_off);\n                start_off = 0;\n            }\n\n            let chunk_end = self.offset + self.contents.len();\n            let resp = source.get_data(chunk_end, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.append_chunk(&resp);\n        }\n    }\n\n    fn get_region<DS, I>(&mut self, source: &DS, interval: I) -> Result<&str, Error>\n    where\n        DS: DataSource,\n        I: IntervalBounds,\n    {\n        let Interval { start, end } = interval.into_interval(self.buf_size);\n        if self.contents.is_empty()\n            || start < self.offset\n            || start >= self.offset + self.contents.len()\n        {\n            let resp = source.get_data(start, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        loop {\n            let start_off = start - self.offset;\n            let end_off = end - self.offset;\n            if end_off <= self.contents.len() {\n                return Ok(&self.contents[start_off..end_off]);\n            }\n\n            if start_off != 0 {\n                self.clear_up_to(start_off);\n            }\n\n            let chunk_end = self.offset + self.contents.len();\n            let resp = source.get_data(chunk_end, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.append_chunk(&resp);\n        }\n    }\n\n    // could reimplement this with get_region, but this doesn't bloat the cache.\n    // Not clear that's a win, though, since if we're using this at all caching\n    // is probably worth it?\n    fn get_document<DS: DataSource>(&mut self, source: &DS) -> Result<String, Error> {\n        let mut result = String::new();\n        let mut cur_idx = 0;\n        while cur_idx < self.buf_size {\n            if self.contents.is_empty() || cur_idx != self.offset {\n                let resp = source.get_data(cur_idx, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n                self.reset_chunk(resp);\n            }\n            result.push_str(&self.contents);\n            cur_idx = self.offset + self.contents.len();\n        }\n        Ok(result)\n    }\n\n    fn offset_of_line<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        line_num: usize,\n    ) -> Result<usize, Error> {\n        if line_num > self.num_lines {\n            return Err(Error::BadRequest);\n        }\n        match self.cached_offset_of_line(line_num) {\n            Some(offset) => Ok(offset),\n            None => {\n                let resp = source.get_data(line_num, TextUnit::Line, CHUNK_SIZE, self.rev)?;\n                self.reset_chunk(resp);\n                self.offset_of_line(source, line_num)\n            }\n        }\n    }\n\n    fn line_of_offset<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        offset: usize,\n    ) -> Result<usize, Error> {\n        if offset > self.buf_size {\n            return Err(Error::BadRequest);\n        }\n        if self.contents.is_empty()\n            || offset < self.offset\n            || offset > self.offset + self.contents.len()\n        {\n            let resp = source.get_data(offset, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        let rel_offset = offset - self.offset;\n        let line_num = match self.line_offsets.binary_search(&rel_offset) {\n            Ok(ix) => ix + self.first_line + 1,\n            Err(ix) => ix + self.first_line,\n        };\n        Ok(line_num)\n    }\n\n    /// Updates the chunk to reflect changes in this delta.\n    fn update(&mut self, delta: Option<&RopeDelta>, new_len: usize, num_lines: usize, rev: u64) {\n        let _t = trace_block(\"ChunkCache::update\", &[\"plugin\"]);\n        let is_empty = self.offset == 0 && self.contents.is_empty();\n        let should_clear = match delta {\n            Some(delta) if !is_empty => self.should_clear(delta),\n            // if no contents, clearing is a noop\n            Some(_) => true,\n            // no delta means a very large edit\n            None => true,\n        };\n\n        if should_clear {\n            self.clear();\n        } else {\n            // only reached if delta exists\n            self.update_chunk(delta.unwrap());\n        }\n        self.buf_size = new_len;\n        self.num_lines = num_lines;\n        self.rev = rev;\n    }\n\n    fn clear(&mut self) {\n        self.contents.clear();\n        self.offset = 0;\n        self.line_offsets.clear();\n        self.first_line = 0;\n        self.first_line_offset = 0;\n    }\n}","impl ChunkCache {\n    /// Returns the offset of the provided `line_num` if it can be determined\n    /// without fetching data. The offset of line 0 is always 0, and there\n    /// is an implicit line at the last offset in the buffer.\n    fn cached_offset_of_line(&self, line_num: usize) -> Option<usize> {\n        if line_num < self.first_line {\n            return None;\n        }\n\n        let rel_line_num = line_num - self.first_line;\n\n        if rel_line_num == 0 {\n            return Some(self.offset - self.first_line_offset);\n        }\n\n        if rel_line_num <= self.line_offsets.len() {\n            return Some(self.offset + self.line_offsets[rel_line_num - 1]);\n        }\n\n        // EOF\n        if line_num == self.num_lines && self.offset + self.contents.len() == self.buf_size {\n            return Some(self.offset + self.contents.len());\n        }\n        None\n    }\n\n    /// Clears anything in the cache up to `offset`, which is indexed relative\n    /// to `self.contents`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `offset` is not a character boundary, or if `offset` is greater than\n    /// the length of `self.content`.\n    fn clear_up_to(&mut self, offset: usize) {\n        if offset > self.contents.len() {\n            panic!(\"offset greater than content length: {} > {}\", offset, self.contents.len())\n        }\n\n        let new_contents = self.contents.split_off(offset);\n        self.contents = new_contents;\n        self.offset += offset;\n        // first find out if offset is a line offset, and set first_line / first_line_offset\n        let (new_line, new_line_off) = match self.line_offsets.binary_search(&offset) {\n            Ok(idx) => (self.first_line + idx + 1, 0),\n            Err(0) => (self.first_line, self.first_line_offset + offset),\n            Err(idx) => (self.first_line + idx, offset - self.line_offsets[idx - 1]),\n        };\n\n        // then clear line_offsets up to and including offset\n        self.line_offsets =\n            self.line_offsets.iter().filter(|i| **i > offset).map(|i| i - offset).collect();\n\n        self.first_line = new_line;\n        self.first_line_offset = new_line_off;\n    }\n\n    /// Discard any existing cache, starting again with the new data.\n    fn reset_chunk(&mut self, data: GetDataResponse) {\n        self.contents = data.chunk;\n        self.offset = data.offset;\n        self.first_line = data.first_line;\n        self.first_line_offset = data.first_line_offset;\n        self.recalculate_line_offsets();\n    }\n\n    /// Append to the existing cache, leaving existing data in place.\n    fn append_chunk(&mut self, data: &GetDataResponse) {\n        self.contents.push_str(data.chunk.as_str());\n        // this is doing extra work in the case where we're fetching a single\n        // massive (multiple of CHUNK_SIZE) line, but unclear if it's worth optimizing\n        self.recalculate_line_offsets();\n    }\n\n    fn recalculate_line_offsets(&mut self) {\n        self.line_offsets.clear();\n        newline_offsets(&self.contents, &mut self.line_offsets);\n    }\n\n    /// Determine whether we should update our state with this delta,\n    /// or if we should clear it. In the update case, also patches up\n    /// offsets.\n    fn should_clear(&mut self, delta: &RopeDelta) -> bool {\n        let (iv, _) = delta.summary();\n        let start = iv.start();\n        let end = iv.end();\n        // we only apply the delta if it is a simple edit, which\n        // begins inside or immediately following our chunk.\n        // - If it begins _before_ our chunk, we are likely going to\n        // want to fetch the edited region, which will reset our state;\n        // - If it's a complex edit the logic is tricky, and this should\n        // be rare enough we can afford to discard.\n        // The one 'complex edit' we should probably be handling is\n        // the replacement of a single range. This could be a new\n        // convenience method on `Delta`?\n        if start < self.offset || start > self.offset + self.contents.len() {\n            true\n        } else if delta.is_simple_delete() {\n            // Don't go over cache boundary.\n            let end = end.min(self.offset + self.contents.len());\n\n            self.simple_delete(start, end);\n            false\n        } else if let Some(text) = delta.as_simple_insert() {\n            assert_eq!(iv.size(), 0);\n            self.simple_insert(text, start);\n            false\n        } else {\n            true\n        }\n    }\n\n    /// Patches up `self.line_offsets` in the simple insert case.\n    fn simple_insert(&mut self, text: &Rope, ins_offset: usize) {\n        let has_newline = text.measure::<LinesMetric>() > 0;\n        let self_off = self.offset;\n        assert!(ins_offset >= self_off);\n        // regardless of if we are inserting newlines we adjust offsets\n        self.line_offsets.iter_mut().for_each(|off| {\n            if *off > ins_offset - self_off {\n                *off += text.len()\n            }\n        });\n        // calculate and insert new newlines if necessary\n        // we could save some hassle and just rerun memchr on the chunk here?\n        if has_newline {\n            let mut new_offsets = Vec::new();\n            newline_offsets(&String::from(text), &mut new_offsets);\n            new_offsets.iter_mut().for_each(|off| *off += ins_offset - self_off);\n\n            let split_idx = self\n                .line_offsets\n                .binary_search(&new_offsets[0])\n                .err()\n                .expect(\"new index cannot be occupied\");\n\n            self.line_offsets =\n                [&self.line_offsets[..split_idx], &new_offsets, &self.line_offsets[split_idx..]]\n                    .concat();\n        }\n    }\n\n    /// Patches up `self.line_offsets` in the simple delete case.\n    fn simple_delete(&mut self, start: usize, end: usize) {\n        let del_size = end - start;\n        let start = start - self.offset;\n        let end = end - self.offset;\n        let has_newline = memchr(b'\\n', &self.contents.as_bytes()[start..end]).is_some();\n        // a bit too fancy: only reallocate if we need to remove an item\n        if has_newline {\n            self.line_offsets = self\n                .line_offsets\n                .iter()\n                .filter_map(|off| match *off {\n                    x if x <= start => Some(x),\n                    x if x > start && x <= end => None,\n                    x if x > end => Some(x - del_size),\n                    hmm => panic!(\"invariant violated {} {} {}?\", start, end, hmm),\n                })\n                .collect();\n        } else {\n            self.line_offsets.iter_mut().for_each(|off| {\n                if *off >= end {\n                    *off -= del_size\n                }\n            });\n        }\n    }\n\n    /// Updates `self.contents` with the given delta.\n    fn update_chunk(&mut self, delta: &RopeDelta) {\n        let chunk_start = self.offset;\n        let chunk_end = chunk_start + self.contents.len();\n        let mut new_state = String::with_capacity(self.contents.len());\n        let mut prev_copy_end = 0;\n        let mut del_before: usize = 0;\n        let mut ins_before: usize = 0;\n\n        for op in delta.els.as_slice() {\n            match *op {\n                DeltaElement::Copy(start, end) => {\n                    if start < chunk_start {\n                        del_before += start - prev_copy_end;\n                        if end >= chunk_start {\n                            let cp_end = (end - chunk_start).min(self.contents.len());\n                            new_state.push_str(&self.contents[0..cp_end]);\n                        }\n                    } else if start <= chunk_end {\n                        if prev_copy_end < chunk_start {\n                            del_before += chunk_start - prev_copy_end;\n                        }\n                        let cp_start = start - chunk_start;\n                        let cp_end = (end - chunk_start).min(self.contents.len());\n                        new_state.push_str(&self.contents[cp_start..cp_end]);\n                    }\n                    prev_copy_end = end;\n                }\n                DeltaElement::Insert(ref s) => {\n                    if prev_copy_end < chunk_start {\n                        ins_before += s.len();\n                    } else if prev_copy_end <= chunk_end {\n                        let s: String = s.into();\n                        new_state.push_str(&s);\n                    }\n                }\n            }\n        }\n        self.offset += ins_before;\n        self.offset -= del_before;\n        self.contents = new_state;\n    }\n}"],"core_proxy::CoreProxy":["Clone","impl CoreProxy {\n    pub fn new(plugin_id: PluginId, rpc_ctx: &RpcCtx) -> Self {\n        CoreProxy { plugin_id, peer: rpc_ctx.get_peer().clone() }\n    }\n\n    pub fn add_status_item(&mut self, view_id: ViewId, key: &str, value: &str, alignment: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key,\n            \"value\": value,\n            \"alignment\": alignment\n        });\n\n        self.peer.send_rpc_notification(\"add_status_item\", &params)\n    }\n\n    pub fn update_status_item(&mut self, view_id: ViewId, key: &str, value: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key,\n            \"value\": value\n        });\n\n        self.peer.send_rpc_notification(\"update_status_item\", &params)\n    }\n\n    pub fn remove_status_item(&mut self, view_id: ViewId, key: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key\n        });\n\n        self.peer.send_rpc_notification(\"remove_status_item\", &params)\n    }\n\n    pub fn display_hover(\n        &mut self,\n        view_id: ViewId,\n        request_id: usize,\n        result: &Result<Hover, RemoteError>,\n    ) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"request_id\": request_id,\n            \"result\": result,\n            \"view_id\": view_id\n        });\n\n        self.peer.send_rpc_notification(\"show_hover\", &params);\n    }\n\n    pub fn schedule_idle(&mut self, view_id: ViewId) {\n        let token: usize = view_id.into();\n        self.peer.schedule_idle(token);\n    }\n}"],"dispatch::Dispatcher":["impl<'a, P: 'a + Plugin> Dispatcher<'a, P> {\n    pub(crate) fn new(plugin: &'a mut P) -> Self {\n        Dispatcher { views: HashMap::new(), pid: None, plugin }\n    }\n\n    fn do_initialize(\n        &mut self,\n        ctx: &RpcCtx,\n        plugin_id: PluginPid,\n        buffers: Vec<PluginBufferInfo>,\n    ) {\n        assert!(self.pid.is_none(), \"initialize rpc received with existing pid\");\n        info!(\"Initializing plugin {:?}\", plugin_id);\n        self.pid = Some(plugin_id);\n\n        let core_proxy = CoreProxy::new(self.pid.unwrap(), ctx);\n        self.plugin.initialize(core_proxy);\n\n        self.do_new_buffer(ctx, buffers);\n    }\n\n    fn do_did_save(&mut self, view_id: ViewId, path: PathBuf) {\n        let v = bail!(self.views.get_mut(&view_id), \"did_save\", self.pid, view_id);\n        let prev_path = v.path.take();\n        v.path = Some(path);\n        self.plugin.did_save(v, prev_path.as_deref());\n    }\n\n    fn do_config_changed(&mut self, view_id: ViewId, changes: &ConfigTable) {\n        let v = bail!(self.views.get_mut(&view_id), \"config_changed\", self.pid, view_id);\n        self.plugin.config_changed(v, &changes);\n        for (key, value) in changes.iter() {\n            v.config_table.insert(key.to_owned(), value.to_owned());\n        }\n        let conf = serde_json::from_value(Value::Object(v.config_table.clone()));\n        v.config = conf.unwrap();\n    }\n\n    fn do_language_changed(&mut self, view_id: ViewId, new_lang: LanguageId) {\n        let v = bail!(self.views.get_mut(&view_id), \"language_changed\", self.pid, view_id);\n        let old_lang = v.language_id.clone();\n        v.set_language(new_lang);\n        self.plugin.language_changed(v, old_lang);\n    }\n\n    fn do_custom_command(&mut self, view_id: ViewId, method: &str, params: Value) {\n        let v = bail!(self.views.get_mut(&view_id), method, self.pid, view_id);\n        self.plugin.custom_command(v, method, params);\n    }\n\n    fn do_new_buffer(&mut self, ctx: &RpcCtx, buffers: Vec<PluginBufferInfo>) {\n        let plugin_id = self.pid.unwrap();\n        buffers\n            .into_iter()\n            .map(|info| View::new(ctx.get_peer().clone(), plugin_id, info))\n            .for_each(|view| {\n                let mut view = view;\n                self.plugin.new_view(&mut view);\n                self.views.insert(view.view_id, view);\n            });\n    }\n\n    fn do_close(&mut self, view_id: ViewId) {\n        {\n            let v = bail!(self.views.get(&view_id), \"close\", self.pid, view_id);\n            self.plugin.did_close(v);\n        }\n        self.views.remove(&view_id);\n    }\n\n    fn do_shutdown(&mut self) {\n        info!(\"rust plugin lib does not shutdown\");\n        //TODO: handle shutdown\n    }\n\n    fn do_get_hover(&mut self, view_id: ViewId, request_id: usize, position: usize) {\n        let v = bail!(self.views.get_mut(&view_id), \"get_hover\", self.pid, view_id);\n        self.plugin.get_hover(v, request_id, position)\n    }\n\n    fn do_tracing_config(&mut self, enabled: bool) {\n        if enabled {\n            xi_trace::enable_tracing();\n            info!(\"Enabling tracing in global plugin {:?}\", self.pid);\n            trace(\"enable tracing\", &[\"plugin\"]);\n        } else {\n            xi_trace::disable_tracing();\n            info!(\"Disabling tracing in global plugin {:?}\", self.pid);\n            trace(\"enable tracing\", &[\"plugin\"]);\n        }\n    }\n\n    fn do_update(&mut self, update: PluginUpdate) -> Result<Value, RemoteError> {\n        let _t = trace_block(\"Dispatcher::do_update\", &[\"plugin\"]);\n        let PluginUpdate {\n            view_id,\n            delta,\n            new_len,\n            new_line_count,\n            rev,\n            undo_group,\n            edit_type,\n            author,\n        } = update;\n        let v = bail_err!(self.views.get_mut(&view_id), \"update\", self.pid, view_id);\n        v.update(delta.as_ref(), new_len, new_line_count, rev, undo_group);\n        self.plugin.update(v, delta.as_ref(), edit_type, author);\n\n        Ok(Value::from(1))\n    }\n\n    fn do_collect_trace(&self) -> Result<Value, RemoteError> {\n        use xi_trace::chrome_trace_dump;\n\n        let samples = xi_trace::samples_cloned_unsorted();\n        chrome_trace_dump::to_value(&samples).map_err(|e| RemoteError::Custom {\n            code: 0,\n            message: format!(\"Could not serialize trace: {:?}\", e),\n            data: None,\n        })\n    }\n}","impl<'a, P: Plugin> RpcHandler for Dispatcher<'a, P> {\n    type Notification = HostNotification;\n    type Request = HostRequest;\n\n    fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification) {\n        use self::HostNotification::*;\n        let _t = trace_block(\"Dispatcher::handle_notif\", &[\"plugin\"]);\n        match rpc {\n            Initialize { plugin_id, buffer_info } => {\n                self.do_initialize(ctx, plugin_id, buffer_info)\n            }\n            DidSave { view_id, path } => self.do_did_save(view_id, path),\n            ConfigChanged { view_id, changes } => self.do_config_changed(view_id, &changes),\n            NewBuffer { buffer_info } => self.do_new_buffer(ctx, buffer_info),\n            DidClose { view_id } => self.do_close(view_id),\n            Shutdown(..) => self.do_shutdown(),\n            TracingConfig { enabled } => self.do_tracing_config(enabled),\n            GetHover { view_id, request_id, position } => {\n                self.do_get_hover(view_id, request_id, position)\n            }\n            LanguageChanged { view_id, new_lang } => self.do_language_changed(view_id, new_lang),\n            CustomCommand { view_id, method, params } => {\n                self.do_custom_command(view_id, &method, params)\n            }\n            Ping(..) => (),\n        }\n    }\n\n    fn handle_request(&mut self, _ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError> {\n        use self::HostRequest::*;\n        let _t = trace_block(\"Dispatcher::handle_request\", &[\"plugin\"]);\n        match rpc {\n            Update(params) => self.do_update(params),\n            CollectTrace(..) => self.do_collect_trace(),\n        }\n    }\n\n    fn idle(&mut self, _ctx: &RpcCtx, token: usize) {\n        let _t = trace_block_payload(\"Dispatcher::idle\", &[\"plugin\"], format!(\"token: {}\", token));\n        let view_id: ViewId = token.into();\n        let v = bail!(self.views.get_mut(&view_id), \"idle\", self.pid, view_id);\n        self.plugin.idle(v);\n    }\n}"],"state_cache::StateCache":["Default","impl<S: Clone + Default> Cache for StateCache<S> {\n    fn new(buf_size: usize, rev: u64, num_lines: usize) -> Self {\n        StateCache {\n            buf_cache: ChunkCache::new(buf_size, rev, num_lines),\n            state_cache: Vec::new(),\n            frontier: Vec::new(),\n        }\n    }\n\n    fn get_line<DS: DataSource>(&mut self, source: &DS, line_num: usize) -> Result<&str, Error> {\n        self.buf_cache.get_line(source, line_num)\n    }\n\n    fn get_region<DS, I>(&mut self, source: &DS, interval: I) -> Result<&str, Error>\n    where\n        DS: DataSource,\n        I: IntervalBounds,\n    {\n        self.buf_cache.get_region(source, interval)\n    }\n\n    fn get_document<DS: DataSource>(&mut self, source: &DS) -> Result<String, Error> {\n        self.buf_cache.get_document(source)\n    }\n\n    fn offset_of_line<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        line_num: usize,\n    ) -> Result<usize, Error> {\n        self.buf_cache.offset_of_line(source, line_num)\n    }\n\n    fn line_of_offset<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        offset: usize,\n    ) -> Result<usize, Error> {\n        self.buf_cache.line_of_offset(source, offset)\n    }\n\n    /// Updates the cache by applying this delta.\n    fn update(&mut self, delta: Option<&RopeDelta>, buf_size: usize, num_lines: usize, rev: u64) {\n        let _t = trace_block(\"StateCache::update\", &[\"plugin\"]);\n\n        if let Some(ref delta) = delta {\n            self.update_line_cache(delta);\n        } else {\n            // if there's no delta (very large edit) we blow away everything\n            self.clear_to_start(0);\n        }\n\n        self.buf_cache.update(delta, buf_size, num_lines, rev);\n    }\n\n    /// Flushes any state held by this cache.\n    fn clear(&mut self) {\n        self.reset()\n    }\n}","impl<S: Clone + Default> StateCache<S> {\n    /// Find an entry in the cache by line num. On return `Ok(i)` means entry\n    /// at index `i` is an exact match, while `Err(i)` means the entry would be\n    /// inserted at `i`.\n    fn find_line(&self, line_num: usize) -> Result<usize, usize> {\n        self.state_cache.binary_search_by(|probe| probe.line_num.cmp(&line_num))\n    }\n\n    /// Find an entry in the cache by offset. Similar to `find_line`.\n    pub fn find_offset(&self, offset: usize) -> Result<usize, usize> {\n        self.state_cache.binary_search_by(|probe| probe.offset.cmp(&offset))\n    }\n\n    /// Get the state from the nearest cache entry at or before given line number.\n    /// Returns line number, offset, and user state.\n    pub fn get_prev(&self, line_num: usize) -> (usize, usize, S) {\n        if line_num > 0 {\n            let mut ix = match self.find_line(line_num) {\n                Ok(ix) => ix,\n                Err(0) => return (0, 0, S::default()),\n                Err(ix) => ix - 1,\n            };\n            loop {\n                let item = &self.state_cache[ix];\n                if let Some(ref s) = item.user_state {\n                    return (item.line_num, item.offset, s.clone());\n                }\n                if ix == 0 {\n                    break;\n                }\n                ix -= 1;\n            }\n        }\n        (0, 0, S::default())\n    }\n\n    /// Get the state at the given line number, if it exists in the cache.\n    pub fn get(&self, line_num: usize) -> Option<&S> {\n        self.find_line(line_num).ok().and_then(|ix| self.state_cache[ix].user_state.as_ref())\n    }\n\n    /// Set the state at the given line number. Note: has no effect if line_num\n    /// references the end of the partial line at EOF.\n    pub fn set<DS>(&mut self, source: &DS, line_num: usize, s: S)\n    where\n        DS: DataSource,\n    {\n        if let Some(entry) = self.get_entry(source, line_num) {\n            entry.user_state = Some(s);\n        }\n    }\n\n    /// Get the cache entry at the given line number, creating it if necessary.\n    /// Returns None if line_num > number of newlines in doc (ie if it references\n    /// the end of the partial line at EOF).\n    fn get_entry<DS>(&mut self, source: &DS, line_num: usize) -> Option<&mut CacheEntry<S>>\n    where\n        DS: DataSource,\n    {\n        match self.find_line(line_num) {\n            Ok(ix) => Some(&mut self.state_cache[ix]),\n            Err(_ix) => {\n                if line_num == self.buf_cache.num_lines {\n                    None\n                } else {\n                    let offset = self\n                        .buf_cache\n                        .offset_of_line(source, line_num)\n                        .expect(\"get_entry should validate inputs\");\n                    let new_ix = self.insert_entry(line_num, offset, None);\n                    Some(&mut self.state_cache[new_ix])\n                }\n            }\n        }\n    }\n\n    /// Insert a new entry into the cache, returning its index.\n    fn insert_entry(&mut self, line_num: usize, offset: usize, user_state: Option<S>) -> usize {\n        if self.state_cache.len() >= CACHE_SIZE {\n            self.evict();\n        }\n        match self.find_line(line_num) {\n            Ok(_ix) => panic!(\"entry already exists\"),\n            Err(ix) => {\n                self.state_cache.insert(ix, CacheEntry { line_num, offset, user_state });\n                ix\n            }\n        }\n    }\n\n    /// Evict one cache entry.\n    fn evict(&mut self) {\n        let ix = self.choose_victim();\n        self.state_cache.remove(ix);\n    }\n\n    fn choose_victim(&self) -> usize {\n        let mut best = None;\n        let mut rng = thread_rng();\n        for _ in 0..NUM_PROBES {\n            let ix = rng.gen_range(0, self.state_cache.len());\n            let gap = self.compute_gap(ix);\n            if best.map(|(last_gap, _)| gap < last_gap).unwrap_or(true) {\n                best = Some((gap, ix));\n            }\n        }\n        best.unwrap().1\n    }\n\n    /// Compute the gap that would result after deleting the given entry.\n    fn compute_gap(&self, ix: usize) -> usize {\n        let before = if ix == 0 { 0 } else { self.state_cache[ix - 1].offset };\n        let after = if let Some(item) = self.state_cache.get(ix + 1) {\n            item.offset\n        } else {\n            self.buf_cache.buf_size\n        };\n        assert!(after >= before, \"{} < {} ix: {}\", after, before, ix);\n        after - before\n    }\n\n    /// Release all state _after_ the given offset.\n    fn truncate_cache(&mut self, offset: usize) {\n        let (line_num, ix) = match self.find_offset(offset) {\n            Ok(ix) => (self.state_cache[ix].line_num, ix + 1),\n            Err(ix) => (if ix == 0 { 0 } else { self.state_cache[ix - 1].line_num }, ix),\n        };\n        self.truncate_frontier(line_num);\n        self.state_cache.truncate(ix);\n    }\n\n    pub(crate) fn truncate_frontier(&mut self, line_num: usize) {\n        match self.frontier.binary_search(&line_num) {\n            Ok(ix) => self.frontier.truncate(ix + 1),\n            Err(ix) => {\n                self.frontier.truncate(ix);\n                self.frontier.push(line_num);\n            }\n        }\n    }\n\n    /// Updates the line cache to reflect this delta.\n    fn update_line_cache(&mut self, delta: &RopeDelta) {\n        let (iv, new_len) = delta.summary();\n        if let Some(n) = delta.as_simple_insert() {\n            assert_eq!(iv.size(), 0);\n            assert_eq!(new_len, n.len());\n\n            let newline_count = n.measure::<LinesMetric>();\n            self.line_cache_simple_insert(iv.start(), new_len, newline_count);\n        } else if delta.is_simple_delete() {\n            assert_eq!(new_len, 0);\n            self.line_cache_simple_delete(iv.start(), iv.end())\n        } else {\n            self.clear_to_start(iv.start());\n        }\n    }\n\n    fn line_cache_simple_insert(&mut self, start: usize, new_len: usize, newline_num: usize) {\n        let ix = match self.find_offset(start) {\n            Ok(ix) => ix + 1,\n            Err(ix) => ix,\n        };\n\n        for entry in &mut self.state_cache[ix..] {\n            entry.line_num += newline_num;\n            entry.offset += new_len;\n        }\n        self.patchup_frontier(ix, newline_num as isize);\n    }\n\n    fn line_cache_simple_delete(&mut self, start: usize, end: usize) {\n        let off = self.buf_cache.offset;\n        let chunk_end = off + self.buf_cache.contents.len();\n        if start >= off && end <= chunk_end {\n            let del_newline_num = count_newlines(&self.buf_cache.contents[start - off..end - off]);\n            // delete all entries that overlap the deleted range\n            let ix = match self.find_offset(start) {\n                Ok(ix) => ix + 1,\n                Err(ix) => ix,\n            };\n            while ix < self.state_cache.len() && self.state_cache[ix].offset <= end {\n                self.state_cache.remove(ix);\n            }\n            for entry in &mut self.state_cache[ix..] {\n                entry.line_num -= del_newline_num;\n                entry.offset -= end - start;\n            }\n            self.patchup_frontier(ix, -(del_newline_num as isize));\n        } else {\n            // if this region isn't in our chunk we can't correctly adjust newlines\n            self.clear_to_start(start);\n        }\n    }\n\n    fn patchup_frontier(&mut self, cache_idx: usize, nl_count_delta: isize) {\n        let line_num = match cache_idx {\n            0 => 0,\n            ix => self.state_cache[ix - 1].line_num,\n        };\n        let mut new_frontier = Vec::new();\n        let mut need_push = true;\n        for old_ln in &self.frontier {\n            if *old_ln < line_num {\n                new_frontier.push(*old_ln);\n            } else if need_push {\n                new_frontier.push(line_num);\n                need_push = false;\n                if let Some(ref entry) = self.state_cache.get(cache_idx) {\n                    if *old_ln >= entry.line_num {\n                        new_frontier.push(old_ln.wrapping_add(nl_count_delta as usize));\n                    }\n                }\n            }\n        }\n        if need_push {\n            new_frontier.push(line_num);\n        }\n        self.frontier = new_frontier;\n    }\n\n    /// Clears any cached text and anything in the state cache before `start`.\n    fn clear_to_start(&mut self, start: usize) {\n        self.truncate_cache(start);\n    }\n\n    /// Clear all state and reset frontier to start.\n    pub fn reset(&mut self) {\n        self.truncate_cache(0);\n    }\n\n    /// The frontier keeps track of work needing to be done. A typical\n    /// user will call `get_frontier` to get a line number, do the work\n    /// on that line, insert state for the next line, and then call either\n    /// `update_frontier` or `close_frontier` depending on whether there\n    /// is more work to be done at that location.\n    pub fn get_frontier(&self) -> Option<usize> {\n        self.frontier.first().cloned()\n    }\n\n    /// Updates the frontier. This can go backward, but most typically\n    /// goes forward by 1 line (compared to the `get_frontier` result).\n    pub fn update_frontier(&mut self, new_frontier: usize) {\n        if self.frontier.get(1) == Some(&new_frontier) {\n            self.frontier.remove(0);\n        } else {\n            self.frontier[0] = new_frontier;\n        }\n    }\n\n    /// Closes the current frontier. This is the correct choice to handle\n    /// EOF.\n    pub fn close_frontier(&mut self) {\n        self.frontier.remove(0);\n    }\n}"],"view::FetchCtx":["impl DataSource for FetchCtx {\n    fn get_data(\n        &self,\n        start: usize,\n        unit: TextUnit,\n        max_size: usize,\n        rev: u64,\n    ) -> Result<GetDataResponse, Error> {\n        let _t = trace_block(\"FetchCtx::get_data\", &[\"plugin\"]);\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"unit\": unit,\n            \"max_size\": max_size,\n            \"rev\": rev,\n        });\n        let result = self.peer.send_rpc_request(\"get_data\", &params).map_err(Error::RpcError)?;\n        GetDataResponse::deserialize(result).map_err(|_| Error::WrongReturnType)\n    }\n}"],"view::View":["impl<C: Cache> View<C> {\n    pub(crate) fn new(peer: RpcPeer, plugin_id: PluginPid, info: PluginBufferInfo) -> Self {\n        let PluginBufferInfo { views, rev, path, config, buf_size, nb_lines, syntax, .. } = info;\n\n        assert_eq!(views.len(), 1, \"assuming single view\");\n        let view_id = views.first().unwrap().to_owned();\n        let path = path.map(PathBuf::from);\n        View {\n            cache: C::new(buf_size, rev, nb_lines),\n            peer,\n            config_table: config.clone(),\n            config: serde_json::from_value(Value::Object(config)).unwrap(),\n            path,\n            plugin_id,\n            view_id,\n            rev,\n            undo_group: None,\n            buf_size,\n            language_id: syntax,\n        }\n    }\n\n    pub(crate) fn update(\n        &mut self,\n        delta: Option<&RopeDelta>,\n        new_len: usize,\n        new_num_lines: usize,\n        rev: u64,\n        undo_group: Option<usize>,\n    ) {\n        self.cache.update(delta, new_len, new_num_lines, rev);\n        self.rev = rev;\n        self.undo_group = undo_group;\n        self.buf_size = new_len;\n    }\n\n    pub(crate) fn set_language(&mut self, new_language_id: LanguageId) {\n        self.language_id = new_language_id;\n    }\n\n    //NOTE: (discuss in review) this feels bad, but because we're mutating cache,\n    // which we own, we can't just pass in a reference to something else we own;\n    // so we create this on each call. The `clone`is only cloning an `Arc`,\n    // but we could maybe use a RefCell or something and make this cleaner.\n    /// Returns a `FetchCtx`, a thin wrapper around an RpcPeer that implements\n    /// the `DataSource` trait and can be used when updating a cache.\n    pub(crate) fn make_ctx(&self) -> FetchCtx {\n        FetchCtx { view_id: self.view_id, plugin_id: self.plugin_id, peer: self.peer.clone() }\n    }\n\n    /// Returns the length of the view's buffer, in bytes.\n    pub fn get_buf_size(&self) -> usize {\n        self.buf_size\n    }\n\n    pub fn get_path(&self) -> Option<&Path> {\n        self.path.as_deref()\n    }\n\n    pub fn get_language_id(&self) -> &LanguageId {\n        &self.language_id\n    }\n\n    pub fn get_config(&self) -> &BufferConfig {\n        &self.config\n    }\n\n    pub fn get_cache(&mut self) -> &mut C {\n        &mut self.cache\n    }\n\n    pub fn get_id(&self) -> ViewId {\n        self.view_id\n    }\n\n    pub fn get_line(&mut self, line_num: usize) -> Result<&str, Error> {\n        let ctx = self.make_ctx();\n        self.cache.get_line(&ctx, line_num)\n    }\n\n    /// Returns a region of the view's buffer.\n    pub fn get_region<I: IntervalBounds>(&mut self, interval: I) -> Result<&str, Error> {\n        let ctx = self.make_ctx();\n        self.cache.get_region(&ctx, interval)\n    }\n\n    pub fn get_document(&mut self) -> Result<String, Error> {\n        let ctx = self.make_ctx();\n        self.cache.get_document(&ctx)\n    }\n\n    pub fn offset_of_line(&mut self, line_num: usize) -> Result<usize, Error> {\n        let ctx = self.make_ctx();\n        self.cache.offset_of_line(&ctx, line_num)\n    }\n\n    pub fn line_of_offset(&mut self, offset: usize) -> Result<usize, Error> {\n        let ctx = self.make_ctx();\n        self.cache.line_of_offset(&ctx, offset)\n    }\n\n    pub fn add_scopes(&self, scopes: &[Vec<String>]) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"scopes\": scopes,\n        });\n        self.peer.send_rpc_notification(\"add_scopes\", &params);\n    }\n\n    pub fn edit(\n        &self,\n        delta: RopeDelta,\n        priority: u64,\n        after_cursor: bool,\n        new_undo_group: bool,\n        author: String,\n    ) {\n        let undo_group = if new_undo_group { None } else { self.undo_group };\n        let edit = PluginEdit { rev: self.rev, delta, priority, after_cursor, undo_group, author };\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"edit\": edit\n        });\n        self.peer.send_rpc_notification(\"edit\", &params);\n    }\n\n    pub fn update_spans(&self, start: usize, len: usize, spans: &[ScopeSpan]) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"len\": len,\n            \"rev\": self.rev,\n            \"spans\": spans,\n        });\n        self.peer.send_rpc_notification(\"update_spans\", &params);\n    }\n\n    pub fn update_annotations(\n        &self,\n        start: usize,\n        len: usize,\n        annotation_spans: &[DataSpan],\n        annotation_type: &AnnotationType,\n    ) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"len\": len,\n            \"rev\": self.rev,\n            \"spans\": annotation_spans,\n            \"annotation_type\": annotation_type,\n        });\n        self.peer.send_rpc_notification(\"update_annotations\", &params);\n    }\n\n    pub fn schedule_idle(&self) {\n        let token: usize = self.view_id.into();\n        self.peer.schedule_idle(token);\n    }\n\n    /// Returns `true` if an incoming RPC is pending. This is intended\n    /// to reduce latency for bulk operations done in the background.\n    pub fn request_is_pending(&self) -> bool {\n        self.peer.request_is_pending()\n    }\n\n    pub fn add_status_item(&self, key: &str, value: &str, alignment: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key,\n            \"value\": value,\n            \"alignment\": alignment\n        });\n        self.peer.send_rpc_notification(\"add_status_item\", &params);\n    }\n\n    pub fn update_status_item(&self, key: &str, value: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key,\n            \"value\": value\n        });\n        self.peer.send_rpc_notification(\"update_status_item\", &params);\n    }\n\n    pub fn remove_status_item(&self, key: &str) {\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key\n        });\n        self.peer.send_rpc_notification(\"remove_status_item\", &params);\n    }\n}","impl<S: Default + Clone> View<StateCache<S>> {\n    pub fn get_frontier(&self) -> Option<usize> {\n        self.cache.get_frontier()\n    }\n\n    pub fn get_prev(&self, line_num: usize) -> (usize, usize, S) {\n        self.cache.get_prev(line_num)\n    }\n\n    pub fn get(&self, line_num: usize) -> Option<&S> {\n        self.cache.get(line_num)\n    }\n\n    pub fn set(&mut self, line_num: usize, s: S) {\n        let ctx = self.make_ctx();\n        self.cache.set(&ctx, line_num, s)\n    }\n\n    pub fn update_frontier(&mut self, new_frontier: usize) {\n        self.cache.update_frontier(new_frontier)\n    }\n\n    pub fn close_frontier(&mut self) {\n        self.cache.close_frontier()\n    }\n\n    pub fn reset(&mut self) {\n        self.cache.reset()\n    }\n\n    pub fn find_offset(&self, offset: usize) -> Result<usize, usize> {\n        self.cache.find_offset(offset)\n    }\n}"]},"single_path_import":{"base_cache::ChunkCache":"ChunkCache","core_proxy::CoreProxy":"CoreProxy","state_cache::StateCache":"StateCache","view::View":"View","xi_core::plugin_rpc::Hover":"Hover","xi_core::plugin_rpc::Range":"Range"},"srcs":{"<base_cache::ChunkCache as Cache>::clear":["fn clear(&mut self){\n        self.contents.clear();\n        self.offset = 0;\n        self.line_offsets.clear();\n        self.first_line = 0;\n        self.first_line_offset = 0;\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::get_document":["fn get_document<DS: DataSource>(&mut self, source: &DS) -> Result<String, Error>{\n        let mut result = String::new();\n        let mut cur_idx = 0;\n        while cur_idx < self.buf_size {\n            if self.contents.is_empty() || cur_idx != self.offset {\n                let resp = source.get_data(cur_idx, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n                self.reset_chunk(resp);\n            }\n            result.push_str(&self.contents);\n            cur_idx = self.offset + self.contents.len();\n        }\n        Ok(result)\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::get_line":["/// Returns the line at `line_num` (zero-indexed). Returns an `Err(_)` if\n/// there is a problem connecting to the peer, or if the requested line\n/// is out of bounds.\n///\n/// The `source` argument is some type that implements [`DataSource`]; in\n/// the general case this is backed by the remote peer.\n///\n/// # Errors\n///\n/// Returns an error if `line_num` is greater than the total number of lines\n/// in the document, or if there is a problem communicating with `source`.\n///\n/// [`DataSource`]: trait.DataSource.html\nfn get_line<DS>(&mut self, source: &DS, line_num: usize) -> Result<&str, Error>\n    where\n        DS: DataSource,{\n        if line_num >= self.num_lines {\n            return Err(Error::BadRequest);\n        }\n\n        // if chunk does not include the start of this line, fetch and reset everything\n        if self.contents.is_empty()\n            || line_num < self.first_line\n            || (line_num == self.first_line && self.first_line_offset > 0)\n            || (line_num > self.first_line + self.line_offsets.len())\n        {\n            let resp = source.get_data(line_num, TextUnit::Line, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        // We now know that the start of this line is contained in self.contents.\n        let mut start_off = self.cached_offset_of_line(line_num).unwrap() - self.offset;\n\n        // Now we make sure we also contain the end of the line, fetching more\n        // of the document as necessary.\n        loop {\n            if let Some(end_off) = self.cached_offset_of_line(line_num + 1) {\n                return Ok(&self.contents[start_off..end_off - self.offset]);\n            }\n            // if we have a chunk and we're fetching more, discard unnecessary\n            // portion of our chunk.\n            if start_off != 0 {\n                self.clear_up_to(start_off);\n                start_off = 0;\n            }\n\n            let chunk_end = self.offset + self.contents.len();\n            let resp = source.get_data(chunk_end, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.append_chunk(&resp);\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::get_region":["fn get_region<DS, I>(&mut self, source: &DS, interval: I) -> Result<&str, Error>\n    where\n        DS: DataSource,\n        I: IntervalBounds,{\n        let Interval { start, end } = interval.into_interval(self.buf_size);\n        if self.contents.is_empty()\n            || start < self.offset\n            || start >= self.offset + self.contents.len()\n        {\n            let resp = source.get_data(start, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        loop {\n            let start_off = start - self.offset;\n            let end_off = end - self.offset;\n            if end_off <= self.contents.len() {\n                return Ok(&self.contents[start_off..end_off]);\n            }\n\n            if start_off != 0 {\n                self.clear_up_to(start_off);\n            }\n\n            let chunk_end = self.offset + self.contents.len();\n            let resp = source.get_data(chunk_end, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.append_chunk(&resp);\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::line_of_offset":["fn line_of_offset<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        offset: usize,\n    ) -> Result<usize, Error>{\n        if offset > self.buf_size {\n            return Err(Error::BadRequest);\n        }\n        if self.contents.is_empty()\n            || offset < self.offset\n            || offset > self.offset + self.contents.len()\n        {\n            let resp = source.get_data(offset, TextUnit::Utf8, CHUNK_SIZE, self.rev)?;\n            self.reset_chunk(resp);\n        }\n\n        let rel_offset = offset - self.offset;\n        let line_num = match self.line_offsets.binary_search(&rel_offset) {\n            Ok(ix) => ix + self.first_line + 1,\n            Err(ix) => ix + self.first_line,\n        };\n        Ok(line_num)\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::new":["fn new(buf_size: usize, rev: u64, num_lines: usize) -> Self{\n        let mut new = Self::default();\n        new.buf_size = buf_size;\n        new.num_lines = num_lines;\n        new.rev = rev;\n        new\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::offset_of_line":["fn offset_of_line<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        line_num: usize,\n    ) -> Result<usize, Error>{\n        if line_num > self.num_lines {\n            return Err(Error::BadRequest);\n        }\n        match self.cached_offset_of_line(line_num) {\n            Some(offset) => Ok(offset),\n            None => {\n                let resp = source.get_data(line_num, TextUnit::Line, CHUNK_SIZE, self.rev)?;\n                self.reset_chunk(resp);\n                self.offset_of_line(source, line_num)\n            }\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<base_cache::ChunkCache as Cache>::update":["/// Updates the chunk to reflect changes in this delta.\nfn update(&mut self, delta: Option<&RopeDelta>, new_len: usize, num_lines: usize, rev: u64){\n        let _t = trace_block(\"ChunkCache::update\", &[\"plugin\"]);\n        let is_empty = self.offset == 0 && self.contents.is_empty();\n        let should_clear = match delta {\n            Some(delta) if !is_empty => self.should_clear(delta),\n            // if no contents, clearing is a noop\n            Some(_) => true,\n            // no delta means a very large edit\n            None => true,\n        };\n\n        if should_clear {\n            self.clear();\n        } else {\n            // only reached if delta exists\n            self.update_chunk(delta.unwrap());\n        }\n        self.buf_size = new_len;\n        self.num_lines = num_lines;\n        self.rev = rev;\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_notification":["fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification){\n        use self::HostNotification::*;\n        let _t = trace_block(\"Dispatcher::handle_notif\", &[\"plugin\"]);\n        match rpc {\n            Initialize { plugin_id, buffer_info } => {\n                self.do_initialize(ctx, plugin_id, buffer_info)\n            }\n            DidSave { view_id, path } => self.do_did_save(view_id, path),\n            ConfigChanged { view_id, changes } => self.do_config_changed(view_id, &changes),\n            NewBuffer { buffer_info } => self.do_new_buffer(ctx, buffer_info),\n            DidClose { view_id } => self.do_close(view_id),\n            Shutdown(..) => self.do_shutdown(),\n            TracingConfig { enabled } => self.do_tracing_config(enabled),\n            GetHover { view_id, request_id, position } => {\n                self.do_get_hover(view_id, request_id, position)\n            }\n            LanguageChanged { view_id, new_lang } => self.do_language_changed(view_id, new_lang),\n            CustomCommand { view_id, method, params } => {\n                self.do_custom_command(view_id, &method, params)\n            }\n            Ping(..) => (),\n        }\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_request":["fn handle_request(&mut self, _ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError>{\n        use self::HostRequest::*;\n        let _t = trace_block(\"Dispatcher::handle_request\", &[\"plugin\"]);\n        match rpc {\n            Update(params) => self.do_update(params),\n            CollectTrace(..) => self.do_collect_trace(),\n        }\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::idle":["fn idle(&mut self, _ctx: &RpcCtx, token: usize){\n        let _t = trace_block_payload(\"Dispatcher::idle\", &[\"plugin\"], format!(\"token: {}\", token));\n        let view_id: ViewId = token.into();\n        let v = bail!(self.views.get_mut(&view_id), \"idle\", self.pid, view_id);\n        self.plugin.idle(v);\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"<state_cache::StateCache<S> as Cache>::clear":["/// Flushes any state held by this cache.\nfn clear(&mut self){\n        self.reset()\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::get_document":["fn get_document<DS: DataSource>(&mut self, source: &DS) -> Result<String, Error>{\n        self.buf_cache.get_document(source)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::get_line":["fn get_line<DS: DataSource>(&mut self, source: &DS, line_num: usize) -> Result<&str, Error>{\n        self.buf_cache.get_line(source, line_num)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::get_region":["fn get_region<DS, I>(&mut self, source: &DS, interval: I) -> Result<&str, Error>\n    where\n        DS: DataSource,\n        I: IntervalBounds,{\n        self.buf_cache.get_region(source, interval)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::line_of_offset":["fn line_of_offset<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        offset: usize,\n    ) -> Result<usize, Error>{\n        self.buf_cache.line_of_offset(source, offset)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::new":["fn new(buf_size: usize, rev: u64, num_lines: usize) -> Self{\n        StateCache {\n            buf_cache: ChunkCache::new(buf_size, rev, num_lines),\n            state_cache: Vec::new(),\n            frontier: Vec::new(),\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::offset_of_line":["fn offset_of_line<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        line_num: usize,\n    ) -> Result<usize, Error>{\n        self.buf_cache.offset_of_line(source, line_num)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<state_cache::StateCache<S> as Cache>::update":["/// Updates the cache by applying this delta.\nfn update(&mut self, delta: Option<&RopeDelta>, buf_size: usize, num_lines: usize, rev: u64){\n        let _t = trace_block(\"StateCache::update\", &[\"plugin\"]);\n\n        if let Some(ref delta) = delta {\n            self.update_line_cache(delta);\n        } else {\n            // if there's no delta (very large edit) we blow away everything\n            self.clear_to_start(0);\n        }\n\n        self.buf_cache.update(delta, buf_size, num_lines, rev);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"<view::FetchCtx as DataSource>::get_data":["fn get_data(\n        &self,\n        start: usize,\n        unit: TextUnit,\n        max_size: usize,\n        rev: u64,\n    ) -> Result<GetDataResponse, Error>{\n        let _t = trace_block(\"FetchCtx::get_data\", &[\"plugin\"]);\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"unit\": unit,\n            \"max_size\": max_size,\n            \"rev\": rev,\n        });\n        let result = self.peer.send_rpc_request(\"get_data\", &params).map_err(Error::RpcError)?;\n        GetDataResponse::deserialize(result).map_err(|_| Error::WrongReturnType)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"Cache":["/// A generic interface for types that cache a remote document.\n///\n/// In general, users of this library should not need to implement this trait;\n/// we provide two concrete Cache implementations, [`ChunkCache`] and\n/// [`StateCache`]. If however a plugin's particular needs are not met by\n/// those implementations, a user may choose to implement their own.\n///\n/// [`ChunkCache`]: ../base_cache/struct.ChunkCache.html\n/// [`StateCache`]: ../state_cache/struct.StateCache.html\npub trait Cache {\n    /// Create a new instance of this type; instances are created automatically\n    /// as relevant views are added.\n    fn new(buf_size: usize, rev: u64, num_lines: usize) -> Self;\n    /// Returns the line at `line_num` (zero-indexed). Returns an `Err(_)` if\n    /// there is a problem connecting to the peer, or if the requested line\n    /// is out of bounds.\n    ///\n    /// The `source` argument is some type that implements [`DataSource`]; in\n    /// the general case this is backed by the remote peer.\n    ///\n    /// [`DataSource`]: trait.DataSource.html\n    fn get_line<DS: DataSource>(&mut self, source: &DS, line_num: usize) -> Result<&str, Error>;\n\n    /// Returns the specified region of the buffer. Returns an `Err(_)` if\n    /// there is a problem connecting to the peer, or if the requested line\n    /// is out of bounds.\n    ///\n    /// The `source` argument is some type that implements [`DataSource`]; in\n    /// the general case this is backed by the remote peer.\n    ///\n    /// [`DataSource`]: trait.DataSource.html\n    fn get_region<DS, I>(&mut self, source: &DS, interval: I) -> Result<&str, Error>\n    where\n        DS: DataSource,\n        I: IntervalBounds;\n\n    /// Returns the entire contents of the remote document, fetching as needed.\n    fn get_document<DS: DataSource>(&mut self, source: &DS) -> Result<String, Error>;\n\n    /// Returns the offset of the line at `line_num`, zero-indexed, fetching\n    /// data from `source` if needed.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if `line_num` is greater than the total number of lines\n    /// in the document, or if there is a problem communicating with `source`.\n    fn offset_of_line<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        line_num: usize,\n    ) -> Result<usize, Error>;\n    /// Returns the index of the line containing `offset`, fetching\n    /// data from `source` if needed.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if `offset` is greater than the total length of\n    /// the document, or if there is a problem communicating with `source`.\n    fn line_of_offset<DS: DataSource>(\n        &mut self,\n        source: &DS,\n        offset: usize,\n    ) -> Result<usize, Error>;\n    /// Updates the cache by applying this delta.\n    fn update(&mut self, delta: Option<&RopeDelta>, buf_size: usize, num_lines: usize, rev: u64);\n    /// Flushes any state held by this cache.\n    fn clear(&mut self);\n}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"DataSource":["/// Abstracts getting data from the peer. Mainly exists for mocking in tests.\npub trait DataSource {\n    fn get_data(\n        &self,\n        start: usize,\n        unit: TextUnit,\n        max_size: usize,\n        rev: u64,\n    ) -> Result<GetDataResponse, Error>;\n}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Error":["pub enum Error {\n    RpcError(xi_rpc::Error),\n    WrongReturnType,\n    BadRequest,\n    PeerDisconnect,\n    // Just used in tests\n    Other(String),\n}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin":["/// An interface for plugins.\n///\n/// Users of this library must implement this trait for some type.\npub trait Plugin {\n    type Cache: Cache;\n\n    /// Called when the Plugin is initialized. The plugin receives CoreProxy\n    /// object that is a wrapper around the RPC Peer and can be used to call\n    /// related methods on the Core in a type-safe manner.\n    #[allow(unused_variables)]\n    fn initialize(&mut self, core: CoreProxy) {}\n\n    /// Called when an edit has occurred in the remote view. If the plugin wishes\n    /// to add its own edit, it must do so using asynchronously via the edit notification.\n    fn update(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        delta: Option<&RopeDelta>,\n        edit_type: String,\n        author: String,\n    );\n    /// Called when a buffer has been saved to disk. The buffer's previous\n    /// path, if one existed, is passed as `old_path`.\n    fn did_save(&mut self, view: &mut View<Self::Cache>, old_path: Option<&Path>);\n    /// Called when a view has been closed. By the time this message is received,\n    /// It is possible to send messages to this view. The plugin may wish to\n    /// perform cleanup, however.\n    fn did_close(&mut self, view: &View<Self::Cache>);\n    /// Called when there is a new view that this buffer is interested in.\n    /// This is called once per view, and is paired with a call to\n    /// `Plugin::did_close` when the view is closed.\n    fn new_view(&mut self, view: &mut View<Self::Cache>);\n\n    /// Called when a config option has changed for this view. `changes`\n    /// is a map of keys/values that have changed; previous values are available\n    /// in the existing config, accessible through `view.get_config()`.\n    fn config_changed(&mut self, view: &mut View<Self::Cache>, changes: &ConfigTable);\n\n    /// Called when syntax language has changed for this view.\n    /// New language is available in the `view`, and old language is available in `old_lang`.\n    #[allow(unused_variables)]\n    fn language_changed(&mut self, view: &mut View<Self::Cache>, old_lang: LanguageId) {}\n\n    /// Called with a custom command.\n    #[allow(unused_variables)]\n    fn custom_command(&mut self, view: &mut View<Self::Cache>, method: &str, params: Value) {}\n\n    /// Called when the runloop is idle, if the plugin has previously\n    /// asked to be scheduled via `View::schedule_idle()`. Plugins that\n    /// are doing things like full document analysis can use this mechanism\n    /// to perform their work incrementally while remaining responsive.\n    #[allow(unused_variables)]\n    fn idle(&mut self, view: &mut View<Self::Cache>) {}\n\n    /// Language Plugins specific methods\n\n    #[allow(unused_variables)]\n    fn get_hover(&mut self, view: &mut View<Self::Cache>, request_id: usize, position: usize) {}\n}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin::custom_command":["/// Called with a custom command.\n#[allow(unused_variables)]\nfn custom_command(&mut self, view: &mut View<Self::Cache>, method: &str, params: Value){}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin::get_hover":["/// Language Plugins specific methods\n#[allow(unused_variables)]\nfn get_hover(&mut self, view: &mut View<Self::Cache>, request_id: usize, position: usize){}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin::idle":["/// Called when the runloop is idle, if the plugin has previously\n/// asked to be scheduled via `View::schedule_idle()`. Plugins that\n/// are doing things like full document analysis can use this mechanism\n/// to perform their work incrementally while remaining responsive.\n#[allow(unused_variables)]\nfn idle(&mut self, view: &mut View<Self::Cache>){}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin::initialize":["/// Called when the Plugin is initialized. The plugin receives CoreProxy\n/// object that is a wrapper around the RPC Peer and can be used to call\n/// related methods on the Core in a type-safe manner.\n#[allow(unused_variables)]\nfn initialize(&mut self, core: CoreProxy){}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"Plugin::language_changed":["/// Called when syntax language has changed for this view.\n/// New language is available in the `view`, and old language is available in `old_lang`.\n#[allow(unused_variables)]\nfn language_changed(&mut self, view: &mut View<Self::Cache>, old_lang: LanguageId){}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"base_cache::ChunkCache":["/// A simple cache, holding a single contiguous chunk of the document.\npub struct ChunkCache {\n    /// The position of this chunk relative to the tracked document.\n    /// All offsets are guaranteed to be valid UTF-8 character boundaries.\n    pub offset: usize,\n    /// A chunk of the remote buffer.\n    pub contents: String,\n    /// The (zero-based) line number of the line containing the start of the chunk.\n    pub first_line: usize,\n    /// The byte offset of the start of the chunk from the start of `first_line`.\n    /// If this chunk starts at a line break, this will be 0.\n    pub first_line_offset: usize,\n    /// A list of indexes of newlines in this chunk.\n    pub line_offsets: Vec<usize>,\n    /// The total size of the tracked document.\n    pub buf_size: usize,\n    pub num_lines: usize,\n    pub rev: u64,\n}","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::append_chunk":["/// Append to the existing cache, leaving existing data in place.\nfn append_chunk(&mut self, data: &GetDataResponse){\n        self.contents.push_str(data.chunk.as_str());\n        // this is doing extra work in the case where we're fetching a single\n        // massive (multiple of CHUNK_SIZE) line, but unclear if it's worth optimizing\n        self.recalculate_line_offsets();\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::cached_offset_of_line":["/// Returns the offset of the provided `line_num` if it can be determined\n/// without fetching data. The offset of line 0 is always 0, and there\n/// is an implicit line at the last offset in the buffer.\nfn cached_offset_of_line(&self, line_num: usize) -> Option<usize>{\n        if line_num < self.first_line {\n            return None;\n        }\n\n        let rel_line_num = line_num - self.first_line;\n\n        if rel_line_num == 0 {\n            return Some(self.offset - self.first_line_offset);\n        }\n\n        if rel_line_num <= self.line_offsets.len() {\n            return Some(self.offset + self.line_offsets[rel_line_num - 1]);\n        }\n\n        // EOF\n        if line_num == self.num_lines && self.offset + self.contents.len() == self.buf_size {\n            return Some(self.offset + self.contents.len());\n        }\n        None\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::clear_up_to":["/// Clears anything in the cache up to `offset`, which is indexed relative\n/// to `self.contents`.\n///\n/// # Panics\n///\n/// Panics if `offset` is not a character boundary, or if `offset` is greater than\n/// the length of `self.content`.\nfn clear_up_to(&mut self, offset: usize){\n        if offset > self.contents.len() {\n            panic!(\"offset greater than content length: {} > {}\", offset, self.contents.len())\n        }\n\n        let new_contents = self.contents.split_off(offset);\n        self.contents = new_contents;\n        self.offset += offset;\n        // first find out if offset is a line offset, and set first_line / first_line_offset\n        let (new_line, new_line_off) = match self.line_offsets.binary_search(&offset) {\n            Ok(idx) => (self.first_line + idx + 1, 0),\n            Err(0) => (self.first_line, self.first_line_offset + offset),\n            Err(idx) => (self.first_line + idx, offset - self.line_offsets[idx - 1]),\n        };\n\n        // then clear line_offsets up to and including offset\n        self.line_offsets =\n            self.line_offsets.iter().filter(|i| **i > offset).map(|i| i - offset).collect();\n\n        self.first_line = new_line;\n        self.first_line_offset = new_line_off;\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::recalculate_line_offsets":["fn recalculate_line_offsets(&mut self){\n        self.line_offsets.clear();\n        newline_offsets(&self.contents, &mut self.line_offsets);\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::reset_chunk":["/// Discard any existing cache, starting again with the new data.\nfn reset_chunk(&mut self, data: GetDataResponse){\n        self.contents = data.chunk;\n        self.offset = data.offset;\n        self.first_line = data.first_line;\n        self.first_line_offset = data.first_line_offset;\n        self.recalculate_line_offsets();\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::should_clear":["/// Determine whether we should update our state with this delta,\n/// or if we should clear it. In the update case, also patches up\n/// offsets.\nfn should_clear(&mut self, delta: &RopeDelta) -> bool{\n        let (iv, _) = delta.summary();\n        let start = iv.start();\n        let end = iv.end();\n        // we only apply the delta if it is a simple edit, which\n        // begins inside or immediately following our chunk.\n        // - If it begins _before_ our chunk, we are likely going to\n        // want to fetch the edited region, which will reset our state;\n        // - If it's a complex edit the logic is tricky, and this should\n        // be rare enough we can afford to discard.\n        // The one 'complex edit' we should probably be handling is\n        // the replacement of a single range. This could be a new\n        // convenience method on `Delta`?\n        if start < self.offset || start > self.offset + self.contents.len() {\n            true\n        } else if delta.is_simple_delete() {\n            // Don't go over cache boundary.\n            let end = end.min(self.offset + self.contents.len());\n\n            self.simple_delete(start, end);\n            false\n        } else if let Some(text) = delta.as_simple_insert() {\n            assert_eq!(iv.size(), 0);\n            self.simple_insert(text, start);\n            false\n        } else {\n            true\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::simple_delete":["/// Patches up `self.line_offsets` in the simple delete case.\nfn simple_delete(&mut self, start: usize, end: usize){\n        let del_size = end - start;\n        let start = start - self.offset;\n        let end = end - self.offset;\n        let has_newline = memchr(b'\\n', &self.contents.as_bytes()[start..end]).is_some();\n        // a bit too fancy: only reallocate if we need to remove an item\n        if has_newline {\n            self.line_offsets = self\n                .line_offsets\n                .iter()\n                .filter_map(|off| match *off {\n                    x if x <= start => Some(x),\n                    x if x > start && x <= end => None,\n                    x if x > end => Some(x - del_size),\n                    hmm => panic!(\"invariant violated {} {} {}?\", start, end, hmm),\n                })\n                .collect();\n        } else {\n            self.line_offsets.iter_mut().for_each(|off| {\n                if *off >= end {\n                    *off -= del_size\n                }\n            });\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::simple_insert":["/// Patches up `self.line_offsets` in the simple insert case.\nfn simple_insert(&mut self, text: &Rope, ins_offset: usize){\n        let has_newline = text.measure::<LinesMetric>() > 0;\n        let self_off = self.offset;\n        assert!(ins_offset >= self_off);\n        // regardless of if we are inserting newlines we adjust offsets\n        self.line_offsets.iter_mut().for_each(|off| {\n            if *off > ins_offset - self_off {\n                *off += text.len()\n            }\n        });\n        // calculate and insert new newlines if necessary\n        // we could save some hassle and just rerun memchr on the chunk here?\n        if has_newline {\n            let mut new_offsets = Vec::new();\n            newline_offsets(&String::from(text), &mut new_offsets);\n            new_offsets.iter_mut().for_each(|off| *off += ins_offset - self_off);\n\n            let split_idx = self\n                .line_offsets\n                .binary_search(&new_offsets[0])\n                .err()\n                .expect(\"new index cannot be occupied\");\n\n            self.line_offsets =\n                [&self.line_offsets[..split_idx], &new_offsets, &self.line_offsets[split_idx..]]\n                    .concat();\n        }\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::ChunkCache::update_chunk":["/// Updates `self.contents` with the given delta.\nfn update_chunk(&mut self, delta: &RopeDelta){\n        let chunk_start = self.offset;\n        let chunk_end = chunk_start + self.contents.len();\n        let mut new_state = String::with_capacity(self.contents.len());\n        let mut prev_copy_end = 0;\n        let mut del_before: usize = 0;\n        let mut ins_before: usize = 0;\n\n        for op in delta.els.as_slice() {\n            match *op {\n                DeltaElement::Copy(start, end) => {\n                    if start < chunk_start {\n                        del_before += start - prev_copy_end;\n                        if end >= chunk_start {\n                            let cp_end = (end - chunk_start).min(self.contents.len());\n                            new_state.push_str(&self.contents[0..cp_end]);\n                        }\n                    } else if start <= chunk_end {\n                        if prev_copy_end < chunk_start {\n                            del_before += chunk_start - prev_copy_end;\n                        }\n                        let cp_start = start - chunk_start;\n                        let cp_end = (end - chunk_start).min(self.contents.len());\n                        new_state.push_str(&self.contents[cp_start..cp_end]);\n                    }\n                    prev_copy_end = end;\n                }\n                DeltaElement::Insert(ref s) => {\n                    if prev_copy_end < chunk_start {\n                        ins_before += s.len();\n                    } else if prev_copy_end <= chunk_end {\n                        let s: String = s.into();\n                        new_state.push_str(&s);\n                    }\n                }\n            }\n        }\n        self.offset += ins_before;\n        self.offset -= del_before;\n        self.contents = new_state;\n    }","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"base_cache::newline_offsets":["/// Calculates the offsets of newlines in `text`,\n/// inserting the results into `storage`. The offsets are the offset\n/// of the start of the line, not the line break character.\nfn newline_offsets(text: &str, storage: &mut Vec<usize>){\n    let mut cur_idx = 0;\n    while let Some(idx) = memchr(b'\\n', &text.as_bytes()[cur_idx..]) {\n        storage.push(cur_idx + idx + 1);\n        cur_idx += idx + 1;\n    }\n}","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))"],"core_proxy::CoreProxy":["pub struct CoreProxy {\n    plugin_id: PluginId,\n    peer: RpcPeer,\n}","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::add_status_item":["pub fn add_status_item(&mut self, view_id: ViewId, key: &str, value: &str, alignment: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key,\n            \"value\": value,\n            \"alignment\": alignment\n        });\n\n        self.peer.send_rpc_notification(\"add_status_item\", &params)\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::display_hover":["pub fn display_hover(\n        &mut self,\n        view_id: ViewId,\n        request_id: usize,\n        result: &Result<Hover, RemoteError>,\n    ){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"request_id\": request_id,\n            \"result\": result,\n            \"view_id\": view_id\n        });\n\n        self.peer.send_rpc_notification(\"show_hover\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::new":["pub fn new(plugin_id: PluginId, rpc_ctx: &RpcCtx) -> Self{\n        CoreProxy { plugin_id, peer: rpc_ctx.get_peer().clone() }\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::remove_status_item":["pub fn remove_status_item(&mut self, view_id: ViewId, key: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key\n        });\n\n        self.peer.send_rpc_notification(\"remove_status_item\", &params)\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::schedule_idle":["pub fn schedule_idle(&mut self, view_id: ViewId){\n        let token: usize = view_id.into();\n        self.peer.schedule_idle(token);\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"core_proxy::CoreProxy::update_status_item":["pub fn update_status_item(&mut self, view_id: ViewId, key: &str, value: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": view_id,\n            \"key\": key,\n            \"value\": value\n        });\n\n        self.peer.send_rpc_notification(\"update_status_item\", &params)\n    }","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))"],"dispatch::Dispatcher":["/// Handles raw RPCs from core, updating state and forwarding calls\n/// to the plugin,\npub struct Dispatcher<'a, P: 'a + Plugin> {\n    //TODO: when we add multi-view, this should be an Arc+Mutex/Rc+RefCell\n    views: HashMap<ViewId, View<P::Cache>>,\n    pid: Option<PluginPid>,\n    plugin: &'a mut P,\n}","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_close":["fn do_close(&mut self, view_id: ViewId){\n        {\n            let v = bail!(self.views.get(&view_id), \"close\", self.pid, view_id);\n            self.plugin.did_close(v);\n        }\n        self.views.remove(&view_id);\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_collect_trace":["fn do_collect_trace(&self) -> Result<Value, RemoteError>{\n        use xi_trace::chrome_trace_dump;\n\n        let samples = xi_trace::samples_cloned_unsorted();\n        chrome_trace_dump::to_value(&samples).map_err(|e| RemoteError::Custom {\n            code: 0,\n            message: format!(\"Could not serialize trace: {:?}\", e),\n            data: None,\n        })\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_config_changed":["fn do_config_changed(&mut self, view_id: ViewId, changes: &ConfigTable){\n        let v = bail!(self.views.get_mut(&view_id), \"config_changed\", self.pid, view_id);\n        self.plugin.config_changed(v, &changes);\n        for (key, value) in changes.iter() {\n            v.config_table.insert(key.to_owned(), value.to_owned());\n        }\n        let conf = serde_json::from_value(Value::Object(v.config_table.clone()));\n        v.config = conf.unwrap();\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_custom_command":["fn do_custom_command(&mut self, view_id: ViewId, method: &str, params: Value){\n        let v = bail!(self.views.get_mut(&view_id), method, self.pid, view_id);\n        self.plugin.custom_command(v, method, params);\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_did_save":["fn do_did_save(&mut self, view_id: ViewId, path: PathBuf){\n        let v = bail!(self.views.get_mut(&view_id), \"did_save\", self.pid, view_id);\n        let prev_path = v.path.take();\n        v.path = Some(path);\n        self.plugin.did_save(v, prev_path.as_deref());\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_get_hover":["fn do_get_hover(&mut self, view_id: ViewId, request_id: usize, position: usize){\n        let v = bail!(self.views.get_mut(&view_id), \"get_hover\", self.pid, view_id);\n        self.plugin.get_hover(v, request_id, position)\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_initialize":["fn do_initialize(\n        &mut self,\n        ctx: &RpcCtx,\n        plugin_id: PluginPid,\n        buffers: Vec<PluginBufferInfo>,\n    ){\n        assert!(self.pid.is_none(), \"initialize rpc received with existing pid\");\n        info!(\"Initializing plugin {:?}\", plugin_id);\n        self.pid = Some(plugin_id);\n\n        let core_proxy = CoreProxy::new(self.pid.unwrap(), ctx);\n        self.plugin.initialize(core_proxy);\n\n        self.do_new_buffer(ctx, buffers);\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_language_changed":["fn do_language_changed(&mut self, view_id: ViewId, new_lang: LanguageId){\n        let v = bail!(self.views.get_mut(&view_id), \"language_changed\", self.pid, view_id);\n        let old_lang = v.language_id.clone();\n        v.set_language(new_lang);\n        self.plugin.language_changed(v, old_lang);\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_new_buffer":["fn do_new_buffer(&mut self, ctx: &RpcCtx, buffers: Vec<PluginBufferInfo>){\n        let plugin_id = self.pid.unwrap();\n        buffers\n            .into_iter()\n            .map(|info| View::new(ctx.get_peer().clone(), plugin_id, info))\n            .for_each(|view| {\n                let mut view = view;\n                self.plugin.new_view(&mut view);\n                self.views.insert(view.view_id, view);\n            });\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_shutdown":["fn do_shutdown(&mut self){\n        info!(\"rust plugin lib does not shutdown\");\n        //TODO: handle shutdown\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_tracing_config":["fn do_tracing_config(&mut self, enabled: bool){\n        if enabled {\n            xi_trace::enable_tracing();\n            info!(\"Enabling tracing in global plugin {:?}\", self.pid);\n            trace(\"enable tracing\", &[\"plugin\"]);\n        } else {\n            xi_trace::disable_tracing();\n            info!(\"Disabling tracing in global plugin {:?}\", self.pid);\n            trace(\"enable tracing\", &[\"plugin\"]);\n        }\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::do_update":["fn do_update(&mut self, update: PluginUpdate) -> Result<Value, RemoteError>{\n        let _t = trace_block(\"Dispatcher::do_update\", &[\"plugin\"]);\n        let PluginUpdate {\n            view_id,\n            delta,\n            new_len,\n            new_line_count,\n            rev,\n            undo_group,\n            edit_type,\n            author,\n        } = update;\n        let v = bail_err!(self.views.get_mut(&view_id), \"update\", self.pid, view_id);\n        v.update(delta.as_ref(), new_len, new_line_count, rev, undo_group);\n        self.plugin.update(v, delta.as_ref(), edit_type, author);\n\n        Ok(Value::from(1))\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"dispatch::Dispatcher::<'a, P>::new":["pub(crate) fn new(plugin: &'a mut P) -> Self{\n        Dispatcher { views: HashMap::new(), pid: None, plugin }\n    }","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))"],"mainloop":["/// Run `plugin` until it exits, blocking the current thread.\npub fn mainloop<P: Plugin>(plugin: &mut P) -> Result<(), ReadError>{\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let mut rpc_looper = RpcLoop::new(stdout);\n    let mut dispatcher = Dispatcher::new(plugin);\n\n    rpc_looper.mainloop(|| stdin.lock(), &mut dispatcher)\n}","Real(LocalPath(\"plugin-lib/src/lib.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::close_frontier":["pub fn close_frontier(&mut self){\n        self.cache.close_frontier()\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::find_offset":["pub fn find_offset(&self, offset: usize) -> Result<usize, usize>{\n        self.cache.find_offset(offset)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get":["pub fn get(&self, line_num: usize) -> Option<&S>{\n        self.cache.get(line_num)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_frontier":["pub fn get_frontier(&self) -> Option<usize>{\n        self.cache.get_frontier()\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_prev":["pub fn get_prev(&self, line_num: usize) -> (usize, usize, S){\n        self.cache.get_prev(line_num)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::reset":["pub fn reset(&mut self){\n        self.cache.reset()\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::set":["pub fn set(&mut self, line_num: usize, s: S){\n        let ctx = self.make_ctx();\n        self.cache.set(&ctx, line_num, s)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::<impl view::View<state_cache::StateCache<S>>>::update_frontier":["pub fn update_frontier(&mut self, new_frontier: usize){\n        self.cache.update_frontier(new_frontier)\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::CacheEntry":["struct CacheEntry<S> {\n    line_num: usize,\n    offset: usize,\n    user_state: Option<S>,\n}","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache":["/// The caching state\npub struct StateCache<S> {\n    pub(crate) buf_cache: ChunkCache,\n    state_cache: Vec<CacheEntry<S>>,\n    /// The frontier, represented as a sorted list of line numbers.\n    frontier: Vec<usize>,\n}","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::choose_victim":["fn choose_victim(&self) -> usize{\n        let mut best = None;\n        let mut rng = thread_rng();\n        for _ in 0..NUM_PROBES {\n            let ix = rng.gen_range(0, self.state_cache.len());\n            let gap = self.compute_gap(ix);\n            if best.map(|(last_gap, _)| gap < last_gap).unwrap_or(true) {\n                best = Some((gap, ix));\n            }\n        }\n        best.unwrap().1\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::clear_to_start":["/// Clears any cached text and anything in the state cache before `start`.\nfn clear_to_start(&mut self, start: usize){\n        self.truncate_cache(start);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::close_frontier":["/// Closes the current frontier. This is the correct choice to handle\n/// EOF.\npub fn close_frontier(&mut self){\n        self.frontier.remove(0);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::compute_gap":["/// Compute the gap that would result after deleting the given entry.\nfn compute_gap(&self, ix: usize) -> usize{\n        let before = if ix == 0 { 0 } else { self.state_cache[ix - 1].offset };\n        let after = if let Some(item) = self.state_cache.get(ix + 1) {\n            item.offset\n        } else {\n            self.buf_cache.buf_size\n        };\n        assert!(after >= before, \"{} < {} ix: {}\", after, before, ix);\n        after - before\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::evict":["/// Evict one cache entry.\nfn evict(&mut self){\n        let ix = self.choose_victim();\n        self.state_cache.remove(ix);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::find_line":["/// Find an entry in the cache by line num. On return `Ok(i)` means entry\n/// at index `i` is an exact match, while `Err(i)` means the entry would be\n/// inserted at `i`.\nfn find_line(&self, line_num: usize) -> Result<usize, usize>{\n        self.state_cache.binary_search_by(|probe| probe.line_num.cmp(&line_num))\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::find_offset":["/// Find an entry in the cache by offset. Similar to `find_line`.\npub fn find_offset(&self, offset: usize) -> Result<usize, usize>{\n        self.state_cache.binary_search_by(|probe| probe.offset.cmp(&offset))\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::get":["/// Get the state at the given line number, if it exists in the cache.\npub fn get(&self, line_num: usize) -> Option<&S>{\n        self.find_line(line_num).ok().and_then(|ix| self.state_cache[ix].user_state.as_ref())\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::get_entry":["/// Get the cache entry at the given line number, creating it if necessary.\n/// Returns None if line_num > number of newlines in doc (ie if it references\n/// the end of the partial line at EOF).\nfn get_entry<DS>(&mut self, source: &DS, line_num: usize) -> Option<&mut CacheEntry<S>>\n    where\n        DS: DataSource,{\n        match self.find_line(line_num) {\n            Ok(ix) => Some(&mut self.state_cache[ix]),\n            Err(_ix) => {\n                if line_num == self.buf_cache.num_lines {\n                    None\n                } else {\n                    let offset = self\n                        .buf_cache\n                        .offset_of_line(source, line_num)\n                        .expect(\"get_entry should validate inputs\");\n                    let new_ix = self.insert_entry(line_num, offset, None);\n                    Some(&mut self.state_cache[new_ix])\n                }\n            }\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::get_frontier":["/// The frontier keeps track of work needing to be done. A typical\n/// user will call `get_frontier` to get a line number, do the work\n/// on that line, insert state for the next line, and then call either\n/// `update_frontier` or `close_frontier` depending on whether there\n/// is more work to be done at that location.\npub fn get_frontier(&self) -> Option<usize>{\n        self.frontier.first().cloned()\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::get_prev":["/// Get the state from the nearest cache entry at or before given line number.\n/// Returns line number, offset, and user state.\npub fn get_prev(&self, line_num: usize) -> (usize, usize, S){\n        if line_num > 0 {\n            let mut ix = match self.find_line(line_num) {\n                Ok(ix) => ix,\n                Err(0) => return (0, 0, S::default()),\n                Err(ix) => ix - 1,\n            };\n            loop {\n                let item = &self.state_cache[ix];\n                if let Some(ref s) = item.user_state {\n                    return (item.line_num, item.offset, s.clone());\n                }\n                if ix == 0 {\n                    break;\n                }\n                ix -= 1;\n            }\n        }\n        (0, 0, S::default())\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::insert_entry":["/// Insert a new entry into the cache, returning its index.\nfn insert_entry(&mut self, line_num: usize, offset: usize, user_state: Option<S>) -> usize{\n        if self.state_cache.len() >= CACHE_SIZE {\n            self.evict();\n        }\n        match self.find_line(line_num) {\n            Ok(_ix) => panic!(\"entry already exists\"),\n            Err(ix) => {\n                self.state_cache.insert(ix, CacheEntry { line_num, offset, user_state });\n                ix\n            }\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::line_cache_simple_delete":["fn line_cache_simple_delete(&mut self, start: usize, end: usize){\n        let off = self.buf_cache.offset;\n        let chunk_end = off + self.buf_cache.contents.len();\n        if start >= off && end <= chunk_end {\n            let del_newline_num = count_newlines(&self.buf_cache.contents[start - off..end - off]);\n            // delete all entries that overlap the deleted range\n            let ix = match self.find_offset(start) {\n                Ok(ix) => ix + 1,\n                Err(ix) => ix,\n            };\n            while ix < self.state_cache.len() && self.state_cache[ix].offset <= end {\n                self.state_cache.remove(ix);\n            }\n            for entry in &mut self.state_cache[ix..] {\n                entry.line_num -= del_newline_num;\n                entry.offset -= end - start;\n            }\n            self.patchup_frontier(ix, -(del_newline_num as isize));\n        } else {\n            // if this region isn't in our chunk we can't correctly adjust newlines\n            self.clear_to_start(start);\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::line_cache_simple_insert":["fn line_cache_simple_insert(&mut self, start: usize, new_len: usize, newline_num: usize){\n        let ix = match self.find_offset(start) {\n            Ok(ix) => ix + 1,\n            Err(ix) => ix,\n        };\n\n        for entry in &mut self.state_cache[ix..] {\n            entry.line_num += newline_num;\n            entry.offset += new_len;\n        }\n        self.patchup_frontier(ix, newline_num as isize);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::patchup_frontier":["fn patchup_frontier(&mut self, cache_idx: usize, nl_count_delta: isize){\n        let line_num = match cache_idx {\n            0 => 0,\n            ix => self.state_cache[ix - 1].line_num,\n        };\n        let mut new_frontier = Vec::new();\n        let mut need_push = true;\n        for old_ln in &self.frontier {\n            if *old_ln < line_num {\n                new_frontier.push(*old_ln);\n            } else if need_push {\n                new_frontier.push(line_num);\n                need_push = false;\n                if let Some(ref entry) = self.state_cache.get(cache_idx) {\n                    if *old_ln >= entry.line_num {\n                        new_frontier.push(old_ln.wrapping_add(nl_count_delta as usize));\n                    }\n                }\n            }\n        }\n        if need_push {\n            new_frontier.push(line_num);\n        }\n        self.frontier = new_frontier;\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::reset":["/// Clear all state and reset frontier to start.\npub fn reset(&mut self){\n        self.truncate_cache(0);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::set":["/// Set the state at the given line number. Note: has no effect if line_num\n/// references the end of the partial line at EOF.\npub fn set<DS>(&mut self, source: &DS, line_num: usize, s: S)\n    where\n        DS: DataSource,{\n        if let Some(entry) = self.get_entry(source, line_num) {\n            entry.user_state = Some(s);\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::truncate_cache":["/// Release all state _after_ the given offset.\nfn truncate_cache(&mut self, offset: usize){\n        let (line_num, ix) = match self.find_offset(offset) {\n            Ok(ix) => (self.state_cache[ix].line_num, ix + 1),\n            Err(ix) => (if ix == 0 { 0 } else { self.state_cache[ix - 1].line_num }, ix),\n        };\n        self.truncate_frontier(line_num);\n        self.state_cache.truncate(ix);\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::truncate_frontier":["pub(crate) fn truncate_frontier(&mut self, line_num: usize){\n        match self.frontier.binary_search(&line_num) {\n            Ok(ix) => self.frontier.truncate(ix + 1),\n            Err(ix) => {\n                self.frontier.truncate(ix);\n                self.frontier.push(line_num);\n            }\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::update_frontier":["/// Updates the frontier. This can go backward, but most typically\n/// goes forward by 1 line (compared to the `get_frontier` result).\npub fn update_frontier(&mut self, new_frontier: usize){\n        if self.frontier.get(1) == Some(&new_frontier) {\n            self.frontier.remove(0);\n        } else {\n            self.frontier[0] = new_frontier;\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::StateCache::<S>::update_line_cache":["/// Updates the line cache to reflect this delta.\nfn update_line_cache(&mut self, delta: &RopeDelta){\n        let (iv, new_len) = delta.summary();\n        if let Some(n) = delta.as_simple_insert() {\n            assert_eq!(iv.size(), 0);\n            assert_eq!(new_len, n.len());\n\n            let newline_count = n.measure::<LinesMetric>();\n            self.line_cache_simple_insert(iv.start(), new_len, newline_count);\n        } else if delta.is_simple_delete() {\n            assert_eq!(new_len, 0);\n            self.line_cache_simple_delete(iv.start(), iv.end())\n        } else {\n            self.clear_to_start(iv.start());\n        }\n    }","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"state_cache::count_newlines":["fn count_newlines(s: &str) -> usize{\n    bytecount::count(s.as_bytes(), b'\\n')\n}","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))"],"view::FetchCtx":["/// A simple wrapper type that acts as a `DataSource`.\npub struct FetchCtx {\n    plugin_id: PluginPid,\n    view_id: ViewId,\n    peer: RpcPeer,\n}","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View":["/// A type that acts as a proxy for a remote view. Provides access to\n/// a document cache, and implements various methods for querying and modifying\n/// view state.\npub struct View<C> {\n    pub(crate) cache: C,\n    pub(crate) peer: RpcPeer,\n    pub(crate) path: Option<PathBuf>,\n    pub(crate) config: BufferConfig,\n    pub(crate) config_table: ConfigTable,\n    plugin_id: PluginPid,\n    // TODO: this is only public to avoid changing the syntect impl\n    // this should go away with async edits\n    pub rev: u64,\n    pub undo_group: Option<usize>,\n    buf_size: usize,\n    pub(crate) view_id: ViewId,\n    pub(crate) language_id: LanguageId,\n}","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::add_scopes":["pub fn add_scopes(&self, scopes: &[Vec<String>]){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"scopes\": scopes,\n        });\n        self.peer.send_rpc_notification(\"add_scopes\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::add_status_item":["pub fn add_status_item(&self, key: &str, value: &str, alignment: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key,\n            \"value\": value,\n            \"alignment\": alignment\n        });\n        self.peer.send_rpc_notification(\"add_status_item\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::edit":["pub fn edit(\n        &self,\n        delta: RopeDelta,\n        priority: u64,\n        after_cursor: bool,\n        new_undo_group: bool,\n        author: String,\n    ){\n        let undo_group = if new_undo_group { None } else { self.undo_group };\n        let edit = PluginEdit { rev: self.rev, delta, priority, after_cursor, undo_group, author };\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"edit\": edit\n        });\n        self.peer.send_rpc_notification(\"edit\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_buf_size":["/// Returns the length of the view's buffer, in bytes.\npub fn get_buf_size(&self) -> usize{\n        self.buf_size\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_cache":["pub fn get_cache(&mut self) -> &mut C{\n        &mut self.cache\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_config":["pub fn get_config(&self) -> &BufferConfig{\n        &self.config\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_document":["pub fn get_document(&mut self) -> Result<String, Error>{\n        let ctx = self.make_ctx();\n        self.cache.get_document(&ctx)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_id":["pub fn get_id(&self) -> ViewId{\n        self.view_id\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_language_id":["pub fn get_language_id(&self) -> &LanguageId{\n        &self.language_id\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_line":["pub fn get_line(&mut self, line_num: usize) -> Result<&str, Error>{\n        let ctx = self.make_ctx();\n        self.cache.get_line(&ctx, line_num)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_path":["pub fn get_path(&self) -> Option<&Path>{\n        self.path.as_deref()\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::get_region":["/// Returns a region of the view's buffer.\npub fn get_region<I: IntervalBounds>(&mut self, interval: I) -> Result<&str, Error>{\n        let ctx = self.make_ctx();\n        self.cache.get_region(&ctx, interval)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::line_of_offset":["pub fn line_of_offset(&mut self, offset: usize) -> Result<usize, Error>{\n        let ctx = self.make_ctx();\n        self.cache.line_of_offset(&ctx, offset)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::make_ctx":["/// Returns a `FetchCtx`, a thin wrapper around an RpcPeer that implements\n/// the `DataSource` trait and can be used when updating a cache.\npub(crate) fn make_ctx(&self) -> FetchCtx{\n        FetchCtx { view_id: self.view_id, plugin_id: self.plugin_id, peer: self.peer.clone() }\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::new":["pub(crate) fn new(peer: RpcPeer, plugin_id: PluginPid, info: PluginBufferInfo) -> Self{\n        let PluginBufferInfo { views, rev, path, config, buf_size, nb_lines, syntax, .. } = info;\n\n        assert_eq!(views.len(), 1, \"assuming single view\");\n        let view_id = views.first().unwrap().to_owned();\n        let path = path.map(PathBuf::from);\n        View {\n            cache: C::new(buf_size, rev, nb_lines),\n            peer,\n            config_table: config.clone(),\n            config: serde_json::from_value(Value::Object(config)).unwrap(),\n            path,\n            plugin_id,\n            view_id,\n            rev,\n            undo_group: None,\n            buf_size,\n            language_id: syntax,\n        }\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::offset_of_line":["pub fn offset_of_line(&mut self, line_num: usize) -> Result<usize, Error>{\n        let ctx = self.make_ctx();\n        self.cache.offset_of_line(&ctx, line_num)\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::remove_status_item":["pub fn remove_status_item(&self, key: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key\n        });\n        self.peer.send_rpc_notification(\"remove_status_item\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::request_is_pending":["/// Returns `true` if an incoming RPC is pending. This is intended\n/// to reduce latency for bulk operations done in the background.\npub fn request_is_pending(&self) -> bool{\n        self.peer.request_is_pending()\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::schedule_idle":["pub fn schedule_idle(&self){\n        let token: usize = self.view_id.into();\n        self.peer.schedule_idle(token);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::set_language":["pub(crate) fn set_language(&mut self, new_language_id: LanguageId){\n        self.language_id = new_language_id;\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::update":["pub(crate) fn update(\n        &mut self,\n        delta: Option<&RopeDelta>,\n        new_len: usize,\n        new_num_lines: usize,\n        rev: u64,\n        undo_group: Option<usize>,\n    ){\n        self.cache.update(delta, new_len, new_num_lines, rev);\n        self.rev = rev;\n        self.undo_group = undo_group;\n        self.buf_size = new_len;\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::update_annotations":["pub fn update_annotations(\n        &self,\n        start: usize,\n        len: usize,\n        annotation_spans: &[DataSpan],\n        annotation_type: &AnnotationType,\n    ){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"len\": len,\n            \"rev\": self.rev,\n            \"spans\": annotation_spans,\n            \"annotation_type\": annotation_type,\n        });\n        self.peer.send_rpc_notification(\"update_annotations\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::update_spans":["pub fn update_spans(&self, start: usize, len: usize, spans: &[ScopeSpan]){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"start\": start,\n            \"len\": len,\n            \"rev\": self.rev,\n            \"spans\": spans,\n        });\n        self.peer.send_rpc_notification(\"update_spans\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"],"view::View::<C>::update_status_item":["pub fn update_status_item(&self, key: &str, value: &str){\n        let params = json!({\n            \"plugin_id\": self.plugin_id,\n            \"view_id\": self.view_id,\n            \"key\": key,\n            \"value\": value\n        });\n        self.peer.send_rpc_notification(\"update_status_item\", &params);\n    }","Real(LocalPath(\"plugin-lib/src/view.rs\"))"]},"struct_constructor":{"&std::path::Path":["get_path"],"&str":["get_line","get_region"],"&xi_core::BufferConfig":["get_config"],"&xi_core::LanguageId":["get_language_id"],"(usize, usize, S)":["get_prev"],"base_cache::ChunkCache":["clone","default","new"],"bool":["request_is_pending","should_clear"],"core_proxy::CoreProxy":["clone","new"],"dispatch::Dispatcher":["new"],"serde_json::Value":["do_collect_trace","do_update","handle_request"],"state_cache::StateCache":["default","new"],"std::string::String":["get_document"],"usize":["choose_victim","count_newlines","get_buf_size","get_frontier"],"view::FetchCtx":["make_ctx"],"view::View":["new"],"xi_core::ViewId":["get_id"],"xi_core::plugin_rpc::GetDataResponse":["get_data"]},"struct_to_trait":{"Error":["std::fmt::Debug"],"base_cache::ChunkCache":["Cache","std::clone::Clone","std::default::Default","std::fmt::Debug"],"core_proxy::CoreProxy":["std::clone::Clone"],"dispatch::Dispatcher":["xi_rpc::Handler"],"state_cache::StateCache":["Cache","std::default::Default"],"view::FetchCtx":["DataSource"]},"targets":{"<base_cache::ChunkCache as Cache>::clear":["clear","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::get_document":["get_document","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::get_line":["get_line","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::get_region":["get_region","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::line_of_offset":["line_of_offset","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::new":["new","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::offset_of_line":["offset_of_line","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<base_cache::ChunkCache as Cache>::update":["update","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))","Cache"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_notification":["handle_notification","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))","xi_rpc::Handler"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::handle_request":["handle_request","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))","xi_rpc::Handler"],"<dispatch::Dispatcher<'a, P> as xi_rpc::Handler>::idle":["idle","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))","xi_rpc::Handler"],"<state_cache::StateCache<S> as Cache>::clear":["clear","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::get_document":["get_document","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::get_line":["get_line","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::get_region":["get_region","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::line_of_offset":["line_of_offset","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::new":["new","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::offset_of_line":["offset_of_line","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<state_cache::StateCache<S> as Cache>::update":["update","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))","Cache"],"<view::FetchCtx as DataSource>::get_data":["get_data","Real(LocalPath(\"plugin-lib/src/view.rs\"))","DataSource"],"Plugin::custom_command":["custom_command","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"Plugin::get_hover":["get_hover","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"Plugin::idle":["idle","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"Plugin::initialize":["initialize","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"Plugin::language_changed":["language_changed","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"base_cache::ChunkCache::append_chunk":["append_chunk","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::cached_offset_of_line":["cached_offset_of_line","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::clear_up_to":["clear_up_to","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::recalculate_line_offsets":["recalculate_line_offsets","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::reset_chunk":["reset_chunk","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::should_clear":["should_clear","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::simple_delete":["simple_delete","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::simple_insert":["simple_insert","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::ChunkCache::update_chunk":["update_chunk","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"base_cache::newline_offsets":["newline_offsets","Real(LocalPath(\"plugin-lib/src/base_cache.rs\"))",""],"core_proxy::CoreProxy::add_status_item":["add_status_item","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"core_proxy::CoreProxy::display_hover":["display_hover","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"core_proxy::CoreProxy::new":["new","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"core_proxy::CoreProxy::remove_status_item":["remove_status_item","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"core_proxy::CoreProxy::schedule_idle":["schedule_idle","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"core_proxy::CoreProxy::update_status_item":["update_status_item","Real(LocalPath(\"plugin-lib/src/core_proxy.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_close":["do_close","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_collect_trace":["do_collect_trace","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_config_changed":["do_config_changed","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_custom_command":["do_custom_command","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_did_save":["do_did_save","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_get_hover":["do_get_hover","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_initialize":["do_initialize","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_language_changed":["do_language_changed","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_new_buffer":["do_new_buffer","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_shutdown":["do_shutdown","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_tracing_config":["do_tracing_config","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::do_update":["do_update","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"dispatch::Dispatcher::<'a, P>::new":["new","Real(LocalPath(\"plugin-lib/src/dispatch.rs\"))",""],"mainloop":["mainloop","Real(LocalPath(\"plugin-lib/src/lib.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::close_frontier":["close_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::find_offset":["find_offset","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get":["get","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_frontier":["get_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::get_prev":["get_prev","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::reset":["reset","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::set":["set","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::<impl view::View<state_cache::StateCache<S>>>::update_frontier":["update_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::choose_victim":["choose_victim","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::clear_to_start":["clear_to_start","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::close_frontier":["close_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::compute_gap":["compute_gap","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::evict":["evict","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::find_line":["find_line","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::find_offset":["find_offset","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::get":["get","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::get_entry":["get_entry","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::get_frontier":["get_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::get_prev":["get_prev","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::insert_entry":["insert_entry","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::line_cache_simple_delete":["line_cache_simple_delete","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::line_cache_simple_insert":["line_cache_simple_insert","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::patchup_frontier":["patchup_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::reset":["reset","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::set":["set","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::truncate_cache":["truncate_cache","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::truncate_frontier":["truncate_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::update_frontier":["update_frontier","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::StateCache::<S>::update_line_cache":["update_line_cache","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"state_cache::count_newlines":["count_newlines","Real(LocalPath(\"plugin-lib/src/state_cache.rs\"))",""],"view::View::<C>::add_scopes":["add_scopes","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::add_status_item":["add_status_item","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::edit":["edit","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_buf_size":["get_buf_size","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_cache":["get_cache","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_config":["get_config","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_document":["get_document","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_id":["get_id","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_language_id":["get_language_id","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_line":["get_line","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_path":["get_path","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::get_region":["get_region","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::line_of_offset":["line_of_offset","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::make_ctx":["make_ctx","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::new":["new","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::offset_of_line":["offset_of_line","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::remove_status_item":["remove_status_item","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::request_is_pending":["request_is_pending","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::schedule_idle":["schedule_idle","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::set_language":["set_language","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::update":["update","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::update_annotations":["update_annotations","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::update_spans":["update_spans","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""],"view::View::<C>::update_status_item":["update_status_item","Real(LocalPath(\"plugin-lib/src/view.rs\"))",""]},"trait_to_struct":{"Cache":["base_cache::ChunkCache","state_cache::StateCache"],"DataSource":["view::FetchCtx"],"std::clone::Clone":["base_cache::ChunkCache","core_proxy::CoreProxy"],"std::default::Default":["base_cache::ChunkCache","state_cache::StateCache"],"std::fmt::Debug":["Error","base_cache::ChunkCache"],"xi_rpc::Handler":["dispatch::Dispatcher"]},"type_to_def_path":{"Error":"Error","base_cache::ChunkCache":"base_cache::ChunkCache","core_proxy::CoreProxy":"core_proxy::CoreProxy","dispatch::Dispatcher<'a, P>":"dispatch::Dispatcher","state_cache::CacheEntry<S>":"state_cache::CacheEntry","state_cache::StateCache<S>":"state_cache::StateCache","view::FetchCtx":"view::FetchCtx","view::View<C>":"view::View"}}