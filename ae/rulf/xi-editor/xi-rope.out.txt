-----------------
rope/src/compare.rs compare::sse_compare_mask
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::sse_compare_mask(p0, p1);
+crate::compare::sse_compare_mask(p0, p1);
+crate::compare::sse_compare_mask(p0, p1);
-----------------
rope/src/compare.rs compare::avx_compare_mask
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::avx_compare_mask(p0, p1);
+crate::compare::avx_compare_mask(p0, p1);
+crate::compare::avx_compare_mask(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx(p0, p1);
+crate::compare::ne_idx(p0, p1);
+crate::compare::ne_idx(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev(p0, p1);
+crate::compare::ne_idx_rev(p0, p1);
+crate::compare::ne_idx_rev(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_avx
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_avx(p0, p1);
+crate::compare::ne_idx_avx(p0, p1);
+crate::compare::ne_idx_avx(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_sse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_sse(p0, p1);
+crate::compare::ne_idx_sse(p0, p1);
+crate::compare::ne_idx_sse(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev_sse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev_sse(p0, p1);
+crate::compare::ne_idx_rev_sse(p0, p1);
+crate::compare::ne_idx_rev_sse(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_fallback
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_fallback(p0, p1);
+crate::compare::ne_idx_fallback(p0, p1);
+crate::compare::ne_idx_fallback(p0, p1);
-----------------
rope/src/compare.rs compare::ne_idx_rev_fallback
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+compare::ne_idx_rev_fallback(p0, p1);
+crate::compare::ne_idx_rev_fallback(p0, p1);
+crate::compare::ne_idx_rev_fallback(p0, p1);
-----------------
rope/src/diff.rs diff::expand_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
let mut p4 = 0usize; // None+usize
+diff::expand_match(p0, p1, p2, p3, p4);
+crate::diff::expand_match(p0, p1, p2, p3, p4);
+crate::diff::expand_match(p0, p1, p2, p3, p4);
-----------------
rope/src/diff.rs diff::longest_increasing_region_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(usize, usize)]
+diff::longest_increasing_region_set(p0);
+crate::diff::longest_increasing_region_set(p0);
+crate::diff::longest_increasing_region_set(p0);
-----------------
rope/src/diff.rs diff::non_ws_offset
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+diff::non_ws_offset(&p0);
+crate::diff::non_ws_offset(&p0);
+crate::diff::non_ws_offset(&p0);
-----------------
rope/src/diff.rs diff::make_line_hashes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+diff::make_line_hashes(p0, p1);
+crate::diff::make_line_hashes(p0, p1);
+crate::diff::make_line_hashes(p0, p1);
-----------------
rope/src/engine.rs engine::default_session
deps:{}
candidates:{}
+engine::default_session();
+crate::engine::default_session();
+crate::engine::default_session();
-----------------
rope/src/engine.rs engine::shuffle_tombstones
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::shuffle_tombstones(p0, p1, p2, p3);
+crate::engine::shuffle_tombstones(p0, p1, p2, p3);
+crate::engine::shuffle_tombstones(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::shuffle
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::shuffle(p0, p1, p2, p3);
+crate::engine::shuffle(p0, p1, p2, p3);
+crate::engine::shuffle(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::find_base_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
+engine::find_base_index(p0, p1);
+crate::engine::find_base_index(p0, p1);
+crate::engine::find_base_index(p0, p1);
-----------------
rope/src/engine.rs engine::find_common
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
+engine::find_common(p0, p1);
+crate::engine::find_common(p0, p1);
+crate::engine::find_common(p0, p1);
-----------------
rope/src/engine.rs engine::rearrange
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<engine::RevId>
let mut p2 = 0usize; // None+usize
+engine::rearrange(p0, p1, p2);
+crate::engine::rearrange(p0, p1, p2);
+crate::engine::rearrange(p0, p1, p2);
-----------------
rope/src/engine.rs engine::compute_deltas
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [engine::Revision]
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p3 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+engine::compute_deltas(p0, p1, p2, p3);
+crate::engine::compute_deltas(p0, p1, p2, p3);
+crate::engine::compute_deltas(p0, p1, p2, p3);
-----------------
rope/src/engine.rs engine::compute_transforms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<engine::Revision>
+engine::compute_transforms(p0);
+crate::engine::compute_transforms(p0);
+crate::engine::compute_transforms(p0);
-----------------
rope/src/engine.rs engine::rebase
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<(engine::FullPriority, multiset::Subset)>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<engine::DeltaOp>
let mut p2 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p3 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p4 = MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p5 = 0usize; // None+usize
+engine::rebase(p0, p1, p2, p3, p4, p5);
+crate::engine::rebase(p0, p1, p2, p3, p4, p5);
+crate::engine::rebase(p0, p1, p2, p3, p4, p5);
-----------------
rope/src/find.rs find::find
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p3 = "sample"; // None+&str
let mut p4 = MaybeUninit::uninit().assume_init(); // std::option::Option<&regex::Regex>
+find::find(p0, p1, p2, &p3, p4);
+crate::find::find(p0, p1, p2, &p3, p4);
+crate::find::find(p0, p1, p2, &p3, p4);
-----------------
rope/src/find.rs find::find_progress
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
let mut p5 = MaybeUninit::uninit().assume_init(); // std::option::Option<&regex::Regex>
+find::find_progress(p0, p1, p2, &p3, p4, p5);
+crate::find::find_progress(p0, p1, p2, &p3, p4, p5);
+crate::find::find_progress(p0, p1, p2, &p3, p4, p5);
-----------------
rope/src/find.rs find::find_progress_iter
deps:{"find::find_progress_iter":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["std::marker::Sized","std::ops::Fn"],"impl Fn(&str) -> Option<usize>":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"find::find_progress_iter":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault"],"impl Fn(&str) -> Option<usize>":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = MaybeUninit::uninit().assume_init(); // impl Fn(&str) -> Option<usize>
let mut p4 = MaybeUninit::uninit().assume_init(); // impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>
let mut p5 = 0usize; // None+usize
+find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
+crate::find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
+crate::find::find_progress_iter(p0, p1, &p2, p3, p4, p5);
-----------------
rope/src/find.rs find::find_core
deps:{"find::find_core":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["std::marker::Sized","std::ops::Fn"],"impl Fn(&str) -> Option<usize>":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"find::find_core":{"impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr"],"impl Fn(&str) -> Option<usize>":["core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = MaybeUninit::uninit().assume_init(); // impl Fn(&str) -> Option<usize>
let mut p4 = MaybeUninit::uninit().assume_init(); // impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>
+find::find_core(p0, p1, &p2, p3, p4);
+crate::find::find_core(p0, p1, &p2, p3, p4);
+crate::find::find_core(p0, p1, &p2, p3, p4);
-----------------
rope/src/find.rs find::compare_cursor_str
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
+find::compare_cursor_str(p0, p1, &p2);
+crate::find::compare_cursor_str(p0, p1, &p2);
+crate::find::compare_cursor_str(p0, p1, &p2);
-----------------
rope/src/find.rs find::compare_cursor_str_casei
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
+find::compare_cursor_str_casei(p0, p1, &p2);
+crate::find::compare_cursor_str_casei(p0, p1, &p2);
+crate::find::compare_cursor_str_casei(p0, p1, &p2);
-----------------
rope/src/find.rs find::compare_cursor_regex
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'_, rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'_>
let mut p2 = "sample"; // None+&str
let mut p3 = & MaybeUninit::uninit().assume_init(); // regex::Regex
+find::compare_cursor_regex(p0, p1, &p2, p3);
+crate::find::compare_cursor_regex(p0, p1, &p2, p3);
+crate::find::compare_cursor_regex(p0, p1, &p2, p3);
-----------------
rope/src/find.rs find::is_multiline_regex
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+find::is_multiline_regex(&p0);
+crate::find::is_multiline_regex(&p0);
+crate::find::is_multiline_regex(&p0);
-----------------
rope/src/find.rs find::scan_lowercase
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = "sample"; // None+&str
+find::scan_lowercase(p0, &p1);
+crate::find::scan_lowercase(p0, &p1);
+crate::find::scan_lowercase(p0, &p1);
-----------------
rope/src/rope.rs rope::len_utf8_from_first_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+rope::len_utf8_from_first_byte(p0);
+crate::rope::len_utf8_from_first_byte(p0);
+crate::rope::len_utf8_from_first_byte(p0);
-----------------
rope/src/rope.rs rope::count_newlines
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::count_newlines(&p0);
+crate::rope::count_newlines(&p0);
+crate::rope::count_newlines(&p0);
-----------------
rope/src/rope.rs rope::count_utf16_code_units
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::count_utf16_code_units(&p0);
+crate::rope::count_utf16_code_units(&p0);
+crate::rope::count_utf16_code_units(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split_for_bulk
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::find_leaf_split_for_bulk(&p0);
+crate::rope::find_leaf_split_for_bulk(&p0);
+crate::rope::find_leaf_split_for_bulk(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split_for_merge
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::find_leaf_split_for_merge(&p0);
+crate::rope::find_leaf_split_for_merge(&p0);
+crate::rope::find_leaf_split_for_merge(&p0);
-----------------
rope/src/rope.rs rope::find_leaf_split
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+rope::find_leaf_split(&p0, p1);
+crate::rope::find_leaf_split(&p0, p1);
+crate::rope::find_leaf_split(&p0, p1);
-----------------
rope/src/rope.rs rope::cow_append
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
let mut p1 = "sample"; // None+&str
+rope::cow_append(p0, &p1);
+crate::rope::cow_append(p0, &p1);
+crate::rope::cow_append(p0, &p1);
-----------------
rope/src/diff.rs diff::Diff::compute_delta
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"diff::Diff::compute_delta":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["diff::Diff"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"diff::Diff::compute_delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"Self":["diff::LineHashDiff"]},"spans::Span":{"T":["find::CaseMatching","rope::BaseMetric","multiset::ZipSegment","tree::NodeBody","diff::DiffOp","tree::NodeVal","tree::Node","engine::FullPriority","delta::DeltaElement","engine::Error","multiset::Subset","rope::LinesMetric","engine::RevId","rope::Utf16CodeUnitsMetric","delta::Delta","engine::DeltaOp","interval::Interval","spans::Span","spans::SpansInfo","breaks::BreaksBaseMetric","multiset::Segment","engine::Contents","breaks::BreaksLeaf","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","breaks::BreaksMetric","multiset::CountMatcher","delta::InsertDelta"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","diff::DiffOp","breaks::BreaksBaseMetric","spans::SpansLeaf","diff::DiffBuilder","engine::DeltaOp","rope::LinesMetric","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","tree::NodeBody","spans::Span","rope::RopeInfo","multiset::CountMatcher","delta::DeltaElement","rope::BaseMetric","engine::Contents","multiset::Segment","spans::SpansInfo","interval::Interval","engine::RevId","engine::Error","engine::FullPriority","delta::InsertDelta","tree::NodeVal","multiset::Subset","breaks::BreaksInfo","delta::Delta","find::CaseMatching","breaks::BreaksLeaf"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","tree::NodeVal","diff::DiffBuilder","breaks::BreaksMetric","tree::Node","breaks::BreaksBaseMetric","multiset::ZipSegment","multiset::Segment","rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::Error","breaks::BreaksInfo","breaks::BreaksLeaf","spans::Span","engine::RevId","interval::Interval","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","rope::RopeInfo","multiset::CountMatcher","rope::BaseMetric","multiset::Subset","engine::Contents","diff::DiffOp","find::CaseMatching","spans::SpansLeaf","rope::LinesMetric","delta::InsertDelta","delta::DeltaElement","tree::NodeBody"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+diff::Diff::compute_delta(p0, p1);
+crate::diff::Diff::compute_delta(p0, p1);
+crate::diff::Diff::compute_delta(p0, p1);
-----------------
rope/src/interval.rs interval::IntervalBounds::into_interval
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"interval::IntervalBounds::into_interval":{"Self":["interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"interval::IntervalBounds::into_interval":{"Self":["std::ops::RangeFrom","std::ops::RangeFull","<T as interval::IntervalBounds>"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+interval::IntervalBounds::into_interval(p0, p1);
+crate::interval::IntervalBounds::into_interval(p0, p1);
+crate::interval::IntervalBounds::into_interval(p0, p1);
-----------------
rope/src/tree.rs tree::NodeInfo::accumulate
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeInfo::accumulate":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::Delta","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","rope::LinesMetric","interval::Interval","tree::Node","breaks::BreaksInfo","diff::DiffBuilder","tree::NodeVal","tree::NodeBody","diff::DiffOp","rope::RopeInfo","delta::DeltaElement","multiset::CountMatcher","multiset::Segment","engine::FullPriority","breaks::BreaksMetric","spans::Span","multiset::ZipSegment","delta::InsertDelta","rope::BaseMetric","spans::SpansInfo","multiset::Subset","engine::Contents","find::CaseMatching","breaks::BreaksLeaf","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","engine::Error"]},"spans::SpansInfo":{"T":["diff::DiffOp","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","delta::Delta","multiset::ZipSegment","tree::Node","engine::FullPriority","multiset::CountMatcher","rope::LinesMetric","rope::BaseMetric","spans::SpansInfo","interval::Interval","multiset::Segment","engine::Contents","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","find::CaseMatching","breaks::BreaksInfo","spans::SpansLeaf","breaks::BreaksLeaf","engine::DeltaOp","engine::Error","spans::Span","rope::RopeInfo","delta::InsertDelta","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksBaseMetric","engine::RevId","tree::NodeBody"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::Contents","diff::DiffOp","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo","delta::DeltaElement","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","breaks::BreaksMetric","spans::SpansInfo","tree::NodeBody","multiset::Subset","interval::Interval","engine::DeltaOp","find::CaseMatching","multiset::CountMatcher","engine::Error","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksLeaf","tree::NodeVal","breaks::BreaksInfo","engine::RevId","multiset::Segment","diff::DiffBuilder","multiset::ZipSegment","delta::Delta","spans::Span","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeInfo::accumulate":{"Self":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.accumulate(p1);
+tree::NodeInfo::accumulate(p0, p1);
+crate::tree::NodeInfo::accumulate(p0, p1);
+crate::tree::NodeInfo::accumulate(p0, p1);
-----------------
rope/src/tree.rs tree::NodeInfo::compute_info
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeInfo::compute_info":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["find::CaseMatching","breaks::BreaksBaseMetric","tree::NodeVal","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::DeltaOp","delta::InsertDelta","rope::BaseMetric","spans::Span","spans::SpansInfo","diff::DiffBuilder","engine::RevId","tree::NodeBody","engine::Error","breaks::BreaksLeaf","multiset::Segment","multiset::ZipSegment","tree::Node","delta::Delta","interval::Interval","engine::Contents","rope::LinesMetric","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::FullPriority","breaks::BreaksInfo","breaks::BreaksMetric","multiset::CountMatcher","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","delta::DeltaElement"]},"spans::SpansInfo":{"T":["tree::NodeVal","spans::SpansInfo","multiset::CountMatcher","engine::FullPriority","delta::Delta","engine::Contents","rope::RopeInfo","spans::Span","tree::NodeBody","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","breaks::BreaksMetric","interval::Interval","diff::DiffOp","delta::DeltaElement","rope::BaseMetric","find::CaseMatching","delta::InsertDelta","breaks::BreaksBaseMetric","multiset::Subset","engine::Error","diff::DiffBuilder","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::Node","multiset::ZipSegment","spans::SpansLeaf","engine::RevId","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","engine::Contents","tree::NodeBody","tree::NodeVal","rope::RopeInfo","multiset::Subset","breaks::BreaksInfo","find::CaseMatching","tree::Node","breaks::BreaksLeaf","spans::Span","multiset::CountMatcher","spans::SpansInfo","diff::DiffOp","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","engine::RevId","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","engine::DeltaOp","delta::Delta","rope::LinesMetric","engine::FullPriority","breaks::BreaksBaseMetric","diff::DiffBuilder","interval::Interval","delta::DeltaElement","engine::Error","delta::InsertDelta","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeInfo::compute_info":{"Self":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <Self as tree::NodeInfo>::L
+tree::NodeInfo::compute_info(p0);
+crate::tree::NodeInfo::compute_info(p0);
+crate::tree::NodeInfo::compute_info(p0);
-----------------
rope/src/tree.rs tree::NodeInfo::identity
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeInfo::identity":{"Self":["tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["interval::Interval","diff::DiffBuilder","spans::Span","spans::SpansInfo","breaks::BreaksBaseMetric","breaks::BreaksLeaf","engine::Contents","multiset::Segment","engine::Error","tree::NodeVal","delta::DeltaElement","rope::RopeInfo","delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::DeltaOp","spans::SpansLeaf","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","breaks::BreaksMetric","rope::LinesMetric","diff::DiffOp","multiset::Subset","find::CaseMatching","rope::BaseMetric","engine::RevId","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksInfo","tree::Node"]},"spans::SpansInfo":{"T":["engine::Contents","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","rope::BaseMetric","tree::NodeBody","find::CaseMatching","engine::RevId","diff::DiffBuilder","tree::Node","diff::DiffOp","multiset::Subset","breaks::BreaksLeaf","delta::InsertDelta","breaks::BreaksMetric","spans::Span","engine::DeltaOp","spans::SpansInfo","delta::DeltaElement","engine::FullPriority","rope::LinesMetric","multiset::CountMatcher","breaks::BreaksInfo","rope::RopeInfo","multiset::Segment","rope::Utf16CodeUnitsMetric","tree::NodeVal","engine::Error","breaks::BreaksBaseMetric","multiset::ZipSegment","delta::Delta"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","multiset::CountMatcher","engine::DeltaOp","spans::Span","find::CaseMatching","engine::Error","tree::NodeBody","engine::Contents","tree::NodeVal","rope::LinesMetric","engine::RevId","tree::Node","rope::Utf16CodeUnitsMetric","spans::SpansInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","multiset::Segment","breaks::BreaksBaseMetric","engine::FullPriority","diff::DiffOp","interval::Interval","breaks::BreaksMetric","breaks::BreaksLeaf","multiset::Subset","delta::DeltaElement","multiset::ZipSegment","diff::DiffBuilder","rope::BaseMetric","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeInfo::identity":{"Self":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
+tree::NodeInfo::identity();
+crate::tree::NodeInfo::identity();
+crate::tree::NodeInfo::identity();
-----------------
rope/src/tree.rs tree::NodeInfo::interval
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeInfo::interval":{"Self":["std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::LinesMetric","multiset::CountMatcher","breaks::BreaksInfo","spans::SpansInfo","breaks::BreaksLeaf","engine::FullPriority","diff::DiffBuilder","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","tree::NodeBody","multiset::Segment","engine::RevId","diff::DiffOp","multiset::ZipSegment","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","rope::RopeInfo","rope::Utf16CodeUnitsMetric","delta::InsertDelta","rope::BaseMetric","delta::DeltaElement","spans::Span","tree::NodeVal","find::CaseMatching","engine::Contents","tree::Node","interval::Interval","multiset::Subset","breaks::BreaksBaseMetric","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","spans::SpansLeaf","delta::Delta","multiset::Subset","tree::Node","multiset::Segment","rope::Utf16CodeUnitsMetric","delta::DeltaElement","delta::InsertDelta","rope::BaseMetric","engine::Contents","rope::LinesMetric","tree::NodeBody","tree::NodeVal","breaks::BreaksLeaf","interval::Interval","spans::Span","breaks::BreaksInfo","diff::DiffBuilder","spans::SpansInfo","engine::RevId","rope::RopeInfo","diff::DiffOp","find::CaseMatching","engine::DeltaOp","breaks::BreaksMetric","multiset::CountMatcher","engine::FullPriority","engine::Error","multiset::ZipSegment"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","diff::DiffBuilder","diff::DiffOp","engine::DeltaOp","multiset::Subset","spans::SpansInfo","tree::NodeBody","breaks::BreaksMetric","tree::NodeVal","breaks::BreaksInfo","engine::Error","engine::RevId","breaks::BreaksBaseMetric","multiset::CountMatcher","rope::LinesMetric","engine::Contents","delta::DeltaElement","multiset::Segment","find::CaseMatching","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","delta::InsertDelta","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","delta::Delta","interval::Interval","engine::FullPriority","multiset::ZipSegment","breaks::BreaksLeaf","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeInfo::interval":{"Self":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.interval(p1);
+tree::NodeInfo::interval(p0, p1);
+crate::tree::NodeInfo::interval(p0, p1);
+crate::tree::NodeInfo::interval(p0, p1);
-----------------
rope/src/tree.rs tree::Leaf::len
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::len":{"Self":["tree::Leaf","std::marker::Sized","std::clone::Clone","std::default::Default"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::CountMatcher","engine::DeltaOp","delta::DeltaElement","multiset::Subset","rope::LinesMetric","engine::Error","tree::NodeVal","find::CaseMatching","rope::Utf16CodeUnitsMetric","delta::Delta","tree::NodeBody","diff::DiffBuilder","rope::RopeInfo","engine::RevId","breaks::BreaksMetric","breaks::BreaksInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","tree::Node","spans::SpansLeaf","engine::FullPriority","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","diff::DiffOp","breaks::BreaksLeaf","delta::InsertDelta","spans::SpansInfo","interval::Interval","spans::Span","multiset::Segment"]},"spans::SpansInfo":{"T":["rope::LinesMetric","tree::NodeBody","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","engine::DeltaOp","breaks::BreaksLeaf","diff::DiffOp","multiset::CountMatcher","diff::DiffBuilder","engine::FullPriority","spans::SpansInfo","multiset::Segment","multiset::Subset","delta::InsertDelta","multiset::ZipSegment","engine::RevId","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksInfo","find::CaseMatching","engine::Error","spans::Span","delta::Delta","delta::DeltaElement","rope::RopeInfo","interval::Interval","engine::Contents","spans::SpansLeaf","tree::Node"]},"spans::SpansLeaf":{"T":["breaks::BreaksLeaf","spans::Span","tree::Node","engine::RevId","delta::DeltaElement","multiset::ZipSegment","engine::Contents","delta::InsertDelta","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::FullPriority","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","delta::Delta","tree::NodeVal","breaks::BreaksMetric","spans::SpansInfo","engine::DeltaOp","multiset::Segment","interval::Interval","multiset::Subset","rope::LinesMetric","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksBaseMetric","tree::NodeBody","rope::RopeInfo","rope::BaseMetric","multiset::CountMatcher","engine::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::len":{"Self":["breaks::BreaksLeaf","spans::SpansLeaf","std::string::String"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+tree::Leaf::len(p0);
+crate::tree::Leaf::len(p0);
+crate::tree::Leaf::len(p0);
-----------------
rope/src/tree.rs tree::Leaf::is_ok_child
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::is_ok_child":{"Self":["std::marker::Sized","tree::Leaf","std::clone::Clone","std::default::Default"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","breaks::BreaksMetric","engine::Error","breaks::BreaksLeaf","tree::NodeBody","delta::DeltaElement","rope::Utf16CodeUnitsMetric","tree::NodeVal","tree::Node","rope::BaseMetric","diff::DiffOp","diff::DiffBuilder","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","engine::FullPriority","rope::LinesMetric","spans::SpansInfo","engine::DeltaOp","multiset::CountMatcher","find::CaseMatching","multiset::Subset","interval::Interval","engine::RevId","delta::InsertDelta","multiset::Segment","multiset::ZipSegment","spans::SpansLeaf","breaks::BreaksInfo","rope::RopeInfo"]},"spans::SpansInfo":{"T":["delta::DeltaElement","find::CaseMatching","breaks::BreaksMetric","tree::Node","spans::SpansInfo","engine::Contents","engine::RevId","engine::DeltaOp","breaks::BreaksLeaf","breaks::BreaksInfo","diff::DiffOp","delta::Delta","diff::DiffBuilder","multiset::ZipSegment","engine::Error","multiset::Segment","rope::RopeInfo","engine::FullPriority","multiset::Subset","tree::NodeVal","multiset::CountMatcher","tree::NodeBody","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","rope::BaseMetric","delta::InsertDelta","breaks::BreaksBaseMetric","rope::LinesMetric","spans::Span"]},"spans::SpansLeaf":{"T":["delta::Delta","diff::DiffBuilder","tree::NodeBody","multiset::CountMatcher","delta::InsertDelta","rope::LinesMetric","engine::FullPriority","multiset::Segment","breaks::BreaksInfo","breaks::BreaksBaseMetric","spans::Span","rope::RopeInfo","interval::Interval","breaks::BreaksLeaf","rope::BaseMetric","delta::DeltaElement","tree::NodeVal","spans::SpansInfo","multiset::ZipSegment","engine::RevId","tree::Node","breaks::BreaksMetric","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","engine::Error","rope::Utf16CodeUnitsMetric","engine::Contents","engine::DeltaOp","spans::SpansLeaf","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::is_ok_child":{"Self":["std::string::String","breaks::BreaksLeaf","spans::SpansLeaf"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_ok_child();
+tree::Leaf::is_ok_child(p0);
+crate::tree::Leaf::is_ok_child(p0);
+crate::tree::Leaf::is_ok_child(p0);
-----------------
rope/src/tree.rs tree::Leaf::push_maybe_split
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::push_maybe_split":{"Self":["tree::Leaf","std::clone::Clone","std::marker::Sized","std::default::Default"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","diff::DiffBuilder","spans::SpansInfo","tree::NodeBody","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksInfo","rope::RopeInfo","breaks::BreaksMetric","delta::InsertDelta","engine::DeltaOp","diff::DiffOp","rope::LinesMetric","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","spans::Span","interval::Interval","delta::Delta","tree::NodeVal","breaks::BreaksLeaf","engine::RevId","multiset::ZipSegment","rope::BaseMetric","multiset::Subset","engine::FullPriority","tree::Node","engine::Error","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["find::CaseMatching","breaks::BreaksLeaf","interval::Interval","engine::DeltaOp","breaks::BreaksInfo","engine::Error","breaks::BreaksMetric","tree::NodeVal","tree::Node","engine::FullPriority","engine::RevId","delta::InsertDelta","delta::Delta","multiset::ZipSegment","delta::DeltaElement","rope::LinesMetric","breaks::BreaksBaseMetric","multiset::Segment","diff::DiffOp","diff::DiffBuilder","rope::BaseMetric","engine::Contents","rope::RopeInfo","multiset::CountMatcher","multiset::Subset","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","tree::NodeBody","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","engine::FullPriority","tree::Node","rope::LinesMetric","multiset::CountMatcher","engine::RevId","diff::DiffBuilder","interval::Interval","engine::DeltaOp","breaks::BreaksInfo","tree::NodeBody","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","engine::Contents","spans::SpansInfo","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","breaks::BreaksBaseMetric","breaks::BreaksLeaf","delta::DeltaElement","breaks::BreaksMetric","delta::InsertDelta","delta::Delta","spans::Span","spans::SpansLeaf","diff::DiffOp","find::CaseMatching","multiset::Subset","rope::BaseMetric","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::push_maybe_split":{"Self":["breaks::BreaksLeaf","spans::SpansLeaf","std::string::String"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+tree::Leaf::push_maybe_split(p0, p1, p2);
+crate::tree::Leaf::push_maybe_split(p0, p1, p2);
+crate::tree::Leaf::push_maybe_split(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Leaf::subseq
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::subseq":{"Self":["tree::Leaf","std::clone::Clone","std::default::Default","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::FullPriority","tree::NodeVal","multiset::Subset","delta::InsertDelta","engine::DeltaOp","diff::DiffBuilder","multiset::Segment","spans::SpansInfo","engine::Contents","tree::NodeBody","interval::Interval","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","rope::RopeInfo","breaks::BreaksInfo","engine::Error","find::CaseMatching","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksMetric","breaks::BreaksBaseMetric","tree::Node","rope::BaseMetric","engine::RevId","breaks::BreaksLeaf","delta::DeltaElement","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","delta::DeltaElement","engine::RevId","tree::NodeBody","multiset::Segment","breaks::BreaksMetric","engine::FullPriority","interval::Interval","delta::Delta","spans::SpansInfo","rope::RopeInfo","breaks::BreaksLeaf","find::CaseMatching","delta::InsertDelta","tree::NodeVal","rope::Utf16CodeUnitsMetric","multiset::Subset","breaks::BreaksInfo","diff::DiffBuilder","spans::Span","diff::DiffOp","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","multiset::CountMatcher","multiset::ZipSegment","tree::Node","engine::DeltaOp","rope::BaseMetric","engine::Contents","engine::Error"]},"spans::SpansLeaf":{"T":["interval::Interval","tree::NodeBody","spans::SpansLeaf","multiset::Segment","tree::NodeVal","find::CaseMatching","engine::DeltaOp","engine::RevId","rope::LinesMetric","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::InsertDelta","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","rope::BaseMetric","delta::Delta","engine::FullPriority","spans::SpansInfo","diff::DiffOp","multiset::Subset","breaks::BreaksBaseMetric","diff::DiffBuilder","breaks::BreaksMetric","rope::RopeInfo","multiset::CountMatcher","engine::Contents","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","breaks::BreaksLeaf","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Leaf::subseq":{"Self":["spans::SpansLeaf","breaks::BreaksLeaf","std::string::String"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.subseq(p1);
+tree::Leaf::subseq(p0, p1);
+crate::tree::Leaf::subseq(p0, p1);
+crate::tree::Leaf::subseq(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::measure
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::measure":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["rope::BaseMetric","multiset::Segment","multiset::CountMatcher","tree::NodeBody","engine::Error","rope::Utf16CodeUnitsMetric","rope::RopeInfo","spans::Span","engine::RevId","find::CaseMatching","tree::NodeVal","multiset::Subset","diff::DiffOp","spans::SpansLeaf","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksLeaf","diff::DiffBuilder","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","delta::InsertDelta","engine::DeltaOp","engine::FullPriority","tree::Node","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","rope::LinesMetric","delta::Delta","engine::Contents","interval::Interval"]},"spans::SpansInfo":{"T":["multiset::Segment","breaks::BreaksInfo","engine::Error","find::CaseMatching","spans::Span","tree::NodeBody","rope::Utf16CodeUnitsMetric","tree::Node","multiset::CountMatcher","diff::DiffBuilder","delta::DeltaElement","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","multiset::Subset","delta::Delta","engine::RevId","rope::LinesMetric","rope::RopeInfo","breaks::BreaksLeaf","tree::NodeVal","engine::DeltaOp","interval::Interval","breaks::BreaksMetric","spans::SpansInfo","engine::Contents","diff::DiffOp","breaks::BreaksBaseMetric","rope::BaseMetric","spans::SpansLeaf","engine::FullPriority"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","delta::DeltaElement","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksLeaf","tree::NodeVal","engine::Contents","rope::BaseMetric","engine::Error","tree::NodeBody","engine::FullPriority","engine::DeltaOp","diff::DiffBuilder","delta::InsertDelta","multiset::Subset","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","tree::Node","breaks::BreaksInfo","engine::RevId","multiset::Segment","rope::LinesMetric","breaks::BreaksMetric","find::CaseMatching","multiset::ZipSegment","spans::SpansInfo","diff::DiffOp","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::measure":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"Self":["rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksBaseMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // N
let mut p1 = 0usize; // None+usize
+tree::Metric::measure(p0, p1);
+crate::tree::Metric::measure(p0, p1);
+crate::tree::Metric::measure(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::to_base_units
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::to_base_units":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","engine::Contents","multiset::Segment","delta::InsertDelta","find::CaseMatching","multiset::CountMatcher","engine::FullPriority","tree::NodeBody","spans::SpansLeaf","engine::Error","rope::Utf16CodeUnitsMetric","diff::DiffOp","breaks::BreaksInfo","engine::RevId","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","multiset::ZipSegment","interval::Interval","multiset::Subset","delta::Delta","delta::DeltaElement","tree::Node","breaks::BreaksBaseMetric","rope::LinesMetric","breaks::BreaksLeaf","tree::NodeVal","diff::DiffBuilder","spans::SpansInfo","engine::DeltaOp","rope::RopeInfo"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","rope::BaseMetric","spans::SpansInfo","breaks::BreaksBaseMetric","rope::LinesMetric","delta::Delta","engine::RevId","multiset::Segment","breaks::BreaksMetric","tree::NodeVal","rope::RopeInfo","tree::Node","engine::DeltaOp","tree::NodeBody","engine::Error","engine::FullPriority","delta::DeltaElement","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","spans::SpansLeaf","breaks::BreaksInfo","interval::Interval","find::CaseMatching","delta::InsertDelta","breaks::BreaksLeaf","multiset::ZipSegment","engine::Contents","diff::DiffBuilder","diff::DiffOp","multiset::Subset"]},"spans::SpansLeaf":{"T":["multiset::Segment","tree::NodeBody","find::CaseMatching","engine::RevId","delta::Delta","interval::Interval","breaks::BreaksLeaf","multiset::ZipSegment","breaks::BreaksInfo","spans::SpansInfo","tree::NodeVal","multiset::Subset","delta::DeltaElement","rope::Utf16CodeUnitsMetric","tree::Node","diff::DiffOp","engine::Contents","engine::DeltaOp","engine::FullPriority","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksMetric","engine::Error","multiset::CountMatcher","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","rope::LinesMetric","rope::RopeInfo","breaks::BreaksBaseMetric","diff::DiffBuilder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::to_base_units":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"Self":["rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::BaseMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::to_base_units(p0, p1);
+crate::tree::Metric::to_base_units(p0, p1);
+crate::tree::Metric::to_base_units(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::from_base_units
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::from_base_units":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","rope::Utf16CodeUnitsMetric","rope::BaseMetric","multiset::Subset","engine::FullPriority","engine::RevId","rope::RopeInfo","tree::NodeVal","multiset::Segment","multiset::ZipSegment","tree::NodeBody","breaks::BreaksBaseMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","delta::Delta","delta::DeltaElement","rope::LinesMetric","breaks::BreaksInfo","engine::DeltaOp","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksMetric","spans::Span","interval::Interval","spans::SpansInfo","delta::InsertDelta","diff::DiffOp","spans::SpansLeaf","tree::Node","engine::Contents"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","tree::NodeVal","engine::DeltaOp","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","tree::NodeBody","interval::Interval","spans::SpansInfo","rope::RopeInfo","diff::DiffBuilder","delta::DeltaElement","diff::DiffOp","delta::Delta","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","breaks::BreaksInfo","engine::RevId","engine::Error","tree::Node","spans::Span","engine::Contents","breaks::BreaksLeaf","delta::InsertDelta","multiset::Segment","rope::LinesMetric","spans::SpansLeaf","engine::FullPriority","find::CaseMatching","breaks::BreaksBaseMetric"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","multiset::Subset","breaks::BreaksLeaf","spans::SpansLeaf","spans::Span","diff::DiffOp","engine::Contents","engine::DeltaOp","breaks::BreaksInfo","multiset::CountMatcher","diff::DiffBuilder","find::CaseMatching","engine::RevId","delta::InsertDelta","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","rope::Utf16CodeUnitsMetric","rope::LinesMetric","spans::SpansInfo","interval::Interval","multiset::Segment","engine::FullPriority","breaks::BreaksBaseMetric","multiset::ZipSegment","delta::Delta","tree::NodeBody","breaks::BreaksMetric","tree::NodeVal","tree::Node","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::from_base_units":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"Self":["breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::from_base_units(p0, p1);
+crate::tree::Metric::from_base_units(p0, p1);
+crate::tree::Metric::from_base_units(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::is_boundary
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::is_boundary":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::FullPriority","multiset::Segment","rope::RopeInfo","delta::Delta","tree::Node","engine::Error","tree::NodeBody","engine::RevId","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::CountMatcher","rope::LinesMetric","spans::SpansLeaf","diff::DiffOp","rope::BaseMetric","tree::NodeVal","engine::DeltaOp","multiset::ZipSegment","engine::Contents","interval::Interval","breaks::BreaksBaseMetric","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksMetric","delta::InsertDelta","delta::DeltaElement","spans::SpansInfo","spans::Span","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching"]},"spans::SpansInfo":{"T":["spans::Span","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","multiset::ZipSegment","rope::RopeInfo","engine::Error","engine::RevId","diff::DiffOp","multiset::Segment","engine::DeltaOp","engine::FullPriority","rope::LinesMetric","rope::BaseMetric","delta::InsertDelta","breaks::BreaksBaseMetric","diff::DiffBuilder","tree::NodeVal","tree::Node","multiset::Subset","find::CaseMatching","multiset::CountMatcher","breaks::BreaksMetric","delta::DeltaElement","interval::Interval","breaks::BreaksInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","delta::Delta","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["spans::Span","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","engine::Error","interval::Interval","engine::Contents","rope::RopeInfo","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","tree::NodeVal","multiset::CountMatcher","rope::LinesMetric","diff::DiffBuilder","spans::SpansInfo","breaks::BreaksMetric","engine::DeltaOp","engine::FullPriority","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","breaks::BreaksBaseMetric","spans::SpansLeaf","delta::Delta","delta::InsertDelta","engine::RevId","tree::Node","multiset::Segment","multiset::Subset","rope::BaseMetric","delta::DeltaElement","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::is_boundary":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"Self":["rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::is_boundary(p0, p1);
+crate::tree::Metric::is_boundary(p0, p1);
+crate::tree::Metric::is_boundary(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::prev
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::prev":{"N":["std::marker::Sized","tree::NodeInfo"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansLeaf","multiset::Segment","breaks::BreaksInfo","interval::Interval","spans::SpansInfo","tree::Node","rope::LinesMetric","spans::Span","tree::NodeVal","rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::Contents","engine::Error","engine::FullPriority","multiset::Subset","breaks::BreaksLeaf","engine::DeltaOp","tree::NodeBody","diff::DiffBuilder","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","engine::RevId","multiset::ZipSegment","breaks::BreaksMetric","multiset::CountMatcher","diff::DiffOp","breaks::BreaksBaseMetric","rope::BaseMetric","delta::Delta","rope::RopeInfo"]},"spans::SpansInfo":{"T":["delta::InsertDelta","engine::Error","breaks::BreaksLeaf","diff::DiffBuilder","tree::NodeVal","rope::LinesMetric","multiset::ZipSegment","engine::RevId","rope::BaseMetric","breaks::BreaksBaseMetric","spans::Span","breaks::BreaksMetric","delta::Delta","spans::SpansInfo","diff::DiffOp","multiset::Segment","spans::SpansLeaf","tree::Node","interval::Interval","rope::RopeInfo","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","engine::FullPriority","tree::NodeBody","delta::DeltaElement","multiset::Subset"]},"spans::SpansLeaf":{"T":["tree::NodeBody","multiset::Subset","rope::RopeInfo","breaks::BreaksBaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::FullPriority","diff::DiffOp","tree::NodeVal","multiset::ZipSegment","find::CaseMatching","engine::Error","diff::DiffBuilder","multiset::CountMatcher","tree::Node","multiset::Segment","delta::DeltaElement","rope::BaseMetric","rope::LinesMetric","delta::Delta","breaks::BreaksInfo","engine::RevId","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","delta::InsertDelta","engine::Contents","spans::SpansInfo","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::prev":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"Self":["rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::BaseMetric"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::prev(p0, p1);
+crate::tree::Metric::prev(p0, p1);
+crate::tree::Metric::prev(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::next
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::next":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["rope::BaseMetric","multiset::CountMatcher","rope::LinesMetric","spans::Span","rope::RopeInfo","delta::Delta","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","spans::SpansLeaf","breaks::BreaksMetric","breaks::BreaksInfo","multiset::ZipSegment","tree::NodeVal","rope::Utf16CodeUnitsMetric","find::CaseMatching","multiset::Segment","engine::Contents","interval::Interval","spans::SpansInfo","tree::Node","engine::DeltaOp","engine::Error","multiset::Subset","breaks::BreaksLeaf","diff::DiffBuilder","engine::RevId","delta::DeltaElement","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","delta::InsertDelta"]},"spans::SpansInfo":{"T":["rope::BaseMetric","delta::DeltaElement","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","tree::NodeVal","diff::DiffBuilder","spans::Span","breaks::BreaksMetric","interval::Interval","multiset::ZipSegment","rope::LinesMetric","engine::Error","breaks::BreaksInfo","find::CaseMatching","delta::InsertDelta","tree::Node","rope::Utf16CodeUnitsMetric","engine::Contents","breaks::BreaksLeaf","spans::SpansInfo","rope::RopeInfo","multiset::Subset","diff::DiffOp","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::FullPriority","multiset::CountMatcher","tree::NodeBody","delta::Delta","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["tree::Node","engine::Contents","breaks::BreaksLeaf","rope::LinesMetric","spans::SpansLeaf","delta::Delta","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","multiset::Subset","multiset::CountMatcher","rope::RopeInfo","engine::DeltaOp","tree::NodeBody","spans::SpansInfo","rope::Utf16CodeUnitsMetric","engine::FullPriority","breaks::BreaksMetric","breaks::BreaksInfo","interval::Interval","diff::DiffOp","engine::Error","delta::InsertDelta","tree::NodeVal","rope::BaseMetric","delta::DeltaElement","engine::RevId","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","diff::DiffBuilder","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::next":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"Self":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p1 = 0usize; // None+usize
+tree::Metric::next(p0, p1);
+crate::tree::Metric::next(p0, p1);
+crate::tree::Metric::next(p0, p1);
-----------------
rope/src/tree.rs tree::Metric::can_fragment
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::can_fragment":{"N":["tree::NodeInfo","std::marker::Sized"],"Self":["tree::Metric"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","diff::DiffBuilder","multiset::Segment","rope::BaseMetric","interval::Interval","multiset::CountMatcher","breaks::BreaksInfo","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::Span","engine::RevId","breaks::BreaksMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric","engine::DeltaOp","delta::InsertDelta","multiset::Subset","multiset::ZipSegment","rope::RopeInfo","delta::DeltaElement","spans::SpansInfo","engine::Contents","engine::Error","rope::LinesMetric","tree::Node","spans::SpansLeaf","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf","find::CaseMatching","tree::NodeBody"]},"spans::SpansInfo":{"T":["engine::RevId","diff::DiffBuilder","spans::SpansInfo","breaks::BreaksInfo","breaks::BreaksMetric","tree::NodeBody","rope::BaseMetric","engine::FullPriority","multiset::CountMatcher","engine::Error","engine::DeltaOp","spans::Span","breaks::BreaksLeaf","tree::NodeVal","breaks::BreaksBaseMetric","delta::Delta","diff::DiffOp","spans::SpansLeaf","find::CaseMatching","delta::DeltaElement","engine::Contents","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","multiset::Subset","rope::Utf16CodeUnitsMetric","tree::Node","multiset::Segment","multiset::ZipSegment","rope::RopeInfo","interval::Interval"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","breaks::BreaksMetric","tree::Node","find::CaseMatching","spans::Span","delta::Delta","engine::Error","breaks::BreaksInfo","interval::Interval","tree::NodeVal","multiset::Segment","rope::LinesMetric","diff::DiffOp","multiset::Subset","engine::FullPriority","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","rope::RopeInfo","delta::InsertDelta","spans::SpansLeaf","engine::RevId","diff::DiffBuilder","multiset::ZipSegment","delta::DeltaElement","spans::SpansInfo","engine::Contents","rope::BaseMetric","breaks::BreaksLeaf","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Metric::can_fragment":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"Self":["rope::Utf16CodeUnitsMetric","rope::LinesMetric","rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
+tree::Metric::can_fragment();
+crate::tree::Metric::can_fragment();
+crate::tree::Metric::can_fragment();
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.clone();
+<breaks::BreaksLeaf as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksLeaf as std::clone::Clone>::clone(p0);
+<breaks::BreaksLeaf>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<breaks::BreaksLeaf as std::fmt::Debug>::fmt(p0, p1);
+crate::<breaks::BreaksLeaf as std::fmt::Debug>::fmt(p0, p1);
+<breaks::BreaksLeaf>::fmt(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::default::Default>::default
deps:{}
candidates:{}
+<breaks::BreaksLeaf as std::default::Default>::default();
+crate::<breaks::BreaksLeaf as std::default::Default>::default();
+<breaks::BreaksLeaf>::default();
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.eq(p1);
+<breaks::BreaksLeaf as std::cmp::PartialEq>::eq(p0, p1);
+crate::<breaks::BreaksLeaf as std::cmp::PartialEq>::eq(p0, p1);
+<breaks::BreaksLeaf>::eq(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.assert_receiver_is_total_eq();
+<breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<breaks::BreaksLeaf>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
+p0.clone();
+<breaks::BreaksInfo as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksInfo as std::clone::Clone>::clone(p0);
+<breaks::BreaksInfo>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<breaks::BreaksInfo as std::fmt::Debug>::fmt(p0, p1);
+crate::<breaks::BreaksInfo as std::fmt::Debug>::fmt(p0, p1);
+<breaks::BreaksInfo>::fmt(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.len();
+<breaks::BreaksLeaf as tree::Leaf>::len(p0);
+crate::<breaks::BreaksLeaf as tree::Leaf>::len(p0);
+<breaks::BreaksLeaf>::len(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::is_ok_child
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.is_ok_child();
+<breaks::BreaksLeaf as tree::Leaf>::is_ok_child(p0);
+crate::<breaks::BreaksLeaf as tree::Leaf>::is_ok_child(p0);
+<breaks::BreaksLeaf>::is_ok_child(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksLeaf as tree::Leaf>::push_maybe_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split(p0, p1, p2);
+crate::<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split(p0, p1, p2);
+<breaks::BreaksLeaf>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as tree::NodeInfo>::accumulate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
+p0.accumulate(p1);
+<breaks::BreaksInfo as tree::NodeInfo>::accumulate(p0, p1);
+crate::<breaks::BreaksInfo as tree::NodeInfo>::accumulate(p0, p1);
+<breaks::BreaksInfo>::accumulate(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksInfo as tree::NodeInfo>::compute_info
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+<breaks::BreaksInfo as tree::NodeInfo>::compute_info(p0);
+crate::<breaks::BreaksInfo as tree::NodeInfo>::compute_info(p0);
+<breaks::BreaksInfo>::compute_info(p0);
-----------------
rope/src/breaks.rs breaks::BreaksLeaf::get_data_cloned
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
+p0.get_data_cloned();
+breaks::BreaksLeaf::get_data_cloned(p0);
+crate::breaks::BreaksLeaf::get_data_cloned(p0);
+<breaks::BreaksLeaf>::get_data_cloned(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksMetric
+p0.clone();
+<breaks::BreaksMetric as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksMetric as std::clone::Clone>::clone(p0);
+<breaks::BreaksMetric>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+<breaks::BreaksMetric>::measure(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+<breaks::BreaksMetric>::to_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+<breaks::BreaksMetric>::from_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+<breaks::BreaksMetric>::is_boundary(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+<breaks::BreaksMetric>::prev(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+<breaks::BreaksMetric>::next(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment
deps:{}
candidates:{}
+<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+crate::<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+<breaks::BreaksMetric>::can_fragment();
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksBaseMetric
+p0.clone();
+<breaks::BreaksBaseMetric as std::clone::Clone>::clone(p0);
+crate::<breaks::BreaksBaseMetric as std::clone::Clone>::clone(p0);
+<breaks::BreaksBaseMetric>::clone(p0);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksInfo
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure(p0, p1);
+<breaks::BreaksBaseMetric>::measure(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units(p0, p1);
+<breaks::BreaksBaseMetric>::to_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units(p0, p1);
+<breaks::BreaksBaseMetric>::from_base_units(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary(p0, p1);
+<breaks::BreaksBaseMetric>::is_boundary(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev(p0, p1);
+<breaks::BreaksBaseMetric>::prev(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // breaks::BreaksLeaf
let mut p1 = 0usize; // None+usize
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next(p0, p1);
+<breaks::BreaksBaseMetric>::next(p0, p1);
-----------------
rope/src/breaks.rs <breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment
deps:{}
candidates:{}
+<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+crate::<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment();
+<breaks::BreaksBaseMetric>::can_fragment();
-----------------
rope/src/breaks.rs breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
+crate::breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
+<tree::Node<breaks::BreaksInfo>>::new_no_break(p0);
-----------------
rope/src/breaks.rs <breaks::BreakBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<breaks::BreakBuilder as std::default::Default>::default();
+crate::<breaks::BreakBuilder as std::default::Default>::default();
+<breaks::BreakBuilder>::default();
-----------------
rope/src/breaks.rs breaks::BreakBuilder::new
deps:{}
candidates:{}
+breaks::BreakBuilder::new();
+crate::breaks::BreakBuilder::new();
+<breaks::BreakBuilder>::new();
-----------------
rope/src/breaks.rs breaks::BreakBuilder::add_break
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
let mut p1 = 0usize; // None+usize
+p0.add_break(p1);
+breaks::BreakBuilder::add_break(p0, p1);
+crate::breaks::BreakBuilder::add_break(p0, p1);
+<breaks::BreakBuilder>::add_break(p0, p1);
-----------------
rope/src/breaks.rs breaks::BreakBuilder::add_no_break
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
let mut p1 = 0usize; // None+usize
+p0.add_no_break(p1);
+breaks::BreakBuilder::add_no_break(p0, p1);
+crate::breaks::BreakBuilder::add_no_break(p0, p1);
+<breaks::BreakBuilder>::add_no_break(p0, p1);
-----------------
rope/src/breaks.rs breaks::BreakBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // breaks::BreakBuilder
+p0.build();
+breaks::BreakBuilder::build(p0);
+crate::breaks::BreakBuilder::build(p0);
+<breaks::BreakBuilder>::build(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+compare::RopeScanner::<'a>::new(p0, p1);
+crate::compare::RopeScanner::<'a>::new(p0, p1);
+<compare::RopeScanner<'a>>::new(p0, p1);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_ne_char_back
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"compare::RopeScanner::<'a>::find_ne_char_back":{"T":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"compare::RopeScanner::<'a>::find_ne_char_back":{"T":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.find_ne_char_back(p1, p2, p3);
+compare::RopeScanner::<'a>::find_ne_char_back(p0, p1, p2, p3);
+crate::compare::RopeScanner::<'a>::find_ne_char_back(p0, p1, p2, p3);
+<compare::RopeScanner<'a>>::find_ne_char_back(p0, p1, p2, p3);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_ne_char
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"compare::RopeScanner::<'a>::find_ne_char":{"T":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"compare::RopeScanner::<'a>::find_ne_char":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.find_ne_char(p1, p2, p3);
+compare::RopeScanner::<'a>::find_ne_char(p0, p1, p2, p3);
+crate::compare::RopeScanner::<'a>::find_ne_char(p0, p1, p2, p3);
+<compare::RopeScanner<'a>>::find_ne_char(p0, p1, p2, p3);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::find_min_diff_range
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.find_min_diff_range();
+compare::RopeScanner::<'a>::find_min_diff_range(p0);
+crate::compare::RopeScanner::<'a>::find_min_diff_range(p0);
+<compare::RopeScanner<'a>>::find_min_diff_range(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::load_prev_chunk
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.load_prev_chunk();
+compare::RopeScanner::<'a>::load_prev_chunk(p0);
+crate::compare::RopeScanner::<'a>::load_prev_chunk(p0);
+<compare::RopeScanner<'a>>::load_prev_chunk(p0);
-----------------
rope/src/compare.rs compare::RopeScanner::<'a>::load_next_chunk
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compare::RopeScanner<'a>
+p0.load_next_chunk();
+compare::RopeScanner::<'a>::load_next_chunk(p0);
+crate::compare::RopeScanner::<'a>::load_next_chunk(p0);
+<compare::RopeScanner<'a>>::load_next_chunk(p0);
-----------------
rope/src/delta.rs <delta::DeltaElement<N> as std::clone::Clone>::clone
deps:{"<delta::DeltaElement<N> as std::clone::Clone>::clone":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<delta::DeltaElement<N> as std::clone::Clone>::clone":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["find::CaseMatching","interval::Interval","spans::SpansLeaf","rope::BaseMetric","rope::RopeInfo","multiset::ZipSegment","engine::FullPriority","multiset::CountMatcher","engine::RevId","spans::SpansInfo","multiset::Subset","rope::LinesMetric","breaks::BreaksInfo","engine::DeltaOp","engine::Error","delta::InsertDelta","delta::DeltaElement","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","spans::Span","multiset::Segment","diff::DiffOp","breaks::BreaksLeaf","tree::NodeBody","engine::Contents","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","tree::Node","breaks::BreaksMetric","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"spans::SpansInfo":{"T":["breaks::BreaksBaseMetric","find::CaseMatching","multiset::CountMatcher","delta::DeltaElement","multiset::ZipSegment","engine::Contents","spans::Span","engine::DeltaOp","tree::NodeBody","rope::BaseMetric","breaks::BreaksInfo","engine::Error","spans::SpansInfo","tree::NodeVal","breaks::BreaksMetric","rope::LinesMetric","multiset::Subset","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","multiset::Segment","engine::FullPriority","interval::Interval","delta::Delta","delta::InsertDelta","rope::RopeInfo","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","diff::DiffOp","diff::DiffBuilder","engine::RevId"]},"spans::SpansLeaf":{"T":["engine::RevId","engine::DeltaOp","diff::DiffOp","multiset::ZipSegment","breaks::BreaksLeaf","delta::DeltaElement","multiset::Subset","spans::SpansLeaf","multiset::Segment","interval::Interval","breaks::BreaksMetric","rope::LinesMetric","delta::Delta","tree::NodeBody","engine::Error","rope::Utf16CodeUnitsMetric","tree::Node","diff::DiffBuilder","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","engine::Contents","delta::InsertDelta","engine::FullPriority","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::RopeInfo","find::CaseMatching","spans::SpansInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaElement<N>
+p0.clone();
+<delta::DeltaElement<N> as std::clone::Clone>::clone(p0);
+crate::<delta::DeltaElement<N> as std::clone::Clone>::clone(p0);
+<delta::DeltaElement<N>>::clone(p0);
-----------------
rope/src/delta.rs <delta::Delta<N> as std::clone::Clone>::clone
deps:{"<delta::Delta<N> as std::clone::Clone>::clone":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<delta::Delta<N> as std::clone::Clone>::clone":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","breaks::BreaksMetric","breaks::BreaksBaseMetric","delta::InsertDelta","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","diff::DiffOp","rope::RopeInfo","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","rope::LinesMetric","interval::Interval","delta::Delta","multiset::Segment","multiset::CountMatcher","delta::DeltaElement","engine::Error","tree::NodeBody","engine::Contents","tree::Node","find::CaseMatching","multiset::ZipSegment","engine::DeltaOp","rope::BaseMetric","diff::DiffBuilder","breaks::BreaksInfo","spans::SpansLeaf","tree::NodeVal","multiset::Subset","spans::SpansInfo"]},"spans::SpansInfo":{"T":["engine::FullPriority","engine::Contents","rope::BaseMetric","spans::SpansInfo","rope::RopeInfo","diff::DiffOp","multiset::ZipSegment","engine::RevId","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","breaks::BreaksBaseMetric","breaks::BreaksMetric","breaks::BreaksInfo","delta::DeltaElement","multiset::CountMatcher","engine::Error","tree::Node","spans::Span","tree::NodeBody","delta::Delta","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::DeltaOp","breaks::BreaksLeaf","multiset::Subset","spans::SpansLeaf","multiset::Segment","interval::Interval","rope::LinesMetric","tree::NodeVal"]},"spans::SpansLeaf":{"T":["tree::NodeVal","engine::FullPriority","breaks::BreaksBaseMetric","rope::LinesMetric","delta::Delta","breaks::BreaksLeaf","multiset::Segment","spans::SpansLeaf","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","tree::Node","breaks::BreaksInfo","spans::Span","spans::SpansInfo","engine::Error","interval::Interval","find::CaseMatching","rope::RopeInfo","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::DeltaElement","multiset::ZipSegment","diff::DiffOp","multiset::Subset","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","engine::DeltaOp","rope::BaseMetric","delta::InsertDelta","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.clone();
+<delta::Delta<N> as std::clone::Clone>::clone(p0);
+crate::<delta::Delta<N> as std::clone::Clone>::clone(p0);
+<delta::Delta<N>>::clone(p0);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::clone::Clone>::clone
deps:{"<delta::InsertDelta<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<delta::InsertDelta<N> as std::clone::Clone>::clone":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["delta::InsertDelta","find::CaseMatching","rope::RopeInfo","tree::Node","spans::Span","rope::BaseMetric","engine::DeltaOp","rope::LinesMetric","spans::SpansLeaf","spans::SpansInfo","multiset::Segment","breaks::BreaksLeaf","breaks::BreaksMetric","interval::Interval","delta::Delta","multiset::Subset","engine::Contents","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","engine::Error","breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::ZipSegment","multiset::CountMatcher","engine::RevId","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","delta::DeltaElement","diff::DiffOp"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","spans::SpansLeaf","spans::Span","multiset::CountMatcher","tree::NodeBody","diff::DiffBuilder","engine::Contents","rope::Utf16CodeUnitsMetric","engine::FullPriority","spans::SpansInfo","delta::Delta","delta::DeltaElement","breaks::BreaksInfo","rope::RopeInfo","diff::DiffOp","multiset::Segment","interval::Interval","rope::LinesMetric","tree::NodeVal","multiset::ZipSegment","engine::DeltaOp","engine::Error","breaks::BreaksLeaf","multiset::Subset","find::CaseMatching","rope::BaseMetric","breaks::BreaksMetric","engine::RevId","breaks::BreaksBaseMetric","tree::Node"]},"spans::SpansLeaf":{"T":["spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","delta::DeltaElement","engine::Contents","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksInfo","find::CaseMatching","engine::FullPriority","engine::DeltaOp","rope::BaseMetric","delta::InsertDelta","rope::RopeInfo","engine::Error","multiset::Segment","rope::LinesMetric","multiset::CountMatcher","multiset::ZipSegment","spans::SpansLeaf","diff::DiffBuilder","tree::Node","diff::DiffOp","engine::RevId","delta::Delta","interval::Interval","breaks::BreaksBaseMetric","spans::SpansInfo","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf","tree::NodeVal"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.clone();
+<delta::InsertDelta<N> as std::clone::Clone>::clone(p0);
+crate::<delta::InsertDelta<N> as std::clone::Clone>::clone(p0);
+<delta::InsertDelta<N>>::clone(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::simple_edit
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::simple_edit":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::simple_edit":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"T":["std::ops::RangeFull","std::ops::RangeFrom","<T as interval::IntervalBounds>"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["delta::InsertDelta","tree::Node","engine::Contents","spans::Span","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::Segment","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","delta::Delta","engine::FullPriority","spans::SpansInfo","multiset::Subset","rope::LinesMetric","diff::DiffBuilder","diff::DiffOp","multiset::ZipSegment","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","tree::NodeVal","tree::NodeBody","engine::Error","interval::Interval","engine::RevId","breaks::BreaksLeaf","rope::RopeInfo","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["engine::FullPriority","engine::RevId","engine::Error","delta::DeltaElement","breaks::BreaksLeaf","rope::LinesMetric","diff::DiffOp","rope::Utf16CodeUnitsMetric","interval::Interval","multiset::ZipSegment","spans::Span","tree::Node","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","delta::InsertDelta","rope::RopeInfo","tree::NodeBody","tree::NodeVal","engine::Contents","diff::DiffBuilder","multiset::CountMatcher","breaks::BreaksMetric","rope::BaseMetric","find::CaseMatching","spans::SpansInfo","breaks::BreaksInfo","spans::SpansLeaf","multiset::Segment","multiset::Subset","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["tree::Node","rope::BaseMetric","interval::Interval","breaks::BreaksMetric","engine::DeltaOp","delta::InsertDelta","diff::DiffBuilder","engine::RevId","delta::Delta","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::Error","diff::DiffOp","engine::FullPriority","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","find::CaseMatching","tree::NodeVal","delta::DeltaElement","rope::LinesMetric","spans::SpansLeaf","spans::Span","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","multiset::ZipSegment","multiset::Subset","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","spans::SpansInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p2 = 0usize; // None+usize
+delta::Delta::<N>::simple_edit(p0, p1, p2);
+crate::delta::Delta::<N>::simple_edit(p0, p1, p2);
+<delta::Delta<N>>::simple_edit(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Delta::<N>::as_simple_insert
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::as_simple_insert":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::as_simple_insert":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","breaks::BreaksInfo","multiset::Subset","rope::RopeInfo","find::CaseMatching","engine::DeltaOp","tree::NodeBody","engine::RevId","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","tree::NodeVal","rope::LinesMetric","spans::Span","delta::Delta","delta::DeltaElement","breaks::BreaksBaseMetric","delta::InsertDelta","diff::DiffBuilder","engine::FullPriority","multiset::Segment","multiset::ZipSegment","interval::Interval","breaks::BreaksMetric","rope::BaseMetric","tree::Node","spans::SpansLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","diff::DiffOp","engine::Contents"]},"spans::SpansInfo":{"T":["tree::NodeBody","spans::Span","engine::DeltaOp","engine::FullPriority","rope::Utf16CodeUnitsMetric","tree::NodeVal","multiset::ZipSegment","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksLeaf","breaks::BreaksInfo","rope::RopeInfo","breaks::BreaksBaseMetric","diff::DiffOp","delta::DeltaElement","delta::InsertDelta","engine::Error","multiset::CountMatcher","find::CaseMatching","rope::LinesMetric","multiset::Segment","spans::SpansLeaf","engine::Contents","diff::DiffBuilder","multiset::Subset","delta::Delta","engine::RevId","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","tree::Node","tree::NodeVal","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","multiset::Subset","spans::Span","engine::DeltaOp","engine::FullPriority","find::CaseMatching","delta::InsertDelta","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","rope::LinesMetric","delta::DeltaElement","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","multiset::ZipSegment","engine::Contents","tree::NodeBody","multiset::Segment","interval::Interval","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffOp","breaks::BreaksMetric","spans::SpansInfo","breaks::BreaksInfo","delta::Delta","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.as_simple_insert();
+delta::Delta::<N>::as_simple_insert(p0);
+crate::delta::Delta::<N>::as_simple_insert(p0);
+<delta::Delta<N>>::as_simple_insert(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::is_simple_delete
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::is_simple_delete":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Delta::<N>::is_simple_delete":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansLeaf","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","multiset::CountMatcher","engine::Contents","rope::LinesMetric","breaks::BreaksLeaf","find::CaseMatching","breaks::BreaksBaseMetric","tree::Node","engine::Error","engine::DeltaOp","breaks::BreaksInfo","diff::DiffBuilder","interval::Interval","rope::BaseMetric","multiset::Segment","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffOp","delta::InsertDelta","rope::Utf16CodeUnitsMetric","tree::NodeBody","engine::FullPriority","multiset::ZipSegment","engine::RevId","breaks::BreaksMetric","tree::NodeVal","multiset::Subset","rope::RopeInfo","delta::DeltaElement"]},"spans::SpansInfo":{"T":["find::CaseMatching","multiset::ZipSegment","engine::RevId","rope::BaseMetric","delta::InsertDelta","tree::NodeBody","spans::Span","diff::DiffOp","breaks::BreaksLeaf","spans::SpansInfo","interval::Interval","engine::FullPriority","tree::Node","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","multiset::Subset","multiset::Segment","spans::SpansLeaf","engine::Contents","rope::LinesMetric","rope::RopeInfo","diff::DiffBuilder","engine::Error","multiset::CountMatcher","breaks::BreaksInfo","delta::Delta","engine::DeltaOp","rope::Utf16CodeUnitsMetric","delta::DeltaElement","tree::NodeVal"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","multiset::Segment","spans::SpansLeaf","tree::NodeBody","diff::DiffBuilder","rope::BaseMetric","breaks::BreaksInfo","engine::Error","interval::Interval","rope::Utf16CodeUnitsMetric","spans::Span","engine::DeltaOp","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","breaks::BreaksLeaf","delta::InsertDelta","engine::RevId","breaks::BreaksBaseMetric","breaks::BreaksMetric","tree::Node","find::CaseMatching","spans::SpansInfo","rope::RopeInfo","engine::Contents","multiset::ZipSegment","tree::NodeVal","delta::DeltaElement","diff::DiffOp","multiset::Subset","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.is_simple_delete();
+delta::Delta::<N>::is_simple_delete(p0);
+crate::delta::Delta::<N>::is_simple_delete(p0);
+<delta::Delta<N>>::is_simple_delete(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::is_identity
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta::<N>::is_identity":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Delta::<N>::is_identity":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::FullPriority","interval::Interval","multiset::Subset","rope::LinesMetric","multiset::Segment","engine::Error","tree::Node","multiset::CountMatcher","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","diff::DiffBuilder","engine::RevId","tree::NodeVal","diff::DiffOp","breaks::BreaksInfo","breaks::BreaksBaseMetric","delta::DeltaElement","breaks::BreaksMetric","engine::Contents","find::CaseMatching","breaks::BreaksLeaf","rope::RopeInfo","spans::SpansLeaf","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::ZipSegment","delta::Delta","delta::InsertDelta","rope::BaseMetric"]},"spans::SpansInfo":{"T":["diff::DiffOp","rope::RopeInfo","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::CountMatcher","engine::FullPriority","breaks::BreaksLeaf","multiset::Subset","multiset::Segment","engine::Contents","spans::Span","tree::NodeBody","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","spans::SpansInfo","breaks::BreaksBaseMetric","tree::Node","breaks::BreaksInfo","rope::LinesMetric","tree::NodeVal","diff::DiffBuilder","multiset::ZipSegment","interval::Interval","delta::InsertDelta","rope::BaseMetric","find::CaseMatching","engine::Error","spans::SpansLeaf","engine::RevId","delta::Delta"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","find::CaseMatching","spans::Span","engine::Error","rope::RopeInfo","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::FullPriority","breaks::BreaksLeaf","spans::SpansInfo","interval::Interval","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::DeltaOp","engine::Contents","tree::NodeVal","multiset::Segment","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","engine::RevId","breaks::BreaksBaseMetric","tree::Node","delta::Delta","rope::BaseMetric","rope::LinesMetric","breaks::BreaksInfo","delta::InsertDelta","multiset::Subset","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.is_identity();
+delta::Delta::<N>::is_identity(p0);
+crate::delta::Delta::<N>::is_identity(p0);
+<delta::Delta<N>>::is_identity(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::apply
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta::<N>::apply":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::apply":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["tree::NodeVal","delta::DeltaElement","multiset::ZipSegment","delta::Delta","engine::DeltaOp","spans::SpansInfo","engine::FullPriority","rope::Utf16CodeUnitsMetric","multiset::Segment","rope::LinesMetric","engine::Error","breaks::BreaksBaseMetric","spans::SpansLeaf","multiset::Subset","breaks::BreaksMetric","breaks::BreaksInfo","interval::Interval","engine::Contents","diff::DiffOp","rope::RopeInfo","delta::InsertDelta","spans::Span","multiset::CountMatcher","find::CaseMatching","diff::DiffBuilder","tree::Node","rope::BaseMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","spans::Span","interval::Interval","multiset::Segment","delta::Delta","multiset::Subset","spans::SpansInfo","engine::FullPriority","multiset::ZipSegment","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::Contents","tree::NodeBody","diff::DiffOp","rope::BaseMetric","rope::RopeInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksLeaf","engine::DeltaOp","rope::Utf16CodeUnitsMetric","tree::NodeVal","rope::LinesMetric","delta::DeltaElement","delta::InsertDelta","spans::SpansLeaf","find::CaseMatching","engine::RevId"]},"spans::SpansLeaf":{"T":["diff::DiffOp","multiset::ZipSegment","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","rope::RopeInfo","delta::InsertDelta","spans::SpansInfo","rope::BaseMetric","engine::FullPriority","tree::NodeBody","delta::DeltaElement","breaks::BreaksInfo","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::RevId","rope::LinesMetric","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::DeltaOp","multiset::CountMatcher","engine::Contents","interval::Interval","delta::Delta","spans::Span","engine::Error","tree::Node","multiset::Subset","find::CaseMatching","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.apply(p1);
+delta::Delta::<N>::apply(p0, p1);
+crate::delta::Delta::<N>::apply(p0, p1);
+<delta::Delta<N>>::apply(p0, p1);
-----------------
rope/src/delta.rs delta::Delta::<N>::factor
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::factor":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::Delta::<N>::factor":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["diff::DiffBuilder","spans::Span","multiset::ZipSegment","engine::RevId","tree::NodeVal","find::CaseMatching","delta::InsertDelta","engine::FullPriority","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","breaks::BreaksInfo","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","rope::LinesMetric","engine::DeltaOp","delta::DeltaElement","breaks::BreaksLeaf","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","diff::DiffOp","tree::NodeBody","rope::RopeInfo","engine::Error","tree::Node","delta::Delta","spans::SpansLeaf","interval::Interval","spans::SpansInfo","rope::BaseMetric","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["engine::Error","delta::Delta","rope::Utf16CodeUnitsMetric","diff::DiffOp","delta::InsertDelta","tree::NodeBody","multiset::Subset","spans::Span","breaks::BreaksInfo","spans::SpansLeaf","multiset::CountMatcher","diff::DiffBuilder","delta::DeltaElement","engine::FullPriority","rope::RopeInfo","spans::SpansInfo","tree::NodeVal","breaks::BreaksMetric","rope::LinesMetric","engine::DeltaOp","multiset::Segment","find::CaseMatching","rope::BaseMetric","engine::RevId","breaks::BreaksLeaf","breaks::BreaksBaseMetric","interval::Interval","engine::Contents","multiset::ZipSegment","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","rope::LinesMetric","multiset::Segment","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","spans::SpansInfo","spans::SpansLeaf","engine::RevId","diff::DiffOp","tree::NodeVal","tree::NodeBody","multiset::Subset","rope::RopeInfo","rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::Contents","delta::Delta","breaks::BreaksLeaf","multiset::ZipSegment","breaks::BreaksInfo","find::CaseMatching","breaks::BreaksMetric","diff::DiffBuilder","engine::Error","tree::Node","engine::DeltaOp","spans::Span","engine::FullPriority","multiset::CountMatcher","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.factor();
+delta::Delta::<N>::factor(p0);
+crate::delta::Delta::<N>::factor(p0);
+<delta::Delta<N>>::factor(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::synthesize
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::synthesize":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::synthesize":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansInfo","breaks::BreaksMetric","rope::BaseMetric","delta::Delta","engine::FullPriority","multiset::Segment","engine::Error","breaks::BreaksLeaf","delta::DeltaElement","spans::Span","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksInfo","multiset::ZipSegment","diff::DiffOp","engine::RevId","engine::Contents","tree::NodeVal","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","interval::Interval","multiset::Subset","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","spans::SpansLeaf","tree::NodeBody","breaks::BreaksBaseMetric"]},"spans::SpansInfo":{"T":["find::CaseMatching","spans::SpansInfo","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","rope::LinesMetric","interval::Interval","breaks::BreaksBaseMetric","delta::InsertDelta","breaks::BreaksLeaf","engine::FullPriority","delta::DeltaElement","multiset::Segment","engine::Contents","engine::RevId","engine::DeltaOp","delta::Delta","multiset::CountMatcher","breaks::BreaksMetric","tree::NodeVal","rope::RopeInfo","spans::Span","engine::Error","spans::SpansLeaf","rope::BaseMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Subset","multiset::ZipSegment","diff::DiffOp","tree::Node","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","engine::DeltaOp","tree::Node","rope::LinesMetric","spans::Span","find::CaseMatching","delta::DeltaElement","spans::SpansLeaf","interval::Interval","diff::DiffOp","delta::Delta","breaks::BreaksLeaf","tree::NodeBody","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","multiset::CountMatcher","rope::RopeInfo","engine::Error","diff::DiffBuilder","breaks::BreaksMetric","multiset::Subset","multiset::Segment","multiset::ZipSegment","engine::RevId","spans::SpansInfo","engine::FullPriority","engine::Contents","breaks::BreaksBaseMetric","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+delta::Delta::<N>::synthesize(p0, p1, p2);
+crate::delta::Delta::<N>::synthesize(p0, p1, p2);
+<delta::Delta<N>>::synthesize(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Delta::<N>::summary
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::Delta::<N>::summary":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta::<N>::summary":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["tree::NodeVal","tree::Node","multiset::Subset","tree::NodeBody","multiset::CountMatcher","diff::DiffOp","rope::RopeInfo","breaks::BreaksBaseMetric","engine::RevId","multiset::ZipSegment","engine::FullPriority","breaks::BreaksInfo","delta::DeltaElement","diff::DiffBuilder","engine::Error","engine::Contents","breaks::BreaksLeaf","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","multiset::Segment","rope::LinesMetric","engine::DeltaOp","find::CaseMatching","rope::BaseMetric","rope::Utf16CodeUnitsMetric","spans::SpansInfo","delta::InsertDelta","interval::Interval","spans::Span","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["engine::Error","multiset::ZipSegment","engine::RevId","multiset::CountMatcher","breaks::BreaksBaseMetric","spans::SpansInfo","engine::FullPriority","breaks::BreaksInfo","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","engine::DeltaOp","breaks::BreaksMetric","delta::InsertDelta","spans::SpansLeaf","spans::Span","diff::DiffOp","rope::BaseMetric","interval::Interval","rope::RopeInfo","multiset::Segment","multiset::Subset","delta::Delta","engine::Contents","breaks::BreaksLeaf","diff::DiffBuilder","find::CaseMatching","rope::LinesMetric","delta::DeltaElement","tree::Node","tree::NodeBody"]},"spans::SpansLeaf":{"T":["rope::LinesMetric","delta::DeltaElement","engine::FullPriority","engine::Error","spans::Span","tree::NodeVal","tree::NodeBody","rope::BaseMetric","diff::DiffOp","rope::Utf16CodeUnitsMetric","multiset::Subset","diff::DiffBuilder","breaks::BreaksLeaf","breaks::BreaksMetric","find::CaseMatching","tree::Node","multiset::ZipSegment","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansInfo","delta::InsertDelta","delta::Delta","multiset::CountMatcher","engine::RevId","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","breaks::BreaksBaseMetric","spans::SpansLeaf","interval::Interval","rope::RopeInfo","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.summary();
+delta::Delta::<N>::summary(p0);
+crate::delta::Delta::<N>::summary(p0);
+<delta::Delta<N>>::summary(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::new_document_len
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta::<N>::new_document_len":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::new_document_len":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["tree::Node","interval::Interval","diff::DiffBuilder","engine::Contents","breaks::BreaksMetric","breaks::BreaksBaseMetric","multiset::ZipSegment","delta::DeltaElement","spans::SpansInfo","spans::Span","rope::RopeInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","engine::Error","engine::DeltaOp","delta::InsertDelta","breaks::BreaksInfo","breaks::BreaksLeaf","find::CaseMatching","delta::Delta","spans::SpansLeaf","tree::NodeVal","engine::FullPriority","rope::Utf16CodeUnitsMetric","rope::BaseMetric","rope::LinesMetric","engine::RevId","multiset::CountMatcher","multiset::Segment","tree::NodeBody"]},"spans::SpansInfo":{"T":["find::CaseMatching","tree::Node","engine::DeltaOp","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","delta::Delta","spans::SpansInfo","engine::Contents","rope::RopeInfo","delta::DeltaElement","spans::Span","breaks::BreaksLeaf","engine::RevId","rope::BaseMetric","multiset::ZipSegment","breaks::BreaksInfo","diff::DiffOp","multiset::Subset","multiset::Segment","interval::Interval","tree::NodeBody","breaks::BreaksBaseMetric","engine::Error","diff::DiffBuilder","engine::FullPriority","tree::NodeVal","spans::SpansLeaf","multiset::CountMatcher","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","rope::LinesMetric","spans::SpansLeaf","breaks::BreaksBaseMetric","rope::RopeInfo","rope::Utf16CodeUnitsMetric","diff::DiffOp","delta::InsertDelta","engine::RevId","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","interval::Interval","multiset::Subset","tree::NodeBody","breaks::BreaksLeaf","engine::Error","tree::NodeVal","multiset::CountMatcher","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","spans::Span","engine::DeltaOp","rope::BaseMetric","spans::SpansInfo","breaks::BreaksMetric","find::CaseMatching","delta::DeltaElement","tree::Node","engine::Contents","diff::DiffBuilder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.new_document_len();
+delta::Delta::<N>::new_document_len(p0);
+crate::delta::Delta::<N>::new_document_len(p0);
+<delta::Delta<N>>::new_document_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::total_element_len
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::Delta::<N>::total_element_len":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Delta::<N>::total_element_len":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::RopeInfo","breaks::BreaksLeaf","engine::Error","tree::Node","spans::SpansInfo","multiset::CountMatcher","interval::Interval","rope::LinesMetric","diff::DiffOp","delta::DeltaElement","delta::InsertDelta","find::CaseMatching","tree::NodeVal","multiset::ZipSegment","engine::DeltaOp","diff::DiffBuilder","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","multiset::Segment","rope::BaseMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","engine::RevId","delta::Delta","engine::FullPriority","spans::Span","breaks::BreaksInfo","multiset::Subset","engine::Contents","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["tree::NodeVal","rope::BaseMetric","tree::Node","spans::SpansLeaf","breaks::BreaksLeaf","engine::Error","spans::SpansInfo","engine::RevId","multiset::ZipSegment","breaks::BreaksInfo","diff::DiffBuilder","engine::FullPriority","spans::Span","diff::DiffOp","rope::Utf16CodeUnitsMetric","tree::NodeBody","breaks::BreaksMetric","rope::LinesMetric","interval::Interval","engine::DeltaOp","breaks::BreaksBaseMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *const T>","rope::RopeInfo","find::CaseMatching","multiset::Subset","engine::Contents","delta::InsertDelta","delta::DeltaElement","delta::Delta","multiset::CountMatcher"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","engine::RevId","engine::Contents","rope::RopeInfo","diff::DiffOp","spans::SpansInfo","multiset::CountMatcher","find::CaseMatching","breaks::BreaksLeaf","breaks::BreaksMetric","breaks::BreaksInfo","engine::DeltaOp","delta::DeltaElement","breaks::BreaksBaseMetric","delta::InsertDelta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","interval::Interval","spans::SpansLeaf","tree::NodeBody","rope::BaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","delta::Delta","multiset::Segment","engine::Error","engine::FullPriority","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [delta::DeltaElement<N>]
+delta::Delta::<N>::total_element_len(p0);
+crate::delta::Delta::<N>::total_element_len(p0);
+<delta::Delta<N>>::total_element_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::inserts_len
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::inserts_len":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::inserts_len":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::RopeInfo","tree::Node","find::CaseMatching","multiset::CountMatcher","multiset::Subset","breaks::BreaksMetric","delta::InsertDelta","engine::FullPriority","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::Segment","engine::RevId","spans::Span","diff::DiffBuilder","spans::SpansLeaf","multiset::ZipSegment","engine::DeltaOp","delta::Delta","rope::LinesMetric","tree::NodeBody","interval::Interval","delta::DeltaElement","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","engine::Error","breaks::BreaksInfo","rope::BaseMetric","breaks::BreaksBaseMetric","tree::NodeVal","engine::Contents"]},"spans::SpansInfo":{"T":["spans::Span","engine::FullPriority","interval::Interval","breaks::BreaksInfo","diff::DiffOp","delta::Delta","breaks::BreaksBaseMetric","spans::SpansLeaf","multiset::ZipSegment","engine::RevId","tree::Node","rope::BaseMetric","tree::NodeBody","delta::InsertDelta","spans::SpansInfo","engine::Error","tree::NodeVal","rope::LinesMetric","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","rope::RopeInfo","find::CaseMatching","multiset::Segment","breaks::BreaksMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","delta::DeltaElement","engine::Contents","multiset::Subset","breaks::BreaksLeaf"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","spans::SpansLeaf","engine::Contents","tree::NodeVal","delta::Delta","breaks::BreaksMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","delta::DeltaElement","engine::FullPriority","diff::DiffOp","spans::SpansInfo","delta::InsertDelta","tree::NodeBody","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","engine::RevId","engine::Error","multiset::Segment","diff::DiffBuilder","breaks::BreaksInfo","spans::Span","tree::Node","multiset::CountMatcher","multiset::ZipSegment","multiset::Subset","engine::DeltaOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.inserts_len();
+delta::Delta::<N>::inserts_len(p0);
+crate::delta::Delta::<N>::inserts_len(p0);
+<delta::Delta<N>>::inserts_len(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::iter_inserts
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::iter_inserts":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::iter_inserts":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","spans::Span","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","breaks::BreaksLeaf","diff::DiffOp","rope::RopeInfo","breaks::BreaksMetric","breaks::BreaksBaseMetric","spans::SpansInfo","engine::FullPriority","tree::Node","delta::DeltaElement","diff::DiffBuilder","multiset::Subset","rope::LinesMetric","rope::Utf16CodeUnitsMetric","engine::Error","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","engine::Contents","engine::DeltaOp","interval::Interval","multiset::CountMatcher","tree::NodeBody","breaks::BreaksInfo","find::CaseMatching","rope::BaseMetric","engine::RevId","multiset::Segment"]},"spans::SpansInfo":{"T":["diff::DiffOp","engine::DeltaOp","multiset::Subset","spans::SpansLeaf","interval::Interval","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","multiset::Segment","multiset::CountMatcher","diff::DiffBuilder","tree::NodeBody","tree::NodeVal","breaks::BreaksBaseMetric","delta::InsertDelta","find::CaseMatching","breaks::BreaksInfo","rope::RopeInfo","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::DeltaElement","breaks::BreaksLeaf","engine::Error","rope::LinesMetric","breaks::BreaksMetric","engine::Contents","tree::Node","engine::FullPriority","spans::SpansInfo","engine::RevId","delta::Delta"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","multiset::ZipSegment","delta::DeltaElement","diff::DiffBuilder","spans::SpansLeaf","breaks::BreaksLeaf","delta::Delta","tree::NodeVal","rope::BaseMetric","rope::Utf16CodeUnitsMetric","engine::FullPriority","multiset::Subset","tree::Node","spans::Span","rope::RopeInfo","diff::DiffOp","interval::Interval","multiset::Segment","tree::NodeBody","engine::Error","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","breaks::BreaksBaseMetric","rope::LinesMetric","engine::Contents","spans::SpansInfo","breaks::BreaksInfo","multiset::CountMatcher","find::CaseMatching","engine::RevId","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.iter_inserts();
+delta::Delta::<N>::iter_inserts(p0);
+crate::delta::Delta::<N>::iter_inserts(p0);
+<delta::Delta<N>>::iter_inserts(p0);
-----------------
rope/src/delta.rs delta::Delta::<N>::iter_deletions
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta::<N>::iter_deletions":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta::<N>::iter_deletions":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","diff::DiffBuilder","interval::Interval","engine::DeltaOp","multiset::ZipSegment","rope::RopeInfo","find::CaseMatching","delta::InsertDelta","spans::SpansLeaf","spans::Span","engine::FullPriority","delta::DeltaElement","rope::LinesMetric","tree::Node","delta::Delta","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeVal","diff::DiffOp","engine::Contents","multiset::Subset","breaks::BreaksInfo","multiset::Segment","breaks::BreaksBaseMetric","engine::RevId","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","rope::BaseMetric"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","engine::Contents","tree::Node","tree::NodeVal","rope::RopeInfo","spans::SpansLeaf","diff::DiffOp","interval::Interval","delta::Delta","find::CaseMatching","multiset::Subset","delta::InsertDelta","engine::RevId","engine::Error","rope::LinesMetric","spans::Span","delta::DeltaElement","multiset::ZipSegment","engine::FullPriority","rope::Utf16CodeUnitsMetric","engine::DeltaOp","breaks::BreaksBaseMetric","breaks::BreaksLeaf","spans::SpansInfo","breaks::BreaksInfo","diff::DiffBuilder","multiset::CountMatcher","breaks::BreaksMetric","tree::NodeBody","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","breaks::BreaksMetric","tree::Node","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","breaks::BreaksLeaf","tree::NodeVal","find::CaseMatching","delta::DeltaElement","engine::FullPriority","delta::Delta","multiset::CountMatcher","rope::LinesMetric","engine::RevId","diff::DiffOp","multiset::ZipSegment","engine::DeltaOp","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","engine::Contents","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","multiset::Subset","interval::Interval","spans::SpansLeaf","engine::Error","tree::NodeBody","delta::InsertDelta","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+p0.iter_deletions();
+delta::Delta::<N>::iter_deletions(p0);
+crate::delta::Delta::<N>::iter_deletions(p0);
+<delta::Delta<N>>::iter_deletions(p0);
-----------------
rope/src/delta.rs <delta::Delta<N> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::Delta<N> as std::fmt::Debug>::fmt":{"N":["tree::NodeInfo","std::marker::Sized"],"tree::Node<N>":["std::fmt::Debug"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::Spans":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::Delta<N> as std::fmt::Debug>::fmt":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"tree::Node<N>":["multiset::CountMatcher","engine::Error","delta::InsertDelta","multiset::Subset","multiset::ZipSegment","delta::DeltaRegion","engine::Revision","<*mut T as std::fmt::Debug>","engine::Engine","rope::Rope","engine::RevId","engine::DeltaOp","delta::Delta","diff::DiffOp","breaks::BreaksLeaf","multiset::Segment","diff::DiffBuilder","breaks::BreaksInfo","spans::Spans","interval::Interval","engine::Contents"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","breaks::BreaksBaseMetric","engine::RevId","breaks::BreaksLeaf","multiset::Segment","tree::Node","spans::SpansInfo","rope::Utf16CodeUnitsMetric","multiset::Subset","rope::BaseMetric","tree::NodeBody","rope::RopeInfo","engine::FullPriority","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","engine::Error","engine::Contents","engine::DeltaOp","multiset::CountMatcher","rope::LinesMetric","find::CaseMatching","breaks::BreaksInfo","multiset::ZipSegment","tree::NodeVal","delta::InsertDelta","breaks::BreaksMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","interval::Interval","delta::DeltaElement"]},"spans::Spans":{"T":["diff::DiffOp","breaks::BreaksLeaf","multiset::Segment","engine::RevId","diff::DiffBuilder","delta::InsertDelta","multiset::CountMatcher","engine::DeltaOp","engine::Error","interval::Interval","multiset::Subset","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","breaks::BreaksInfo","engine::Contents"]},"spans::SpansInfo":{"T":["find::CaseMatching","engine::DeltaOp","rope::RopeInfo","engine::RevId","diff::DiffBuilder","tree::NodeBody","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::LinesMetric","breaks::BreaksInfo","delta::Delta","engine::Contents","engine::FullPriority","breaks::BreaksLeaf","delta::InsertDelta","multiset::Subset","spans::SpansLeaf","interval::Interval","spans::Span","tree::NodeVal","multiset::ZipSegment","engine::Error","diff::DiffOp","multiset::Segment","multiset::CountMatcher","spans::SpansInfo","breaks::BreaksBaseMetric","rope::BaseMetric","delta::DeltaElement","tree::Node"]},"spans::SpansLeaf":{"T":["engine::FullPriority","engine::DeltaOp","breaks::BreaksLeaf","rope::LinesMetric","multiset::ZipSegment","breaks::BreaksMetric","delta::DeltaElement","tree::NodeVal","find::CaseMatching","rope::Utf16CodeUnitsMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","multiset::Subset","multiset::CountMatcher","engine::RevId","tree::NodeBody","spans::SpansLeaf","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","delta::Delta","breaks::BreaksBaseMetric","spans::Span","rope::BaseMetric","rope::RopeInfo","delta::InsertDelta","breaks::BreaksInfo","engine::Error","interval::Interval","engine::Contents","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::Delta<N> as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::Delta<N> as std::fmt::Debug>::fmt(p0, p1);
+<delta::Delta<N>>::fmt(p0, p1);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":{"N":["tree::NodeInfo","std::marker::Sized"],"tree::Node<N>":["std::fmt::Debug"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::Spans":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"],"tree::Node<N>":["delta::DeltaRegion","delta::Delta","engine::RevId","engine::Contents","delta::InsertDelta","rope::Rope","breaks::BreaksLeaf","multiset::Segment","engine::Engine","spans::Spans","multiset::Subset","breaks::BreaksInfo","engine::Error","<*const T as std::fmt::Debug>","multiset::CountMatcher","diff::DiffOp","interval::Interval","diff::DiffBuilder","engine::DeltaOp","multiset::ZipSegment","engine::Revision"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::CountMatcher","breaks::BreaksInfo","tree::NodeVal","tree::NodeBody","diff::DiffBuilder","delta::DeltaElement","spans::Span","engine::RevId","breaks::BreaksLeaf","engine::Contents","delta::Delta","tree::Node","delta::InsertDelta","multiset::Segment","engine::Error","breaks::BreaksBaseMetric","find::CaseMatching","multiset::ZipSegment","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","rope::LinesMetric","spans::SpansLeaf","multiset::Subset","engine::DeltaOp","rope::BaseMetric","spans::SpansInfo"]},"spans::Spans":{"T":["breaks::BreaksInfo","multiset::ZipSegment","multiset::Subset","engine::RevId","delta::Delta","diff::DiffOp","multiset::Segment","multiset::CountMatcher","interval::Interval","engine::DeltaOp","engine::Error","diff::DiffBuilder","engine::Contents","delta::InsertDelta","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansInfo":{"T":["diff::DiffOp","spans::SpansLeaf","tree::NodeVal","multiset::Segment","delta::DeltaElement","engine::FullPriority","breaks::BreaksLeaf","rope::BaseMetric","tree::NodeBody","delta::InsertDelta","multiset::CountMatcher","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","delta::Delta","multiset::Subset","engine::Contents","rope::Utf16CodeUnitsMetric","find::CaseMatching","tree::Node","multiset::ZipSegment","spans::SpansInfo","breaks::BreaksBaseMetric","diff::DiffBuilder","rope::RopeInfo","engine::Error","breaks::BreaksInfo","engine::RevId","spans::Span","breaks::BreaksMetric","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","engine::Error","engine::RevId","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansInfo","breaks::BreaksLeaf","rope::LinesMetric","find::CaseMatching","breaks::BreaksInfo","multiset::CountMatcher","spans::SpansLeaf","diff::DiffBuilder","interval::Interval","engine::DeltaOp","tree::NodeBody","tree::Node","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksBaseMetric","multiset::Segment","delta::Delta","multiset::Subset","spans::Span","multiset::ZipSegment","engine::FullPriority","engine::Contents","tree::NodeVal","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::InsertDelta<N> as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::InsertDelta<N> as std::fmt::Debug>::fmt(p0, p1);
+<delta::InsertDelta<N>>::fmt(p0, p1);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::transform_expand
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta::<N>::transform_expand":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta::<N>::transform_expand":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["interval::Interval","multiset::Subset","tree::Node","tree::NodeVal","breaks::BreaksMetric","rope::LinesMetric","spans::SpansInfo","breaks::BreaksLeaf","breaks::BreaksInfo","tree::NodeBody","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment","engine::DeltaOp","engine::Contents","breaks::BreaksBaseMetric","engine::Error","rope::BaseMetric","delta::Delta","engine::FullPriority","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","spans::Span","diff::DiffBuilder","spans::SpansLeaf","diff::DiffOp","rope::RopeInfo","multiset::ZipSegment","multiset::CountMatcher","delta::InsertDelta","engine::RevId"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","engine::Contents","tree::Node","tree::NodeVal","delta::Delta","breaks::BreaksInfo","spans::Span","rope::BaseMetric","breaks::BreaksLeaf","breaks::BreaksMetric","multiset::ZipSegment","delta::DeltaElement","engine::Error","engine::DeltaOp","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","delta::InsertDelta","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","multiset::Subset","rope::LinesMetric","interval::Interval","find::CaseMatching","diff::DiffOp","rope::RopeInfo","multiset::Segment","engine::RevId","diff::DiffBuilder","engine::FullPriority","tree::NodeBody"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","breaks::BreaksLeaf","multiset::Segment","engine::DeltaOp","rope::RopeInfo","spans::SpansLeaf","multiset::CountMatcher","spans::SpansInfo","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","spans::Span","interval::Interval","rope::BaseMetric","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","tree::Node","rope::Utf16CodeUnitsMetric","delta::DeltaElement","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Error","breaks::BreaksMetric","multiset::Subset","find::CaseMatching","engine::FullPriority","diff::DiffOp","multiset::ZipSegment","tree::NodeBody","breaks::BreaksInfo","engine::RevId"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = true; // None+bool
+p0.transform_expand(p1, p2);
+delta::InsertDelta::<N>::transform_expand(p0, p1, p2);
+crate::delta::InsertDelta::<N>::transform_expand(p0, p1, p2);
+<delta::InsertDelta<N>>::transform_expand(p0, p1, p2);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::transform_shrink
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta::<N>::transform_shrink":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta::<N>::transform_shrink":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::Delta","rope::BaseMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","breaks::BreaksBaseMetric","delta::InsertDelta","diff::DiffOp","tree::NodeVal","find::CaseMatching","interval::Interval","diff::DiffBuilder","engine::Contents","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","breaks::BreaksInfo","breaks::BreaksLeaf","breaks::BreaksMetric","engine::Error","rope::RopeInfo","multiset::Segment","rope::LinesMetric","tree::Node","multiset::CountMatcher","engine::DeltaOp","engine::FullPriority","delta::DeltaElement","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","multiset::Subset","engine::RevId"]},"spans::SpansInfo":{"T":["tree::Node","spans::SpansLeaf","rope::RopeInfo","multiset::ZipSegment","rope::BaseMetric","tree::NodeVal","engine::RevId","multiset::Segment","engine::Contents","breaks::BreaksLeaf","engine::DeltaOp","spans::Span","interval::Interval","find::CaseMatching","rope::Utf16CodeUnitsMetric","delta::Delta","tree::NodeBody","delta::DeltaElement","engine::FullPriority","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","engine::Error","breaks::BreaksMetric","spans::SpansInfo","rope::LinesMetric","delta::InsertDelta","diff::DiffOp","diff::DiffBuilder","breaks::BreaksInfo","multiset::Subset"]},"spans::SpansLeaf":{"T":["engine::RevId","diff::DiffOp","multiset::Subset","spans::SpansInfo","diff::DiffBuilder","delta::InsertDelta","tree::Node","engine::FullPriority","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","multiset::Segment","engine::DeltaOp","breaks::BreaksLeaf","tree::NodeBody","multiset::ZipSegment","delta::DeltaElement","tree::NodeVal","breaks::BreaksMetric","rope::RopeInfo","breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::CountMatcher","spans::SpansLeaf","rope::BaseMetric","rope::Utf16CodeUnitsMetric","interval::Interval","rope::LinesMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","engine::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_shrink(p1);
+delta::InsertDelta::<N>::transform_shrink(p0, p1);
+crate::delta::InsertDelta::<N>::transform_shrink(p0, p1);
+<delta::InsertDelta<N>>::transform_shrink(p0, p1);
-----------------
rope/src/delta.rs delta::InsertDelta::<N>::inserted_subset
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta::<N>::inserted_subset":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta::<N>::inserted_subset":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::ZipSegment","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","rope::RopeInfo","delta::DeltaElement","interval::Interval","tree::NodeBody","engine::FullPriority","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","breaks::BreaksLeaf","spans::SpansLeaf","tree::Node","rope::LinesMetric","delta::InsertDelta","delta::Delta","engine::RevId","spans::Span","multiset::Segment","breaks::BreaksMetric","multiset::CountMatcher","find::CaseMatching","tree::NodeVal","rope::BaseMetric","diff::DiffOp","engine::Contents","engine::Error"]},"spans::SpansInfo":{"T":["delta::Delta","engine::FullPriority","spans::Span","tree::NodeVal","engine::Contents","diff::DiffOp","engine::DeltaOp","breaks::BreaksInfo","breaks::BreaksLeaf","find::CaseMatching","tree::Node","engine::Error","rope::BaseMetric","breaks::BreaksMetric","rope::RopeInfo","multiset::Segment","multiset::ZipSegment","multiset::CountMatcher","multiset::Subset","spans::SpansInfo","tree::NodeBody","rope::Utf16CodeUnitsMetric","delta::InsertDelta","interval::Interval","delta::DeltaElement","diff::DiffBuilder","breaks::BreaksBaseMetric","engine::RevId","spans::SpansLeaf","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","breaks::BreaksInfo","multiset::Segment","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","delta::Delta","breaks::BreaksMetric","tree::NodeBody","multiset::Subset","diff::DiffBuilder","find::CaseMatching","rope::RopeInfo","engine::RevId","rope::LinesMetric","breaks::BreaksBaseMetric","engine::DeltaOp","multiset::ZipSegment","tree::Node","spans::Span","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","spans::SpansInfo","multiset::CountMatcher","interval::Interval","tree::NodeVal","engine::Contents","diff::DiffOp","engine::Error","delta::InsertDelta","delta::DeltaElement"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.inserted_subset();
+delta::InsertDelta::<N>::inserted_subset(p0);
+crate::delta::InsertDelta::<N>::inserted_subset(p0);
+<delta::InsertDelta<N>>::inserted_subset(p0);
-----------------
rope/src/delta.rs <delta::InsertDelta<N> as std::ops::Deref>::deref
deps:{"<delta::InsertDelta<N> as std::ops::Deref>::deref":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<delta::InsertDelta<N> as std::ops::Deref>::deref":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansInfo","spans::SpansLeaf","breaks::BreaksInfo","rope::BaseMetric","tree::Node","engine::DeltaOp","interval::Interval","multiset::Subset","delta::InsertDelta","breaks::BreaksLeaf","multiset::ZipSegment","tree::NodeVal","find::CaseMatching","spans::Span","rope::LinesMetric","engine::RevId","diff::DiffBuilder","multiset::CountMatcher","delta::DeltaElement","engine::FullPriority","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","diff::DiffOp","breaks::BreaksMetric","rope::RopeInfo","multiset::Segment","tree::NodeBody","delta::Delta"]},"spans::SpansInfo":{"T":["tree::Node","spans::Span","rope::LinesMetric","spans::SpansInfo","multiset::Segment","interval::Interval","engine::Contents","breaks::BreaksInfo","multiset::CountMatcher","multiset::ZipSegment","multiset::Subset","breaks::BreaksLeaf","delta::DeltaElement","breaks::BreaksMetric","engine::DeltaOp","tree::NodeBody","rope::BaseMetric","diff::DiffOp","find::CaseMatching","tree::NodeVal","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","rope::Utf16CodeUnitsMetric","engine::FullPriority","breaks::BreaksBaseMetric","rope::RopeInfo","diff::DiffBuilder","delta::Delta","spans::SpansLeaf","engine::Error"]},"spans::SpansLeaf":{"T":["breaks::BreaksBaseMetric","breaks::BreaksMetric","tree::Node","spans::SpansInfo","tree::NodeBody","find::CaseMatching","delta::Delta","diff::DiffBuilder","diff::DiffOp","engine::FullPriority","multiset::Segment","rope::Utf16CodeUnitsMetric","rope::LinesMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","delta::InsertDelta","delta::DeltaElement","interval::Interval","rope::RopeInfo","multiset::Subset","engine::Contents","tree::NodeVal","breaks::BreaksLeaf","multiset::CountMatcher","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","spans::Span","rope::BaseMetric","engine::Error","breaks::BreaksInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::InsertDelta<N>
+p0.deref();
+<delta::InsertDelta<N> as std::ops::Deref>::deref(p0);
+crate::<delta::InsertDelta<N> as std::ops::Deref>::deref(p0);
+<delta::InsertDelta<N>>::deref(p0);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::new
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::Transformer::<'a, N>::new":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Transformer::<'a, N>::new":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","engine::RevId","multiset::Segment","delta::DeltaElement","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksLeaf","engine::FullPriority","engine::DeltaOp","multiset::CountMatcher","interval::Interval","tree::Node","multiset::ZipSegment","rope::LinesMetric","spans::SpansInfo","rope::Utf16CodeUnitsMetric","engine::Error","spans::Span","tree::NodeBody","delta::Delta","tree::NodeVal","diff::DiffOp","delta::InsertDelta","breaks::BreaksInfo","multiset::Subset","find::CaseMatching","rope::BaseMetric","engine::Contents"]},"spans::SpansInfo":{"T":["rope::RopeInfo","delta::Delta","tree::NodeBody","rope::BaseMetric","multiset::CountMatcher","engine::DeltaOp","engine::Contents","multiset::ZipSegment","delta::DeltaElement","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","rope::Utf16CodeUnitsMetric","multiset::Segment","interval::Interval","tree::Node","spans::SpansInfo","tree::NodeVal","breaks::BreaksMetric","breaks::BreaksLeaf","rope::LinesMetric","engine::FullPriority","engine::RevId","find::CaseMatching","spans::Span","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksBaseMetric","delta::InsertDelta","multiset::Subset","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","rope::BaseMetric","delta::Delta","find::CaseMatching","multiset::Subset","engine::FullPriority","spans::Span","breaks::BreaksLeaf","tree::NodeBody","spans::SpansInfo","multiset::CountMatcher","breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::InsertDelta","tree::Node","diff::DiffOp","engine::DeltaOp","rope::RopeInfo","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","breaks::BreaksMetric","tree::NodeVal","diff::DiffBuilder","rope::LinesMetric","interval::Interval","spans::SpansLeaf","engine::Contents","engine::RevId","multiset::ZipSegment","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Delta<N>
+delta::Transformer::<'a, N>::new(p0);
+crate::delta::Transformer::<'a, N>::new(p0);
+<delta::Transformer<'a, N>>::new(p0);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::transform
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Transformer::<'a, N>::transform":{"N":["std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Transformer::<'a, N>::transform":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::BaseMetric","multiset::ZipSegment","engine::Error","spans::SpansLeaf","tree::NodeVal","rope::LinesMetric","engine::FullPriority","engine::DeltaOp","rope::RopeInfo","tree::Node","interval::Interval","engine::RevId","delta::InsertDelta","tree::NodeBody","breaks::BreaksInfo","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","spans::SpansInfo","multiset::Segment","diff::DiffBuilder","delta::Delta","engine::Contents","delta::DeltaElement","breaks::BreaksBaseMetric","diff::DiffOp","multiset::Subset","breaks::BreaksMetric","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","breaks::BreaksInfo","find::CaseMatching","engine::DeltaOp","diff::DiffBuilder","rope::BaseMetric","multiset::ZipSegment","multiset::Subset","rope::RopeInfo","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::Contents","spans::Span","interval::Interval","tree::NodeVal","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","breaks::BreaksLeaf","engine::Error","multiset::CountMatcher","spans::SpansLeaf","breaks::BreaksBaseMetric","tree::Node","engine::FullPriority","delta::DeltaElement","engine::RevId","multiset::Segment","delta::Delta","delta::InsertDelta","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","rope::RopeInfo","multiset::ZipSegment","tree::Node","engine::RevId","multiset::Segment","multiset::Subset","delta::DeltaElement","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","engine::Contents","delta::InsertDelta","tree::NodeVal","spans::SpansLeaf","diff::DiffBuilder","engine::Error","engine::DeltaOp","tree::NodeBody","spans::SpansInfo","find::CaseMatching","interval::Interval","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","breaks::BreaksLeaf","breaks::BreaksBaseMetric","spans::Span","engine::FullPriority","delta::Delta","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'a, N>
let mut p1 = 0usize; // None+usize
let mut p2 = true; // None+bool
+p0.transform(p1, p2);
+delta::Transformer::<'a, N>::transform(p0, p1, p2);
+crate::delta::Transformer::<'a, N>::transform(p0, p1, p2);
+<delta::Transformer<'a, N>>::transform(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Transformer::<'a, N>::interval_untouched
'a
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::Transformer::<'a, N>::interval_untouched":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["interval::IntervalBounds","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::Transformer::<'a, N>::interval_untouched":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"],"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","multiset::Segment","delta::InsertDelta","engine::RevId","rope::BaseMetric","multiset::CountMatcher","tree::NodeVal","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::Node","engine::Contents","interval::Interval","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","delta::DeltaElement","breaks::BreaksMetric","multiset::ZipSegment","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","diff::DiffBuilder","spans::SpansLeaf","diff::DiffOp","find::CaseMatching","engine::DeltaOp","spans::Span","rope::RopeInfo","tree::NodeBody","breaks::BreaksInfo","spans::SpansInfo","delta::Delta","engine::FullPriority"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","rope::LinesMetric","diff::DiffBuilder","engine::RevId","rope::BaseMetric","spans::SpansInfo","breaks::BreaksInfo","tree::Node","engine::Contents","breaks::BreaksLeaf","engine::Error","multiset::ZipSegment","delta::Delta","rope::RopeInfo","delta::DeltaElement","multiset::CountMatcher","interval::Interval","multiset::Subset","find::CaseMatching","tree::NodeVal","spans::Span","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffOp","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::FullPriority","delta::InsertDelta","engine::DeltaOp","tree::NodeBody","breaks::BreaksBaseMetric"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","tree::NodeBody","engine::DeltaOp","rope::LinesMetric","tree::Node","find::CaseMatching","rope::Utf16CodeUnitsMetric","multiset::Subset","breaks::BreaksBaseMetric","spans::Span","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksLeaf","delta::InsertDelta","breaks::BreaksMetric","diff::DiffBuilder","engine::RevId","engine::FullPriority","interval::Interval","engine::Error","multiset::CountMatcher","delta::DeltaElement","multiset::ZipSegment","multiset::Segment","diff::DiffOp","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","breaks::BreaksInfo","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'a, N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.interval_untouched(p1);
+delta::Transformer::<'a, N>::interval_untouched(p0, p1);
+crate::delta::Transformer::<'a, N>::interval_untouched(p0, p1);
+<delta::Transformer<'a, N>>::interval_untouched(p0, p1);
-----------------
rope/src/delta.rs delta::Builder::<N>::new
deps:{"delta::Builder::<N>::new":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Builder::<N>::new":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::Error","find::CaseMatching","multiset::Segment","rope::BaseMetric","breaks::BreaksBaseMetric","multiset::ZipSegment","multiset::CountMatcher","engine::FullPriority","tree::NodeBody","engine::DeltaOp","spans::SpansInfo","spans::Span","engine::RevId","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","delta::InsertDelta","tree::Node","multiset::Subset","breaks::BreaksInfo","engine::Contents","interval::Interval","diff::DiffOp","rope::RopeInfo","delta::Delta","breaks::BreaksLeaf","breaks::BreaksMetric","delta::DeltaElement","diff::DiffBuilder","spans::SpansLeaf","rope::Utf16CodeUnitsMetric"]},"spans::SpansInfo":{"T":["tree::NodeVal","delta::InsertDelta","rope::LinesMetric","multiset::ZipSegment","tree::Node","breaks::BreaksInfo","engine::RevId","diff::DiffOp","delta::DeltaElement","tree::NodeBody","spans::Span","engine::FullPriority","engine::DeltaOp","engine::Contents","breaks::BreaksLeaf","interval::Interval","engine::Error","multiset::Subset","rope::RopeInfo","breaks::BreaksMetric","diff::DiffBuilder","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","spans::SpansInfo","rope::BaseMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","multiset::Segment","breaks::BreaksBaseMetric","delta::Delta"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","multiset::Segment","engine::Contents","spans::Span","rope::RopeInfo","breaks::BreaksInfo","find::CaseMatching","tree::NodeVal","interval::Interval","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","rope::Utf16CodeUnitsMetric","engine::DeltaOp","engine::Error","delta::Delta","multiset::Subset","breaks::BreaksLeaf","engine::FullPriority","diff::DiffOp","spans::SpansInfo","breaks::BreaksMetric","engine::RevId","rope::BaseMetric","breaks::BreaksBaseMetric","rope::LinesMetric","diff::DiffBuilder","delta::InsertDelta","multiset::ZipSegment","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = 0usize; // None+usize
+delta::Builder::<N>::new(p0);
+crate::delta::Builder::<N>::new(p0);
+<delta::Builder<N>>::new(p0);
-----------------
rope/src/delta.rs delta::Builder::<N>::delete
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Builder::<N>::delete":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Builder::<N>::delete":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"],"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","breaks::BreaksLeaf","tree::NodeBody","spans::SpansInfo","multiset::Segment","spans::Span","diff::DiffOp","engine::Contents","diff::DiffBuilder","breaks::BreaksBaseMetric","rope::RopeInfo","multiset::Subset","tree::Node","interval::Interval","engine::DeltaOp","tree::NodeVal","engine::RevId","multiset::ZipSegment","rope::LinesMetric","engine::Error","engine::FullPriority","find::CaseMatching","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","rope::BaseMetric","delta::Delta","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","spans::SpansLeaf","interval::Interval","rope::LinesMetric","tree::NodeVal","engine::DeltaOp","rope::RopeInfo","tree::Node","delta::DeltaElement","engine::Error","tree::NodeBody","engine::RevId","spans::Span","diff::DiffOp","diff::DiffBuilder","multiset::Subset","spans::SpansInfo","breaks::BreaksInfo","multiset::CountMatcher","find::CaseMatching","breaks::BreaksMetric","engine::Contents","delta::InsertDelta","multiset::Segment","engine::FullPriority","breaks::BreaksLeaf","breaks::BreaksBaseMetric"]},"spans::SpansLeaf":{"T":["breaks::BreaksInfo","find::CaseMatching","delta::InsertDelta","diff::DiffBuilder","engine::RevId","rope::RopeInfo","breaks::BreaksMetric","multiset::Segment","diff::DiffOp","rope::Utf16CodeUnitsMetric","multiset::Subset","engine::DeltaOp","tree::Node","tree::NodeVal","multiset::ZipSegment","rope::LinesMetric","delta::Delta","engine::FullPriority","interval::Interval","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","engine::Error","multiset::CountMatcher","spans::Span","breaks::BreaksLeaf","tree::NodeBody","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","delta::DeltaElement","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Builder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.delete(p1);
+delta::Builder::<N>::delete(p0, p1);
+crate::delta::Builder::<N>::delete(p0, p1);
+<delta::Builder<N>>::delete(p0, p1);
-----------------
rope/src/delta.rs delta::Builder::<N>::replace
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Builder::<N>::replace":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","interval::IntervalBounds"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Builder::<N>::replace":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"T":["std::ops::RangeFrom","std::ops::RangeFull","<T as interval::IntervalBounds>"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::ZipSegment","delta::DeltaElement","rope::Utf16CodeUnitsMetric","engine::RevId","delta::InsertDelta","multiset::Subset","breaks::BreaksLeaf","engine::Error","breaks::BreaksMetric","delta::Delta","spans::SpansLeaf","rope::LinesMetric","spans::SpansInfo","interval::Interval","tree::NodeVal","multiset::CountMatcher","engine::FullPriority","tree::NodeBody","tree::Node","multiset::Segment","engine::DeltaOp","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","find::CaseMatching","breaks::BreaksInfo","rope::RopeInfo","engine::Contents","diff::DiffBuilder","spans::Span"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","engine::Contents","tree::NodeVal","engine::Error","diff::DiffOp","multiset::Segment","multiset::Subset","interval::Interval","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","multiset::ZipSegment","spans::Span","diff::DiffBuilder","spans::SpansInfo","rope::BaseMetric","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::InsertDelta","tree::NodeBody","delta::DeltaElement","spans::SpansLeaf","delta::Delta","multiset::CountMatcher","engine::FullPriority","breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::RopeInfo","engine::RevId","breaks::BreaksLeaf","engine::DeltaOp","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","delta::InsertDelta","breaks::BreaksBaseMetric","multiset::Subset","multiset::Segment","engine::DeltaOp","rope::RopeInfo","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","tree::Node","multiset::ZipSegment","delta::Delta","breaks::BreaksMetric","breaks::BreaksLeaf","engine::Error","engine::Contents","diff::DiffOp","spans::SpansInfo","engine::RevId","rope::LinesMetric","interval::Interval","diff::DiffBuilder","engine::FullPriority","tree::NodeVal","spans::Span","breaks::BreaksInfo","delta::DeltaElement","multiset::CountMatcher","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::Builder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.replace(p1, p2);
+delta::Builder::<N>::replace(p0, p1, p2);
+crate::delta::Builder::<N>::replace(p0, p1, p2);
+<delta::Builder<N>>::replace(p0, p1, p2);
-----------------
rope/src/delta.rs delta::Builder::<N>::is_empty
deps:{"delta::Builder::<N>::is_empty":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Builder::<N>::is_empty":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","tree::NodeVal","engine::Error","rope::RopeInfo","find::CaseMatching","delta::Delta","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","engine::DeltaOp","tree::NodeBody","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","multiset::Segment","engine::Contents","multiset::ZipSegment","breaks::BreaksLeaf","interval::Interval","breaks::BreaksBaseMetric","rope::BaseMetric","breaks::BreaksMetric","spans::SpansInfo","spans::Span","multiset::Subset","multiset::CountMatcher","engine::FullPriority","diff::DiffOp","delta::DeltaElement","engine::RevId","diff::DiffBuilder"]},"spans::SpansInfo":{"T":["delta::Delta","delta::DeltaElement","multiset::CountMatcher","diff::DiffOp","engine::FullPriority","tree::NodeBody","engine::Error","delta::InsertDelta","engine::RevId","multiset::ZipSegment","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","spans::SpansInfo","engine::DeltaOp","tree::NodeVal","find::CaseMatching","breaks::BreaksBaseMetric","rope::RopeInfo","spans::Span","rope::BaseMetric","breaks::BreaksLeaf","multiset::Segment","rope::LinesMetric","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","breaks::BreaksMetric","diff::DiffBuilder","multiset::Subset","tree::Node"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","multiset::Subset","engine::FullPriority","diff::DiffBuilder","spans::SpansInfo","multiset::Segment","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","multiset::CountMatcher","spans::Span","delta::DeltaElement","breaks::BreaksInfo","breaks::BreaksBaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","delta::InsertDelta","diff::DiffOp","rope::BaseMetric","spans::SpansLeaf","rope::LinesMetric","tree::NodeVal","engine::Contents","engine::Error","rope::RopeInfo","delta::Delta","interval::Interval","engine::RevId","find::CaseMatching"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::Builder<N>
+p0.is_empty();
+delta::Builder::<N>::is_empty(p0);
+crate::delta::Builder::<N>::is_empty(p0);
+<delta::Builder<N>>::is_empty(p0);
-----------------
rope/src/delta.rs delta::Builder::<N>::build
deps:{"delta::Builder::<N>::build":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Builder::<N>::build":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","engine::Error","find::CaseMatching","engine::DeltaOp","breaks::BreaksInfo","breaks::BreaksMetric","rope::BaseMetric","engine::RevId","rope::RopeInfo","diff::DiffOp","delta::Delta","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::FullPriority","multiset::Segment","delta::InsertDelta","interval::Interval","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","engine::Contents","delta::DeltaElement","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","spans::SpansInfo","tree::NodeVal","spans::Span","breaks::BreaksLeaf","tree::NodeBody","multiset::CountMatcher","diff::DiffBuilder"]},"spans::SpansInfo":{"T":["rope::BaseMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","engine::FullPriority","engine::DeltaOp","find::CaseMatching","multiset::Segment","rope::RopeInfo","breaks::BreaksLeaf","spans::SpansLeaf","spans::SpansInfo","engine::RevId","multiset::Subset","engine::Contents","tree::NodeVal","rope::LinesMetric","interval::Interval","multiset::ZipSegment","tree::NodeBody","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","spans::Span","diff::DiffBuilder","diff::DiffOp","tree::Node","delta::DeltaElement","breaks::BreaksBaseMetric","delta::Delta","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["interval::Interval","rope::Utf16CodeUnitsMetric","rope::RopeInfo","spans::SpansLeaf","spans::Span","engine::DeltaOp","find::CaseMatching","engine::Error","tree::Node","rope::LinesMetric","multiset::Segment","delta::DeltaElement","rope::BaseMetric","spans::SpansInfo","engine::RevId","breaks::BreaksMetric","engine::FullPriority","diff::DiffOp","delta::Delta","multiset::Subset","tree::NodeBody","multiset::CountMatcher","breaks::BreaksBaseMetric","multiset::ZipSegment","tree::NodeVal","delta::InsertDelta","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // delta::Builder<N>
+p0.build();
+delta::Builder::<N>::build(p0);
+crate::delta::Builder::<N>::build(p0);
+<delta::Builder<N>>::build(p0);
-----------------
rope/src/delta.rs <delta::DeltaRegion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<delta::DeltaRegion as std::fmt::Debug>::fmt(p0, p1);
+crate::<delta::DeltaRegion as std::fmt::Debug>::fmt(p0, p1);
+<delta::DeltaRegion>::fmt(p0, p1);
-----------------
rope/src/delta.rs <delta::DeltaRegion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
let mut p1 = & MaybeUninit::uninit().assume_init(); // delta::DeltaRegion
+p0.eq(p1);
+<delta::DeltaRegion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<delta::DeltaRegion as std::cmp::PartialEq>::eq(p0, p1);
+<delta::DeltaRegion>::eq(p0, p1);
-----------------
rope/src/delta.rs delta::DeltaRegion::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+delta::DeltaRegion::new(p0, p1, p2);
+crate::delta::DeltaRegion::new(p0, p1, p2);
+<delta::DeltaRegion>::new(p0, p1, p2);
-----------------
rope/src/delta.rs <delta::InsertsIter<'a, N> as std::iter::Iterator>::next
'a
deps:{"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::InsertDelta","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","find::CaseMatching","multiset::ZipSegment","engine::FullPriority","engine::DeltaOp","rope::RopeInfo","multiset::Segment","engine::Contents","rope::Utf16CodeUnitsMetric","engine::RevId","delta::Delta","diff::DiffOp","rope::BaseMetric","tree::NodeBody","delta::DeltaElement","breaks::BreaksBaseMetric","spans::SpansInfo","interval::Interval","tree::NodeVal","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","breaks::BreaksMetric","breaks::BreaksInfo","rope::LinesMetric","spans::Span","diff::DiffBuilder","tree::Node","multiset::Subset"]},"spans::SpansInfo":{"T":["multiset::Subset","rope::LinesMetric","spans::Span","find::CaseMatching","multiset::ZipSegment","diff::DiffBuilder","engine::Error","delta::DeltaElement","spans::SpansInfo","tree::NodeBody","multiset::CountMatcher","diff::DiffOp","multiset::Segment","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","rope::BaseMetric","engine::Contents","tree::NodeVal","spans::SpansLeaf","tree::Node","engine::RevId","engine::DeltaOp","engine::FullPriority","breaks::BreaksBaseMetric","interval::Interval","delta::InsertDelta","rope::RopeInfo","delta::Delta","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["engine::FullPriority","rope::RopeInfo","multiset::CountMatcher","engine::Error","rope::Utf16CodeUnitsMetric","spans::Span","delta::InsertDelta","delta::Delta","spans::SpansLeaf","engine::DeltaOp","breaks::BreaksInfo","breaks::BreaksMetric","interval::Interval","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","tree::NodeVal","breaks::BreaksLeaf","diff::DiffOp","find::CaseMatching","tree::Node","tree::NodeBody","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","delta::DeltaElement","multiset::Segment","rope::BaseMetric","engine::Contents","diff::DiffBuilder","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::InsertsIter<'a, N>
+p0.next();
+<delta::InsertsIter<'a, N> as std::iter::Iterator>::next(p0);
+crate::<delta::InsertsIter<'a, N> as std::iter::Iterator>::next(p0);
+<delta::InsertsIter<'a, N>>::next(p0);
-----------------
rope/src/delta.rs <delta::DeletionsIter<'a, N> as std::iter::Iterator>::next
'a
deps:{"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","multiset::CountMatcher","breaks::BreaksInfo","engine::FullPriority","delta::DeltaElement","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","engine::DeltaOp","engine::Contents","spans::SpansInfo","tree::NodeVal","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","diff::DiffBuilder","rope::LinesMetric","multiset::Subset","find::CaseMatching","engine::RevId","multiset::ZipSegment","breaks::BreaksMetric","delta::InsertDelta","multiset::Segment","delta::Delta","spans::Span","interval::Interval","tree::Node","rope::RopeInfo","breaks::BreaksLeaf","rope::BaseMetric","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["delta::DeltaElement","multiset::Segment","tree::NodeBody","multiset::Subset","tree::Node","multiset::ZipSegment","interval::Interval","engine::Error","spans::Span","engine::Contents","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","spans::SpansInfo","engine::RevId","find::CaseMatching","breaks::BreaksInfo","spans::SpansLeaf","diff::DiffOp","breaks::BreaksMetric","rope::LinesMetric","breaks::BreaksBaseMetric","engine::DeltaOp","rope::BaseMetric","delta::Delta","engine::FullPriority","rope::RopeInfo","multiset::CountMatcher","tree::NodeVal","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","spans::Span","diff::DiffBuilder","tree::Node","delta::InsertDelta","rope::LinesMetric","engine::RevId","engine::Contents","delta::DeltaElement","tree::NodeBody","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","diff::DiffOp","spans::SpansInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","rope::RopeInfo","multiset::Segment","rope::BaseMetric","interval::Interval","breaks::BreaksBaseMetric","breaks::BreaksLeaf","spans::SpansLeaf","multiset::Subset","find::CaseMatching","engine::DeltaOp","multiset::CountMatcher","engine::FullPriority","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // delta::DeletionsIter<'a, N>
+p0.next();
+<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next(p0);
+crate::<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next(p0);
+<delta::DeletionsIter<'a, N>>::next(p0);
-----------------
rope/src/diff.rs <diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta(p0, p1);
+crate::<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta(p0, p1);
+<diff::LineHashDiff>::compute_delta(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<diff::DiffOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<diff::DiffOp as std::fmt::Debug>::fmt(p0, p1);
+<diff::DiffOp>::fmt(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffOp
+p0.clone();
+<diff::DiffOp as std::clone::Clone>::clone(p0);
+crate::<diff::DiffOp as std::clone::Clone>::clone(p0);
+<diff::DiffOp>::clone(p0);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<diff::DiffBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<diff::DiffBuilder as std::fmt::Debug>::fmt(p0, p1);
+<diff::DiffBuilder>::fmt(p0, p1);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
+p0.clone();
+<diff::DiffBuilder as std::clone::Clone>::clone(p0);
+crate::<diff::DiffBuilder as std::clone::Clone>::clone(p0);
+<diff::DiffBuilder>::clone(p0);
-----------------
rope/src/diff.rs <diff::DiffBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<diff::DiffBuilder as std::default::Default>::default();
+crate::<diff::DiffBuilder as std::default::Default>::default();
+<diff::DiffBuilder>::default();
-----------------
rope/src/diff.rs diff::DiffBuilder::copy
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+p0.copy(p1, p2, p3);
+diff::DiffBuilder::copy(p0, p1, p2, p3);
+crate::diff::DiffBuilder::copy(p0, p1, p2, p3);
+<diff::DiffBuilder>::copy(p0, p1, p2, p3);
-----------------
rope/src/diff.rs diff::DiffBuilder::to_delta
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // diff::DiffBuilder
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p2 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+p0.to_delta(p1, p2);
+diff::DiffBuilder::to_delta(p0, p1, p2);
+crate::diff::DiffBuilder::to_delta(p0, p1, p2);
+<diff::DiffBuilder>::to_delta(p0, p1, p2);
-----------------
rope/src/engine.rs <engine::Engine as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Engine as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Engine as std::fmt::Debug>::fmt(p0, p1);
+<engine::Engine>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::RevId as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::RevId as std::fmt::Debug>::fmt(p0, p1);
+<engine::RevId>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.clone();
+<engine::RevId as std::clone::Clone>::clone(p0);
+crate::<engine::RevId as std::clone::Clone>::clone(p0);
+<engine::RevId>::clone(p0);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.partial_cmp(p1);
+<engine::RevId as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<engine::RevId as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<engine::RevId>::partial_cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.cmp(p1);
+<engine::RevId as std::cmp::Ord>::cmp(p0, p1);
+crate::<engine::RevId as std::cmp::Ord>::cmp(p0, p1);
+<engine::RevId>::cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.eq(p1);
+<engine::RevId as std::cmp::PartialEq>::eq(p0, p1);
+crate::<engine::RevId as std::cmp::PartialEq>::eq(p0, p1);
+<engine::RevId>::eq(p0, p1);
-----------------
rope/src/engine.rs <engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.assert_receiver_is_total_eq();
+<engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<engine::RevId>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/engine.rs <engine::RevId as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<engine::RevId as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<engine::RevId as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<engine::RevId as std::hash::Hash>::hash(p0, p1);
+crate::<engine::RevId as std::hash::Hash>::hash(p0, p1);
+<engine::RevId>::hash(p0, p1);
-----------------
rope/src/engine.rs <engine::Revision as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Revision
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Revision as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Revision as std::fmt::Debug>::fmt(p0, p1);
+<engine::Revision>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
+p0.clone();
+<engine::Error as std::clone::Clone>::clone(p0);
+crate::<engine::Error as std::clone::Clone>::clone(p0);
+<engine::Error>::clone(p0);
-----------------
rope/src/engine.rs <engine::FullPriority as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.clone();
+<engine::FullPriority as std::clone::Clone>::clone(p0);
+crate::<engine::FullPriority as std::clone::Clone>::clone(p0);
+<engine::FullPriority>::clone(p0);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.partial_cmp(p1);
+<engine::FullPriority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<engine::FullPriority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<engine::FullPriority>::partial_cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.cmp(p1);
+<engine::FullPriority as std::cmp::Ord>::cmp(p0, p1);
+crate::<engine::FullPriority as std::cmp::Ord>::cmp(p0, p1);
+<engine::FullPriority>::cmp(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.eq(p1);
+<engine::FullPriority as std::cmp::PartialEq>::eq(p0, p1);
+crate::<engine::FullPriority as std::cmp::PartialEq>::eq(p0, p1);
+<engine::FullPriority>::eq(p0, p1);
-----------------
rope/src/engine.rs <engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::FullPriority
+p0.assert_receiver_is_total_eq();
+<engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<engine::FullPriority>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/engine.rs <engine::Contents as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Contents
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Contents as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Contents as std::fmt::Debug>::fmt(p0, p1);
+<engine::Contents>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Contents as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Contents
+p0.clone();
+<engine::Contents as std::clone::Clone>::clone(p0);
+crate::<engine::Contents as std::clone::Clone>::clone(p0);
+<engine::Contents>::clone(p0);
-----------------
rope/src/engine.rs engine::RevId::token
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.token();
+engine::RevId::token(p0);
+crate::engine::RevId::token(p0);
+<engine::RevId>::token(p0);
-----------------
rope/src/engine.rs engine::RevId::session_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.session_id();
+engine::RevId::session_id(p0);
+crate::engine::RevId::session_id(p0);
+<engine::RevId>::session_id(p0);
-----------------
rope/src/engine.rs engine::Engine::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+engine::Engine::new(p0);
+crate::engine::Engine::new(p0);
+<engine::Engine>::new(p0);
-----------------
rope/src/engine.rs engine::Engine::empty
deps:{}
candidates:{}
+engine::Engine::empty();
+crate::engine::Engine::empty();
+<engine::Engine>::empty();
-----------------
rope/src/engine.rs engine::Engine::next_rev_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.next_rev_id();
+engine::Engine::next_rev_id(p0);
+crate::engine::Engine::next_rev_id(p0);
+<engine::Engine>::next_rev_id(p0);
-----------------
rope/src/engine.rs engine::Engine::find_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.find_rev(p1);
+engine::Engine::find_rev(p0, p1);
+crate::engine::Engine::find_rev(p0, p1);
+<engine::Engine>::find_rev(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::find_rev_token
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.find_rev_token(p1);
+engine::Engine::find_rev_token(p0, p1);
+crate::engine::Engine::find_rev_token(p0, p1);
+<engine::Engine>::find_rev_token(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_union_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.deletes_from_union_for_index(p1);
+engine::Engine::deletes_from_union_for_index(p0, p1);
+crate::engine::Engine::deletes_from_union_for_index(p0, p1);
+<engine::Engine>::deletes_from_union_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_union_before_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = true; // None+bool
+p0.deletes_from_union_before_index(p1, p2);
+engine::Engine::deletes_from_union_before_index(p0, p1, p2);
+crate::engine::Engine::deletes_from_union_before_index(p0, p1, p2);
+<engine::Engine>::deletes_from_union_before_index(p0, p1, p2);
-----------------
rope/src/engine.rs engine::Engine::rev_content_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.rev_content_for_index(p1);
+engine::Engine::rev_content_for_index(p0, p1);
+crate::engine::Engine::rev_content_for_index(p0, p1);
+<engine::Engine>::rev_content_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::deletes_from_cur_union_for_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
+p0.deletes_from_cur_union_for_index(p1);
+engine::Engine::deletes_from_cur_union_for_index(p0, p1);
+crate::engine::Engine::deletes_from_cur_union_for_index(p0, p1);
+<engine::Engine>::deletes_from_cur_union_for_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::max_undo_group_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.max_undo_group_id();
+engine::Engine::max_undo_group_id(p0);
+crate::engine::Engine::max_undo_group_id(p0);
+<engine::Engine>::max_undo_group_id(p0);
-----------------
rope/src/engine.rs engine::Engine::get_head_rev_id
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.get_head_rev_id();
+engine::Engine::get_head_rev_id(p0);
+crate::engine::Engine::get_head_rev_id(p0);
+<engine::Engine>::get_head_rev_id(p0);
-----------------
rope/src/engine.rs engine::Engine::get_head
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.get_head();
+engine::Engine::get_head(p0);
+crate::engine::Engine::get_head(p0);
+<engine::Engine>::get_head(p0);
-----------------
rope/src/engine.rs engine::Engine::get_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.get_rev(p1);
+engine::Engine::get_rev(p0, p1);
+crate::engine::Engine::get_rev(p0, p1);
+<engine::Engine>::get_rev(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::try_delta_rev_head
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0u64; // None+u64
+p0.try_delta_rev_head(p1);
+engine::Engine::try_delta_rev_head(p0, p1);
+crate::engine::Engine::try_delta_rev_head(p0, p1);
+<engine::Engine>::try_delta_rev_head(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::mk_new_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.mk_new_rev(p1, p2, p3, p4);
+engine::Engine::mk_new_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::mk_new_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::mk_new_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::edit_rev
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.edit_rev(p1, p2, p3, p4);
+engine::Engine::edit_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::edit_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::edit_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::try_edit_rev
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0u64; // None+u64
let mut p4 = MaybeUninit::uninit().assume_init(); // delta::Delta<rope::RopeInfo>
+p0.try_edit_rev(p1, p2, p3, p4);
+engine::Engine::try_edit_rev(p0, p1, p2, p3, p4);
+crate::engine::Engine::try_edit_rev(p0, p1, p2, p3, p4);
+<engine::Engine>::try_edit_rev(p0, p1, p2, p3, p4);
-----------------
rope/src/engine.rs engine::Engine::empty_subset_before_first_rev
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.empty_subset_before_first_rev();
+engine::Engine::empty_subset_before_first_rev(p0);
+crate::engine::Engine::empty_subset_before_first_rev(p0);
+<engine::Engine>::empty_subset_before_first_rev(p0);
-----------------
rope/src/engine.rs engine::Engine::find_first_undo_candidate_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.find_first_undo_candidate_index(p1);
+engine::Engine::find_first_undo_candidate_index(p0, p1);
+crate::engine::Engine::find_first_undo_candidate_index(p0, p1);
+<engine::Engine>::find_first_undo_candidate_index(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::compute_undo
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.compute_undo(p1);
+engine::Engine::compute_undo(p0, p1);
+crate::engine::Engine::compute_undo(p0, p1);
+<engine::Engine>::compute_undo(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::undo
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.undo(p1);
+engine::Engine::undo(p0, p1);
+crate::engine::Engine::undo(p0, p1);
+<engine::Engine>::undo(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::is_equivalent_revision
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // engine::RevId
let mut p2 = MaybeUninit::uninit().assume_init(); // engine::RevId
+p0.is_equivalent_revision(p1, p2);
+engine::Engine::is_equivalent_revision(p0, p1, p2);
+crate::engine::Engine::is_equivalent_revision(p0, p1, p2);
+<engine::Engine>::is_equivalent_revision(p0, p1, p2);
-----------------
rope/src/engine.rs engine::Engine::gc
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::collections::BTreeSet<usize>
+p0.gc(p1);
+engine::Engine::gc(p0, p1);
+crate::engine::Engine::gc(p0, p1);
+<engine::Engine>::gc(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::merge
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = & MaybeUninit::uninit().assume_init(); // engine::Engine
+p0.merge(p1);
+engine::Engine::merge(p0, p1);
+crate::engine::Engine::merge(p0, p1);
+<engine::Engine>::merge(p0, p1);
-----------------
rope/src/engine.rs engine::Engine::set_session_id
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // engine::Engine
let mut p1 = MaybeUninit::uninit().assume_init(); // (u64, u32)
+p0.set_session_id(p1);
+engine::Engine::set_session_id(p0, p1);
+crate::engine::Engine::set_session_id(p0, p1);
+<engine::Engine>::set_session_id(p0, p1);
-----------------
rope/src/engine.rs <engine::DeltaOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::DeltaOp
+p0.clone();
+<engine::DeltaOp as std::clone::Clone>::clone(p0);
+crate::<engine::DeltaOp as std::clone::Clone>::clone(p0);
+<engine::DeltaOp>::clone(p0);
-----------------
rope/src/engine.rs <engine::DeltaOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::DeltaOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::DeltaOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::DeltaOp as std::fmt::Debug>::fmt(p0, p1);
+<engine::DeltaOp>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<engine::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<engine::Error as std::fmt::Display>::fmt(p0, p1);
+<engine::Error>::fmt(p0, p1);
-----------------
rope/src/engine.rs <engine::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // engine::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<engine::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<engine::Error as std::fmt::Debug>::fmt(p0, p1);
+<engine::Error>::fmt(p0, p1);
-----------------
rope/src/find.rs <find::CaseMatching as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
+p0.clone();
+<find::CaseMatching as std::clone::Clone>::clone(p0);
+crate::<find::CaseMatching as std::clone::Clone>::clone(p0);
+<find::CaseMatching>::clone(p0);
-----------------
rope/src/find.rs <find::CaseMatching as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
let mut p1 = & MaybeUninit::uninit().assume_init(); // find::CaseMatching
+p0.eq(p1);
+<find::CaseMatching as std::cmp::PartialEq>::eq(p0, p1);
+crate::<find::CaseMatching as std::cmp::PartialEq>::eq(p0, p1);
+<find::CaseMatching>::eq(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.clone();
+<interval::Interval as std::clone::Clone>::clone(p0);
+crate::<interval::Interval as std::clone::Clone>::clone(p0);
+<interval::Interval>::clone(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.eq(p1);
+<interval::Interval as std::cmp::PartialEq>::eq(p0, p1);
+crate::<interval::Interval as std::cmp::PartialEq>::eq(p0, p1);
+<interval::Interval>::eq(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.assert_receiver_is_total_eq();
+<interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<interval::Interval>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/interval.rs interval::Interval::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new(p0, p1);
+crate::interval::Interval::new(p0, p1);
+<interval::Interval>::new(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_closed_open
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_closed_open(p0, p1);
+crate::interval::Interval::new_closed_open(p0, p1);
+<interval::Interval>::new_closed_open(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_open_closed
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_open_closed(p0, p1);
+crate::interval::Interval::new_open_closed(p0, p1);
+<interval::Interval>::new_open_closed(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_closed_closed
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_closed_closed(p0, p1);
+crate::interval::Interval::new_closed_closed(p0, p1);
+<interval::Interval>::new_closed_closed(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::new_open_open
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+interval::Interval::new_open_open(p0, p1);
+crate::interval::Interval::new_open_open(p0, p1);
+<interval::Interval>::new_open_open(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.start();
+interval::Interval::start(p0);
+crate::interval::Interval::start(p0);
+<interval::Interval>::start(p0);
-----------------
rope/src/interval.rs interval::Interval::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.end();
+interval::Interval::end(p0);
+crate::interval::Interval::end(p0);
+<interval::Interval>::end(p0);
-----------------
rope/src/interval.rs interval::Interval::start_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.start_end();
+interval::Interval::start_end(p0);
+crate::interval::Interval::start_end(p0);
+<interval::Interval>::start_end(p0);
-----------------
rope/src/interval.rs interval::Interval::is_before
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.is_before(p1);
+interval::Interval::is_before(p0, p1);
+crate::interval::Interval::is_before(p0, p1);
+<interval::Interval>::is_before(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.contains(p1);
+interval::Interval::contains(p0, p1);
+crate::interval::Interval::contains(p0, p1);
+<interval::Interval>::contains(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::is_after
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.is_after(p1);
+interval::Interval::is_after(p0, p1);
+crate::interval::Interval::is_after(p0, p1);
+<interval::Interval>::is_after(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.is_empty();
+interval::Interval::is_empty(p0);
+crate::interval::Interval::is_empty(p0);
+<interval::Interval>::is_empty(p0);
-----------------
rope/src/interval.rs interval::Interval::intersect
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.intersect(p1);
+interval::Interval::intersect(p0, p1);
+crate::interval::Interval::intersect(p0, p1);
+<interval::Interval>::intersect(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.union(p1);
+interval::Interval::union(p0, p1);
+crate::interval::Interval::union(p0, p1);
+<interval::Interval>::union(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.prefix(p1);
+interval::Interval::prefix(p0, p1);
+crate::interval::Interval::prefix(p0, p1);
+<interval::Interval>::prefix(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.suffix(p1);
+interval::Interval::suffix(p0, p1);
+crate::interval::Interval::suffix(p0, p1);
+<interval::Interval>::suffix(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::translate
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.translate(p1);
+interval::Interval::translate(p0, p1);
+crate::interval::Interval::translate(p0, p1);
+<interval::Interval>::translate(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::translate_neg
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = 0usize; // None+usize
+p0.translate_neg(p1);
+interval::Interval::translate_neg(p0, p1);
+crate::interval::Interval::translate_neg(p0, p1);
+<interval::Interval>::translate_neg(p0, p1);
-----------------
rope/src/interval.rs interval::Interval::size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.size();
+interval::Interval::size(p0);
+crate::interval::Interval::size(p0);
+<interval::Interval>::size(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<interval::Interval as std::fmt::Display>::fmt(p0, p1);
+crate::<interval::Interval as std::fmt::Display>::fmt(p0, p1);
+<interval::Interval>::fmt(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // interval::Interval
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<interval::Interval as std::fmt::Debug>::fmt(p0, p1);
+crate::<interval::Interval as std::fmt::Debug>::fmt(p0, p1);
+<interval::Interval>::fmt(p0, p1);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::Range<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from(p0);
+crate::<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from(p0);
+<interval::Interval>::from(p0);
-----------------
rope/src/interval.rs <T as interval::IntervalBounds>::into_interval
deps:{"<T as interval::IntervalBounds>::into_interval":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>::into_interval":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<T as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<T as interval::IntervalBounds>::into_interval(p0, p1);
+<T>::into_interval(p0, p1);
-----------------
rope/src/interval.rs <std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval(p0, p1);
+<std::ops::RangeFrom<usize>>::into_interval(p0, p1);
-----------------
rope/src/interval.rs <std::ops::RangeFull as interval::IntervalBounds>::into_interval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
let mut p1 = 0usize; // None+usize
+p0.into_interval(p1);
+<std::ops::RangeFull as interval::IntervalBounds>::into_interval(p0, p1);
+crate::<std::ops::RangeFull as interval::IntervalBounds>::into_interval(p0, p1);
+<std::ops::RangeFull>::into_interval(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Segment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.clone();
+<multiset::Segment as std::clone::Clone>::clone(p0);
+crate::<multiset::Segment as std::clone::Clone>::clone(p0);
+<multiset::Segment>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::Segment as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.eq(p1);
+<multiset::Segment as std::cmp::PartialEq>::eq(p0, p1);
+crate::<multiset::Segment as std::cmp::PartialEq>::eq(p0, p1);
+<multiset::Segment>::eq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.assert_receiver_is_total_eq();
+<multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<multiset::Segment>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/multiset.rs <multiset::Segment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::Segment as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::Segment as std::fmt::Debug>::fmt(p0, p1);
+<multiset::Segment>::fmt(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.clone();
+<multiset::Subset as std::clone::Clone>::clone(p0);
+crate::<multiset::Subset as std::clone::Clone>::clone(p0);
+<multiset::Subset>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::Subset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.eq(p1);
+<multiset::Subset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<multiset::Subset as std::cmp::PartialEq>::eq(p0, p1);
+<multiset::Subset>::eq(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.assert_receiver_is_total_eq();
+<multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<multiset::Subset>::assert_receiver_is_total_eq(p0);
-----------------
rope/src/multiset.rs <multiset::SubsetBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<multiset::SubsetBuilder as std::default::Default>::default();
+crate::<multiset::SubsetBuilder as std::default::Default>::default();
+<multiset::SubsetBuilder>::default();
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::new
deps:{}
candidates:{}
+multiset::SubsetBuilder::new();
+crate::multiset::SubsetBuilder::new();
+<multiset::SubsetBuilder>::new();
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::pad_to_len
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
+p0.pad_to_len(p1);
+multiset::SubsetBuilder::pad_to_len(p0, p1);
+crate::multiset::SubsetBuilder::pad_to_len(p0, p1);
+<multiset::SubsetBuilder>::pad_to_len(p0, p1);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::add_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+p0.add_range(p1, p2, p3);
+multiset::SubsetBuilder::add_range(p0, p1, p2, p3);
+crate::multiset::SubsetBuilder::add_range(p0, p1, p2, p3);
+<multiset::SubsetBuilder>::add_range(p0, p1, p2, p3);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::push_segment
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.push_segment(p1, p2);
+multiset::SubsetBuilder::push_segment(p0, p1, p2);
+crate::multiset::SubsetBuilder::push_segment(p0, p1, p2);
+<multiset::SubsetBuilder>::push_segment(p0, p1, p2);
-----------------
rope/src/multiset.rs multiset::SubsetBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::SubsetBuilder
+p0.build();
+multiset::SubsetBuilder::build(p0);
+crate::multiset::SubsetBuilder::build(p0);
+<multiset::SubsetBuilder>::build(p0);
-----------------
rope/src/multiset.rs <multiset::CountMatcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.clone();
+<multiset::CountMatcher as std::clone::Clone>::clone(p0);
+crate::<multiset::CountMatcher as std::clone::Clone>::clone(p0);
+<multiset::CountMatcher>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::CountMatcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::CountMatcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::CountMatcher as std::fmt::Debug>::fmt(p0, p1);
+<multiset::CountMatcher>::fmt(p0, p1);
-----------------
rope/src/multiset.rs multiset::CountMatcher::matches
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Segment
+p0.matches(p1);
+multiset::CountMatcher::matches(p0, p1);
+crate::multiset::CountMatcher::matches(p0, p1);
+<multiset::CountMatcher>::matches(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+multiset::Subset::new(p0);
+crate::multiset::Subset::new(p0);
+<multiset::Subset>::new(p0);
-----------------
rope/src/multiset.rs multiset::Subset::delete_from_string
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = "sample"; // None+&str
+p0.delete_from_string(&p1);
+multiset::Subset::delete_from_string(p0, &p1);
+crate::multiset::Subset::delete_from_string(p0, &p1);
+<multiset::Subset>::delete_from_string(p0, &p1);
-----------------
rope/src/multiset.rs multiset::Subset::delete_from
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"multiset::Subset::delete_from":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"multiset::Subset::delete_from":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["diff::DiffOp","find::CaseMatching","tree::NodeBody","multiset::Segment","engine::Error","breaks::BreaksBaseMetric","multiset::CountMatcher","tree::Node","multiset::Subset","spans::Span","spans::SpansLeaf","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","rope::RopeInfo","delta::Delta","breaks::BreaksMetric","engine::FullPriority","diff::DiffBuilder","engine::DeltaOp","interval::Interval","breaks::BreaksInfo","rope::BaseMetric","multiset::ZipSegment","engine::RevId","spans::SpansInfo","engine::Contents","tree::NodeVal","rope::LinesMetric"]},"spans::SpansInfo":{"T":["find::CaseMatching","spans::SpansInfo","tree::NodeBody","interval::Interval","engine::FullPriority","multiset::CountMatcher","rope::RopeInfo","multiset::Subset","diff::DiffBuilder","engine::Contents","delta::Delta","breaks::BreaksInfo","multiset::Segment","engine::RevId","engine::DeltaOp","diff::DiffOp","breaks::BreaksMetric","delta::InsertDelta","rope::BaseMetric","engine::Error","tree::Node","spans::Span","delta::DeltaElement","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::LinesMetric","spans::SpansLeaf","tree::NodeVal"]},"spans::SpansLeaf":{"T":["diff::DiffOp","engine::RevId","rope::LinesMetric","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::Segment","tree::NodeVal","breaks::BreaksLeaf","find::CaseMatching","delta::InsertDelta","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","interval::Interval","spans::Span","tree::Node","delta::DeltaElement","multiset::Subset","breaks::BreaksBaseMetric","engine::FullPriority","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric","diff::DiffBuilder","delta::Delta","rope::BaseMetric","spans::SpansInfo","spans::SpansLeaf","breaks::BreaksInfo","rope::RopeInfo","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.delete_from(p1);
+multiset::Subset::delete_from(p0, p1);
+crate::multiset::Subset::delete_from(p0, p1);
+<multiset::Subset>::delete_from(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::len_after_delete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.len_after_delete();
+multiset::Subset::len_after_delete(p0);
+crate::multiset::Subset::len_after_delete(p0);
+<multiset::Subset>::len_after_delete(p0);
-----------------
rope/src/multiset.rs multiset::Subset::count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.count(p1);
+multiset::Subset::count(p0, p1);
+crate::multiset::Subset::count(p0, p1);
+<multiset::Subset>::count(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.len();
+multiset::Subset::len(p0);
+crate::multiset::Subset::len(p0);
+<multiset::Subset>::len(p0);
-----------------
rope/src/multiset.rs multiset::Subset::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.is_empty();
+multiset::Subset::is_empty(p0);
+crate::multiset::Subset::is_empty(p0);
+<multiset::Subset>::is_empty(p0);
-----------------
rope/src/multiset.rs multiset::Subset::union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.union(p1);
+multiset::Subset::union(p0, p1);
+crate::multiset::Subset::union(p0, p1);
+<multiset::Subset>::union(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::subtract
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.subtract(p1);
+multiset::Subset::subtract(p0, p1);
+crate::multiset::Subset::subtract(p0, p1);
+<multiset::Subset>::subtract(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::bitxor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.bitxor(p1);
+multiset::Subset::bitxor(p0, p1);
+crate::multiset::Subset::bitxor(p0, p1);
+<multiset::Subset>::bitxor(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p2 = true; // None+bool
+p0.transform(p1, p2);
+multiset::Subset::transform(p0, p1, p2);
+crate::multiset::Subset::transform(p0, p1, p2);
+<multiset::Subset>::transform(p0, p1, p2);
-----------------
rope/src/multiset.rs multiset::Subset::transform_expand
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_expand(p1);
+multiset::Subset::transform_expand(p0, p1);
+crate::multiset::Subset::transform_expand(p0, p1);
+<multiset::Subset>::transform_expand(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform_union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_union(p1);
+multiset::Subset::transform_union(p0, p1);
+crate::multiset::Subset::transform_union(p0, p1);
+<multiset::Subset>::transform_union(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::transform_shrink
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.transform_shrink(p1);
+multiset::Subset::transform_shrink(p0, p1);
+crate::multiset::Subset::transform_shrink(p0, p1);
+<multiset::Subset>::transform_shrink(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::range_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.range_iter(p1);
+multiset::Subset::range_iter(p0, p1);
+crate::multiset::Subset::range_iter(p0, p1);
+<multiset::Subset>::range_iter(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::complement_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.complement_iter();
+multiset::Subset::complement_iter(p0);
+crate::multiset::Subset::complement_iter(p0);
+<multiset::Subset>::complement_iter(p0);
-----------------
rope/src/multiset.rs multiset::Subset::zip
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.zip(p1);
+multiset::Subset::zip(p0, p1);
+crate::multiset::Subset::zip(p0, p1);
+<multiset::Subset>::zip(p0, p1);
-----------------
rope/src/multiset.rs multiset::Subset::complement
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
+p0.complement();
+multiset::Subset::complement(p0);
+crate::multiset::Subset::complement(p0);
+<multiset::Subset>::complement(p0);
-----------------
rope/src/multiset.rs multiset::Subset::mapper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = MaybeUninit::uninit().assume_init(); // multiset::CountMatcher
+p0.mapper(p1);
+multiset::Subset::mapper(p0, p1);
+crate::multiset::Subset::mapper(p0, p1);
+<multiset::Subset>::mapper(p0, p1);
-----------------
rope/src/multiset.rs <multiset::Subset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::Subset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::Subset as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::Subset as std::fmt::Debug>::fmt(p0, p1);
+<multiset::Subset>::fmt(p0, p1);
-----------------
rope/src/multiset.rs <multiset::RangeIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::RangeIter<'a>
+p0.next();
+<multiset::RangeIter<'a> as std::iter::Iterator>::next(p0);
+crate::<multiset::RangeIter<'a> as std::iter::Iterator>::next(p0);
+<multiset::RangeIter<'a>>::next(p0);
-----------------
rope/src/multiset.rs <multiset::ZipSegment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::ZipSegment
+p0.clone();
+<multiset::ZipSegment as std::clone::Clone>::clone(p0);
+crate::<multiset::ZipSegment as std::clone::Clone>::clone(p0);
+<multiset::ZipSegment>::clone(p0);
-----------------
rope/src/multiset.rs <multiset::ZipSegment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // multiset::ZipSegment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<multiset::ZipSegment as std::fmt::Debug>::fmt(p0, p1);
+crate::<multiset::ZipSegment as std::fmt::Debug>::fmt(p0, p1);
+<multiset::ZipSegment>::fmt(p0, p1);
-----------------
rope/src/multiset.rs <multiset::ZipIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::ZipIter<'a>
+p0.next();
+<multiset::ZipIter<'a> as std::iter::Iterator>::next(p0);
+crate::<multiset::ZipIter<'a> as std::iter::Iterator>::next(p0);
+<multiset::ZipIter<'a>>::next(p0);
-----------------
rope/src/multiset.rs multiset::Mapper::<'a>::doc_index_to_subset
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // multiset::Mapper<'a>
let mut p1 = 0usize; // None+usize
+p0.doc_index_to_subset(p1);
+multiset::Mapper::<'a>::doc_index_to_subset(p0, p1);
+crate::multiset::Mapper::<'a>::doc_index_to_subset(p0, p1);
+<multiset::Mapper<'a>>::doc_index_to_subset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::len
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.len();
+rope::<impl tree::Leaf for std::string::String>::len(p0);
+crate::rope::<impl tree::Leaf for std::string::String>::len(p0);
+<std::string::String>::len(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::is_ok_child
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.is_ok_child();
+rope::<impl tree::Leaf for std::string::String>::is_ok_child(p0);
+crate::rope::<impl tree::Leaf for std::string::String>::is_ok_child(p0);
+<std::string::String>::is_ok_child(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Leaf for std::string::String>::push_maybe_split
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = & std::string::String::new(); // None+std::string::String
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+rope::<impl tree::Leaf for std::string::String>::push_maybe_split(p0, p1, p2);
+crate::rope::<impl tree::Leaf for std::string::String>::push_maybe_split(p0, p1, p2);
+<std::string::String>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/rope.rs <rope::RopeInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
+p0.clone();
+<rope::RopeInfo as std::clone::Clone>::clone(p0);
+crate::<rope::RopeInfo as std::clone::Clone>::clone(p0);
+<rope::RopeInfo>::clone(p0);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::accumulate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
+p0.accumulate(p1);
+<rope::RopeInfo as tree::NodeInfo>::accumulate(p0, p1);
+crate::<rope::RopeInfo as tree::NodeInfo>::accumulate(p0, p1);
+<rope::RopeInfo>::accumulate(p0, p1);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::compute_info
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<rope::RopeInfo as tree::NodeInfo>::compute_info(p0);
+crate::<rope::RopeInfo as tree::NodeInfo>::compute_info(p0);
+<rope::RopeInfo>::compute_info(p0);
-----------------
rope/src/rope.rs <rope::RopeInfo as tree::NodeInfo>::identity
deps:{}
candidates:{}
+<rope::RopeInfo as tree::NodeInfo>::identity();
+crate::<rope::RopeInfo as tree::NodeInfo>::identity();
+<rope::RopeInfo>::identity();
-----------------
rope/src/rope.rs <rope::BaseMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::BaseMetric
+p0.clone();
+<rope::BaseMetric as std::clone::Clone>::clone(p0);
+crate::<rope::BaseMetric as std::clone::Clone>::clone(p0);
+<rope::BaseMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::BaseMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::BaseMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::BaseMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::BaseMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::BaseMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::BaseMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::BaseMetric>::can_fragment();
-----------------
rope/src/rope.rs <rope::LinesMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::LinesMetric
+p0.clone();
+<rope::LinesMetric as std::clone::Clone>::clone(p0);
+crate::<rope::LinesMetric as std::clone::Clone>::clone(p0);
+<rope::LinesMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::LinesMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::LinesMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::LinesMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::LinesMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::LinesMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::LinesMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::LinesMetric>::can_fragment();
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::Utf16CodeUnitsMetric
+p0.clone();
+<rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone(p0);
+crate::<rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone(p0);
+<rope::Utf16CodeUnitsMetric>::clone(p0);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // rope::RopeInfo
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure(p0, p1);
+<rope::Utf16CodeUnitsMetric>::measure(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary(p0, p1);
+<rope::Utf16CodeUnitsMetric>::is_boundary(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units(p0, p1);
+<rope::Utf16CodeUnitsMetric>::to_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units(p0, p1);
+<rope::Utf16CodeUnitsMetric>::from_base_units(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev(p0, p1);
+<rope::Utf16CodeUnitsMetric>::prev(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = 0usize; // None+usize
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next(p0, p1);
+<rope::Utf16CodeUnitsMetric>::next(p0, p1);
-----------------
rope/src/rope.rs <rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment
deps:{}
candidates:{}
+<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+crate::<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment();
+<rope::Utf16CodeUnitsMetric>::can_fragment();
-----------------
rope/src/rope.rs rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str(&p0);
+crate::rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str(&p0);
+<tree::Node<rope::RopeInfo>>::from_str(&p0);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::edit_str
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":{"T":["<T as interval::IntervalBounds>","std::ops::RangeFrom","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = "sample"; // None+&str
+p0.edit_str(p1, &p2);
+rope::<impl tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
+<tree::Node<rope::RopeInfo>>::edit_str(p0, p1, &p2);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::slice
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice":{"T":["std::ops::RangeFrom","std::ops::RangeFull","<T as interval::IntervalBounds>"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.slice(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::slice(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::slice(p0, p1);
+<tree::Node<rope::RopeInfo>>::slice(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.is_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::is_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.prev_codepoint_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::prev_codepoint_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.next_codepoint_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::next_codepoint_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.at_or_next_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.at_or_prev_codepoint_boundary(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
+<tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.prev_grapheme_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::prev_grapheme_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.next_grapheme_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::next_grapheme_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.line_of_offset(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
+<tree::Node<rope::RopeInfo>>::line_of_offset(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.offset_of_line(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
+<tree::Node<rope::RopeInfo>>::offset_of_line(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":{"T":["interval::IntervalBounds","std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":{"T":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.iter_chunks(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
+<tree::Node<rope::RopeInfo>>::iter_chunks(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::lines_raw
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":{"T":["std::marker::Sized","interval::IntervalBounds"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":{"T":["<T as interval::IntervalBounds>","std::ops::RangeFrom","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.lines_raw(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
+<tree::Node<rope::RopeInfo>>::lines_raw(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::lines
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines":{"T":["interval::IntervalBounds","std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::lines":{"T":["std::ops::RangeFull","<T as interval::IntervalBounds>","std::ops::RangeFrom"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.lines(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::lines(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::lines(p0, p1);
+<tree::Node<rope::RopeInfo>>::lines(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::byte_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = 0usize; // None+usize
+p0.byte_at(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
+<tree::Node<rope::RopeInfo>>::byte_at(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow
deps:{"<T as interval::IntervalBounds>":{"T":["std::marker::Sized","std::convert::Into"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":{"T":["interval::IntervalBounds","std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":{"T":["std::ops::RangeFrom","<T as interval::IntervalBounds>","std::ops::RangeFull"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.slice_to_cow(p1);
+rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
+crate::rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
+<tree::Node<rope::RopeInfo>>::slice_to_cow(p0, p1);
-----------------
rope/src/rope.rs <rope::ChunkIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::ChunkIter<'a>
+p0.next();
+<rope::ChunkIter<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::ChunkIter<'a> as std::iter::Iterator>::next(p0);
+<rope::ChunkIter<'a>>::next(p0);
-----------------
rope/src/rope.rs rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<rope::RopeInfo>
let mut p1 = "sample"; // None+&str
+p0.push_str(&p1);
+rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
+crate::rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
+<tree::TreeBuilder<rope::RopeInfo>>::push_str(p0, &p1);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":{"T":["std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":{"T":["std::borrow::Cow<'_, T>","std::rc::Rc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::slice::Iter<'_, T>","std::vec::Drain<'a, T, A>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>","<&T as std::convert::AsRef<U>>","<&mut T as std::convert::AsRef<U>>","std::ffi::CStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from(p0);
+crate::rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from(p0);
+<tree::Node<rope::RopeInfo>>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+crate::rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+<std::string::String>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+crate::rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from(p0);
+<std::string::String>::from(p0);
-----------------
rope/src/rope.rs rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+crate::rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+<tree::Node<rope::RopeInfo>>::fmt(p0, p1);
-----------------
rope/src/rope.rs rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+crate::rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt(p0, p1);
+<tree::Node<rope::RopeInfo>>::fmt(p0, p1);
-----------------
rope/src/rope.rs rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<rope::RopeInfo>
+p0.add(p1);
+rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add(p0, p1);
+crate::rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add(p0, p1);
+<tree::Node<rope::RopeInfo>>::add(p0, p1);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.prev_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.next_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::next_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.peek_next_codepoint();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.next_grapheme();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::next_grapheme(p0);
-----------------
rope/src/rope.rs rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, rope::RopeInfo>
+p0.prev_grapheme();
+rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
+crate::rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
+<tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme(p0);
-----------------
rope/src/rope.rs <rope::LinesRaw<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::LinesRaw<'a>
+p0.next();
+<rope::LinesRaw<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::LinesRaw<'a> as std::iter::Iterator>::next(p0);
+<rope::LinesRaw<'a>>::next(p0);
-----------------
rope/src/rope.rs <rope::Lines<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // rope::Lines<'a>
+p0.next();
+<rope::Lines<'a> as std::iter::Iterator>::next(p0);
+crate::<rope::Lines<'a> as std::iter::Iterator>::next(p0);
+<rope::Lines<'a>>::next(p0);
-----------------
rope/src/spans.rs <spans::Span<T> as std::clone::Clone>::clone
deps:{"<spans::Span<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<spans::Span<T> as std::clone::Clone>::clone":{"T":["tree::NodeBody","rope::Utf16CodeUnitsMetric","spans::Span","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeVal","find::CaseMatching","delta::InsertDelta","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksBaseMetric","rope::RopeInfo","engine::RevId","multiset::Segment","breaks::BreaksLeaf","spans::SpansInfo","engine::Error","rope::LinesMetric","diff::DiffOp","engine::Contents","multiset::Subset","engine::DeltaOp","interval::Interval","breaks::BreaksInfo","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["engine::RevId","diff::DiffBuilder","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","multiset::Segment","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::Span","engine::FullPriority","breaks::BreaksInfo","find::CaseMatching","rope::RopeInfo","delta::Delta","rope::LinesMetric","tree::NodeBody","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","diff::DiffOp","delta::InsertDelta","engine::Error","rope::BaseMetric","tree::NodeVal","multiset::Subset","spans::SpansInfo","tree::Node","multiset::CountMatcher","multiset::ZipSegment","interval::Interval","engine::Contents","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["delta::DeltaElement","engine::FullPriority","tree::NodeBody","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","breaks::BreaksMetric","tree::NodeVal","delta::Delta","rope::RopeInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","diff::DiffOp","breaks::BreaksLeaf","spans::SpansInfo","multiset::CountMatcher","multiset::Segment","spans::SpansLeaf","spans::Span","diff::DiffBuilder","rope::BaseMetric","multiset::ZipSegment","delta::InsertDelta","engine::RevId","rope::LinesMetric","engine::DeltaOp","engine::Contents","tree::Node","find::CaseMatching","multiset::Subset","breaks::BreaksBaseMetric"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","spans::SpansInfo","breaks::BreaksBaseMetric","engine::DeltaOp","breaks::BreaksMetric","diff::DiffOp","tree::NodeBody","rope::RopeInfo","multiset::Segment","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","delta::DeltaElement","breaks::BreaksInfo","tree::NodeVal","engine::FullPriority","diff::DiffBuilder","engine::RevId","delta::Delta","breaks::BreaksLeaf","spans::Span","delta::InsertDelta","interval::Interval","engine::Contents","engine::Error","find::CaseMatching","rope::LinesMetric","multiset::Subset","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::Span<T>
+p0.clone();
+<spans::Span<T> as std::clone::Clone>::clone(p0);
+crate::<spans::Span<T> as std::clone::Clone>::clone(p0);
+<spans::Span<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as std::clone::Clone>::clone
deps:{"<spans::SpansLeaf<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<spans::SpansLeaf<T> as std::clone::Clone>::clone":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","multiset::ZipSegment","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","find::CaseMatching","rope::BaseMetric","engine::FullPriority","spans::SpansInfo","tree::Node","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","breaks::BreaksBaseMetric","diff::DiffOp","multiset::CountMatcher","rope::LinesMetric","multiset::Segment","tree::NodeBody","interval::Interval","rope::RopeInfo","breaks::BreaksMetric","engine::RevId","tree::NodeVal","multiset::Subset","delta::DeltaElement","spans::SpansLeaf","spans::Span","engine::Error","diff::DiffBuilder","delta::Delta","engine::DeltaOp"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffOp","find::CaseMatching","tree::Node","engine::Contents","breaks::BreaksBaseMetric","multiset::Segment","interval::Interval","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","breaks::BreaksInfo","multiset::ZipSegment","rope::BaseMetric","rope::RopeInfo","delta::DeltaElement","diff::DiffBuilder","spans::SpansLeaf","delta::InsertDelta","tree::NodeBody","spans::Span","engine::DeltaOp","engine::Error","multiset::Subset","multiset::CountMatcher","breaks::BreaksLeaf","spans::SpansInfo","delta::Delta","engine::RevId","rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric"]},"spans::SpansInfo":{"T":["rope::BaseMetric","diff::DiffOp","rope::LinesMetric","multiset::CountMatcher","multiset::Subset","multiset::Segment","rope::RopeInfo","tree::NodeBody","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::DeltaElement","spans::SpansInfo","breaks::BreaksMetric","engine::RevId","interval::Interval","engine::Contents","spans::Span","breaks::BreaksInfo","tree::Node","tree::NodeVal","engine::DeltaOp","breaks::BreaksLeaf","delta::InsertDelta","delta::Delta","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::FullPriority","engine::Error","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","diff::DiffOp","multiset::CountMatcher","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","interval::Interval","rope::BaseMetric","spans::Span","tree::NodeVal","breaks::BreaksMetric","spans::SpansInfo","rope::RopeInfo","multiset::Segment","diff::DiffBuilder","find::CaseMatching","breaks::BreaksLeaf","breaks::BreaksBaseMetric","engine::DeltaOp","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::Node","multiset::ZipSegment","tree::NodeBody","engine::RevId","engine::Contents","multiset::Subset","engine::Error","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","breaks::BreaksInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.clone();
+<spans::SpansLeaf<T> as std::clone::Clone>::clone(p0);
+crate::<spans::SpansLeaf<T> as std::clone::Clone>::clone(p0);
+<spans::SpansLeaf<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as std::default::Default>::default
deps:{"<spans::SpansLeaf<T> as std::default::Default>::default":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"<spans::SpansLeaf<T> as std::default::Default>::default":{"T":["find::CaseMatching","rope::RopeInfo","rope::BaseMetric","breaks::BreaksInfo","breaks::BreaksMetric","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","diff::DiffOp","engine::FullPriority","diff::DiffBuilder","multiset::CountMatcher","engine::Contents","tree::NodeVal","delta::InsertDelta","delta::Delta","tree::NodeBody","engine::Error","spans::SpansInfo","engine::DeltaOp","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","breaks::BreaksBaseMetric","engine::RevId","spans::Span","multiset::Segment","rope::LinesMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","multiset::ZipSegment","interval::Interval"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::Segment","breaks::BreaksBaseMetric","spans::Span","rope::LinesMetric","rope::BaseMetric","multiset::Subset","interval::Interval","breaks::BreaksLeaf","engine::RevId","multiset::CountMatcher","engine::Contents","spans::SpansLeaf","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","rope::RopeInfo","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","find::CaseMatching","engine::DeltaOp","delta::DeltaElement","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::FullPriority","diff::DiffBuilder","delta::InsertDelta","tree::Node","tree::NodeBody","breaks::BreaksMetric","engine::Error","spans::SpansInfo"]},"spans::SpansInfo":{"T":["diff::DiffOp","breaks::BreaksMetric","engine::DeltaOp","tree::NodeVal","spans::Span","tree::NodeBody","multiset::Segment","spans::SpansLeaf","engine::Error","delta::DeltaElement","rope::LinesMetric","rope::BaseMetric","rope::RopeInfo","delta::Delta","engine::FullPriority","multiset::CountMatcher","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","diff::DiffBuilder","breaks::BreaksLeaf","tree::Node","breaks::BreaksBaseMetric","multiset::ZipSegment","engine::RevId","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","multiset::Subset","find::CaseMatching","spans::SpansInfo","interval::Interval"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","spans::Span","breaks::BreaksLeaf","breaks::BreaksBaseMetric","diff::DiffBuilder","multiset::ZipSegment","find::CaseMatching","tree::Node","engine::RevId","tree::NodeVal","delta::InsertDelta","diff::DiffOp","delta::Delta","multiset::Segment","multiset::CountMatcher","multiset::Subset","spans::SpansLeaf","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","engine::Error","tree::NodeBody","breaks::BreaksInfo","interval::Interval","engine::FullPriority","engine::DeltaOp","rope::LinesMetric","rope::RopeInfo","breaks::BreaksMetric","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
+<spans::SpansLeaf<T> as std::default::Default>::default();
+crate::<spans::SpansLeaf<T> as std::default::Default>::default();
+<spans::SpansLeaf<T>>::default();
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as std::clone::Clone>::clone
deps:{"<spans::SpansInfo<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<spans::SpansInfo<T> as std::clone::Clone>::clone":{"T":["delta::InsertDelta","multiset::Segment","breaks::BreaksInfo","multiset::Subset","rope::BaseMetric","diff::DiffBuilder","spans::SpansLeaf","engine::Error","delta::Delta","rope::RopeInfo","tree::NodeVal","tree::Node","engine::Contents","multiset::CountMatcher","interval::Interval","engine::DeltaOp","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","spans::Span","multiset::ZipSegment","breaks::BreaksMetric","find::CaseMatching","rope::Utf16CodeUnitsMetric","rope::LinesMetric","engine::RevId","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","diff::DiffOp","delta::DeltaElement","engine::FullPriority"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::InsertDelta","rope::LinesMetric","multiset::Subset","delta::Delta","spans::Span","breaks::BreaksMetric","rope::BaseMetric","multiset::CountMatcher","spans::SpansInfo","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","multiset::Segment","delta::DeltaElement","engine::FullPriority","interval::Interval","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","breaks::BreaksInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","tree::NodeVal","spans::SpansLeaf","engine::Contents","find::CaseMatching","multiset::ZipSegment","diff::DiffBuilder","engine::Error","tree::Node","tree::NodeBody"]},"spans::SpansInfo":{"T":["multiset::Segment","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","rope::RopeInfo","spans::Span","interval::Interval","tree::NodeVal","delta::InsertDelta","delta::Delta","rope::LinesMetric","engine::DeltaOp","breaks::BreaksInfo","breaks::BreaksMetric","multiset::ZipSegment","engine::Contents","tree::NodeBody","rope::BaseMetric","diff::DiffBuilder","engine::Error","delta::DeltaElement","engine::FullPriority","tree::Node","spans::SpansInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksLeaf","multiset::Subset","spans::SpansLeaf","diff::DiffOp","engine::RevId"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","engine::DeltaOp","spans::SpansLeaf","engine::Contents","delta::DeltaElement","rope::Utf16CodeUnitsMetric","rope::BaseMetric","delta::InsertDelta","spans::Span","engine::RevId","engine::FullPriority","spans::SpansInfo","multiset::CountMatcher","interval::Interval","breaks::BreaksBaseMetric","tree::NodeBody","rope::LinesMetric","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","rope::RopeInfo","diff::DiffBuilder","delta::Delta","multiset::Subset","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","breaks::BreaksMetric","diff::DiffOp","find::CaseMatching","breaks::BreaksInfo","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
+p0.clone();
+<spans::SpansInfo<T> as std::clone::Clone>::clone(p0);
+crate::<spans::SpansInfo<T> as std::clone::Clone>::clone(p0);
+<spans::SpansInfo<T>>::clone(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::len
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::len":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::len":{"T":["engine::RevId","engine::Error","tree::NodeBody","engine::FullPriority","spans::SpansLeaf","engine::DeltaOp","diff::DiffBuilder","delta::InsertDelta","find::CaseMatching","rope::RopeInfo","breaks::BreaksMetric","interval::Interval","spans::Span","tree::Node","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","spans::SpansInfo","breaks::BreaksInfo","tree::NodeVal","multiset::CountMatcher","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","breaks::BreaksLeaf","rope::BaseMetric","multiset::ZipSegment","delta::Delta","multiset::Subset","multiset::Segment"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["diff::DiffOp","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","spans::SpansLeaf","breaks::BreaksInfo","rope::RopeInfo","engine::FullPriority","tree::NodeVal","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","tree::Node","diff::DiffBuilder","engine::RevId","multiset::Subset","multiset::Segment","engine::Contents","find::CaseMatching","interval::Interval","spans::Span","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksLeaf","breaks::BreaksBaseMetric","tree::NodeBody","multiset::ZipSegment","engine::DeltaOp","rope::LinesMetric","spans::SpansInfo"]},"spans::SpansInfo":{"T":["engine::Contents","diff::DiffBuilder","tree::NodeVal","tree::Node","multiset::CountMatcher","multiset::Segment","breaks::BreaksMetric","interval::Interval","breaks::BreaksLeaf","delta::Delta","spans::SpansInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","delta::DeltaElement","rope::RopeInfo","spans::SpansLeaf","delta::InsertDelta","diff::DiffOp","rope::Utf16CodeUnitsMetric","rope::BaseMetric","engine::RevId","breaks::BreaksInfo","tree::NodeBody","breaks::BreaksBaseMetric","engine::FullPriority","spans::Span","rope::LinesMetric","engine::DeltaOp","multiset::ZipSegment","multiset::Subset"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","breaks::BreaksInfo","spans::SpansInfo","breaks::BreaksMetric","interval::Interval","diff::DiffOp","find::CaseMatching","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","rope::BaseMetric","spans::Span","multiset::Segment","engine::DeltaOp","delta::InsertDelta","tree::NodeVal","engine::Contents","rope::RopeInfo","multiset::CountMatcher","tree::NodeBody","multiset::Subset","engine::RevId","breaks::BreaksBaseMetric","engine::Error","delta::Delta","breaks::BreaksLeaf","rope::LinesMetric","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","diff::DiffBuilder","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.len();
+<spans::SpansLeaf<T> as tree::Leaf>::len(p0);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::len(p0);
+<spans::SpansLeaf<T>>::len(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::is_ok_child
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":{"T":["spans::SpansInfo","delta::DeltaElement","multiset::CountMatcher","diff::DiffOp","breaks::BreaksBaseMetric","rope::LinesMetric","breaks::BreaksInfo","multiset::ZipSegment","engine::RevId","find::CaseMatching","breaks::BreaksMetric","engine::Error","engine::DeltaOp","tree::NodeVal","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","rope::BaseMetric","multiset::Segment","multiset::Subset","interval::Interval","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","engine::Contents","engine::FullPriority","spans::SpansLeaf","delta::Delta","spans::Span","tree::NodeBody","delta::InsertDelta","rope::Utf16CodeUnitsMetric"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::CountMatcher","delta::Delta","multiset::Segment","breaks::BreaksMetric","find::CaseMatching","engine::RevId","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","spans::Span","multiset::Subset","multiset::ZipSegment","rope::RopeInfo","diff::DiffOp","breaks::BreaksBaseMetric","interval::Interval","diff::DiffBuilder","tree::Node","engine::Contents","spans::SpansLeaf","breaks::BreaksInfo","tree::NodeVal","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","rope::BaseMetric","delta::DeltaElement","engine::DeltaOp","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","engine::Error","tree::NodeBody"]},"spans::SpansInfo":{"T":["find::CaseMatching","tree::Node","breaks::BreaksInfo","rope::RopeInfo","breaks::BreaksMetric","multiset::ZipSegment","engine::Error","tree::NodeVal","breaks::BreaksLeaf","engine::Contents","tree::NodeBody","multiset::Segment","multiset::Subset","multiset::CountMatcher","engine::DeltaOp","breaks::BreaksBaseMetric","interval::Interval","delta::Delta","rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::RevId","spans::Span","rope::BaseMetric","delta::DeltaElement","engine::FullPriority","diff::DiffBuilder","spans::SpansInfo","rope::LinesMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp"]},"spans::SpansLeaf":{"T":["engine::Contents","find::CaseMatching","delta::Delta","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","tree::NodeVal","multiset::Subset","spans::SpansLeaf","engine::DeltaOp","engine::RevId","multiset::ZipSegment","tree::NodeBody","breaks::BreaksBaseMetric","engine::FullPriority","interval::Interval","diff::DiffOp","spans::Span","breaks::BreaksMetric","delta::DeltaElement","tree::Node","delta::InsertDelta","breaks::BreaksInfo","multiset::CountMatcher","diff::DiffBuilder","engine::Error","rope::RopeInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","spans::SpansInfo","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+p0.is_ok_child();
+<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child(p0);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child(p0);
+<spans::SpansLeaf<T>>::is_ok_child(p0);
-----------------
rope/src/spans.rs <spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split
deps:{"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":{"T":["std::marker::Sized","std::clone::Clone"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":{"T":["delta::DeltaElement","tree::NodeBody","multiset::Segment","breaks::BreaksLeaf","engine::Error","rope::BaseMetric","breaks::BreaksBaseMetric","delta::InsertDelta","engine::FullPriority","engine::DeltaOp","rope::RopeInfo","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","interval::Interval","breaks::BreaksInfo","engine::RevId","diff::DiffOp","multiset::Subset","rope::LinesMetric","delta::Delta","multiset::ZipSegment","breaks::BreaksMetric","diff::DiffBuilder","spans::Span","engine::Contents","find::CaseMatching","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","tree::Node","spans::SpansInfo"]},"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::FullPriority","delta::Delta","multiset::ZipSegment","rope::RopeInfo","diff::DiffOp","engine::DeltaOp","rope::LinesMetric","spans::SpansInfo","multiset::Segment","multiset::Subset","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","breaks::BreaksMetric","engine::RevId","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","interval::Interval","tree::Node","find::CaseMatching","tree::NodeBody","breaks::BreaksInfo","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","delta::InsertDelta","engine::Error","delta::DeltaElement","tree::NodeVal","engine::Contents","spans::Span"]},"spans::SpansInfo":{"T":["diff::DiffOp","tree::NodeVal","engine::RevId","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffBuilder","rope::RopeInfo","breaks::BreaksInfo","engine::Contents","spans::SpansLeaf","breaks::BreaksMetric","delta::DeltaElement","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","interval::Interval","rope::LinesMetric","find::CaseMatching","tree::NodeBody","engine::FullPriority","rope::BaseMetric","delta::Delta","spans::SpansInfo","tree::Node","engine::Error","multiset::Segment","engine::DeltaOp","delta::InsertDelta","breaks::BreaksLeaf","multiset::Subset","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","breaks::BreaksMetric","multiset::Subset","tree::NodeBody","tree::NodeVal","breaks::BreaksLeaf","diff::DiffBuilder","spans::SpansInfo","engine::RevId","delta::DeltaElement","engine::Contents","delta::InsertDelta","rope::Utf16CodeUnitsMetric","find::CaseMatching","breaks::BreaksBaseMetric","delta::Delta","breaks::BreaksInfo","rope::RopeInfo","multiset::CountMatcher","diff::DiffOp","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","engine::DeltaOp","engine::FullPriority","tree::Node","multiset::ZipSegment","rope::BaseMetric","spans::Span","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_maybe_split(p1, p2);
+<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split(p0, p1, p2);
+crate::<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split(p0, p1, p2);
+<spans::SpansLeaf<T>>::push_maybe_split(p0, p1, p2);
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as tree::NodeInfo>::accumulate
deps:{"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","delta::InsertDelta","tree::NodeBody","multiset::ZipSegment","breaks::BreaksMetric","tree::NodeVal","multiset::CountMatcher","rope::RopeInfo","engine::DeltaOp","multiset::Segment","breaks::BreaksBaseMetric","engine::FullPriority","tree::Node","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","rope::BaseMetric","spans::Span","rope::LinesMetric","engine::RevId","multiset::Subset","delta::Delta","rope::Utf16CodeUnitsMetric","engine::Contents","diff::DiffOp","diff::DiffBuilder","delta::DeltaElement","interval::Interval","engine::Error","spans::SpansInfo","spans::SpansLeaf"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksLeaf","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","interval::Interval","spans::SpansLeaf","diff::DiffBuilder","engine::Contents","breaks::BreaksBaseMetric","engine::RevId","engine::FullPriority","multiset::Subset","tree::NodeBody","breaks::BreaksMetric","tree::NodeVal","delta::DeltaElement","rope::LinesMetric","multiset::Segment","multiset::CountMatcher","delta::InsertDelta","engine::Error","breaks::BreaksInfo","spans::SpansInfo","rope::Utf16CodeUnitsMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","engine::DeltaOp","rope::BaseMetric","find::CaseMatching","tree::Node","delta::Delta","diff::DiffOp"]},"spans::SpansInfo":{"T":["tree::Node","tree::NodeBody","engine::FullPriority","rope::BaseMetric","engine::Contents","rope::Utf16CodeUnitsMetric","engine::DeltaOp","spans::SpansLeaf","engine::Error","delta::InsertDelta","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","breaks::BreaksInfo","multiset::Subset","rope::LinesMetric","multiset::Segment","multiset::ZipSegment","spans::Span","diff::DiffBuilder","breaks::BreaksMetric","rope::RopeInfo","delta::DeltaElement","diff::DiffOp","breaks::BreaksLeaf","delta::Delta","tree::NodeVal","interval::Interval","engine::RevId","find::CaseMatching","multiset::CountMatcher"]},"spans::SpansLeaf":{"T":["find::CaseMatching","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","engine::Error","breaks::BreaksLeaf","rope::RopeInfo","engine::RevId","rope::BaseMetric","tree::Node","multiset::Segment","tree::NodeBody","diff::DiffBuilder","multiset::Subset","tree::NodeVal","rope::LinesMetric","multiset::ZipSegment","delta::DeltaElement","breaks::BreaksInfo","engine::DeltaOp","diff::DiffOp","delta::Delta","spans::Span","spans::SpansLeaf","engine::FullPriority","breaks::BreaksMetric","multiset::CountMatcher","spans::SpansInfo","interval::Interval","rope::Utf16CodeUnitsMetric","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spans::SpansInfo<T>
+p0.accumulate(p1);
+<spans::SpansInfo<T> as tree::NodeInfo>::accumulate(p0, p1);
+crate::<spans::SpansInfo<T> as tree::NodeInfo>::accumulate(p0, p1);
+<spans::SpansInfo<T>>::accumulate(p0, p1);
-----------------
rope/src/spans.rs <spans::SpansInfo<T> as tree::NodeInfo>::compute_info
deps:{"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":{"T":["engine::FullPriority","breaks::BreaksLeaf","interval::Interval","spans::SpansInfo","delta::Delta","breaks::BreaksMetric","multiset::CountMatcher","delta::DeltaElement","engine::DeltaOp","spans::SpansLeaf","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","find::CaseMatching","multiset::Subset","multiset::Segment","diff::DiffOp","rope::Utf16CodeUnitsMetric","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","tree::Node","spans::Span","multiset::ZipSegment","engine::Error","engine::RevId","diff::DiffBuilder","rope::BaseMetric","rope::RopeInfo","rope::LinesMetric","breaks::BreaksInfo","tree::NodeBody"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["tree::NodeBody","breaks::BreaksMetric","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","breaks::BreaksBaseMetric","interval::Interval","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","engine::DeltaOp","rope::RopeInfo","find::CaseMatching","engine::Error","delta::DeltaElement","multiset::Segment","engine::FullPriority","rope::BaseMetric","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::RevId","diff::DiffBuilder","engine::Contents","spans::SpansInfo","spans::Span","multiset::Subset","spans::SpansLeaf","tree::Node","rope::LinesMetric","tree::NodeVal","breaks::BreaksInfo","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["spans::Span","find::CaseMatching","delta::InsertDelta","breaks::BreaksMetric","multiset::CountMatcher","delta::DeltaElement","rope::LinesMetric","engine::RevId","rope::Utf16CodeUnitsMetric","rope::RopeInfo","tree::NodeBody","tree::Node","breaks::BreaksLeaf","tree::NodeVal","spans::SpansLeaf","multiset::Segment","engine::Contents","breaks::BreaksBaseMetric","multiset::Subset","diff::DiffBuilder","diff::DiffOp","rope::BaseMetric","breaks::BreaksInfo","interval::Interval","engine::Error","engine::DeltaOp","engine::FullPriority","delta::Delta","multiset::ZipSegment","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"spans::SpansLeaf":{"T":["engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Contents","breaks::BreaksBaseMetric","multiset::CountMatcher","engine::FullPriority","interval::Interval","diff::DiffOp","rope::Utf16CodeUnitsMetric","spans::SpansInfo","delta::InsertDelta","spans::Span","engine::DeltaOp","engine::Error","tree::NodeBody","tree::NodeVal","spans::SpansLeaf","breaks::BreaksLeaf","rope::BaseMetric","find::CaseMatching","breaks::BreaksInfo","multiset::Segment","multiset::ZipSegment","delta::Delta","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","rope::RopeInfo","multiset::Subset","delta::DeltaElement","rope::LinesMetric","diff::DiffBuilder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spans::SpansLeaf<T>
+<spans::SpansInfo<T> as tree::NodeInfo>::compute_info(p0);
+crate::<spans::SpansInfo<T> as tree::NodeInfo>::compute_info(p0);
+<spans::SpansInfo<T>>::compute_info(p0);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::new
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansBuilder::<T>::new":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","rope::LinesMetric","breaks::BreaksInfo","delta::Delta","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","engine::DeltaOp","engine::Contents","engine::RevId","rope::BaseMetric","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","multiset::Subset","tree::Node","diff::DiffBuilder","spans::SpansInfo","tree::NodeVal","spans::Span","breaks::BreaksLeaf","interval::Interval","diff::DiffOp","delta::InsertDelta","rope::RopeInfo","engine::FullPriority","multiset::CountMatcher","multiset::Segment","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::Error"]},"spans::SpansBuilder::<T>::new":{"T":["engine::DeltaOp","rope::BaseMetric","delta::DeltaElement","engine::Error","find::CaseMatching","spans::Span","engine::FullPriority","delta::InsertDelta","diff::DiffOp","diff::DiffBuilder","breaks::BreaksInfo","multiset::Subset","multiset::Segment","rope::Utf16CodeUnitsMetric","spans::SpansInfo","tree::NodeBody","multiset::CountMatcher","tree::NodeVal","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","breaks::BreaksLeaf","engine::RevId","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","tree::Node","rope::RopeInfo","breaks::BreaksBaseMetric","spans::SpansLeaf","interval::Interval","delta::Delta"]},"spans::SpansInfo":{"T":["spans::SpansInfo","breaks::BreaksInfo","multiset::ZipSegment","diff::DiffOp","multiset::CountMatcher","rope::LinesMetric","spans::SpansLeaf","rope::BaseMetric","breaks::BreaksBaseMetric","tree::Node","spans::Span","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","tree::NodeVal","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","engine::DeltaOp","multiset::Segment","multiset::Subset","find::CaseMatching","delta::DeltaElement","engine::Contents","engine::RevId","tree::NodeBody","breaks::BreaksLeaf","diff::DiffBuilder","delta::InsertDelta","delta::Delta","interval::Interval","rope::RopeInfo"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","delta::Delta","breaks::BreaksLeaf","breaks::BreaksBaseMetric","engine::FullPriority","multiset::Subset","breaks::BreaksInfo","rope::BaseMetric","engine::Contents","tree::Node","breaks::BreaksMetric","multiset::Segment","engine::DeltaOp","tree::NodeBody","multiset::CountMatcher","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::RevId","spans::SpansInfo","tree::NodeVal","delta::DeltaElement","spans::Span","diff::DiffOp","engine::Error","rope::LinesMetric","delta::InsertDelta","interval::Interval","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = 0usize; // None+usize
+spans::SpansBuilder::<T>::new(p0);
+crate::spans::SpansBuilder::<T>::new(p0);
+<spans::SpansBuilder<T>>::new(p0);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::add_span
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansBuilder::<T>::add_span":{"IV":["std::marker::Sized","interval::IntervalBounds"],"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["spans::Span","rope::LinesMetric","multiset::ZipSegment","engine::DeltaOp","breaks::BreaksMetric","spans::SpansInfo","multiset::CountMatcher","delta::Delta","rope::BaseMetric","delta::InsertDelta","tree::NodeBody","engine::Error","tree::Node","breaks::BreaksLeaf","engine::RevId","multiset::Subset","rope::RopeInfo","tree::NodeVal","engine::FullPriority","delta::DeltaElement","rope::Utf16CodeUnitsMetric","interval::Interval","engine::Contents","diff::DiffOp","breaks::BreaksInfo","multiset::Segment","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","find::CaseMatching","diff::DiffBuilder"]},"spans::SpansBuilder::<T>::add_span":{"IV":["std::ops::RangeFull","std::ops::RangeFrom","<T as interval::IntervalBounds>"],"T":["std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf","rope::BaseMetric","tree::NodeVal","multiset::Subset","spans::SpansLeaf","multiset::Segment","diff::DiffOp","engine::Contents","delta::DeltaElement","spans::SpansInfo","tree::Node","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","interval::Interval","breaks::BreaksBaseMetric","spans::Span","breaks::BreaksInfo","diff::DiffBuilder","delta::Delta","find::CaseMatching","rope::RopeInfo","breaks::BreaksMetric","delta::InsertDelta","engine::DeltaOp","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::RevId","engine::Error","tree::NodeBody"]},"spans::SpansInfo":{"T":["find::CaseMatching","engine::DeltaOp","tree::NodeBody","multiset::Segment","diff::DiffBuilder","breaks::BreaksBaseMetric","rope::RopeInfo","engine::RevId","multiset::Subset","tree::Node","multiset::ZipSegment","spans::Span","breaks::BreaksInfo","interval::Interval","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Error","engine::FullPriority","spans::SpansLeaf","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","delta::InsertDelta","diff::DiffOp","rope::LinesMetric","breaks::BreaksLeaf","tree::NodeVal","delta::Delta","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","multiset::Segment","engine::Error","delta::DeltaElement","rope::Utf16CodeUnitsMetric","rope::RopeInfo","multiset::CountMatcher","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","find::CaseMatching","engine::FullPriority","tree::Node","tree::NodeVal","rope::LinesMetric","delta::InsertDelta","rope::BaseMetric","engine::Contents","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","spans::Span","breaks::BreaksLeaf","multiset::Subset","engine::RevId","interval::Interval","delta::Delta","breaks::BreaksBaseMetric","breaks::BreaksInfo","tree::NodeBody","spans::SpansLeaf","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpansBuilder<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // IV
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.add_span(p1, p2);
+spans::SpansBuilder::<T>::add_span(p0, p1, p2);
+crate::spans::SpansBuilder::<T>::add_span(p0, p1, p2);
+<spans::SpansBuilder<T>>::add_span(p0, p1, p2);
-----------------
rope/src/spans.rs spans::SpansBuilder::<T>::build
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansBuilder::<T>::build":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","delta::Delta","engine::RevId","rope::BaseMetric","rope::RopeInfo","spans::SpansInfo","delta::DeltaElement","engine::DeltaOp","tree::Node","tree::NodeVal","tree::NodeBody","breaks::BreaksMetric","interval::Interval","find::CaseMatching","multiset::Subset","breaks::BreaksInfo","engine::FullPriority","engine::Error","breaks::BreaksLeaf","engine::Contents","multiset::CountMatcher","diff::DiffBuilder","rope::LinesMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","spans::Span","spans::SpansLeaf"]},"spans::SpansBuilder::<T>::build":{"T":["breaks::BreaksInfo","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","interval::Interval","find::CaseMatching","spans::SpansLeaf","rope::RopeInfo","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","engine::FullPriority","delta::Delta","rope::BaseMetric","rope::LinesMetric","engine::DeltaOp","tree::Node","engine::Error","breaks::BreaksLeaf","spans::SpansInfo","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::InsertDelta","engine::RevId","tree::NodeBody","multiset::CountMatcher","breaks::BreaksMetric","breaks::BreaksBaseMetric","engine::Contents","multiset::Subset","tree::NodeVal"]},"spans::SpansInfo":{"T":["engine::Error","engine::FullPriority","spans::SpansInfo","breaks::BreaksMetric","spans::Span","find::CaseMatching","multiset::CountMatcher","interval::Interval","breaks::BreaksBaseMetric","engine::Contents","multiset::Segment","rope::BaseMetric","delta::DeltaElement","tree::NodeBody","tree::Node","diff::DiffOp","breaks::BreaksLeaf","multiset::Subset","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","delta::InsertDelta","tree::NodeVal","engine::RevId","engine::DeltaOp","rope::RopeInfo","rope::LinesMetric","diff::DiffBuilder","delta::Delta","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","delta::Delta","engine::RevId","rope::BaseMetric","engine::Contents","diff::DiffOp","engine::Error","tree::NodeBody","spans::SpansInfo","spans::Span","rope::RopeInfo","multiset::CountMatcher","spans::SpansLeaf","engine::FullPriority","rope::LinesMetric","interval::Interval","multiset::ZipSegment","engine::DeltaOp","delta::DeltaElement","breaks::BreaksBaseMetric","find::CaseMatching","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","breaks::BreaksInfo","multiset::Segment","rope::Utf16CodeUnitsMetric","multiset::Subset","diff::DiffBuilder","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // spans::SpansBuilder<T>
+p0.build();
+spans::SpansBuilder::<T>::build(p0);
+crate::spans::SpansBuilder::<T>::build(p0);
+<spans::SpansBuilder<T>>::build(p0);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::transform
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":{"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"T":["multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","find::CaseMatching","tree::Node","rope::LinesMetric","engine::DeltaOp","breaks::BreaksBaseMetric","engine::FullPriority","engine::Contents","breaks::BreaksMetric","multiset::Subset","rope::BaseMetric","delta::InsertDelta","diff::DiffBuilder","tree::NodeBody","breaks::BreaksLeaf","multiset::ZipSegment","spans::SpansInfo","interval::Interval","diff::DiffOp","spans::SpansLeaf","delta::DeltaElement","tree::NodeVal","engine::RevId","spans::Span","multiset::Segment","rope::Utf16CodeUnitsMetric","rope::RopeInfo","breaks::BreaksInfo","delta::Delta"]},"spans::Span":{"T":["spans::SpansInfo","tree::Node","engine::DeltaOp","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","breaks::BreaksMetric","multiset::Subset","rope::RopeInfo","tree::NodeVal","engine::RevId","interval::Interval","find::CaseMatching","diff::DiffOp","breaks::BreaksInfo","engine::Error","breaks::BreaksLeaf","multiset::CountMatcher","tree::NodeBody","engine::Contents","engine::FullPriority","spans::Span","rope::LinesMetric","diff::DiffBuilder","multiset::Segment","delta::InsertDelta","breaks::BreaksBaseMetric","delta::Delta","delta::DeltaElement","rope::BaseMetric"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","rope::BaseMetric","spans::SpansLeaf","interval::Interval","rope::Utf16CodeUnitsMetric","diff::DiffOp","breaks::BreaksMetric","tree::Node","multiset::Subset","rope::LinesMetric","engine::FullPriority","delta::InsertDelta","breaks::BreaksBaseMetric","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","diff::DiffBuilder","engine::DeltaOp","spans::Span","rope::RopeInfo","tree::NodeBody","multiset::Segment","spans::SpansInfo","delta::DeltaElement","engine::Contents","tree::NodeVal","multiset::CountMatcher","multiset::ZipSegment","delta::Delta","engine::RevId","find::CaseMatching"]},"spans::SpansLeaf":{"T":["engine::Contents","multiset::CountMatcher","tree::NodeBody","breaks::BreaksBaseMetric","spans::SpansInfo","breaks::BreaksInfo","delta::DeltaElement","tree::Node","spans::Span","diff::DiffBuilder","multiset::Segment","rope::RopeInfo","multiset::Subset","engine::FullPriority","tree::NodeVal","engine::Error","breaks::BreaksMetric","spans::SpansLeaf","engine::DeltaOp","rope::BaseMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","delta::Delta","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::LinesMetric","interval::Interval","delta::InsertDelta","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // delta::Transformer<'_, N>
+p0.transform(p1, p2, p3);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
+<tree::Node<spans::SpansInfo<T>>>::transform(p0, p1, p2, p3);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::merge
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":{"F":["std::ops::FnMut","std::marker::Sized"],"O":["std::marker::Sized","std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"],"O":["engine::RevId","tree::NodeBody","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","engine::Contents","multiset::Segment","breaks::BreaksBaseMetric","engine::Error","rope::RopeInfo","diff::DiffOp","delta::DeltaElement","engine::DeltaOp","multiset::CountMatcher","multiset::Subset","tree::Node","multiset::ZipSegment","breaks::BreaksLeaf","spans::SpansLeaf","diff::DiffBuilder","delta::Delta","spans::Span","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","tree::NodeVal","rope::LinesMetric","spans::SpansInfo","rope::BaseMetric","engine::FullPriority"],"T":["breaks::BreaksLeaf","engine::FullPriority","delta::Delta","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","rope::RopeInfo","spans::SpansLeaf","engine::Error","engine::DeltaOp","tree::NodeBody","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffOp","multiset::Segment","rope::LinesMetric","multiset::CountMatcher","spans::Span","interval::Interval","tree::Node","spans::SpansInfo","multiset::Subset","rope::BaseMetric","tree::NodeVal","breaks::BreaksBaseMetric","find::CaseMatching","engine::RevId","delta::DeltaElement","breaks::BreaksMetric","engine::Contents","delta::InsertDelta","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::DeltaOp","multiset::Segment","breaks::BreaksMetric","multiset::CountMatcher","spans::Span","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","delta::DeltaElement","rope::Utf16CodeUnitsMetric","engine::Error","diff::DiffOp","rope::BaseMetric","delta::InsertDelta","rope::LinesMetric","delta::Delta","breaks::BreaksLeaf","rope::RopeInfo","breaks::BreaksBaseMetric","spans::SpansLeaf","tree::Node","multiset::Subset","engine::FullPriority","find::CaseMatching","tree::NodeVal","interval::Interval","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","engine::RevId","tree::NodeBody","diff::DiffBuilder","spans::SpansInfo"]},"spans::SpansInfo":{"T":["delta::DeltaElement","engine::DeltaOp","diff::DiffOp","breaks::BreaksInfo","engine::FullPriority","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeBody","breaks::BreaksLeaf","multiset::Subset","find::CaseMatching","delta::Delta","engine::Error","multiset::Segment","breaks::BreaksMetric","spans::Span","interval::Interval","tree::Node","rope::RopeInfo","breaks::BreaksBaseMetric","rope::BaseMetric","spans::SpansInfo","delta::InsertDelta","multiset::ZipSegment","multiset::CountMatcher","engine::Contents","rope::LinesMetric","rope::Utf16CodeUnitsMetric","tree::NodeVal","diff::DiffBuilder","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","delta::InsertDelta","tree::NodeVal","spans::SpansInfo","diff::DiffOp","interval::Interval","spans::SpansLeaf","delta::Delta","breaks::BreaksMetric","breaks::BreaksLeaf","engine::RevId","multiset::Subset","engine::FullPriority","engine::Error","diff::DiffBuilder","spans::Span","breaks::BreaksInfo","rope::LinesMetric","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::Segment","tree::Node","delta::DeltaElement","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeBody","rope::BaseMetric","rope::RopeInfo","breaks::BreaksBaseMetric","engine::Contents","find::CaseMatching"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+p0.merge(p1, p2);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
+<tree::Node<spans::SpansInfo<T>>>::merge(p0, p1, p2);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::iter
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::ZipSegment","interval::Interval","spans::Span","rope::RopeInfo","delta::InsertDelta","rope::BaseMetric","engine::DeltaOp","diff::DiffBuilder","multiset::Subset","engine::Contents","tree::NodeBody","spans::SpansInfo","multiset::Segment","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::FullPriority","multiset::CountMatcher","delta::Delta","tree::Node","breaks::BreaksMetric","diff::DiffOp","breaks::BreaksLeaf","spans::SpansLeaf","engine::RevId","delta::DeltaElement","engine::Error","rope::Utf16CodeUnitsMetric","find::CaseMatching","tree::NodeVal"]},"spans::Span":{"T":["rope::BaseMetric","multiset::Subset","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::DeltaOp","spans::SpansLeaf","tree::Node","engine::FullPriority","diff::DiffBuilder","diff::DiffOp","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","engine::RevId","breaks::BreaksLeaf","spans::Span","delta::Delta","delta::InsertDelta","multiset::CountMatcher","engine::Contents","breaks::BreaksInfo","breaks::BreaksMetric","rope::LinesMetric","engine::Error","spans::SpansInfo","breaks::BreaksBaseMetric","delta::DeltaElement","tree::NodeVal","tree::NodeBody","find::CaseMatching","multiset::ZipSegment","rope::RopeInfo"]},"spans::SpansInfo":{"T":["rope::BaseMetric","tree::NodeVal","rope::LinesMetric","spans::SpansInfo","spans::Span","breaks::BreaksBaseMetric","diff::DiffOp","rope::RopeInfo","multiset::Subset","breaks::BreaksMetric","interval::Interval","engine::Contents","breaks::BreaksInfo","delta::InsertDelta","tree::Node","engine::Error","engine::RevId","rope::Utf16CodeUnitsMetric","find::CaseMatching","multiset::CountMatcher","delta::Delta","breaks::BreaksLeaf","multiset::ZipSegment","spans::SpansLeaf","engine::FullPriority","delta::DeltaElement","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Segment","tree::NodeBody","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","spans::SpansLeaf","breaks::BreaksMetric","multiset::ZipSegment","engine::FullPriority","spans::Span","delta::InsertDelta","engine::Error","multiset::CountMatcher","tree::NodeVal","breaks::BreaksLeaf","delta::DeltaElement","multiset::Subset","diff::DiffBuilder","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","engine::Contents","interval::Interval","engine::DeltaOp","rope::LinesMetric","multiset::Segment","find::CaseMatching","tree::Node","diff::DiffOp","tree::NodeBody","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
+p0.iter();
+spans::<impl tree::Node<spans::SpansInfo<T>>>::iter(p0);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::iter(p0);
+<tree::Node<spans::SpansInfo<T>>>::iter(p0);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":{"M":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":{"M":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"],"T":["spans::SpansLeaf","tree::NodeVal","multiset::Subset","multiset::Segment","spans::Span","rope::RopeInfo","delta::InsertDelta","engine::RevId","tree::Node","rope::BaseMetric","multiset::ZipSegment","breaks::BreaksInfo","interval::Interval","multiset::CountMatcher","engine::Error","spans::SpansInfo","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","rope::LinesMetric","delta::DeltaElement","engine::DeltaOp","diff::DiffOp","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","delta::Delta","rope::Utf16CodeUnitsMetric","find::CaseMatching","engine::Contents","breaks::BreaksMetric","diff::DiffBuilder"]},"spans::Span":{"T":["tree::NodeBody","rope::Utf16CodeUnitsMetric","find::CaseMatching","engine::FullPriority","engine::Contents","delta::DeltaElement","engine::Error","breaks::BreaksBaseMetric","multiset::CountMatcher","tree::NodeVal","rope::LinesMetric","multiset::ZipSegment","engine::RevId","rope::RopeInfo","engine::DeltaOp","spans::SpansLeaf","delta::Delta","spans::SpansInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","interval::Interval","tree::Node","breaks::BreaksMetric","breaks::BreaksInfo","multiset::Subset","rope::BaseMetric","multiset::Segment","diff::DiffOp","diff::DiffBuilder","delta::InsertDelta","spans::Span"]},"spans::SpansInfo":{"T":["delta::Delta","spans::Span","rope::RopeInfo","diff::DiffBuilder","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","engine::FullPriority","engine::Contents","tree::Node","diff::DiffOp","engine::DeltaOp","delta::DeltaElement","tree::NodeVal","multiset::Segment","find::CaseMatching","multiset::Subset","spans::SpansLeaf","breaks::BreaksLeaf","breaks::BreaksBaseMetric","rope::BaseMetric","multiset::ZipSegment","tree::NodeBody","breaks::BreaksMetric","rope::LinesMetric","spans::SpansInfo","interval::Interval","engine::RevId","breaks::BreaksInfo","engine::Error"]},"spans::SpansLeaf":{"T":["interval::Interval","engine::Error","tree::NodeVal","diff::DiffBuilder","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","rope::RopeInfo","engine::RevId","multiset::ZipSegment","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","engine::Contents","diff::DiffOp","tree::Node","breaks::BreaksLeaf","delta::Delta","breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::FullPriority","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","multiset::Segment","delta::InsertDelta","engine::DeltaOp","spans::Span","spans::SpansInfo","multiset::CountMatcher","spans::SpansLeaf","rope::BaseMetric","multiset::Subset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = & MaybeUninit::uninit().assume_init(); // delta::Delta<M>
+p0.apply_shape(p1);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::apply_shape(p0, p1);
-----------------
rope/src/spans.rs spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":{"T":["tree::NodeBody","delta::Delta","find::CaseMatching","multiset::Segment","rope::LinesMetric","diff::DiffOp","breaks::BreaksInfo","delta::DeltaElement","spans::Span","multiset::CountMatcher","engine::RevId","engine::DeltaOp","engine::FullPriority","tree::Node","breaks::BreaksLeaf","interval::Interval","breaks::BreaksBaseMetric","spans::SpansInfo","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","multiset::ZipSegment","breaks::BreaksMetric","tree::NodeVal","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::Subset","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric","engine::Error","diff::DiffBuilder"]},"spans::Span":{"T":["tree::NodeVal","delta::DeltaElement","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::Subset","rope::LinesMetric","diff::DiffOp","breaks::BreaksMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","delta::Delta","engine::RevId","engine::FullPriority","spans::SpansInfo","diff::DiffBuilder","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","multiset::CountMatcher","multiset::ZipSegment","rope::RopeInfo","breaks::BreaksLeaf","spans::Span","find::CaseMatching","rope::BaseMetric","engine::Contents","breaks::BreaksBaseMetric","tree::NodeBody","spans::SpansLeaf","tree::Node","delta::InsertDelta"]},"spans::SpansInfo":{"T":["tree::NodeBody","diff::DiffOp","spans::Span","delta::DeltaElement","multiset::Segment","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksInfo","interval::Interval","multiset::ZipSegment","engine::RevId","breaks::BreaksMetric","diff::DiffBuilder","rope::LinesMetric","spans::SpansLeaf","delta::InsertDelta","find::CaseMatching","engine::DeltaOp","multiset::Subset","spans::SpansInfo","rope::BaseMetric","breaks::BreaksLeaf","rope::RopeInfo","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","tree::Node","breaks::BreaksBaseMetric","engine::FullPriority","engine::Contents","engine::Error","tree::NodeVal"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","rope::LinesMetric","multiset::CountMatcher","rope::RopeInfo","multiset::ZipSegment","delta::Delta","rope::BaseMetric","spans::SpansInfo","engine::RevId","tree::Node","delta::DeltaElement","multiset::Segment","spans::SpansLeaf","delta::InsertDelta","tree::NodeBody","engine::Error","diff::DiffOp","spans::Span","engine::DeltaOp","engine::FullPriority","find::CaseMatching","breaks::BreaksInfo","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","multiset::Subset","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksBaseMetric","breaks::BreaksMetric","breaks::BreaksLeaf","tree::NodeVal"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.delete_after(p1);
+spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
+crate::spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::delete_after(p0, p1);
-----------------
rope/src/spans.rs spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":{"T":["multiset::CountMatcher","delta::Delta","<*const T as std::fmt::Debug>","<*mut T as std::fmt::Debug>","multiset::Segment","engine::Contents","engine::DeltaOp","breaks::BreaksInfo","engine::RevId","engine::Error","diff::DiffOp","interval::Interval","delta::InsertDelta","diff::DiffBuilder","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","breaks::BreaksLeaf"]},"spans::Span":{"T":["spans::SpansLeaf","multiset::Subset","tree::NodeBody","breaks::BreaksInfo","rope::LinesMetric","diff::DiffOp","interval::Interval","breaks::BreaksMetric","spans::Span","engine::RevId","delta::Delta","engine::DeltaOp","spans::SpansInfo","engine::FullPriority","multiset::ZipSegment","tree::Node","breaks::BreaksLeaf","delta::DeltaElement","multiset::CountMatcher","tree::NodeVal","breaks::BreaksBaseMetric","rope::RopeInfo","engine::Error","find::CaseMatching","diff::DiffBuilder","delta::InsertDelta","multiset::Segment","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","rope::BaseMetric"]},"spans::SpansInfo":{"T":["rope::LinesMetric","tree::Node","breaks::BreaksLeaf","multiset::CountMatcher","find::CaseMatching","spans::SpansInfo","tree::NodeVal","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","multiset::Segment","interval::Interval","rope::RopeInfo","multiset::ZipSegment","spans::Span","breaks::BreaksMetric","delta::Delta","rope::BaseMetric","multiset::Subset","engine::RevId","tree::NodeBody","delta::InsertDelta","delta::DeltaElement","engine::Contents","diff::DiffOp","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","spans::SpansLeaf","engine::DeltaOp","engine::FullPriority","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","multiset::ZipSegment","multiset::Subset","tree::NodeVal","rope::LinesMetric","engine::Contents","engine::Error","multiset::CountMatcher","diff::DiffOp","delta::DeltaElement","engine::DeltaOp","find::CaseMatching","spans::SpansLeaf","delta::Delta","breaks::BreaksMetric","interval::Interval","tree::Node","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","diff::DiffBuilder","multiset::Segment","spans::SpansInfo","breaks::BreaksInfo","engine::FullPriority","rope::BaseMetric","breaks::BreaksLeaf","spans::Span","rope::RopeInfo","tree::NodeBody","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<spans::SpansInfo<T>>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
+crate::spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
+<tree::Node<spans::SpansInfo<T>>>::fmt(p0, p1);
-----------------
rope/src/spans.rs <spans::SpanIter<'a, T> as std::iter::Iterator>::next
'a
deps:{"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":{"T":["std::clone::Clone","std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":{"T":["rope::BaseMetric","engine::FullPriority","breaks::BreaksLeaf","engine::DeltaOp","multiset::ZipSegment","engine::RevId","multiset::Subset","breaks::BreaksInfo","spans::Span","rope::RopeInfo","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksMetric","find::CaseMatching","engine::Contents","interval::Interval","multiset::CountMatcher","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","tree::Node","spans::SpansLeaf","tree::NodeBody","engine::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","breaks::BreaksBaseMetric","multiset::Segment","rope::Utf16CodeUnitsMetric","diff::DiffOp","spans::SpansInfo","delta::Delta"]},"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansLeaf","engine::Contents","rope::BaseMetric","breaks::BreaksInfo","spans::Span","tree::NodeVal","rope::LinesMetric","multiset::ZipSegment","breaks::BreaksBaseMetric","diff::DiffBuilder","delta::Delta","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","tree::Node","delta::InsertDelta","spans::SpansInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","engine::Error","engine::DeltaOp","multiset::Subset","interval::Interval","engine::RevId","find::CaseMatching","delta::DeltaElement","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","rope::RopeInfo","breaks::BreaksMetric","multiset::Segment"]},"spans::SpansInfo":{"T":["rope::BaseMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","engine::DeltaOp","engine::FullPriority","find::CaseMatching","breaks::BreaksBaseMetric","engine::Error","engine::Contents","spans::SpansLeaf","interval::Interval","tree::NodeBody","rope::RopeInfo","breaks::BreaksLeaf","diff::DiffOp","spans::SpansInfo","multiset::ZipSegment","engine::RevId","delta::InsertDelta","tree::NodeVal","delta::DeltaElement","breaks::BreaksInfo","multiset::CountMatcher","rope::LinesMetric","rope::Utf16CodeUnitsMetric","multiset::Subset","multiset::Segment","delta::Delta","spans::Span","breaks::BreaksMetric","tree::Node"]},"spans::SpansLeaf":{"T":["engine::Error","delta::DeltaElement","breaks::BreaksBaseMetric","breaks::BreaksMetric","delta::Delta","multiset::Segment","diff::DiffBuilder","rope::RopeInfo","tree::NodeBody","engine::RevId","diff::DiffOp","engine::Contents","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","breaks::BreaksInfo","tree::NodeVal","multiset::Subset","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","rope::LinesMetric","find::CaseMatching","breaks::BreaksLeaf","spans::Span","multiset::ZipSegment","engine::DeltaOp","spans::SpansInfo","engine::FullPriority","interval::Interval","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spans::SpanIter<'a, T>
+p0.next();
+<spans::SpanIter<'a, T> as std::iter::Iterator>::next(p0);
+crate::<spans::SpanIter<'a, T> as std::iter::Iterator>::next(p0);
+<spans::SpanIter<'a, T>>::next(p0);
-----------------
rope/src/tree.rs <tree::Node<N> as std::clone::Clone>::clone
deps:{"<tree::Node<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<tree::Node<N> as std::clone::Clone>::clone":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","interval::Interval","multiset::CountMatcher","diff::DiffOp","rope::BaseMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","tree::Node","multiset::ZipSegment","spans::SpansLeaf","engine::Error","multiset::Subset","breaks::BreaksMetric","delta::Delta","rope::RopeInfo","tree::NodeVal","tree::NodeBody","diff::DiffBuilder","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::DeltaOp","rope::LinesMetric","find::CaseMatching","engine::Contents","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","delta::DeltaElement","engine::FullPriority","delta::InsertDelta","engine::RevId"]},"spans::SpansInfo":{"T":["multiset::ZipSegment","rope::LinesMetric","rope::RopeInfo","delta::InsertDelta","breaks::BreaksLeaf","engine::RevId","multiset::CountMatcher","spans::SpansInfo","diff::DiffBuilder","spans::Span","tree::NodeBody","delta::Delta","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksInfo","tree::Node","breaks::BreaksBaseMetric","multiset::Segment","rope::BaseMetric","interval::Interval","multiset::Subset","spans::SpansLeaf","find::CaseMatching","engine::Contents","delta::DeltaElement","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffOp","engine::DeltaOp","engine::Error","tree::NodeVal"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","breaks::BreaksBaseMetric","breaks::BreaksInfo","diff::DiffOp","find::CaseMatching","engine::Contents","engine::RevId","multiset::Subset","multiset::Segment","rope::RopeInfo","spans::Span","rope::Utf16CodeUnitsMetric","delta::DeltaElement","breaks::BreaksMetric","diff::DiffBuilder","engine::FullPriority","multiset::ZipSegment","delta::InsertDelta","spans::SpansInfo","tree::NodeBody","tree::NodeVal","breaks::BreaksLeaf","engine::Error","rope::LinesMetric","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","tree::Node","engine::DeltaOp","delta::Delta","multiset::CountMatcher"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.clone();
+<tree::Node<N> as std::clone::Clone>::clone(p0);
+crate::<tree::Node<N> as std::clone::Clone>::clone(p0);
+<tree::Node<N>>::clone(p0);
-----------------
rope/src/tree.rs <tree::NodeBody<N> as std::clone::Clone>::clone
deps:{"<tree::NodeBody<N> as std::clone::Clone>::clone":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<tree::NodeBody<N> as std::clone::Clone>::clone":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["rope::RopeInfo","multiset::Segment","multiset::ZipSegment","find::CaseMatching","rope::BaseMetric","spans::SpansInfo","delta::Delta","interval::Interval","rope::LinesMetric","breaks::BreaksLeaf","multiset::CountMatcher","tree::NodeBody","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","engine::Contents","engine::DeltaOp","engine::RevId","spans::SpansLeaf","diff::DiffBuilder","tree::NodeVal","tree::Node","spans::Span","delta::InsertDelta","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","breaks::BreaksMetric","multiset::Subset","engine::FullPriority","delta::DeltaElement"]},"spans::SpansInfo":{"T":["tree::NodeBody","breaks::BreaksInfo","delta::InsertDelta","multiset::ZipSegment","multiset::Segment","multiset::Subset","engine::RevId","interval::Interval","breaks::BreaksLeaf","tree::Node","find::CaseMatching","delta::DeltaElement","spans::SpansLeaf","tree::NodeVal","spans::Span","engine::Error","engine::FullPriority","rope::Utf16CodeUnitsMetric","engine::Contents","rope::RopeInfo","diff::DiffOp","engine::DeltaOp","delta::Delta","diff::DiffBuilder","spans::SpansInfo","rope::BaseMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","breaks::BreaksBaseMetric","diff::DiffBuilder","multiset::Subset","delta::Delta","multiset::ZipSegment","multiset::CountMatcher","delta::InsertDelta","interval::Interval","rope::RopeInfo","engine::Error","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","tree::Node","tree::NodeVal","rope::LinesMetric","engine::FullPriority","tree::NodeBody","delta::DeltaElement","find::CaseMatching","spans::SpansLeaf","engine::RevId","breaks::BreaksLeaf","engine::DeltaOp","breaks::BreaksInfo","spans::Span","multiset::Segment","breaks::BreaksMetric","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::NodeBody<N>
+p0.clone();
+<tree::NodeBody<N> as std::clone::Clone>::clone(p0);
+crate::<tree::NodeBody<N> as std::clone::Clone>::clone(p0);
+<tree::NodeBody<N>>::clone(p0);
-----------------
rope/src/tree.rs <tree::NodeVal<N> as std::clone::Clone>::clone
deps:{"<tree::NodeVal<N> as std::clone::Clone>::clone":{"<N as tree::NodeInfo>::L":["std::clone::Clone"],"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<tree::NodeVal<N> as std::clone::Clone>::clone":{"<N as tree::NodeInfo>::L":["rope::RopeInfo","multiset::Subset","delta::Delta","interval::Interval","breaks::BreaksInfo","diff::DiffBuilder","engine::RevId","find::CaseMatching","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","spans::SpansInfo","multiset::ZipSegment","tree::Node","delta::DeltaElement","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta","rope::LinesMetric","multiset::Segment","engine::FullPriority","rope::BaseMetric","spans::Span","tree::NodeBody","diff::DiffOp","breaks::BreaksLeaf","breaks::BreaksMetric","engine::Error","engine::Contents","engine::DeltaOp","tree::NodeVal","breaks::BreaksBaseMetric"],"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["spans::SpansLeaf","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","rope::LinesMetric","rope::BaseMetric","breaks::BreaksBaseMetric","multiset::ZipSegment","diff::DiffOp","engine::FullPriority","breaks::BreaksInfo","delta::InsertDelta","tree::Node","breaks::BreaksMetric","multiset::Segment","breaks::BreaksLeaf","engine::RevId","delta::Delta","rope::Utf16CodeUnitsMetric","find::CaseMatching","multiset::CountMatcher","rope::RopeInfo","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","engine::DeltaOp","diff::DiffBuilder","spans::SpansInfo","tree::NodeBody","engine::Error","spans::Span","interval::Interval"]},"spans::SpansInfo":{"T":["delta::Delta","delta::InsertDelta","engine::Error","delta::DeltaElement","tree::NodeVal","engine::DeltaOp","diff::DiffOp","breaks::BreaksLeaf","multiset::CountMatcher","engine::Contents","rope::LinesMetric","multiset::Subset","multiset::ZipSegment","rope::RopeInfo","engine::RevId","spans::Span","multiset::Segment","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","interval::Interval","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpansInfo","tree::Node","spans::SpansLeaf","engine::FullPriority","rope::Utf16CodeUnitsMetric","find::CaseMatching","tree::NodeBody"]},"spans::SpansLeaf":{"T":["multiset::ZipSegment","multiset::CountMatcher","spans::SpansLeaf","multiset::Subset","breaks::BreaksBaseMetric","spans::SpansInfo","interval::Interval","multiset::Segment","engine::FullPriority","spans::Span","diff::DiffBuilder","engine::Contents","rope::Utf16CodeUnitsMetric","tree::NodeVal","delta::Delta","rope::LinesMetric","tree::Node","engine::Error","delta::InsertDelta","breaks::BreaksInfo","diff::DiffOp","find::CaseMatching","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksLeaf","rope::BaseMetric","rope::RopeInfo","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","engine::DeltaOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::NodeVal<N>
+p0.clone();
+<tree::NodeVal<N> as std::clone::Clone>::clone(p0);
+crate::<tree::NodeVal<N> as std::clone::Clone>::clone(p0);
+<tree::NodeVal<N>>::clone(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::from_leaf
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::Node::<N>::from_leaf":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["delta::InsertDelta","engine::DeltaOp","engine::RevId","multiset::Segment","engine::FullPriority","diff::DiffBuilder","find::CaseMatching","delta::Delta","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","breaks::BreaksBaseMetric","tree::NodeBody","spans::SpansInfo","spans::SpansLeaf","delta::DeltaElement","multiset::ZipSegment","interval::Interval","rope::LinesMetric","tree::NodeVal","spans::Span","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksLeaf","engine::Contents","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksMetric","multiset::Subset","diff::DiffOp","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["tree::Node","breaks::BreaksInfo","spans::SpansInfo","breaks::BreaksBaseMetric","diff::DiffOp","engine::Contents","engine::DeltaOp","delta::InsertDelta","multiset::CountMatcher","breaks::BreaksMetric","rope::LinesMetric","spans::SpansLeaf","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","tree::NodeBody","find::CaseMatching","multiset::Subset","multiset::Segment","engine::RevId","spans::Span","delta::Delta","interval::Interval","rope::RopeInfo","breaks::BreaksLeaf","engine::Error","rope::BaseMetric","engine::FullPriority","multiset::ZipSegment","tree::NodeVal"]},"spans::SpansLeaf":{"T":["delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","tree::NodeBody","tree::Node","rope::RopeInfo","diff::DiffOp","multiset::Segment","spans::SpansInfo","multiset::Subset","engine::Error","spans::Span","diff::DiffBuilder","breaks::BreaksInfo","breaks::BreaksLeaf","spans::SpansLeaf","find::CaseMatching","engine::Contents","breaks::BreaksBaseMetric","rope::BaseMetric","tree::NodeVal","engine::RevId","interval::Interval","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","engine::FullPriority","engine::DeltaOp","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::CountMatcher","delta::DeltaElement","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::from_leaf":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
+tree::Node::<N>::from_leaf(p0);
+crate::tree::Node::<N>::from_leaf(p0);
+<tree::Node<N>>::from_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::from_nodes
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::Node::<N>::from_nodes":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["delta::Delta","engine::Contents","tree::NodeBody","engine::FullPriority","breaks::BreaksLeaf","multiset::ZipSegment","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksMetric","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","rope::LinesMetric","engine::Error","delta::DeltaElement","spans::Span","multiset::CountMatcher","diff::DiffBuilder","engine::DeltaOp","rope::RopeInfo","spans::SpansInfo","interval::Interval","tree::Node","engine::RevId","breaks::BreaksInfo","diff::DiffOp","multiset::Subset","find::CaseMatching","delta::InsertDelta","tree::NodeVal","multiset::Segment"]},"spans::SpansInfo":{"T":["tree::Node","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","engine::DeltaOp","diff::DiffOp","rope::RopeInfo","engine::RevId","rope::LinesMetric","delta::Delta","tree::NodeVal","breaks::BreaksBaseMetric","spans::Span","rope::BaseMetric","breaks::BreaksMetric","engine::Contents","tree::NodeBody","rope::Utf16CodeUnitsMetric","engine::Error","delta::InsertDelta","spans::SpansInfo","breaks::BreaksInfo","delta::DeltaElement","diff::DiffBuilder","spans::SpansLeaf","multiset::CountMatcher","multiset::ZipSegment","multiset::Segment","interval::Interval","find::CaseMatching","engine::FullPriority","multiset::Subset"]},"spans::SpansLeaf":{"T":["tree::Node","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","tree::NodeBody","delta::Delta","diff::DiffBuilder","find::CaseMatching","engine::RevId","rope::RopeInfo","diff::DiffOp","spans::SpansLeaf","rope::LinesMetric","breaks::BreaksInfo","spans::SpansInfo","interval::Interval","multiset::Segment","engine::DeltaOp","delta::InsertDelta","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","engine::FullPriority","breaks::BreaksMetric","breaks::BreaksLeaf","rope::BaseMetric","tree::NodeVal","engine::Contents","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","spans::Span","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::from_nodes":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<tree::Node<N>>
+tree::Node::<N>::from_nodes(p0);
+crate::tree::Node::<N>::from_nodes(p0);
+<tree::Node<N>>::from_nodes(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::len
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized","tree::DefaultMetric"]},"tree::Node::<N>::len":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansInfo","engine::Contents","rope::RopeInfo","multiset::Segment","rope::LinesMetric","find::CaseMatching","breaks::BreaksInfo","diff::DiffBuilder","interval::Interval","engine::RevId","delta::Delta","spans::Span","tree::NodeVal","engine::Error","spans::SpansLeaf","breaks::BreaksMetric","tree::NodeBody","engine::FullPriority","breaks::BreaksBaseMetric","diff::DiffOp","rope::BaseMetric","tree::Node","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","engine::DeltaOp","multiset::CountMatcher","delta::InsertDelta"]},"spans::SpansInfo":{"T":["engine::DeltaOp","diff::DiffBuilder","spans::SpansInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric","find::CaseMatching","tree::NodeBody","tree::Node","breaks::BreaksLeaf","delta::InsertDelta","breaks::BreaksBaseMetric","rope::BaseMetric","rope::RopeInfo","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","engine::RevId","spans::Span","multiset::Subset","engine::FullPriority","engine::Contents","engine::Error","multiset::Segment","tree::NodeVal","multiset::ZipSegment","interval::Interval","spans::SpansLeaf","diff::DiffOp","delta::Delta"]},"spans::SpansLeaf":{"T":["diff::DiffBuilder","tree::Node","engine::FullPriority","engine::DeltaOp","find::CaseMatching","delta::InsertDelta","breaks::BreaksInfo","spans::SpansLeaf","breaks::BreaksBaseMetric","breaks::BreaksLeaf","interval::Interval","diff::DiffOp","tree::NodeBody","breaks::BreaksMetric","rope::RopeInfo","multiset::ZipSegment","rope::LinesMetric","rope::BaseMetric","multiset::Segment","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","tree::NodeVal","spans::SpansInfo","delta::DeltaElement","multiset::CountMatcher","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::Span","engine::Contents","delta::Delta","engine::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::len":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.len();
+tree::Node::<N>::len(p0);
+crate::tree::Node::<N>::len(p0);
+<tree::Node<N>>::len(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::is_empty
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::Node::<N>::is_empty":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","engine::RevId","multiset::ZipSegment","rope::LinesMetric","spans::SpansInfo","delta::InsertDelta","engine::FullPriority","interval::Interval","engine::Contents","find::CaseMatching","diff::DiffOp","multiset::Subset","rope::BaseMetric","breaks::BreaksInfo","multiset::Segment","tree::NodeBody","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","tree::NodeVal","breaks::BreaksMetric","delta::DeltaElement","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","diff::DiffBuilder","spans::SpansLeaf","delta::Delta","engine::Error","tree::Node","multiset::CountMatcher","spans::Span","engine::DeltaOp"]},"spans::SpansInfo":{"T":["engine::FullPriority","multiset::Segment","rope::LinesMetric","spans::Span","engine::Contents","delta::InsertDelta","breaks::BreaksBaseMetric","diff::DiffOp","find::CaseMatching","tree::NodeVal","engine::DeltaOp","spans::SpansLeaf","delta::Delta","diff::DiffBuilder","tree::Node","multiset::CountMatcher","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","interval::Interval","multiset::Subset","tree::NodeBody","engine::RevId","delta::DeltaElement","rope::Utf16CodeUnitsMetric","rope::RopeInfo","engine::Error","breaks::BreaksInfo","multiset::ZipSegment","breaks::BreaksMetric","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["tree::NodeBody","rope::LinesMetric","delta::InsertDelta","breaks::BreaksLeaf","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Contents","delta::DeltaElement","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","tree::Node","engine::DeltaOp","engine::Error","spans::SpansInfo","engine::RevId","multiset::ZipSegment","engine::FullPriority","multiset::CountMatcher","find::CaseMatching","breaks::BreaksInfo","spans::Span","delta::Delta","rope::BaseMetric","interval::Interval","multiset::Subset","diff::DiffOp","spans::SpansLeaf","tree::NodeVal","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::is_empty":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_empty();
+tree::Node::<N>::is_empty(p0);
+crate::tree::Node::<N>::is_empty(p0);
+<tree::Node<N>>::is_empty(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::ptr_eq
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::ptr_eq":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::ZipSegment","delta::Delta","interval::Interval","rope::LinesMetric","rope::RopeInfo","tree::Node","spans::SpansInfo","tree::NodeBody","multiset::Segment","breaks::BreaksMetric","tree::NodeVal","multiset::Subset","breaks::BreaksLeaf","multiset::CountMatcher","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","diff::DiffOp","rope::BaseMetric","engine::DeltaOp","rope::Utf16CodeUnitsMetric","engine::FullPriority","breaks::BreaksInfo","find::CaseMatching","spans::SpansLeaf","delta::InsertDelta","engine::RevId","delta::DeltaElement","engine::Contents","engine::Error","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansInfo":{"T":["rope::BaseMetric","tree::NodeVal","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","multiset::CountMatcher","rope::LinesMetric","breaks::BreaksMetric","rope::RopeInfo","breaks::BreaksInfo","tree::NodeBody","engine::Error","tree::Node","breaks::BreaksLeaf","engine::Contents","diff::DiffOp","engine::FullPriority","find::CaseMatching","spans::SpansInfo","delta::Delta","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","multiset::Subset","diff::DiffBuilder","delta::InsertDelta","delta::DeltaElement","engine::DeltaOp","breaks::BreaksBaseMetric","engine::RevId","multiset::Segment","interval::Interval"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::Error","engine::DeltaOp","delta::DeltaElement","rope::LinesMetric","diff::DiffBuilder","spans::Span","multiset::CountMatcher","breaks::BreaksBaseMetric","tree::NodeBody","rope::BaseMetric","interval::Interval","engine::RevId","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","delta::Delta","spans::SpansInfo","tree::Node","delta::InsertDelta","find::CaseMatching","multiset::ZipSegment","multiset::Segment","breaks::BreaksMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","tree::NodeVal","diff::DiffOp","multiset::Subset","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::ptr_eq":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.ptr_eq(p1);
+tree::Node::<N>::ptr_eq(p0, p1);
+crate::tree::Node::<N>::ptr_eq(p0, p1);
+<tree::Node<N>>::ptr_eq(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::height
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::Node::<N>::height":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::InsertDelta","rope::RopeInfo","breaks::BreaksBaseMetric","multiset::Subset","delta::DeltaElement","rope::LinesMetric","rope::BaseMetric","breaks::BreaksLeaf","engine::DeltaOp","engine::Contents","engine::RevId","diff::DiffBuilder","delta::Delta","multiset::ZipSegment","spans::SpansInfo","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Segment","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::Node","tree::NodeBody","breaks::BreaksMetric","tree::NodeVal","breaks::BreaksInfo","interval::Interval","engine::FullPriority","multiset::CountMatcher","find::CaseMatching","engine::Error"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","rope::Utf16CodeUnitsMetric","spans::Span","diff::DiffOp","interval::Interval","breaks::BreaksMetric","delta::DeltaElement","engine::FullPriority","engine::RevId","delta::Delta","tree::Node","delta::InsertDelta","tree::NodeBody","multiset::Subset","find::CaseMatching","multiset::CountMatcher","spans::SpansInfo","engine::DeltaOp","multiset::ZipSegment","diff::DiffBuilder","rope::BaseMetric","rope::LinesMetric","rope::RopeInfo","breaks::BreaksBaseMetric","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","engine::Error","breaks::BreaksInfo","multiset::Segment","breaks::BreaksLeaf"]},"spans::SpansLeaf":{"T":["rope::BaseMetric","interval::Interval","find::CaseMatching","tree::NodeVal","delta::InsertDelta","breaks::BreaksLeaf","engine::DeltaOp","spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","multiset::CountMatcher","tree::Node","delta::DeltaElement","multiset::ZipSegment","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::Contents","engine::Error","engine::RevId","multiset::Segment","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::FullPriority","tree::NodeBody","spans::Span","diff::DiffBuilder","delta::Delta","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::height":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.height();
+tree::Node::<N>::height(p0);
+crate::tree::Node::<N>::height(p0);
+<tree::Node<N>>::height(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::is_leaf
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::Node::<N>::is_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::Delta","breaks::BreaksLeaf","multiset::Subset","interval::Interval","spans::Span","rope::Utf16CodeUnitsMetric","tree::Node","breaks::BreaksMetric","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","rope::RopeInfo","tree::NodeVal","spans::SpansInfo","find::CaseMatching","diff::DiffOp","delta::DeltaElement","breaks::BreaksBaseMetric","spans::SpansLeaf","engine::Contents","engine::DeltaOp","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","tree::NodeBody","breaks::BreaksInfo","multiset::Segment","rope::LinesMetric","multiset::ZipSegment","delta::InsertDelta","rope::BaseMetric","engine::FullPriority"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","diff::DiffOp","delta::InsertDelta","delta::Delta","spans::Span","breaks::BreaksLeaf","rope::LinesMetric","tree::Node","delta::DeltaElement","breaks::BreaksInfo","engine::RevId","tree::NodeVal","tree::NodeBody","rope::RopeInfo","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","interval::Interval","breaks::BreaksBaseMetric","find::CaseMatching","multiset::ZipSegment","engine::DeltaOp","rope::Utf16CodeUnitsMetric","spans::SpansInfo","spans::SpansLeaf","multiset::Segment","engine::Contents","engine::Error","diff::DiffBuilder","engine::FullPriority","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","engine::DeltaOp","breaks::BreaksInfo","spans::Span","delta::Delta","diff::DiffBuilder","breaks::BreaksLeaf","rope::BaseMetric","rope::LinesMetric","spans::SpansInfo","engine::Error","tree::NodeBody","diff::DiffOp","engine::RevId","engine::FullPriority","multiset::CountMatcher","interval::Interval","multiset::Subset","engine::Contents","multiset::Segment","breaks::BreaksMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksBaseMetric","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","rope::Utf16CodeUnitsMetric","rope::RopeInfo","spans::SpansLeaf","find::CaseMatching","tree::Node"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::is_leaf":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_leaf();
+tree::Node::<N>::is_leaf(p0);
+crate::tree::Node::<N>::is_leaf(p0);
+<tree::Node<N>>::is_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::interval
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::Node::<N>::interval":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["breaks::BreaksBaseMetric","multiset::CountMatcher","spans::SpansInfo","tree::Node","find::CaseMatching","breaks::BreaksMetric","rope::RopeInfo","engine::RevId","multiset::Segment","rope::BaseMetric","multiset::ZipSegment","spans::Span","spans::SpansLeaf","breaks::BreaksLeaf","delta::DeltaElement","rope::LinesMetric","engine::Contents","tree::NodeBody","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","multiset::Subset","engine::DeltaOp","diff::DiffOp","breaks::BreaksInfo","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Error","rope::Utf16CodeUnitsMetric","interval::Interval","delta::Delta","engine::FullPriority"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","tree::Node","multiset::ZipSegment","rope::RopeInfo","multiset::CountMatcher","multiset::Subset","multiset::Segment","engine::DeltaOp","delta::Delta","engine::RevId","interval::Interval","diff::DiffOp","spans::Span","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","breaks::BreaksBaseMetric","delta::DeltaElement","diff::DiffBuilder","rope::BaseMetric","rope::Utf16CodeUnitsMetric","engine::Contents","find::CaseMatching","delta::InsertDelta","rope::LinesMetric","engine::FullPriority","engine::Error","spans::SpansInfo","tree::NodeVal","spans::SpansLeaf","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["interval::Interval","engine::FullPriority","engine::RevId","breaks::BreaksMetric","spans::Span","breaks::BreaksLeaf","spans::SpansInfo","delta::DeltaElement","delta::Delta","multiset::Segment","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","spans::SpansLeaf","tree::NodeBody","multiset::Subset","rope::LinesMetric","rope::BaseMetric","diff::DiffBuilder","tree::Node","rope::RopeInfo","find::CaseMatching","tree::NodeVal","engine::DeltaOp","multiset::ZipSegment","delta::InsertDelta","engine::Error","breaks::BreaksBaseMetric","diff::DiffOp"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::interval":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.interval();
+tree::Node::<N>::interval(p0);
+crate::tree::Node::<N>::interval(p0);
+<tree::Node<N>>::interval(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::get_children
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::Node::<N>::get_children":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::DeltaOp","tree::NodeBody","tree::NodeVal","spans::SpansInfo","delta::InsertDelta","diff::DiffBuilder","multiset::Subset","delta::Delta","breaks::BreaksInfo","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffOp","breaks::BreaksBaseMetric","engine::RevId","rope::LinesMetric","multiset::ZipSegment","breaks::BreaksLeaf","rope::BaseMetric","engine::Contents","interval::Interval","breaks::BreaksMetric","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","engine::Error","tree::Node","find::CaseMatching","multiset::CountMatcher","rope::RopeInfo","multiset::Segment","engine::FullPriority"]},"spans::SpansInfo":{"T":["engine::Contents","tree::NodeBody","breaks::BreaksInfo","engine::FullPriority","breaks::BreaksMetric","multiset::Subset","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","find::CaseMatching","multiset::Segment","spans::SpansLeaf","rope::RopeInfo","delta::Delta","rope::BaseMetric","engine::RevId","tree::Node","diff::DiffBuilder","tree::NodeVal","interval::Interval","engine::Error","spans::Span","breaks::BreaksBaseMetric","diff::DiffOp","rope::LinesMetric","delta::DeltaElement","multiset::ZipSegment","spans::SpansInfo","engine::DeltaOp","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::CountMatcher"]},"spans::SpansLeaf":{"T":["multiset::Segment","breaks::BreaksBaseMetric","breaks::BreaksLeaf","delta::InsertDelta","diff::DiffBuilder","tree::NodeVal","engine::DeltaOp","breaks::BreaksInfo","rope::LinesMetric","interval::Interval","spans::SpansLeaf","multiset::Subset","spans::Span","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","rope::RopeInfo","engine::RevId","diff::DiffOp","spans::SpansInfo","find::CaseMatching","multiset::CountMatcher","tree::Node","engine::Error","rope::BaseMetric","engine::FullPriority","multiset::ZipSegment","breaks::BreaksMetric","tree::NodeBody","engine::Contents"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::get_children":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.get_children();
+tree::Node::<N>::get_children(p0);
+crate::tree::Node::<N>::get_children(p0);
+<tree::Node<N>>::get_children(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::get_leaf
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::get_leaf":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","spans::SpansLeaf","tree::Node","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","multiset::Segment","rope::LinesMetric","interval::Interval","diff::DiffBuilder","tree::NodeVal","engine::Contents","spans::SpansInfo","engine::RevId","rope::BaseMetric","multiset::CountMatcher","spans::Span","engine::DeltaOp","multiset::ZipSegment","engine::Error","engine::FullPriority","diff::DiffOp","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","tree::NodeBody","delta::InsertDelta","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::Subset","delta::DeltaElement","delta::Delta","find::CaseMatching"]},"spans::SpansInfo":{"T":["diff::DiffOp","engine::Error","breaks::BreaksLeaf","breaks::BreaksInfo","tree::NodeVal","spans::SpansLeaf","engine::RevId","engine::FullPriority","spans::Span","delta::DeltaElement","tree::Node","multiset::CountMatcher","multiset::Segment","diff::DiffBuilder","rope::LinesMetric","rope::RopeInfo","multiset::ZipSegment","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","tree::NodeBody","delta::Delta","spans::SpansInfo","engine::DeltaOp","interval::Interval","breaks::BreaksMetric","engine::Contents","breaks::BreaksBaseMetric","multiset::Subset","rope::BaseMetric","rope::Utf16CodeUnitsMetric"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","interval::Interval","engine::Error","engine::Contents","tree::NodeBody","tree::Node","tree::NodeVal","breaks::BreaksInfo","spans::SpansLeaf","multiset::CountMatcher","rope::BaseMetric","find::CaseMatching","multiset::Segment","diff::DiffBuilder","multiset::Subset","breaks::BreaksLeaf","delta::InsertDelta","engine::RevId","delta::Delta","diff::DiffOp","breaks::BreaksBaseMetric","engine::FullPriority","engine::DeltaOp","rope::RopeInfo","delta::DeltaElement","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","breaks::BreaksMetric","rope::LinesMetric","spans::Span","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::get_leaf":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.get_leaf();
+tree::Node::<N>::get_leaf(p0);
+crate::tree::Node::<N>::get_leaf(p0);
+<tree::Node<N>>::get_leaf(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::with_leaf_mut
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::with_leaf_mut":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut N::L) -> T":["std::ops::FnOnce","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["tree::Node","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","engine::DeltaOp","breaks::BreaksLeaf","delta::DeltaElement","multiset::CountMatcher","engine::RevId","multiset::ZipSegment","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","engine::Error","find::CaseMatching","delta::Delta","diff::DiffBuilder","spans::Span","breaks::BreaksMetric","diff::DiffOp","multiset::Subset","tree::NodeVal","rope::LinesMetric","delta::InsertDelta","spans::SpansLeaf","engine::FullPriority","rope::RopeInfo","interval::Interval","rope::BaseMetric","tree::NodeBody","engine::Contents"]},"spans::SpansInfo":{"T":["diff::DiffBuilder","spans::SpansInfo","delta::DeltaElement","multiset::Subset","rope::RopeInfo","rope::LinesMetric","engine::FullPriority","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","breaks::BreaksMetric","multiset::Segment","breaks::BreaksLeaf","breaks::BreaksInfo","multiset::CountMatcher","diff::DiffOp","tree::NodeBody","multiset::ZipSegment","spans::SpansLeaf","spans::Span","delta::Delta","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::DeltaOp","tree::Node","engine::Error","breaks::BreaksBaseMetric","find::CaseMatching","engine::Contents","interval::Interval","delta::InsertDelta"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","diff::DiffOp","spans::SpansInfo","multiset::ZipSegment","tree::Node","breaks::BreaksBaseMetric","find::CaseMatching","tree::NodeVal","tree::NodeBody","engine::RevId","rope::RopeInfo","engine::Error","spans::SpansLeaf","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","delta::DeltaElement","spans::Span","rope::LinesMetric","multiset::Subset","engine::FullPriority","multiset::Segment","breaks::BreaksMetric","multiset::CountMatcher","engine::Contents","rope::BaseMetric","delta::InsertDelta","breaks::BreaksInfo","engine::DeltaOp","delta::Delta","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::with_leaf_mut":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"],"T":["RUG_ANY"],"impl FnOnce(&mut N::L) -> T":["std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut N::L) -> T
+p0.with_leaf_mut(p1);
+tree::Node::<N>::with_leaf_mut(p0, p1);
+crate::tree::Node::<N>::with_leaf_mut(p0, p1);
+<tree::Node<N>>::with_leaf_mut(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::is_ok_child
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::DefaultMetric","tree::NodeInfo"]},"tree::Node::<N>::is_ok_child":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","multiset::Subset","engine::Error","spans::SpansLeaf","engine::FullPriority","engine::RevId","spans::Span","delta::InsertDelta","find::CaseMatching","engine::DeltaOp","tree::NodeBody","breaks::BreaksMetric","delta::Delta","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","tree::NodeVal","delta::DeltaElement","rope::LinesMetric","rope::RopeInfo","tree::Node","interval::Interval","breaks::BreaksBaseMetric","engine::Contents","rope::BaseMetric","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","breaks::BreaksLeaf","multiset::Segment","diff::DiffOp","spans::SpansInfo"]},"spans::SpansInfo":{"T":["delta::InsertDelta","diff::DiffBuilder","delta::DeltaElement","breaks::BreaksLeaf","tree::Node","spans::Span","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","spans::SpansLeaf","multiset::CountMatcher","spans::SpansInfo","delta::Delta","rope::BaseMetric","tree::NodeBody","engine::Error","interval::Interval","rope::LinesMetric","multiset::Subset","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","engine::DeltaOp","find::CaseMatching","engine::Contents","engine::RevId","multiset::Segment","rope::RopeInfo","tree::NodeVal","multiset::ZipSegment","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["rope::LinesMetric","find::CaseMatching","tree::Node","engine::Contents","engine::DeltaOp","delta::Delta","interval::Interval","engine::Error","tree::NodeVal","multiset::Subset","diff::DiffBuilder","breaks::BreaksInfo","breaks::BreaksBaseMetric","spans::Span","tree::NodeBody","rope::Utf16CodeUnitsMetric","engine::FullPriority","multiset::Segment","breaks::BreaksMetric","rope::BaseMetric","rope::RopeInfo","spans::SpansInfo","spans::SpansLeaf","delta::InsertDelta","multiset::CountMatcher","delta::DeltaElement","breaks::BreaksLeaf","engine::RevId","diff::DiffOp","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::is_ok_child":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.is_ok_child();
+tree::Node::<N>::is_ok_child(p0);
+crate::tree::Node::<N>::is_ok_child(p0);
+<tree::Node<N>>::is_ok_child(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::merge_nodes
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::Node::<N>::merge_nodes":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::DeltaOp","diff::DiffBuilder","rope::RopeInfo","delta::InsertDelta","multiset::Subset","breaks::BreaksInfo","spans::SpansLeaf","engine::Error","delta::Delta","rope::LinesMetric","rope::BaseMetric","delta::DeltaElement","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","tree::Node","engine::FullPriority","engine::Contents","tree::NodeVal","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","multiset::CountMatcher","interval::Interval","multiset::ZipSegment","spans::SpansInfo","diff::DiffOp","breaks::BreaksLeaf","tree::NodeBody","breaks::BreaksMetric","find::CaseMatching","spans::Span","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>"]},"spans::SpansInfo":{"T":["breaks::BreaksLeaf","tree::NodeVal","rope::LinesMetric","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","delta::DeltaElement","engine::Error","find::CaseMatching","rope::Utf16CodeUnitsMetric","spans::SpansInfo","engine::DeltaOp","rope::BaseMetric","breaks::BreaksMetric","engine::Contents","breaks::BreaksInfo","multiset::Segment","breaks::BreaksBaseMetric","tree::Node","tree::NodeBody","multiset::Subset","multiset::ZipSegment","diff::DiffOp","delta::Delta","interval::Interval","multiset::CountMatcher","diff::DiffBuilder","rope::RopeInfo","delta::InsertDelta","engine::RevId","spans::Span"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","engine::RevId","tree::NodeVal","delta::InsertDelta","engine::FullPriority","rope::LinesMetric","spans::Span","multiset::Subset","tree::NodeBody","spans::SpansInfo","diff::DiffBuilder","multiset::Segment","engine::DeltaOp","interval::Interval","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksInfo","delta::Delta","multiset::CountMatcher","diff::DiffOp","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksLeaf","multiset::ZipSegment","tree::Node","engine::Contents","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::merge_nodes":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [tree::Node<N>]
let mut p1 = & MaybeUninit::uninit().assume_init(); // [tree::Node<N>]
+tree::Node::<N>::merge_nodes(p0, p1);
+crate::tree::Node::<N>::merge_nodes(p0, p1);
+<tree::Node<N>>::merge_nodes(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::merge_leaves
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::Node::<N>::merge_leaves":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksInfo","breaks::BreaksBaseMetric","delta::DeltaElement","engine::Error","tree::NodeBody","breaks::BreaksMetric","engine::FullPriority","multiset::ZipSegment","multiset::Segment","rope::BaseMetric","find::CaseMatching","rope::LinesMetric","multiset::CountMatcher","spans::Span","multiset::Subset","breaks::BreaksLeaf","engine::Contents","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","tree::Node","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","engine::DeltaOp","delta::Delta","diff::DiffBuilder","rope::RopeInfo","interval::Interval","diff::DiffOp","engine::RevId","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["engine::Error","spans::SpansLeaf","breaks::BreaksBaseMetric","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","find::CaseMatching","spans::SpansInfo","engine::Contents","engine::DeltaOp","multiset::Segment","spans::Span","multiset::ZipSegment","rope::RopeInfo","delta::Delta","tree::NodeBody","engine::RevId","interval::Interval","tree::Node","diff::DiffOp","tree::NodeVal","breaks::BreaksLeaf","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric","delta::DeltaElement","diff::DiffBuilder","engine::FullPriority","multiset::CountMatcher","rope::BaseMetric","breaks::BreaksMetric"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","delta::Delta","breaks::BreaksMetric","multiset::Subset","breaks::BreaksLeaf","delta::DeltaElement","tree::NodeVal","engine::Contents","rope::RopeInfo","diff::DiffBuilder","engine::RevId","diff::DiffOp","find::CaseMatching","engine::Error","multiset::ZipSegment","tree::Node","spans::Span","spans::SpansInfo","multiset::Segment","breaks::BreaksBaseMetric","rope::BaseMetric","rope::LinesMetric","tree::NodeBody","spans::SpansLeaf","engine::FullPriority","multiset::CountMatcher","interval::Interval","delta::InsertDelta","engine::DeltaOp","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::merge_leaves":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+tree::Node::<N>::merge_leaves(p0, p1);
+crate::tree::Node::<N>::merge_leaves(p0, p1);
+<tree::Node<N>>::merge_leaves(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::concat
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::Node::<N>::concat":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","multiset::Subset","tree::NodeVal","rope::LinesMetric","engine::RevId","find::CaseMatching","delta::Delta","breaks::BreaksInfo","diff::DiffBuilder","engine::Contents","rope::RopeInfo","breaks::BreaksLeaf","spans::SpansLeaf","multiset::Segment","engine::Error","rope::BaseMetric","engine::DeltaOp","diff::DiffOp","rope::Utf16CodeUnitsMetric","spans::Span","multiset::ZipSegment","delta::InsertDelta","tree::Node","breaks::BreaksBaseMetric","interval::Interval","breaks::BreaksMetric","multiset::CountMatcher","tree::NodeBody","delta::DeltaElement","engine::FullPriority"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","delta::Delta","rope::LinesMetric","breaks::BreaksInfo","multiset::Subset","tree::NodeVal","breaks::BreaksBaseMetric","engine::DeltaOp","interval::Interval","spans::Span","engine::FullPriority","diff::DiffBuilder","diff::DiffOp","delta::InsertDelta","multiset::ZipSegment","engine::Error","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","find::CaseMatching","rope::RopeInfo","spans::SpansInfo","tree::NodeBody","breaks::BreaksLeaf","rope::BaseMetric","tree::Node","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","multiset::Segment","engine::RevId","engine::Contents","delta::DeltaElement"]},"spans::SpansLeaf":{"T":["multiset::CountMatcher","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","breaks::BreaksMetric","delta::Delta","rope::Utf16CodeUnitsMetric","diff::DiffOp","rope::RopeInfo","tree::NodeBody","multiset::Segment","delta::InsertDelta","engine::FullPriority","breaks::BreaksInfo","diff::DiffBuilder","delta::DeltaElement","rope::LinesMetric","spans::Span","engine::Error","spans::SpansLeaf","rope::BaseMetric","multiset::ZipSegment","multiset::Subset","tree::Node","spans::SpansInfo","breaks::BreaksBaseMetric","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","engine::Contents","engine::RevId","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::concat":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+tree::Node::<N>::concat(p0, p1);
+crate::tree::Node::<N>::concat(p0, p1);
+<tree::Node<N>>::concat(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::measure
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::Node::<N>::measure":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["diff::DiffOp","breaks::BreaksBaseMetric","spans::SpansLeaf","rope::RopeInfo","engine::DeltaOp","tree::NodeVal","multiset::Subset","breaks::BreaksInfo","multiset::ZipSegment","spans::Span","rope::BaseMetric","engine::Contents","engine::Error","delta::Delta","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","multiset::Segment","interval::Interval","spans::SpansInfo","tree::Node","multiset::CountMatcher","engine::FullPriority","delta::InsertDelta","diff::DiffBuilder","breaks::BreaksMetric","delta::DeltaElement","rope::LinesMetric","breaks::BreaksLeaf","tree::NodeBody","engine::RevId"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","engine::FullPriority","multiset::Segment","spans::SpansInfo","rope::BaseMetric","delta::InsertDelta","engine::RevId","tree::Node","delta::DeltaElement","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","diff::DiffOp","engine::Contents","multiset::CountMatcher","interval::Interval","breaks::BreaksInfo","multiset::ZipSegment","tree::NodeVal","delta::Delta","spans::SpansLeaf","rope::LinesMetric","breaks::BreaksBaseMetric","rope::RopeInfo","tree::NodeBody","engine::Error","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","multiset::Subset","find::CaseMatching","spans::Span"]},"spans::SpansLeaf":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","breaks::BreaksInfo","delta::Delta","delta::DeltaElement","spans::SpansLeaf","engine::DeltaOp","tree::NodeBody","breaks::BreaksBaseMetric","multiset::CountMatcher","multiset::Subset","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::NodeVal","engine::Error","diff::DiffBuilder","breaks::BreaksMetric","interval::Interval","diff::DiffOp","rope::RopeInfo","tree::Node","engine::Contents","spans::Span","multiset::ZipSegment","multiset::Segment","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","find::CaseMatching","breaks::BreaksLeaf","engine::FullPriority","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::measure":{"M":["rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric"],"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.measure();
+tree::Node::<N>::measure(p0);
+crate::tree::Node::<N>::measure(p0);
+<tree::Node<N>>::measure(p0);
-----------------
rope/src/tree.rs tree::Node::<N>::push_subseq
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized","tree::DefaultMetric"]},"tree::Node::<N>::push_subseq":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["breaks::BreaksMetric","multiset::ZipSegment","delta::InsertDelta","multiset::CountMatcher","diff::DiffOp","engine::FullPriority","breaks::BreaksBaseMetric","spans::Span","tree::NodeBody","tree::NodeVal","rope::BaseMetric","engine::DeltaOp","engine::Contents","delta::Delta","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::Error","multiset::Segment","spans::SpansLeaf","engine::RevId","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","rope::RopeInfo","spans::SpansInfo","rope::LinesMetric","find::CaseMatching","diff::DiffBuilder","breaks::BreaksInfo","interval::Interval"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","spans::Span","breaks::BreaksInfo","interval::Interval","engine::RevId","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::CountMatcher","multiset::ZipSegment","diff::DiffOp","rope::LinesMetric","breaks::BreaksLeaf","multiset::Subset","find::CaseMatching","multiset::Segment","rope::BaseMetric","spans::SpansInfo","tree::Node","engine::Error","breaks::BreaksBaseMetric","engine::FullPriority","rope::RopeInfo","tree::NodeBody","delta::Delta","diff::DiffBuilder","engine::DeltaOp","engine::Contents","tree::NodeVal","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","tree::NodeVal","breaks::BreaksInfo","rope::BaseMetric","multiset::CountMatcher","spans::SpansLeaf","multiset::ZipSegment","engine::Contents","spans::Span","delta::Delta","breaks::BreaksMetric","spans::SpansInfo","tree::Node","find::CaseMatching","interval::Interval","breaks::BreaksBaseMetric","engine::DeltaOp","delta::DeltaElement","tree::NodeBody","diff::DiffBuilder","engine::FullPriority","multiset::Subset","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","diff::DiffOp","delta::InsertDelta","rope::Utf16CodeUnitsMetric","multiset::Segment","rope::LinesMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::push_subseq":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_subseq(p1, p2);
+tree::Node::<N>::push_subseq(p0, p1, p2);
+crate::tree::Node::<N>::push_subseq(p0, p1, p2);
+<tree::Node<N>>::push_subseq(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Node::<N>::subseq
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::Node::<N>::subseq":{"N":["tree::NodeInfo","std::marker::Sized"],"T":["std::marker::Sized","interval::IntervalBounds"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["tree::Node","breaks::BreaksBaseMetric","delta::DeltaElement","breaks::BreaksLeaf","engine::Error","breaks::BreaksInfo","interval::Interval","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","multiset::Subset","tree::NodeBody","multiset::Segment","spans::Span","breaks::BreaksMetric","engine::Contents","engine::DeltaOp","engine::RevId","spans::SpansInfo","delta::Delta","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","find::CaseMatching","diff::DiffOp","rope::RopeInfo","spans::SpansLeaf","tree::NodeVal","delta::InsertDelta","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","rope::BaseMetric","engine::FullPriority","diff::DiffOp","find::CaseMatching","multiset::ZipSegment","breaks::BreaksInfo","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment","delta::Delta","multiset::CountMatcher","diff::DiffBuilder","tree::NodeVal","interval::Interval","rope::LinesMetric","delta::InsertDelta","tree::NodeBody","multiset::Subset","tree::Node","breaks::BreaksBaseMetric","spans::Span","breaks::BreaksLeaf","engine::RevId","delta::DeltaElement","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Error","rope::RopeInfo","engine::DeltaOp","spans::SpansInfo"]},"spans::SpansLeaf":{"T":["breaks::BreaksMetric","tree::Node","breaks::BreaksBaseMetric","engine::DeltaOp","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","rope::Utf16CodeUnitsMetric","rope::LinesMetric","spans::SpansLeaf","breaks::BreaksInfo","spans::SpansInfo","interval::Interval","multiset::Segment","delta::Delta","diff::DiffBuilder","spans::Span","engine::Error","multiset::CountMatcher","multiset::ZipSegment","tree::NodeBody","rope::BaseMetric","engine::FullPriority","engine::Contents","delta::InsertDelta","delta::DeltaElement","rope::RopeInfo","engine::RevId","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","multiset::Subset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node::<N>::subseq":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"],"T":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.subseq(p1);
+tree::Node::<N>::subseq(p0, p1);
+crate::tree::Node::<N>::subseq(p0, p1);
+<tree::Node<N>>::subseq(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::edit
deps:{"<T as interval::IntervalBounds>":{"T":["std::convert::Into","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::Node::<N>::edit":{"IV":["interval::IntervalBounds","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"],"T":["std::convert::Into","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"<T as interval::IntervalBounds>":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["find::CaseMatching","rope::BaseMetric","breaks::BreaksLeaf","engine::FullPriority","multiset::CountMatcher","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::InsertDelta","multiset::ZipSegment","rope::LinesMetric","multiset::Subset","breaks::BreaksMetric","spans::SpansInfo","engine::DeltaOp","tree::NodeBody","delta::Delta","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","rope::RopeInfo","engine::Error","spans::Span","delta::DeltaElement","interval::Interval","engine::Contents","breaks::BreaksInfo","diff::DiffOp","engine::RevId","breaks::BreaksBaseMetric","tree::NodeVal","tree::Node"]},"spans::SpansInfo":{"T":["engine::DeltaOp","rope::RopeInfo","multiset::ZipSegment","breaks::BreaksBaseMetric","engine::Error","tree::NodeVal","tree::Node","find::CaseMatching","rope::LinesMetric","rope::BaseMetric","interval::Interval","spans::Span","diff::DiffOp","breaks::BreaksLeaf","delta::InsertDelta","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","tree::NodeBody","engine::RevId","engine::FullPriority","breaks::BreaksMetric","multiset::CountMatcher","delta::Delta","diff::DiffBuilder","multiset::Subset","delta::DeltaElement","spans::SpansLeaf","multiset::Segment","spans::SpansInfo","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["interval::Interval","engine::FullPriority","spans::SpansInfo","multiset::Subset","spans::SpansLeaf","engine::Contents","find::CaseMatching","engine::DeltaOp","engine::RevId","tree::NodeBody","breaks::BreaksLeaf","rope::RopeInfo","rope::BaseMetric","diff::DiffBuilder","tree::Node","multiset::CountMatcher","delta::DeltaElement","spans::Span","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::LinesMetric","breaks::BreaksMetric","engine::Error","multiset::Segment","tree::NodeVal","breaks::BreaksBaseMetric","delta::Delta","diff::DiffOp","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","delta::InsertDelta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::edit":{"IV":["<T as interval::IntervalBounds>","std::ops::RangeFull","std::ops::RangeFrom"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"],"T":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // IV
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.edit(p1, p2);
+tree::Node::<N>::edit(p0, p1, p2);
+crate::tree::Node::<N>::edit(p0, p1, p2);
+<tree::Node<N>>::edit(p0, p1, p2);
-----------------
rope/src/tree.rs tree::Node::<N>::convert_metrics
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::Node::<N>::convert_metrics":{"M1":["tree::Metric","std::marker::Sized"],"M2":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::Contents","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","engine::RevId","diff::DiffOp","tree::Node","breaks::BreaksMetric","multiset::CountMatcher","delta::Delta","breaks::BreaksLeaf","rope::RopeInfo","tree::NodeBody","spans::SpansInfo","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::Error","spans::Span","tree::NodeVal","diff::DiffBuilder","breaks::BreaksInfo","multiset::Subset","delta::InsertDelta","interval::Interval","delta::DeltaElement","rope::LinesMetric","find::CaseMatching","rope::BaseMetric","engine::FullPriority","engine::DeltaOp","spans::SpansLeaf","multiset::Segment"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","delta::DeltaElement","tree::NodeVal","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksLeaf","engine::DeltaOp","engine::Contents","multiset::Segment","spans::SpansLeaf","multiset::ZipSegment","breaks::BreaksInfo","find::CaseMatching","tree::NodeBody","spans::SpansInfo","multiset::Subset","delta::InsertDelta","diff::DiffOp","delta::Delta","interval::Interval","rope::RopeInfo","engine::Error","diff::DiffBuilder","engine::RevId","breaks::BreaksMetric","tree::Node","rope::BaseMetric","spans::Span"]},"spans::SpansLeaf":{"T":["engine::DeltaOp","spans::Span","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansInfo","diff::DiffOp","rope::RopeInfo","tree::NodeBody","breaks::BreaksMetric","breaks::BreaksInfo","engine::Error","interval::Interval","delta::InsertDelta","multiset::CountMatcher","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","find::CaseMatching","rope::LinesMetric","rope::Utf16CodeUnitsMetric","delta::Delta","diff::DiffBuilder","multiset::Segment","delta::DeltaElement","engine::RevId","spans::SpansLeaf","rope::BaseMetric","engine::Contents","multiset::ZipSegment","tree::Node","multiset::Subset","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node::<N>::convert_metrics":{"M1":["breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"M2":["breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.convert_metrics(p1);
+tree::Node::<N>::convert_metrics(p0, p1);
+crate::tree::Node::<N>::convert_metrics(p0, p1);
+<tree::Node<N>>::convert_metrics(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::count
deps:{"tree::Node::<N>::count":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::DefaultMetric"]}}
candidates:{"tree::Node::<N>::count":{"M":["rope::LinesMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.count(p1);
+tree::Node::<N>::count(p0, p1);
+crate::tree::Node::<N>::count(p0, p1);
+<tree::Node<N>>::count(p0, p1);
-----------------
rope/src/tree.rs tree::Node::<N>::count_base_units
deps:{"tree::Node::<N>::count_base_units":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::DefaultMetric"]}}
candidates:{"tree::Node::<N>::count_base_units":{"M":["breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","rope::LinesMetric","rope::BaseMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+p0.count_base_units(p1);
+tree::Node::<N>::count_base_units(p0, p1);
+crate::tree::Node::<N>::count_base_units(p0, p1);
+<tree::Node<N>>::count_base_units(p0, p1);
-----------------
rope/src/tree.rs <tree::Node<N> as std::default::Default>::default
deps:{"<tree::Node<N> as std::default::Default>::default":{"N":["std::marker::Sized","tree::NodeInfo"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<tree::Node<N> as std::default::Default>::default":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["tree::NodeBody","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","diff::DiffOp","interval::Interval","engine::Contents","engine::DeltaOp","spans::SpansLeaf","engine::FullPriority","tree::Node","std::clone::impls::<impl std::clone::Clone for *const T>","rope::LinesMetric","breaks::BreaksMetric","rope::BaseMetric","engine::Error","tree::NodeVal","engine::RevId","breaks::BreaksBaseMetric","find::CaseMatching","breaks::BreaksInfo","multiset::Subset","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::Delta","spans::SpansInfo","multiset::CountMatcher","multiset::Segment","diff::DiffBuilder","delta::InsertDelta","spans::Span","rope::RopeInfo","breaks::BreaksLeaf"]},"spans::SpansInfo":{"T":["multiset::CountMatcher","find::CaseMatching","rope::BaseMetric","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","multiset::ZipSegment","engine::Error","spans::SpansInfo","tree::Node","spans::Span","breaks::BreaksLeaf","delta::InsertDelta","tree::NodeBody","multiset::Subset","tree::NodeVal","breaks::BreaksBaseMetric","rope::RopeInfo","spans::SpansLeaf","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","interval::Interval","engine::RevId","breaks::BreaksMetric","delta::Delta","engine::Contents","delta::DeltaElement","diff::DiffOp","multiset::Segment","rope::LinesMetric","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["find::CaseMatching","diff::DiffBuilder","engine::Error","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","engine::DeltaOp","breaks::BreaksMetric","engine::FullPriority","multiset::Subset","tree::NodeVal","delta::InsertDelta","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","breaks::BreaksInfo","spans::SpansLeaf","multiset::Segment","spans::SpansInfo","engine::Contents","breaks::BreaksLeaf","multiset::ZipSegment","tree::Node","delta::Delta","tree::NodeBody","spans::Span","rope::LinesMetric","breaks::BreaksBaseMetric","multiset::CountMatcher","engine::RevId","delta::DeltaElement","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
+<tree::Node<N> as std::default::Default>::default();
+crate::<tree::Node<N> as std::default::Default>::default();
+<tree::Node<N>>::default();
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::new
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::TreeBuilder::<N>::new":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::Error","rope::LinesMetric","delta::DeltaElement","breaks::BreaksBaseMetric","tree::NodeVal","tree::NodeBody","delta::Delta","engine::FullPriority","engine::Contents","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","engine::RevId","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","engine::DeltaOp","tree::Node","rope::BaseMetric","spans::Span","multiset::Segment","find::CaseMatching","breaks::BreaksInfo","multiset::CountMatcher","breaks::BreaksLeaf","spans::SpansInfo","breaks::BreaksMetric","spans::SpansLeaf","interval::Interval","rope::RopeInfo","multiset::ZipSegment","multiset::Subset"]},"spans::SpansInfo":{"T":["rope::BaseMetric","breaks::BreaksMetric","spans::SpansLeaf","delta::Delta","multiset::ZipSegment","breaks::BreaksBaseMetric","tree::Node","rope::RopeInfo","delta::InsertDelta","engine::Error","engine::Contents","diff::DiffOp","spans::Span","rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::RevId","diff::DiffBuilder","breaks::BreaksInfo","rope::LinesMetric","multiset::Segment","delta::DeltaElement","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::Subset","tree::NodeBody","breaks::BreaksLeaf","tree::NodeVal","spans::SpansInfo","interval::Interval","engine::DeltaOp","find::CaseMatching"]},"spans::SpansLeaf":{"T":["tree::NodeVal","tree::NodeBody","diff::DiffBuilder","delta::DeltaElement","engine::Error","spans::SpansInfo","breaks::BreaksMetric","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksInfo","engine::Contents","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","spans::Span","multiset::Segment","rope::Utf16CodeUnitsMetric","delta::InsertDelta","diff::DiffOp","engine::DeltaOp","rope::LinesMetric","rope::BaseMetric","multiset::Subset","spans::SpansLeaf","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::RopeInfo","tree::Node","multiset::ZipSegment","delta::Delta","interval::Interval","engine::FullPriority","engine::RevId"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::TreeBuilder::<N>::new":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
+tree::TreeBuilder::<N>::new();
+crate::tree::TreeBuilder::<N>::new();
+<tree::TreeBuilder<N>>::new();
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::TreeBuilder::<N>::push":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeVal","find::CaseMatching","engine::Contents","multiset::ZipSegment","delta::Delta","multiset::Segment","interval::Interval","breaks::BreaksInfo","breaks::BreaksMetric","delta::DeltaElement","spans::SpansInfo","tree::Node","breaks::BreaksLeaf","engine::Error","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","multiset::CountMatcher","tree::NodeBody","engine::DeltaOp","delta::InsertDelta","engine::FullPriority","spans::SpansLeaf","diff::DiffOp","rope::LinesMetric","spans::Span","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","rope::BaseMetric","multiset::Subset","rope::RopeInfo"]},"spans::SpansInfo":{"T":["find::CaseMatching","tree::NodeVal","breaks::BreaksLeaf","engine::FullPriority","multiset::Subset","multiset::CountMatcher","diff::DiffOp","spans::SpansLeaf","tree::NodeBody","rope::LinesMetric","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::Delta","delta::InsertDelta","delta::DeltaElement","engine::Contents","spans::SpansInfo","breaks::BreaksMetric","engine::Error","rope::RopeInfo","interval::Interval","spans::Span","engine::RevId","rope::BaseMetric","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksBaseMetric","engine::DeltaOp","multiset::Segment","tree::Node","rope::Utf16CodeUnitsMetric"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::Utf16CodeUnitsMetric","diff::DiffOp","engine::Contents","rope::RopeInfo","engine::Error","breaks::BreaksInfo","spans::SpansInfo","delta::Delta","rope::BaseMetric","breaks::BreaksMetric","tree::Node","delta::DeltaElement","spans::Span","multiset::Segment","tree::NodeVal","engine::RevId","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeBody","interval::Interval","multiset::CountMatcher","breaks::BreaksBaseMetric","find::CaseMatching","rope::LinesMetric","engine::FullPriority","delta::InsertDelta","multiset::Subset","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::TreeBuilder::<N>::push":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // tree::Node<N>
+p0.push(p1);
+tree::TreeBuilder::<N>::push(p0, p1);
+crate::tree::TreeBuilder::<N>::push(p0, p1);
+<tree::TreeBuilder<N>>::push(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaves
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::cached::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"delta::DeletionsIter":{"N":["tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertsIter":{"N":["tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpanIter":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::TreeBuilder::<N>::push_leaves":{"N":["tree::NodeInfo","std::marker::Sized"],"impl IntoIterator<Item = N::L>":["std::marker::Sized","std::iter::IntoIterator"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::cached::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["rope::Lines","delta::DeletionsIter","<&mut I as std::iter::Iterator>","spans::SpanIter","tree::CursorIter","delta::InsertsIter","rope::ChunkIter","multiset::RangeIter","multiset::ZipIter","rope::LinesRaw"]},"delta::DeletionsIter":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertsIter":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["tree::Node","rope::RopeInfo","breaks::BreaksInfo","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::DeltaOp","delta::InsertDelta","interval::Interval","delta::Delta","multiset::ZipSegment","find::CaseMatching","rope::Utf16CodeUnitsMetric","spans::Span","breaks::BreaksMetric","tree::NodeVal","spans::SpansInfo","multiset::Subset","multiset::CountMatcher","breaks::BreaksBaseMetric","engine::Error","spans::SpansLeaf","diff::DiffOp","diff::DiffBuilder","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","rope::BaseMetric","multiset::Segment","engine::FullPriority","engine::Contents","tree::NodeBody","rope::LinesMetric"]},"spans::SpanIter":{"T":["interval::Interval","breaks::BreaksInfo","tree::NodeBody","delta::InsertDelta","tree::NodeVal","engine::FullPriority","diff::DiffBuilder","breaks::BreaksLeaf","multiset::Segment","breaks::BreaksBaseMetric","spans::SpansLeaf","spans::Span","spans::SpansInfo","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","breaks::BreaksMetric","multiset::CountMatcher","engine::Error","engine::DeltaOp","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::RevId","multiset::Subset","rope::LinesMetric","diff::DiffOp","multiset::ZipSegment","delta::Delta","engine::Contents","find::CaseMatching","rope::BaseMetric"]},"spans::SpansInfo":{"T":["breaks::BreaksBaseMetric","engine::FullPriority","engine::RevId","diff::DiffOp","tree::NodeBody","rope::BaseMetric","spans::Span","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","spans::SpansInfo","multiset::CountMatcher","rope::RopeInfo","tree::NodeVal","interval::Interval","tree::Node","multiset::Subset","breaks::BreaksLeaf","spans::SpansLeaf","find::CaseMatching","delta::InsertDelta","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::DeltaOp","delta::DeltaElement","engine::Contents","multiset::Segment","diff::DiffBuilder","delta::Delta","rope::LinesMetric","engine::Error"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","tree::NodeBody","diff::DiffOp","engine::RevId","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","delta::DeltaElement","rope::LinesMetric","interval::Interval","engine::FullPriority","breaks::BreaksLeaf","breaks::BreaksInfo","diff::DiffBuilder","breaks::BreaksMetric","delta::Delta","find::CaseMatching","engine::Error","engine::DeltaOp","rope::Utf16CodeUnitsMetric","multiset::Segment","delta::InsertDelta","tree::NodeVal","tree::Node","engine::Contents","spans::SpansLeaf","breaks::BreaksBaseMetric","multiset::Subset","spans::Span","spans::SpansInfo","multiset::CountMatcher","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for &T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter":{"M":["breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric","breaks::BreaksMetric","rope::LinesMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::TreeBuilder::<N>::push_leaves":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"],"impl IntoIterator<Item = N::L>":["std::option::Option<T>","std::sync::mpsc::Receiver<T>","std::collections::LinkedList<T>","<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","std::result::Result<T, E>","std::collections::VecDeque<T, A>","&'a std::path::Path","std::collections::BTreeSet<T, A>","std::collections::HashSet<T, S>","std::collections::BinaryHeap<T>","<&'a mut thread_local::cached::CachedThreadLocal<T> as std::iter::IntoIterator>","std::vec::Vec<T, A>","std::collections::HashMap<K, V, S>","&'a std::os::unix::net::UnixListener","std::collections::BTreeMap<K, V, A>","&'a std::path::PathBuf"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl IntoIterator<Item = N::L>
+p0.push_leaves(p1);
+tree::TreeBuilder::<N>::push_leaves(p0, p1);
+crate::tree::TreeBuilder::<N>::push_leaves(p0, p1);
+<tree::TreeBuilder<N>>::push_leaves(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaf
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::TreeBuilder::<N>::push_leaf":{"N":["tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::LinesMetric","breaks::BreaksInfo","multiset::CountMatcher","breaks::BreaksLeaf","engine::Contents","rope::BaseMetric","tree::Node","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","find::CaseMatching","engine::RevId","spans::SpansInfo","delta::InsertDelta","delta::DeltaElement","multiset::Segment","engine::FullPriority","interval::Interval","engine::Error","spans::Span","engine::DeltaOp","multiset::ZipSegment","breaks::BreaksBaseMetric","diff::DiffBuilder","tree::NodeBody","delta::Delta","rope::RopeInfo","diff::DiffOp","tree::NodeVal"]},"spans::SpansInfo":{"T":["multiset::ZipSegment","tree::NodeVal","multiset::CountMatcher","tree::NodeBody","rope::RopeInfo","engine::RevId","interval::Interval","breaks::BreaksInfo","delta::Delta","spans::Span","engine::Contents","spans::SpansInfo","spans::SpansLeaf","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::BaseMetric","engine::DeltaOp","delta::InsertDelta","multiset::Segment","breaks::BreaksLeaf","find::CaseMatching","rope::Utf16CodeUnitsMetric","engine::Error","breaks::BreaksMetric","delta::DeltaElement","rope::LinesMetric","tree::Node","breaks::BreaksBaseMetric","diff::DiffOp","diff::DiffBuilder","multiset::Subset"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","rope::RopeInfo","spans::SpansLeaf","tree::Node","multiset::ZipSegment","multiset::Subset","multiset::Segment","breaks::BreaksLeaf","engine::Contents","engine::FullPriority","engine::RevId","tree::NodeVal","delta::InsertDelta","spans::SpansInfo","interval::Interval","engine::Error","diff::DiffOp","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffBuilder","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","tree::NodeBody","engine::DeltaOp","breaks::BreaksBaseMetric","delta::Delta","rope::Utf16CodeUnitsMetric","find::CaseMatching","breaks::BreaksMetric","rope::LinesMetric","multiset::CountMatcher","rope::BaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::TreeBuilder::<N>::push_leaf":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
+p0.push_leaf(p1);
+tree::TreeBuilder::<N>::push_leaf(p0, p1);
+crate::tree::TreeBuilder::<N>::push_leaf(p0, p1);
+<tree::TreeBuilder<N>>::push_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::push_leaf_slice
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::TreeBuilder::<N>::push_leaf_slice":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for *const T>","multiset::ZipSegment","spans::SpansInfo","find::CaseMatching","interval::Interval","tree::Node","breaks::BreaksInfo","delta::Delta","engine::DeltaOp","engine::Error","diff::DiffBuilder","spans::Span","tree::NodeVal","delta::DeltaElement","breaks::BreaksBaseMetric","rope::BaseMetric","breaks::BreaksLeaf","multiset::Subset","spans::SpansLeaf","diff::DiffOp","delta::InsertDelta","breaks::BreaksMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::FullPriority","rope::RopeInfo","rope::LinesMetric","engine::RevId","tree::NodeBody","engine::Contents","multiset::CountMatcher"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric","engine::Error","diff::DiffOp","rope::RopeInfo","breaks::BreaksBaseMetric","tree::NodeVal","engine::RevId","multiset::Subset","rope::LinesMetric","delta::InsertDelta","multiset::Segment","delta::Delta","delta::DeltaElement","breaks::BreaksMetric","spans::Span","tree::Node","multiset::ZipSegment","interval::Interval","engine::DeltaOp","diff::DiffBuilder","breaks::BreaksLeaf","find::CaseMatching","spans::SpansLeaf","engine::Contents","spans::SpansInfo","tree::NodeBody"]},"spans::SpansLeaf":{"T":["tree::Node","engine::DeltaOp","diff::DiffBuilder","tree::NodeVal","rope::LinesMetric","interval::Interval","multiset::CountMatcher","breaks::BreaksLeaf","breaks::BreaksMetric","spans::SpansInfo","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","multiset::ZipSegment","multiset::Segment","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","engine::Error","find::CaseMatching","delta::InsertDelta","breaks::BreaksInfo","spans::Span","tree::NodeBody","engine::RevId","rope::BaseMetric","multiset::Subset","diff::DiffOp","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","breaks::BreaksBaseMetric","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::TreeBuilder::<N>::push_leaf_slice":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
let mut p1 = & MaybeUninit::uninit().assume_init(); // <N as tree::NodeInfo>::L
let mut p2 = MaybeUninit::uninit().assume_init(); // interval::Interval
+p0.push_leaf_slice(p1, p2);
+tree::TreeBuilder::<N>::push_leaf_slice(p0, p1, p2);
+crate::tree::TreeBuilder::<N>::push_leaf_slice(p0, p1, p2);
+<tree::TreeBuilder<N>>::push_leaf_slice(p0, p1, p2);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::build
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::TreeBuilder::<N>::build":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["engine::DeltaOp","diff::DiffBuilder","engine::Error","breaks::BreaksMetric","find::CaseMatching","breaks::BreaksInfo","spans::SpansLeaf","multiset::Segment","multiset::Subset","breaks::BreaksBaseMetric","tree::NodeVal","engine::Contents","engine::FullPriority","multiset::ZipSegment","multiset::CountMatcher","interval::Interval","delta::Delta","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","rope::LinesMetric","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","rope::BaseMetric","engine::RevId","tree::Node","rope::RopeInfo","tree::NodeBody","breaks::BreaksLeaf","delta::DeltaElement","spans::Span","spans::SpansInfo"]},"spans::SpansInfo":{"T":["tree::NodeVal","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric","tree::Node","diff::DiffBuilder","breaks::BreaksLeaf","diff::DiffOp","find::CaseMatching","rope::RopeInfo","interval::Interval","engine::Contents","rope::BaseMetric","tree::NodeBody","multiset::Segment","engine::FullPriority","multiset::ZipSegment","multiset::CountMatcher","rope::LinesMetric","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","delta::DeltaElement","engine::Error","engine::DeltaOp","breaks::BreaksInfo","spans::SpansLeaf","delta::InsertDelta","engine::RevId","multiset::Subset","spans::Span","delta::Delta"]},"spans::SpansLeaf":{"T":["delta::Delta","tree::Node","rope::RopeInfo","multiset::Segment","rope::BaseMetric","engine::DeltaOp","engine::RevId","breaks::BreaksBaseMetric","spans::Span","breaks::BreaksLeaf","diff::DiffBuilder","delta::InsertDelta","breaks::BreaksInfo","diff::DiffOp","delta::DeltaElement","find::CaseMatching","rope::LinesMetric","breaks::BreaksMetric","engine::Contents","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","interval::Interval","multiset::Subset","tree::NodeVal","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","tree::NodeBody","engine::FullPriority","spans::SpansLeaf","rope::Utf16CodeUnitsMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::TreeBuilder::<N>::build":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
+p0.build();
+tree::TreeBuilder::<N>::build(p0);
+crate::tree::TreeBuilder::<N>::build(p0);
+<tree::TreeBuilder<N>>::build(p0);
-----------------
rope/src/tree.rs tree::TreeBuilder::<N>::pop
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::TreeBuilder::<N>::pop":{"N":["std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["multiset::Subset","rope::Utf16CodeUnitsMetric","spans::Span","engine::FullPriority","delta::Delta","diff::DiffBuilder","engine::RevId","breaks::BreaksBaseMetric","multiset::CountMatcher","engine::Contents","breaks::BreaksInfo","breaks::BreaksMetric","spans::SpansLeaf","diff::DiffOp","rope::RopeInfo","engine::DeltaOp","find::CaseMatching","rope::BaseMetric","tree::Node","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansInfo","rope::LinesMetric","interval::Interval","tree::NodeBody","delta::InsertDelta","delta::DeltaElement","breaks::BreaksLeaf","engine::Error","multiset::ZipSegment","tree::NodeVal"]},"spans::SpansInfo":{"T":["engine::FullPriority","breaks::BreaksInfo","multiset::Segment","multiset::CountMatcher","delta::DeltaElement","engine::DeltaOp","rope::BaseMetric","tree::Node","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksMetric","delta::InsertDelta","breaks::BreaksLeaf","tree::NodeVal","spans::SpansLeaf","multiset::ZipSegment","tree::NodeBody","interval::Interval","rope::Utf16CodeUnitsMetric","find::CaseMatching","diff::DiffOp","engine::RevId","delta::Delta","breaks::BreaksBaseMetric","diff::DiffBuilder","engine::Contents","rope::RopeInfo","spans::Span","spans::SpansInfo","engine::Error","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["spans::SpansInfo","breaks::BreaksBaseMetric","multiset::Segment","spans::SpansLeaf","rope::LinesMetric","tree::NodeBody","engine::DeltaOp","multiset::CountMatcher","find::CaseMatching","diff::DiffOp","engine::RevId","rope::Utf16CodeUnitsMetric","tree::NodeVal","delta::Delta","rope::BaseMetric","breaks::BreaksInfo","tree::Node","engine::Error","interval::Interval","delta::InsertDelta","multiset::ZipSegment","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","spans::Span","breaks::BreaksLeaf","rope::RopeInfo","diff::DiffBuilder","breaks::BreaksMetric","multiset::Subset","engine::Contents","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::TreeBuilder::<N>::pop":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::TreeBuilder<N>
+p0.pop();
+tree::TreeBuilder::<N>::pop(p0);
+crate::tree::TreeBuilder::<N>::pop(p0);
+<tree::TreeBuilder<N>>::pop(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::new
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::new":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::Error","tree::NodeVal","spans::SpansInfo","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","breaks::BreaksInfo","interval::Interval","engine::RevId","tree::Node","breaks::BreaksMetric","rope::RopeInfo","diff::DiffOp","multiset::Subset","multiset::CountMatcher","engine::Contents","breaks::BreaksBaseMetric","find::CaseMatching","delta::InsertDelta","diff::DiffBuilder","rope::LinesMetric","multiset::ZipSegment","tree::NodeBody","engine::DeltaOp","spans::SpansLeaf","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","multiset::Segment","spans::Span","rope::BaseMetric","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"spans::SpansInfo":{"T":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::BaseMetric","tree::NodeBody","delta::DeltaElement","engine::Error","engine::RevId","multiset::ZipSegment","diff::DiffBuilder","delta::InsertDelta","tree::NodeVal","rope::LinesMetric","multiset::CountMatcher","breaks::BreaksLeaf","spans::Span","diff::DiffOp","spans::SpansInfo","find::CaseMatching","rope::RopeInfo","engine::FullPriority","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &T>","engine::Contents","multiset::Segment","delta::Delta","tree::Node","interval::Interval","spans::SpansLeaf","multiset::Subset","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric"]},"spans::SpansLeaf":{"T":["multiset::Subset","breaks::BreaksMetric","multiset::ZipSegment","spans::SpansLeaf","breaks::BreaksLeaf","multiset::CountMatcher","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","rope::RopeInfo","diff::DiffBuilder","diff::DiffOp","spans::SpansInfo","engine::Error","tree::NodeBody","engine::FullPriority","tree::NodeVal","rope::Utf16CodeUnitsMetric","engine::Contents","tree::Node","multiset::Segment","breaks::BreaksBaseMetric","engine::RevId","spans::Span","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for &T>","engine::DeltaOp","rope::LinesMetric","delta::Delta","delta::DeltaElement","breaks::BreaksInfo","interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::new":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Node<N>
let mut p1 = 0usize; // None+usize
+tree::Cursor::<'a, N>::new(p0, p1);
+crate::tree::Cursor::<'a, N>::new(p0, p1);
+<tree::Cursor<'a, N>>::new(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::total_len
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::total_len":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::ZipSegment","tree::Node","rope::LinesMetric","spans::SpansInfo","engine::RevId","rope::Utf16CodeUnitsMetric","delta::InsertDelta","breaks::BreaksInfo","breaks::BreaksMetric","delta::DeltaElement","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","engine::DeltaOp","interval::Interval","rope::RopeInfo","breaks::BreaksLeaf","rope::BaseMetric","spans::SpansLeaf","engine::FullPriority","delta::Delta","engine::Contents","spans::Span","engine::Error","diff::DiffBuilder","tree::NodeBody","multiset::Segment","breaks::BreaksBaseMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &T>","tree::NodeVal","multiset::Subset"]},"spans::SpansInfo":{"T":["spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksInfo","spans::SpansInfo","spans::SpansLeaf","engine::RevId","diff::DiffBuilder","engine::FullPriority","breaks::BreaksLeaf","tree::NodeBody","multiset::Subset","engine::Error","find::CaseMatching","tree::Node","delta::DeltaElement","interval::Interval","rope::RopeInfo","delta::InsertDelta","engine::Contents","multiset::Segment","rope::LinesMetric","multiset::CountMatcher","diff::DiffOp","tree::NodeVal","multiset::ZipSegment","engine::DeltaOp","delta::Delta","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["tree::Node","delta::InsertDelta","multiset::CountMatcher","multiset::Segment","rope::LinesMetric","delta::Delta","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Error","diff::DiffBuilder","rope::RopeInfo","tree::NodeVal","interval::Interval","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","multiset::Subset","engine::FullPriority","tree::NodeBody","rope::BaseMetric","spans::SpansLeaf","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksMetric","spans::Span","engine::Contents","breaks::BreaksBaseMetric","delta::DeltaElement","engine::DeltaOp","engine::RevId","spans::SpansInfo","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::total_len":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.total_len();
+tree::Cursor::<'a, N>::total_len(p0);
+crate::tree::Cursor::<'a, N>::total_len(p0);
+<tree::Cursor<'a, N>>::total_len(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::root
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::root":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::ZipSegment","find::CaseMatching","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","interval::Interval","tree::Node","multiset::CountMatcher","delta::DeltaElement","delta::InsertDelta","breaks::BreaksBaseMetric","breaks::BreaksMetric","spans::SpansLeaf","breaks::BreaksLeaf","rope::LinesMetric","engine::Contents","multiset::Segment","delta::Delta","spans::Span","multiset::Subset","rope::Utf16CodeUnitsMetric","engine::RevId","engine::Error","engine::DeltaOp","tree::NodeBody","engine::FullPriority","rope::RopeInfo","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksInfo","diff::DiffOp","tree::NodeVal","rope::BaseMetric"]},"spans::SpansInfo":{"T":["delta::InsertDelta","spans::SpansInfo","multiset::Subset","engine::DeltaOp","spans::Span","multiset::ZipSegment","breaks::BreaksLeaf","rope::RopeInfo","multiset::Segment","engine::RevId","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","rope::BaseMetric","find::CaseMatching","breaks::BreaksInfo","engine::FullPriority","delta::Delta","tree::NodeBody","breaks::BreaksBaseMetric","interval::Interval","breaks::BreaksMetric","diff::DiffBuilder","tree::NodeVal","rope::LinesMetric","engine::Error","spans::SpansLeaf","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &mut T>","diff::DiffOp","tree::Node","engine::Contents"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","engine::DeltaOp","breaks::BreaksBaseMetric","spans::SpansLeaf","find::CaseMatching","breaks::BreaksLeaf","diff::DiffOp","tree::NodeVal","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","delta::Delta","diff::DiffBuilder","engine::Error","multiset::ZipSegment","multiset::Subset","breaks::BreaksInfo","interval::Interval","tree::NodeBody","breaks::BreaksMetric","multiset::CountMatcher","rope::LinesMetric","engine::Contents","engine::FullPriority","engine::RevId","delta::DeltaElement","spans::SpansInfo","multiset::Segment","rope::BaseMetric","tree::Node","spans::Span"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::root":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.root();
+tree::Cursor::<'a, N>::root(p0);
+crate::tree::Cursor::<'a, N>::root(p0);
+<tree::Cursor<'a, N>>::root(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::get_leaf
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::get_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::NodeInfo","std::clone::Clone","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["tree::Node","delta::DeltaElement","delta::InsertDelta","rope::LinesMetric","breaks::BreaksMetric","tree::NodeBody","multiset::Subset","delta::Delta","diff::DiffOp","breaks::BreaksLeaf","tree::NodeVal","rope::BaseMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","engine::DeltaOp","find::CaseMatching","interval::Interval","spans::Span","multiset::Segment","breaks::BreaksInfo","engine::FullPriority","engine::Error","rope::RopeInfo","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","spans::SpansInfo","multiset::CountMatcher","diff::DiffBuilder","engine::Contents"]},"spans::SpansInfo":{"T":["rope::LinesMetric","interval::Interval","engine::RevId","rope::RopeInfo","rope::BaseMetric","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","engine::Error","tree::Node","breaks::BreaksMetric","engine::Contents","delta::Delta","engine::FullPriority","diff::DiffBuilder","spans::SpansInfo","delta::InsertDelta","breaks::BreaksInfo","multiset::Subset","breaks::BreaksBaseMetric","delta::DeltaElement","multiset::CountMatcher","engine::DeltaOp","spans::SpansLeaf","multiset::ZipSegment","spans::Span","rope::Utf16CodeUnitsMetric","multiset::Segment","breaks::BreaksLeaf","find::CaseMatching","diff::DiffOp","tree::NodeBody"]},"spans::SpansLeaf":{"T":["tree::NodeVal","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","rope::BaseMetric","delta::InsertDelta","multiset::Segment","rope::LinesMetric","engine::Contents","spans::Span","breaks::BreaksInfo","diff::DiffBuilder","spans::SpansLeaf","spans::SpansInfo","find::CaseMatching","engine::Error","engine::RevId","tree::NodeBody","breaks::BreaksLeaf","tree::Node","interval::Interval","delta::Delta","engine::DeltaOp","multiset::Subset","breaks::BreaksBaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","multiset::CountMatcher","diff::DiffOp","engine::FullPriority","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::get_leaf":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.get_leaf();
+tree::Cursor::<'a, N>::get_leaf(p0);
+crate::tree::Cursor::<'a, N>::get_leaf(p0);
+<tree::Cursor<'a, N>>::get_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::set
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::set":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","find::CaseMatching","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","spans::SpansInfo","engine::DeltaOp","spans::SpansLeaf","multiset::Segment","rope::BaseMetric","diff::DiffOp","multiset::Subset","delta::Delta","breaks::BreaksInfo","breaks::BreaksLeaf","delta::DeltaElement","rope::LinesMetric","multiset::CountMatcher","engine::Error","interval::Interval","tree::NodeBody","engine::Contents","spans::Span","tree::NodeVal","delta::InsertDelta","engine::RevId","diff::DiffBuilder","rope::RopeInfo","tree::Node","breaks::BreaksBaseMetric","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"spans::SpansInfo":{"T":["multiset::Segment","multiset::ZipSegment","spans::SpansInfo","spans::Span","rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksLeaf","rope::RopeInfo","delta::DeltaElement","multiset::Subset","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","tree::Node","tree::NodeVal","tree::NodeBody","engine::Error","multiset::CountMatcher","breaks::BreaksBaseMetric","delta::InsertDelta","engine::Contents","engine::RevId","rope::LinesMetric","engine::FullPriority","diff::DiffOp","breaks::BreaksInfo","spans::SpansLeaf","find::CaseMatching","delta::Delta","engine::DeltaOp","diff::DiffBuilder","interval::Interval"]},"spans::SpansLeaf":{"T":["delta::Delta","interval::Interval","breaks::BreaksMetric","engine::Contents","breaks::BreaksBaseMetric","engine::RevId","multiset::Subset","tree::NodeVal","tree::Node","spans::Span","rope::BaseMetric","engine::Error","delta::InsertDelta","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","diff::DiffOp","multiset::Segment","tree::NodeBody","delta::DeltaElement","multiset::CountMatcher","rope::RopeInfo","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","find::CaseMatching","rope::LinesMetric","engine::FullPriority","spans::SpansInfo","engine::DeltaOp","breaks::BreaksInfo","spans::SpansLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::set":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.set(p1);
+tree::Cursor::<'a, N>::set(p0, p1);
+crate::tree::Cursor::<'a, N>::set(p0, p1);
+<tree::Cursor<'a, N>>::set(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::pos
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::pos":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["diff::DiffOp","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksLeaf","breaks::BreaksInfo","spans::SpansInfo","diff::DiffBuilder","multiset::ZipSegment","breaks::BreaksMetric","rope::BaseMetric","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::InsertDelta","breaks::BreaksBaseMetric","engine::FullPriority","delta::DeltaElement","tree::NodeBody","interval::Interval","spans::Span","multiset::CountMatcher","engine::Error","tree::Node","rope::RopeInfo","engine::Contents","delta::Delta","multiset::Subset","engine::RevId","rope::Utf16CodeUnitsMetric","rope::LinesMetric","tree::NodeVal","spans::SpansLeaf","multiset::Segment"]},"spans::SpansInfo":{"T":["rope::Utf16CodeUnitsMetric","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","tree::NodeBody","spans::SpansLeaf","delta::DeltaElement","multiset::Subset","tree::Node","multiset::ZipSegment","engine::DeltaOp","breaks::BreaksBaseMetric","spans::Span","diff::DiffBuilder","multiset::CountMatcher","engine::FullPriority","find::CaseMatching","interval::Interval","engine::Contents","engine::RevId","breaks::BreaksInfo","diff::DiffOp","spans::SpansInfo","engine::Error","multiset::Segment","breaks::BreaksMetric","delta::InsertDelta","delta::Delta","rope::LinesMetric","breaks::BreaksLeaf","rope::BaseMetric"]},"spans::SpansLeaf":{"T":["multiset::Segment","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksBaseMetric","interval::Interval","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","find::CaseMatching","engine::FullPriority","tree::NodeBody","rope::RopeInfo","multiset::ZipSegment","diff::DiffBuilder","rope::LinesMetric","tree::NodeVal","engine::Error","engine::DeltaOp","rope::Utf16CodeUnitsMetric","delta::Delta","engine::Contents","diff::DiffOp","multiset::Subset","spans::SpansLeaf","spans::Span","delta::InsertDelta","spans::SpansInfo","multiset::CountMatcher","rope::BaseMetric","engine::RevId","breaks::BreaksInfo","breaks::BreaksLeaf"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::pos":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.pos();
+tree::Cursor::<'a, N>::pos(p0);
+crate::tree::Cursor::<'a, N>::pos(p0);
+<tree::Cursor<'a, N>>::pos(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::is_boundary
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::is_boundary":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::clone::Clone","tree::DefaultMetric","tree::NodeInfo","std::marker::Sized"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["interval::Interval","spans::Span","diff::DiffBuilder","tree::NodeVal","engine::FullPriority","engine::DeltaOp","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","breaks::BreaksInfo","rope::LinesMetric","find::CaseMatching","delta::Delta","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &T>","multiset::ZipSegment","delta::DeltaElement","tree::NodeBody","engine::RevId","multiset::Segment","tree::Node","engine::Error","engine::Contents","multiset::CountMatcher","delta::InsertDelta","spans::SpansLeaf","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","diff::DiffOp","breaks::BreaksMetric","rope::RopeInfo","rope::BaseMetric","multiset::Subset"]},"spans::SpansInfo":{"T":["rope::LinesMetric","diff::DiffOp","engine::RevId","breaks::BreaksInfo","tree::NodeVal","multiset::Segment","engine::Contents","spans::SpansInfo","engine::Error","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksLeaf","breaks::BreaksBaseMetric","spans::Span","engine::FullPriority","multiset::CountMatcher","interval::Interval","multiset::ZipSegment","spans::SpansLeaf","find::CaseMatching","rope::RopeInfo","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::Delta","multiset::Subset","breaks::BreaksMetric","tree::Node","delta::InsertDelta","delta::DeltaElement","tree::NodeBody","rope::BaseMetric","engine::DeltaOp"]},"spans::SpansLeaf":{"T":["engine::RevId","multiset::ZipSegment","interval::Interval","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","rope::Utf16CodeUnitsMetric","tree::NodeBody","std::clone::impls::<impl std::clone::Clone for *const T>","diff::DiffBuilder","spans::SpansLeaf","spans::Span","tree::NodeVal","engine::Contents","engine::FullPriority","tree::Node","engine::DeltaOp","delta::InsertDelta","engine::Error","delta::DeltaElement","find::CaseMatching","multiset::Subset","diff::DiffOp","rope::LinesMetric","delta::Delta","rope::RopeInfo","multiset::CountMatcher","multiset::Segment","breaks::BreaksMetric","breaks::BreaksLeaf","spans::SpansInfo","rope::BaseMetric","breaks::BreaksBaseMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::is_boundary":{"M":["breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.is_boundary();
+tree::Cursor::<'a, N>::is_boundary(p0);
+crate::tree::Cursor::<'a, N>::is_boundary(p0);
+<tree::Cursor<'a, N>>::is_boundary(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::prev
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::clone::Clone","std::marker::Sized","tree::DefaultMetric","tree::NodeInfo"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","tree::NodeVal","diff::DiffOp","spans::Span","engine::Error","interval::Interval","breaks::BreaksLeaf","tree::NodeBody","multiset::ZipSegment","spans::SpansLeaf","breaks::BreaksMetric","multiset::Segment","spans::SpansInfo","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","rope::BaseMetric","tree::Node","rope::LinesMetric","delta::DeltaElement","delta::Delta","delta::InsertDelta","rope::RopeInfo","engine::DeltaOp","diff::DiffBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::FullPriority","engine::Contents","multiset::Subset","find::CaseMatching"]},"spans::SpansInfo":{"T":["multiset::Subset","multiset::ZipSegment","multiset::Segment","spans::Span","find::CaseMatching","multiset::CountMatcher","breaks::BreaksLeaf","tree::NodeBody","rope::Utf16CodeUnitsMetric","engine::FullPriority","diff::DiffBuilder","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &T>","delta::DeltaElement","breaks::BreaksInfo","rope::RopeInfo","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::LinesMetric","tree::Node","rope::BaseMetric","tree::NodeVal","interval::Interval","delta::InsertDelta","engine::Contents","delta::Delta","engine::DeltaOp","engine::Error","diff::DiffOp","spans::SpansInfo","engine::RevId"]},"spans::SpansLeaf":{"T":["tree::NodeVal","spans::SpansInfo","rope::Utf16CodeUnitsMetric","engine::RevId","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","diff::DiffOp","tree::Node","delta::Delta","multiset::Subset","multiset::ZipSegment","spans::SpansLeaf","delta::InsertDelta","delta::DeltaElement","tree::NodeBody","diff::DiffBuilder","engine::DeltaOp","interval::Interval","find::CaseMatching","breaks::BreaksBaseMetric","multiset::Segment","engine::Contents","spans::Span","rope::BaseMetric","breaks::BreaksInfo","multiset::CountMatcher","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::FullPriority","breaks::BreaksMetric","rope::LinesMetric","rope::RopeInfo","engine::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev":{"M":["rope::BaseMetric","rope::LinesMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.prev();
+tree::Cursor::<'a, N>::prev(p0);
+crate::tree::Cursor::<'a, N>::prev(p0);
+<tree::Cursor<'a, N>>::prev(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::Error","rope::RopeInfo","breaks::BreaksBaseMetric","breaks::BreaksMetric","multiset::ZipSegment","interval::Interval","multiset::Subset","tree::NodeVal","spans::SpansInfo","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::Contents","rope::Utf16CodeUnitsMetric","find::CaseMatching","delta::DeltaElement","spans::SpansLeaf","spans::Span","breaks::BreaksLeaf","breaks::BreaksInfo","rope::BaseMetric","multiset::Segment","rope::LinesMetric","diff::DiffOp","delta::Delta","multiset::CountMatcher","tree::NodeBody","engine::FullPriority","engine::RevId","engine::DeltaOp","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","delta::InsertDelta"]},"spans::SpansInfo":{"T":["engine::FullPriority","multiset::CountMatcher","delta::Delta","engine::RevId","interval::Interval","rope::RopeInfo","multiset::Segment","tree::Node","breaks::BreaksInfo","diff::DiffOp","multiset::Subset","delta::InsertDelta","engine::DeltaOp","rope::BaseMetric","engine::Error","spans::Span","breaks::BreaksLeaf","delta::DeltaElement","std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric","tree::NodeBody","multiset::ZipSegment","diff::DiffBuilder","spans::SpansLeaf","tree::NodeVal","rope::LinesMetric","spans::SpansInfo","engine::Contents"]},"spans::SpansLeaf":{"T":["spans::SpansLeaf","multiset::ZipSegment","breaks::BreaksLeaf","diff::DiffBuilder","diff::DiffOp","breaks::BreaksBaseMetric","engine::RevId","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::Delta","tree::NodeVal","rope::BaseMetric","interval::Interval","breaks::BreaksMetric","rope::Utf16CodeUnitsMetric","engine::Contents","tree::NodeBody","delta::InsertDelta","tree::Node","std::clone::impls::<impl std::clone::Clone for &T>","multiset::CountMatcher","breaks::BreaksInfo","rope::RopeInfo","engine::Error","multiset::Subset","spans::Span","engine::DeltaOp","delta::DeltaElement","rope::LinesMetric","find::CaseMatching","multiset::Segment","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next":{"M":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next();
+tree::Cursor::<'a, N>::next(p0);
+crate::tree::Cursor::<'a, N>::next(p0);
+<tree::Cursor<'a, N>>::next(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::at_or_next
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_next":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::clone::Clone","tree::NodeInfo","tree::DefaultMetric","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["spans::SpansInfo","breaks::BreaksMetric","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffOp","multiset::ZipSegment","delta::InsertDelta","engine::DeltaOp","engine::Contents","tree::NodeVal","find::CaseMatching","multiset::Subset","tree::NodeBody","rope::RopeInfo","rope::BaseMetric","spans::SpansLeaf","breaks::BreaksInfo","engine::Error","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","breaks::BreaksBaseMetric","delta::DeltaElement","interval::Interval","tree::Node","multiset::Segment","spans::Span","breaks::BreaksLeaf","multiset::CountMatcher","rope::LinesMetric","delta::Delta","engine::FullPriority","rope::Utf16CodeUnitsMetric"]},"spans::SpansInfo":{"T":["delta::Delta","breaks::BreaksMetric","spans::Span","multiset::CountMatcher","rope::RopeInfo","delta::DeltaElement","tree::Node","tree::NodeVal","tree::NodeBody","engine::FullPriority","spans::SpansLeaf","engine::Error","rope::LinesMetric","engine::DeltaOp","rope::BaseMetric","breaks::BreaksBaseMetric","engine::RevId","interval::Interval","delta::InsertDelta","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for *const T>","engine::Contents","multiset::Subset","multiset::ZipSegment","diff::DiffOp","multiset::Segment","spans::SpansInfo","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","diff::DiffBuilder","find::CaseMatching"]},"spans::SpansLeaf":{"T":["tree::NodeBody","spans::SpansLeaf","multiset::Subset","breaks::BreaksLeaf","engine::RevId","engine::DeltaOp","engine::Contents","interval::Interval","spans::SpansInfo","diff::DiffOp","rope::BaseMetric","engine::Error","breaks::BreaksBaseMetric","rope::RopeInfo","breaks::BreaksInfo","multiset::Segment","spans::Span","find::CaseMatching","engine::FullPriority","delta::DeltaElement","delta::Delta","multiset::ZipSegment","multiset::CountMatcher","delta::InsertDelta","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","rope::Utf16CodeUnitsMetric","tree::Node","breaks::BreaksMetric","diff::DiffBuilder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_next":{"M":["rope::LinesMetric","breaks::BreaksBaseMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksMetric"],"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.at_or_next();
+tree::Cursor::<'a, N>::at_or_next(p0);
+crate::tree::Cursor::<'a, N>::at_or_next(p0);
+<tree::Cursor<'a, N>>::at_or_next(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::at_or_prev
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_prev":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"spans::Span":{"T":["tree::Node","multiset::Subset","rope::RopeInfo","engine::DeltaOp","multiset::Segment","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","tree::NodeBody","engine::RevId","multiset::CountMatcher","rope::LinesMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","breaks::BreaksBaseMetric","delta::InsertDelta","multiset::ZipSegment","spans::Span","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo","breaks::BreaksMetric","delta::DeltaElement","breaks::BreaksLeaf","engine::FullPriority","engine::Error","spans::SpansInfo","interval::Interval","rope::BaseMetric","delta::Delta","diff::DiffBuilder","engine::Contents","spans::SpansLeaf"]},"spans::SpansInfo":{"T":["rope::RopeInfo","engine::Contents","delta::InsertDelta","rope::LinesMetric","tree::NodeVal","tree::NodeBody","rope::BaseMetric","breaks::BreaksInfo","diff::DiffOp","tree::Node","multiset::Segment","find::CaseMatching","spans::Span","rope::Utf16CodeUnitsMetric","delta::DeltaElement","engine::Error","delta::Delta","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","engine::RevId","multiset::Subset","engine::FullPriority","breaks::BreaksBaseMetric","interval::Interval","spans::SpansInfo","multiset::ZipSegment","breaks::BreaksLeaf","multiset::CountMatcher","breaks::BreaksMetric","engine::DeltaOp","diff::DiffBuilder"]},"spans::SpansLeaf":{"T":["multiset::Segment","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *mut T>","engine::RevId","breaks::BreaksLeaf","rope::BaseMetric","multiset::ZipSegment","spans::SpansInfo","rope::Utf16CodeUnitsMetric","multiset::Subset","tree::Node","tree::NodeBody","engine::Error","diff::DiffBuilder","find::CaseMatching","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","delta::Delta","rope::RopeInfo","diff::DiffOp","engine::Contents","engine::DeltaOp","spans::SpansLeaf","delta::DeltaElement","rope::LinesMetric","multiset::CountMatcher","interval::Interval","breaks::BreaksBaseMetric","engine::FullPriority","spans::Span"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::at_or_prev":{"M":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::LinesMetric","breaks::BreaksMetric"],"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.at_or_prev();
+tree::Cursor::<'a, N>::at_or_prev(p0);
+crate::tree::Cursor::<'a, N>::at_or_prev(p0);
+<tree::Cursor<'a, N>>::at_or_prev(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::iter
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::iter":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","find::CaseMatching","diff::DiffOp","tree::Node","rope::Utf16CodeUnitsMetric","spans::SpansLeaf","spans::SpansInfo","multiset::ZipSegment","spans::Span","diff::DiffBuilder","engine::Error","interval::Interval","delta::DeltaElement","multiset::Segment","rope::LinesMetric","tree::NodeBody","multiset::CountMatcher","tree::NodeVal","engine::DeltaOp","breaks::BreaksBaseMetric","breaks::BreaksMetric","engine::RevId","engine::Contents","rope::BaseMetric","delta::Delta","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","engine::FullPriority","rope::RopeInfo","delta::InsertDelta","multiset::Subset","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["spans::Span","rope::BaseMetric","multiset::CountMatcher","breaks::BreaksBaseMetric","diff::DiffBuilder","interval::Interval","breaks::BreaksMetric","diff::DiffOp","engine::RevId","multiset::Subset","spans::SpansLeaf","multiset::ZipSegment","multiset::Segment","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","tree::Node","engine::Error","delta::Delta","engine::DeltaOp","rope::LinesMetric","delta::DeltaElement","engine::FullPriority","rope::RopeInfo","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","tree::NodeVal","tree::NodeBody","delta::InsertDelta","breaks::BreaksInfo","find::CaseMatching","engine::Contents"]},"spans::SpansLeaf":{"T":["tree::NodeVal","rope::RopeInfo","engine::DeltaOp","engine::Error","multiset::Segment","diff::DiffBuilder","spans::SpansInfo","tree::NodeBody","find::CaseMatching","breaks::BreaksMetric","spans::SpansLeaf","multiset::CountMatcher","engine::Contents","breaks::BreaksLeaf","spans::Span","delta::InsertDelta","rope::LinesMetric","interval::Interval","multiset::Subset","rope::BaseMetric","delta::Delta","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","breaks::BreaksBaseMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","tree::Node","engine::RevId","delta::DeltaElement","rope::Utf16CodeUnitsMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::iter":{"M":["rope::LinesMetric","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric"],"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.iter();
+tree::Cursor::<'a, N>::iter(p0);
+crate::tree::Cursor::<'a, N>::iter(p0);
+<tree::Cursor<'a, N>>::iter(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::last_inside_leaf
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::last_inside_leaf":{"M":["std::marker::Sized","tree::Metric"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","tree::DefaultMetric","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"tree::NodeVal":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"spans::Span":{"T":["engine::FullPriority","breaks::BreaksInfo","rope::RopeInfo","find::CaseMatching","breaks::BreaksBaseMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","tree::Node","breaks::BreaksLeaf","multiset::Subset","rope::BaseMetric","multiset::CountMatcher","rope::LinesMetric","multiset::ZipSegment","diff::DiffBuilder","spans::SpansLeaf","engine::Contents","breaks::BreaksMetric","delta::DeltaElement","multiset::Segment","spans::Span","tree::NodeBody","interval::Interval","delta::Delta","engine::RevId","spans::SpansInfo","engine::DeltaOp","engine::Error","rope::Utf16CodeUnitsMetric","tree::NodeVal"]},"spans::SpansInfo":{"T":["breaks::BreaksInfo","engine::Contents","spans::SpansLeaf","multiset::Segment","engine::Error","tree::NodeBody","engine::RevId","delta::InsertDelta","find::CaseMatching","breaks::BreaksBaseMetric","engine::FullPriority","multiset::ZipSegment","rope::Utf16CodeUnitsMetric","rope::BaseMetric","rope::LinesMetric","interval::Interval","breaks::BreaksLeaf","delta::Delta","tree::NodeVal","std::clone::impls::<impl std::clone::Clone for &T>","rope::RopeInfo","tree::Node","spans::SpansInfo","engine::DeltaOp","breaks::BreaksMetric","delta::DeltaElement","diff::DiffBuilder","diff::DiffOp","multiset::Subset","multiset::CountMatcher","spans::Span"]},"spans::SpansLeaf":{"T":["rope::Utf16CodeUnitsMetric","spans::SpansLeaf","engine::RevId","tree::NodeBody","engine::Error","delta::Delta","interval::Interval","engine::DeltaOp","engine::Contents","multiset::Segment","delta::DeltaElement","multiset::CountMatcher","breaks::BreaksLeaf","multiset::Subset","breaks::BreaksMetric","breaks::BreaksInfo","tree::Node","diff::DiffOp","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","engine::FullPriority","find::CaseMatching","spans::SpansInfo","tree::NodeVal","breaks::BreaksBaseMetric","rope::RopeInfo","rope::LinesMetric","delta::InsertDelta","spans::Span","diff::DiffBuilder","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::last_inside_leaf":{"M":["rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","rope::BaseMetric","rope::LinesMetric","breaks::BreaksMetric"],"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.last_inside_leaf(p1);
+tree::Cursor::<'a, N>::last_inside_leaf(p0, p1);
+crate::tree::Cursor::<'a, N>::last_inside_leaf(p0, p1);
+<tree::Cursor<'a, N>>::last_inside_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next_inside_leaf
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_inside_leaf":{"M":["tree::Metric","std::marker::Sized"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["interval::Interval","engine::FullPriority","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","tree::NodeBody","spans::Span","engine::Error","delta::DeltaElement","engine::Contents","rope::LinesMetric","delta::InsertDelta","find::CaseMatching","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansInfo","rope::RopeInfo","multiset::Subset","diff::DiffOp","multiset::Segment","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksMetric","rope::BaseMetric","engine::DeltaOp","tree::Node","breaks::BreaksBaseMetric","engine::RevId","delta::Delta","spans::SpansLeaf","tree::NodeVal","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder"]},"spans::SpansInfo":{"T":["find::CaseMatching","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::CountMatcher","engine::FullPriority","rope::RopeInfo","spans::SpansInfo","breaks::BreaksLeaf","spans::Span","engine::RevId","diff::DiffBuilder","tree::NodeBody","rope::Utf16CodeUnitsMetric","engine::Error","engine::DeltaOp","delta::DeltaElement","multiset::ZipSegment","engine::Contents","breaks::BreaksInfo","interval::Interval","delta::InsertDelta","breaks::BreaksMetric","multiset::Segment","delta::Delta","diff::DiffOp","rope::LinesMetric","spans::SpansLeaf","tree::NodeVal","tree::Node","breaks::BreaksBaseMetric","multiset::Subset"]},"spans::SpansLeaf":{"T":["delta::InsertDelta","rope::RopeInfo","delta::DeltaElement","tree::NodeBody","breaks::BreaksMetric","tree::Node","spans::SpansLeaf","breaks::BreaksInfo","engine::RevId","breaks::BreaksBaseMetric","engine::DeltaOp","diff::DiffBuilder","delta::Delta","spans::SpansInfo","engine::Error","multiset::Segment","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","diff::DiffOp","multiset::Subset","tree::NodeVal","spans::Span","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","find::CaseMatching","engine::Contents","rope::BaseMetric","engine::FullPriority","multiset::CountMatcher","rope::LinesMetric","multiset::ZipSegment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_inside_leaf":{"M":["breaks::BreaksBaseMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksMetric"],"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next_inside_leaf();
+tree::Cursor::<'a, N>::next_inside_leaf(p0);
+crate::tree::Cursor::<'a, N>::next_inside_leaf(p0);
+<tree::Cursor<'a, N>>::next_inside_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::next_leaf
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_leaf":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::DeltaElement","engine::RevId","multiset::Subset","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","spans::Span","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::LinesMetric","breaks::BreaksMetric","breaks::BreaksLeaf","engine::FullPriority","find::CaseMatching","multiset::CountMatcher","breaks::BreaksBaseMetric","tree::NodeVal","spans::SpansInfo","multiset::ZipSegment","spans::SpansLeaf","delta::Delta","multiset::Segment","engine::DeltaOp","tree::NodeBody","rope::BaseMetric","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","delta::InsertDelta","engine::Error","breaks::BreaksInfo","rope::RopeInfo","engine::Contents","interval::Interval"]},"spans::SpansInfo":{"T":["breaks::BreaksMetric","spans::SpansLeaf","multiset::Segment","find::CaseMatching","rope::Utf16CodeUnitsMetric","delta::InsertDelta","tree::Node","spans::Span","rope::BaseMetric","engine::Error","tree::NodeBody","engine::Contents","multiset::Subset","rope::RopeInfo","engine::FullPriority","engine::DeltaOp","breaks::BreaksInfo","interval::Interval","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksBaseMetric","engine::RevId","diff::DiffOp","multiset::ZipSegment","delta::DeltaElement","diff::DiffBuilder","multiset::CountMatcher","tree::NodeVal","breaks::BreaksLeaf","delta::Delta","spans::SpansInfo","rope::LinesMetric"]},"spans::SpansLeaf":{"T":["find::CaseMatching","breaks::BreaksLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","breaks::BreaksMetric","engine::Contents","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","delta::DeltaElement","delta::Delta","rope::BaseMetric","spans::SpansInfo","breaks::BreaksBaseMetric","spans::Span","interval::Interval","multiset::Subset","engine::Error","delta::InsertDelta","tree::NodeVal","tree::Node","rope::LinesMetric","tree::NodeBody","multiset::ZipSegment","engine::RevId","diff::DiffOp","spans::SpansLeaf","breaks::BreaksInfo","multiset::CountMatcher","rope::RopeInfo","rope::Utf16CodeUnitsMetric","engine::FullPriority","engine::DeltaOp","multiset::Segment"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::next_leaf":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.next_leaf();
+tree::Cursor::<'a, N>::next_leaf(p0);
+crate::tree::Cursor::<'a, N>::next_leaf(p0);
+<tree::Cursor<'a, N>>::next_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::prev_leaf
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev_leaf":{"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::DefaultMetric","tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeBody":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeVal":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::ZipSegment","engine::Error","breaks::BreaksLeaf","rope::Utf16CodeUnitsMetric","delta::DeltaElement","multiset::Segment","breaks::BreaksBaseMetric","std::clone::impls::<impl std::clone::Clone for *mut T>","breaks::BreaksInfo","diff::DiffBuilder","rope::LinesMetric","engine::FullPriority","spans::SpansLeaf","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::BaseMetric","tree::NodeBody","engine::RevId","tree::Node","engine::DeltaOp","interval::Interval","multiset::CountMatcher","find::CaseMatching","multiset::Subset","spans::SpansInfo","delta::Delta","breaks::BreaksMetric","tree::NodeVal","delta::InsertDelta","spans::Span","engine::Contents","diff::DiffOp"]},"spans::SpansInfo":{"T":["tree::NodeVal","spans::Span","diff::DiffOp","interval::Interval","delta::DeltaElement","rope::BaseMetric","breaks::BreaksInfo","delta::Delta","engine::DeltaOp","multiset::CountMatcher","multiset::ZipSegment","breaks::BreaksLeaf","engine::Contents","tree::Node","multiset::Segment","engine::RevId","engine::Error","multiset::Subset","rope::RopeInfo","spans::SpansInfo","breaks::BreaksMetric","diff::DiffBuilder","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for *const T>","rope::Utf16CodeUnitsMetric","breaks::BreaksBaseMetric","tree::NodeBody","engine::FullPriority","rope::LinesMetric","find::CaseMatching","spans::SpansLeaf"]},"spans::SpansLeaf":{"T":["rope::RopeInfo","spans::Span","delta::DeltaElement","engine::Error","rope::BaseMetric","interval::Interval","spans::SpansInfo","breaks::BreaksBaseMetric","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for *mut T>","spans::SpansLeaf","find::CaseMatching","engine::Contents","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Segment","multiset::CountMatcher","delta::InsertDelta","multiset::ZipSegment","diff::DiffOp","rope::Utf16CodeUnitsMetric","engine::DeltaOp","breaks::BreaksInfo","tree::NodeVal","multiset::Subset","tree::NodeBody","tree::Node","breaks::BreaksMetric","engine::RevId","rope::LinesMetric","diff::DiffBuilder","breaks::BreaksLeaf","delta::Delta"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::prev_leaf":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.prev_leaf();
+tree::Cursor::<'a, N>::prev_leaf(p0);
+crate::tree::Cursor::<'a, N>::prev_leaf(p0);
+<tree::Cursor<'a, N>>::prev_leaf(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::descend
'a
deps:{"delta::Delta":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::DeltaElement":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend":{"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["tree::DefaultMetric","std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["find::CaseMatching","engine::Contents","tree::NodeBody","interval::Interval","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::InsertDelta","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","rope::LinesMetric","tree::Node","breaks::BreaksMetric","spans::SpansLeaf","multiset::CountMatcher","multiset::Segment","rope::BaseMetric","engine::FullPriority","diff::DiffOp","rope::RopeInfo","spans::SpansInfo","breaks::BreaksLeaf","engine::RevId","engine::DeltaOp","engine::Error","breaks::BreaksBaseMetric","multiset::Subset","tree::NodeVal","delta::DeltaElement","multiset::ZipSegment","diff::DiffBuilder","spans::Span","rope::Utf16CodeUnitsMetric","breaks::BreaksInfo"]},"spans::SpansInfo":{"T":["diff::DiffOp","multiset::Segment","spans::SpansInfo","rope::BaseMetric","multiset::ZipSegment","interval::Interval","engine::RevId","rope::RopeInfo","std::clone::impls::<impl std::clone::Clone for &T>","spans::SpansLeaf","engine::Error","delta::InsertDelta","breaks::BreaksLeaf","multiset::Subset","multiset::CountMatcher","spans::Span","engine::DeltaOp","delta::DeltaElement","delta::Delta","breaks::BreaksMetric","tree::NodeVal","rope::LinesMetric","find::CaseMatching","engine::FullPriority","engine::Contents","diff::DiffBuilder","breaks::BreaksBaseMetric","tree::Node","rope::Utf16CodeUnitsMetric","tree::NodeBody","breaks::BreaksInfo"]},"spans::SpansLeaf":{"T":["delta::DeltaElement","diff::DiffBuilder","rope::LinesMetric","engine::FullPriority","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","tree::Node","multiset::Segment","breaks::BreaksInfo","rope::BaseMetric","breaks::BreaksLeaf","interval::Interval","breaks::BreaksBaseMetric","tree::NodeVal","spans::SpansLeaf","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","find::CaseMatching","delta::Delta","tree::NodeBody","multiset::CountMatcher","delta::InsertDelta","diff::DiffOp","engine::DeltaOp","engine::Error","multiset::Subset","spans::Span","rope::RopeInfo","engine::RevId","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
+p0.descend();
+tree::Cursor::<'a, N>::descend(p0);
+crate::tree::Cursor::<'a, N>::descend(p0);
+<tree::Cursor<'a, N>>::descend(p0);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::measure_leaf
'a
deps:{"delta::Delta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::measure_leaf":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"tree::Node":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["delta::DeltaElement","delta::Delta","breaks::BreaksBaseMetric","rope::BaseMetric","rope::Utf16CodeUnitsMetric","engine::Contents","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::NodeVal","diff::DiffOp","interval::Interval","multiset::Segment","breaks::BreaksMetric","engine::FullPriority","multiset::ZipSegment","rope::LinesMetric","spans::Span","multiset::CountMatcher","diff::DiffBuilder","find::CaseMatching","engine::DeltaOp","breaks::BreaksLeaf","engine::RevId","delta::InsertDelta","tree::Node","multiset::Subset","std::clone::impls::<impl std::clone::Clone for &mut T>","rope::RopeInfo","engine::Error","spans::SpansLeaf","breaks::BreaksInfo","spans::SpansInfo","tree::NodeBody"]},"spans::SpansInfo":{"T":["tree::Node","spans::SpansLeaf","rope::Utf16CodeUnitsMetric","multiset::Segment","engine::Contents","rope::BaseMetric","diff::DiffBuilder","delta::Delta","multiset::Subset","engine::RevId","tree::NodeVal","breaks::BreaksMetric","multiset::CountMatcher","multiset::ZipSegment","delta::InsertDelta","breaks::BreaksLeaf","breaks::BreaksInfo","engine::FullPriority","find::CaseMatching","delta::DeltaElement","rope::RopeInfo","breaks::BreaksBaseMetric","diff::DiffOp","std::clone::impls::<impl std::clone::Clone for &mut T>","interval::Interval","tree::NodeBody","engine::DeltaOp","rope::LinesMetric","spans::SpansInfo","spans::Span","engine::Error"]},"spans::SpansLeaf":{"T":["find::CaseMatching","breaks::BreaksLeaf","rope::LinesMetric","engine::FullPriority","delta::InsertDelta","rope::Utf16CodeUnitsMetric","rope::RopeInfo","breaks::BreaksInfo","engine::Error","rope::BaseMetric","std::clone::impls::<impl std::clone::Clone for &T>","breaks::BreaksBaseMetric","tree::NodeBody","multiset::CountMatcher","spans::SpansInfo","multiset::Segment","interval::Interval","delta::DeltaElement","diff::DiffOp","engine::RevId","std::clone::impls::<impl std::clone::Clone for &mut T>","multiset::Subset","diff::DiffBuilder","spans::SpansLeaf","tree::Node","delta::Delta","engine::DeltaOp","spans::Span","breaks::BreaksMetric","multiset::ZipSegment","engine::Contents","tree::NodeVal"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::measure_leaf":{"M":["rope::LinesMetric","breaks::BreaksMetric","rope::BaseMetric","breaks::BreaksBaseMetric","rope::Utf16CodeUnitsMetric"],"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.measure_leaf(p1);
+tree::Cursor::<'a, N>::measure_leaf(p0, p1);
+crate::tree::Cursor::<'a, N>::measure_leaf(p0, p1);
+<tree::Cursor<'a, N>>::measure_leaf(p0, p1);
-----------------
rope/src/tree.rs tree::Cursor::<'a, N>::descend_metric
'a
deps:{"delta::Delta":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend_metric":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone","tree::DefaultMetric"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"delta::Delta":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"delta::InsertDelta":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"spans::Span":{"T":["rope::RopeInfo","breaks::BreaksLeaf","multiset::Subset","engine::Contents","spans::Span","breaks::BreaksMetric","delta::Delta","tree::NodeVal","spans::SpansLeaf","engine::DeltaOp","rope::BaseMetric","find::CaseMatching","tree::NodeBody","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *const T>","delta::InsertDelta","engine::FullPriority","multiset::ZipSegment","rope::LinesMetric","engine::RevId","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","multiset::Segment","breaks::BreaksInfo","spans::SpansInfo","breaks::BreaksBaseMetric","diff::DiffOp","interval::Interval","engine::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","tree::Node","delta::DeltaElement"]},"spans::SpansInfo":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksLeaf","diff::DiffBuilder","spans::SpansLeaf","spans::SpansInfo","engine::Contents","tree::NodeBody","tree::NodeVal","engine::Error","multiset::Subset","engine::DeltaOp","breaks::BreaksBaseMetric","breaks::BreaksMetric","delta::Delta","breaks::BreaksInfo","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","delta::InsertDelta","rope::LinesMetric","multiset::CountMatcher","interval::Interval","engine::RevId","rope::RopeInfo","delta::DeltaElement","tree::Node","rope::BaseMetric","engine::FullPriority","spans::Span","find::CaseMatching","diff::DiffOp","multiset::Segment"]},"spans::SpansLeaf":{"T":["tree::NodeVal","delta::Delta","breaks::BreaksLeaf","engine::RevId","rope::BaseMetric","spans::SpansInfo","diff::DiffOp","multiset::ZipSegment","engine::Contents","engine::DeltaOp","breaks::BreaksMetric","engine::FullPriority","diff::DiffBuilder","multiset::CountMatcher","spans::Span","rope::LinesMetric","multiset::Segment","std::clone::impls::<impl std::clone::Clone for &T>","rope::Utf16CodeUnitsMetric","tree::Node","find::CaseMatching","interval::Interval","multiset::Subset","engine::Error","delta::InsertDelta","tree::NodeBody","spans::SpansLeaf","std::clone::impls::<impl std::clone::Clone for &mut T>","delta::DeltaElement","breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::RopeInfo"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Cursor::<'a, N>::descend_metric":{"M":["rope::BaseMetric","rope::Utf16CodeUnitsMetric","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::Cursor<'a, N>
let mut p1 = 0usize; // None+usize
+p0.descend_metric(p1);
+tree::Cursor::<'a, N>::descend_metric(p0, p1);
+crate::tree::Cursor::<'a, N>::descend_metric(p0, p1);
+<tree::Cursor<'a, N>>::descend_metric(p0, p1);
-----------------
rope/src/tree.rs <tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next
'c,'a
deps:{"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":{"M":["tree::Metric","std::marker::Sized"],"N":["tree::NodeInfo","std::marker::Sized"]},"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::marker::Sized","tree::NodeInfo","std::clone::Clone"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::clone::Clone","std::marker::Sized"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["std::marker::Sized","tree::DefaultMetric","tree::NodeInfo","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]},"tree::NodeVal":{"N":["tree::NodeInfo","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":{"M":["rope::LinesMetric","rope::Utf16CodeUnitsMetric","rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric"],"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::Delta":{"N":["breaks::BreaksInfo","spans::SpansInfo","rope::RopeInfo"]},"delta::DeltaElement":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"spans::Span":{"T":["multiset::CountMatcher","engine::FullPriority","tree::Node","tree::NodeBody","diff::DiffOp","delta::Delta","breaks::BreaksLeaf","rope::LinesMetric","delta::DeltaElement","interval::Interval","breaks::BreaksMetric","delta::InsertDelta","rope::RopeInfo","engine::Error","multiset::ZipSegment","multiset::Segment","tree::NodeVal","breaks::BreaksInfo","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansLeaf","breaks::BreaksBaseMetric","spans::SpansInfo","engine::RevId","rope::Utf16CodeUnitsMetric","std::clone::impls::<impl std::clone::Clone for &T>","diff::DiffBuilder","engine::DeltaOp","find::CaseMatching","multiset::Subset","engine::Contents","rope::BaseMetric","spans::Span"]},"spans::SpansInfo":{"T":["spans::SpansLeaf","breaks::BreaksBaseMetric","diff::DiffOp","tree::NodeVal","engine::RevId","interval::Interval","engine::DeltaOp","tree::Node","diff::DiffBuilder","multiset::CountMatcher","breaks::BreaksInfo","breaks::BreaksMetric","delta::InsertDelta","breaks::BreaksLeaf","multiset::ZipSegment","multiset::Segment","rope::BaseMetric","find::CaseMatching","spans::SpansInfo","rope::Utf16CodeUnitsMetric","rope::LinesMetric","delta::DeltaElement","multiset::Subset","engine::FullPriority","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","engine::Error","tree::NodeBody","engine::Contents","rope::RopeInfo","spans::Span"]},"spans::SpansLeaf":{"T":["find::CaseMatching","breaks::BreaksLeaf","delta::DeltaElement","multiset::Subset","diff::DiffBuilder","engine::FullPriority","rope::LinesMetric","breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::DeltaOp","spans::SpansLeaf","tree::NodeBody","diff::DiffOp","interval::Interval","engine::RevId","multiset::Segment","rope::Utf16CodeUnitsMetric","multiset::ZipSegment","multiset::CountMatcher","tree::NodeVal","engine::Error","rope::BaseMetric","spans::Span","delta::Delta","engine::Contents","rope::RopeInfo","delta::InsertDelta","tree::Node","spans::SpansInfo","std::clone::impls::<impl std::clone::Clone for *const T>","breaks::BreaksMetric"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::NodeVal":{"N":["spans::SpansInfo","rope::RopeInfo","breaks::BreaksInfo"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // tree::CursorIter<'c, 'a, N, M>
+p0.next();
+<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next(p0);
+crate::<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next(p0);
+<tree::CursorIter<'c, 'a, N, M>>::next(p0);
-----------------
rope/src/tree.rs tree::CursorIter::<'c, 'a, N, M>::pos
'c,'a
deps:{"delta::Delta":{"N":["std::clone::Clone","tree::NodeInfo","std::marker::Sized"]},"delta::DeltaElement":{"N":["std::clone::Clone","std::marker::Sized","tree::NodeInfo"]},"delta::InsertDelta":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]},"spans::Span":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansInfo":{"T":["std::marker::Sized","std::clone::Clone"]},"spans::SpansLeaf":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter::<'c, 'a, N, M>::pos":{"M":["std::marker::Sized","tree::Metric"],"N":["std::marker::Sized","tree::NodeInfo"]},"tree::Node":{"N":["std::marker::Sized","tree::NodeInfo","tree::DefaultMetric","std::clone::Clone"]},"tree::NodeBody":{"N":["tree::NodeInfo","std::marker::Sized","std::clone::Clone"]},"tree::NodeVal":{"N":["std::marker::Sized","std::clone::Clone","tree::NodeInfo"]}}
candidates:{"delta::Delta":{"N":["rope::RopeInfo","spans::SpansInfo","breaks::BreaksInfo"]},"delta::DeltaElement":{"N":["rope::RopeInfo","breaks::BreaksInfo","spans::SpansInfo"]},"delta::InsertDelta":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"spans::Span":{"T":["multiset::Subset","tree::NodeBody","interval::Interval","engine::Contents","breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::Span","delta::Delta","delta::InsertDelta","rope::LinesMetric","engine::DeltaOp","multiset::Segment","delta::DeltaElement","rope::BaseMetric","breaks::BreaksMetric","tree::NodeVal","multiset::ZipSegment","std::clone::impls::<impl std::clone::Clone for *const T>","engine::RevId","engine::Error","rope::RopeInfo","multiset::CountMatcher","spans::SpansInfo","diff::DiffBuilder","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","tree::Node","std::clone::impls::<impl std::clone::Clone for &mut T>","spans::SpansLeaf","engine::FullPriority","diff::DiffOp","find::CaseMatching"]},"spans::SpansInfo":{"T":["multiset::Subset","tree::NodeBody","breaks::BreaksBaseMetric","engine::FullPriority","delta::InsertDelta","breaks::BreaksMetric","engine::RevId","rope::BaseMetric","tree::NodeVal","multiset::CountMatcher","spans::SpansLeaf","tree::Node","breaks::BreaksLeaf","rope::RopeInfo","rope::LinesMetric","delta::DeltaElement","breaks::BreaksInfo","find::CaseMatching","interval::Interval","spans::Span","std::clone::impls::<impl std::clone::Clone for *const T>","spans::SpansInfo","multiset::ZipSegment","engine::Contents","engine::Error","diff::DiffBuilder","engine::DeltaOp","multiset::Segment","diff::DiffOp","rope::Utf16CodeUnitsMetric","delta::Delta"]},"spans::SpansLeaf":{"T":["rope::LinesMetric","engine::Error","interval::Interval","tree::NodeVal","spans::SpansLeaf","multiset::Segment","rope::RopeInfo","engine::RevId","spans::Span","std::clone::impls::<impl std::clone::Clone for &T>","delta::Delta","multiset::Subset","breaks::BreaksBaseMetric","engine::Contents","engine::DeltaOp","diff::DiffBuilder","std::clone::impls::<impl std::clone::Clone for *mut T>","multiset::ZipSegment","diff::DiffOp","breaks::BreaksInfo","delta::DeltaElement","multiset::CountMatcher","rope::Utf16CodeUnitsMetric","breaks::BreaksLeaf","tree::Node","tree::NodeBody","spans::SpansInfo","breaks::BreaksMetric","find::CaseMatching","delta::InsertDelta","rope::BaseMetric","engine::FullPriority"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"tree::CursorIter::<'c, 'a, N, M>::pos":{"M":["rope::BaseMetric","breaks::BreaksMetric","breaks::BreaksBaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"tree::Node":{"N":["breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeBody":{"N":["spans::SpansInfo","breaks::BreaksInfo","rope::RopeInfo"]},"tree::NodeVal":{"N":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // tree::CursorIter<'c, 'a, N, M>
+p0.pos();
+tree::CursorIter::<'c, 'a, N, M>::pos(p0);
+crate::tree::CursorIter::<'c, 'a, N, M>::pos(p0);
+<tree::CursorIter<'c, 'a, N, M>>::pos(p0);