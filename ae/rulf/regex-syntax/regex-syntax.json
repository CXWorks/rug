{"dependencies":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["utf8::Utf8Range","utf8::Utf8Sequence"],"<ast::Alternation as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Assertion as std::clone::Clone>::clone":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::cmp::PartialEq>::eq":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::fmt::Debug>::fmt":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::AssertionKind as std::clone::Clone>::clone":["ast::AssertionKind"],"<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::AssertionKind"],"<ast::AssertionKind as std::cmp::PartialEq>::eq":["ast::AssertionKind"],"<ast::AssertionKind as std::fmt::Debug>::fmt":["ast::AssertionKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Ast as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Ast as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Ast as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Class as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassAscii as std::clone::Clone>::clone":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::cmp::PartialEq>::eq":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::fmt::Debug>::fmt":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassAsciiKind as std::clone::Clone>::clone":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::cmp::PartialEq>::eq":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::fmt::Debug>::fmt":["ast::ClassAsciiKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassBracketed as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassPerl as std::clone::Clone>::clone":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::cmp::PartialEq>::eq":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::fmt::Debug>::fmt":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassPerlKind as std::clone::Clone>::clone":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::cmp::PartialEq>::eq":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::fmt::Debug>::fmt":["ast::ClassPerlKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSet as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetBinaryOp as std::clone::Clone>::clone":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt":["ast::ClassSetBinaryOpKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSetItem as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassSetRange as std::clone::Clone>::clone":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::cmp::PartialEq>::eq":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::fmt::Debug>::fmt":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSetUnion as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::ClassUnicode as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeOpKind as std::clone::Clone>::clone":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt":["ast::ClassUnicodeOpKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Comment as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Concat as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::error::Error>::description":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ErrorKind as std::clone::Clone>::clone":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::cmp::PartialEq>::eq":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::fmt::Debug>::fmt":["ast::ErrorKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ErrorKind as std::fmt::Display>::fmt":["ast::ErrorKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Flag as std::clone::Clone>::clone":["ast::Flag"],"<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag"],"<ast::Flag as std::cmp::PartialEq>::eq":["ast::Flag"],"<ast::Flag as std::fmt::Debug>::fmt":["ast::Flag","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Flags as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::FlagsItem as std::clone::Clone>::clone":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::cmp::PartialEq>::eq":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::fmt::Debug>::fmt":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::FlagsItemKind as std::clone::Clone>::clone":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::cmp::PartialEq>::eq":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::fmt::Debug>::fmt":["ast::Flag","ast::FlagsItemKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Group as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::HexLiteralKind as std::clone::Clone>::clone":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::cmp::PartialEq>::eq":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::fmt::Debug>::fmt":["ast::HexLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Literal as std::clone::Clone>::clone":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::cmp::PartialEq>::eq":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::fmt::Debug>::fmt":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::LiteralKind as std::clone::Clone>::clone":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::cmp::PartialEq>::eq":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::fmt::Debug>::fmt":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Position as std::clone::Clone>::clone":["ast::Position"],"<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position"],"<ast::Position as std::cmp::Ord>::cmp":["ast::Position","std::cmp::Ordering"],"<ast::Position as std::cmp::PartialEq>::eq":["ast::Position"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["ast::Position","std::marker::Sized","std::option::Option"],"<ast::Position as std::fmt::Debug>::fmt":["ast::Position","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Repetition as std::clone::Clone>::clone":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::cmp::PartialEq>::eq":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::fmt::Debug>::fmt":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::RepetitionKind as std::clone::Clone>::clone":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::cmp::PartialEq>::eq":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::fmt::Debug>::fmt":["ast::RepetitionKind","ast::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::RepetitionOp as std::clone::Clone>::clone":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::cmp::PartialEq>::eq":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::fmt::Debug>::fmt":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::RepetitionRange as std::clone::Clone>::clone":["ast::RepetitionRange"],"<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::RepetitionRange"],"<ast::RepetitionRange as std::cmp::PartialEq>::eq":["ast::RepetitionRange"],"<ast::RepetitionRange as std::fmt::Debug>::fmt":["ast::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::SetFlags as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Span as std::clone::Clone>::clone":["ast::Position","ast::Span"],"<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::Span"],"<ast::Span as std::cmp::Ord>::cmp":["ast::Position","ast::Span","std::cmp::Ordering"],"<ast::Span as std::cmp::PartialEq>::eq":["ast::Position","ast::Span"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["ast::Position","ast::Span","std::marker::Sized","std::option::Option"],"<ast::Span as std::fmt::Debug>::fmt":["ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::SpecialLiteralKind as std::clone::Clone>::clone":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::fmt::Debug>::fmt":["ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::WithComments as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::ClassState as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::ClassState as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::GroupState as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::GroupState as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":["ast::parse::NestLimiter","ast::parse::ParserI","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::Parser as std::clone::Clone>::clone":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<ast::parse::Parser as std::fmt::Debug>::fmt":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::ParserBuilder as std::clone::Clone>::clone":["ast::parse::ParserBuilder"],"<ast::parse::ParserBuilder as std::default::Default>::default":["ast::parse::ParserBuilder"],"<ast::parse::ParserBuilder as std::fmt::Debug>::fmt":["ast::parse::ParserBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":["ast::parse::ParserI","std::marker::Sized"],"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":["ast::parse::ParserI","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::Primitive as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Printer as std::fmt::Debug>::fmt":["ast::print::Printer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::print::PrinterBuilder as std::clone::Clone>::clone":["ast::print::PrinterBuilder"],"<ast::print::PrinterBuilder as std::default::Default>::default":["ast::print::PrinterBuilder"],"<ast::print::PrinterBuilder as std::fmt::Debug>::fmt":["ast::print::PrinterBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":["ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":["ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt":["ast::print::Printer","ast::print::Writer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<char as hir::interval::Bound>::as_u32":[],"<char as hir::interval::Bound>::decrement":[],"<char as hir::interval::Bound>::increment":[],"<char as hir::interval::Bound>::max_value":[],"<char as hir::interval::Bound>::min_value":[],"<either::Either<Left, Right> as std::clone::Clone>::clone":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::fmt::Debug>::fmt":["either::Either","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::convert::From<ast::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::convert::From<hir::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::error::Error>::description":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<error::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":["ast::Position","ast::Span","error::Formatter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["ast::Position","ast::Span","error::Formatter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Formatter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["alloc::raw_vec::RawVec","ast::Position","ast::Span","error::Formatter","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Anchor as std::clone::Clone>::clone":["hir::Anchor"],"<hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Anchor"],"<hir::Anchor as std::cmp::PartialEq>::eq":["hir::Anchor"],"<hir::Anchor as std::fmt::Debug>::fmt":["hir::Anchor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Class as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytes as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassBytesRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::clone::Clone>::clone":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::Ord>::cmp":["hir::ClassBytesRange","std::cmp::Ordering"],"<hir::ClassBytesRange as std::cmp::PartialEq>::eq":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp":["hir::ClassBytesRange","std::marker::Sized","std::option::Option"],"<hir::ClassBytesRange as std::default::Default>::default":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["hir::ClassBytesRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::ClassUnicode as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicodeRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::clone::Clone>::clone":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::Ord>::cmp":["hir::ClassUnicodeRange","std::cmp::Ordering"],"<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp":["hir::ClassUnicodeRange","std::marker::Sized","std::option::Option"],"<hir::ClassUnicodeRange as std::default::Default>::default":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["hir::ClassUnicodeRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::error::Error>::description":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::ErrorKind as std::clone::Clone>::clone":["hir::ErrorKind"],"<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ErrorKind"],"<hir::ErrorKind as std::cmp::PartialEq>::eq":["hir::ErrorKind"],"<hir::ErrorKind as std::fmt::Debug>::fmt":["hir::ErrorKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::ErrorKind as std::fmt::Display>::fmt":["hir::ErrorKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Group as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Group","hir::GroupKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Group","hir::GroupKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Group as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Group","hir::GroupKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Group as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Group","hir::GroupKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::GroupKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::GroupKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::GroupKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::GroupKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::GroupKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::GroupKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::GroupKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Hir as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Hir as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Hir as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Hir as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Hir as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::HirInfo as std::clone::Clone>::clone":["hir::HirInfo"],"<hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::HirInfo"],"<hir::HirInfo as std::cmp::PartialEq>::eq":["hir::HirInfo"],"<hir::HirInfo as std::fmt::Debug>::fmt":["hir::HirInfo","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::HirKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::HirKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::HirKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Literal as std::clone::Clone>::clone":["hir::Literal"],"<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Literal"],"<hir::Literal as std::cmp::PartialEq>::eq":["hir::Literal"],"<hir::Literal as std::fmt::Debug>::fmt":["hir::Literal","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Repetition as std::clone::Clone>::clone":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::cmp::PartialEq>::eq":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::fmt::Debug>::fmt":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::RepetitionKind as std::clone::Clone>::clone":["hir::RepetitionKind","hir::RepetitionRange"],"<hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::RepetitionKind","hir::RepetitionRange"],"<hir::RepetitionKind as std::cmp::PartialEq>::eq":["hir::RepetitionKind","hir::RepetitionRange"],"<hir::RepetitionKind as std::fmt::Debug>::fmt":["hir::RepetitionKind","hir::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::RepetitionRange as std::clone::Clone>::clone":["hir::RepetitionRange"],"<hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::RepetitionRange"],"<hir::RepetitionRange as std::cmp::PartialEq>::eq":["hir::RepetitionRange"],"<hir::RepetitionRange as std::fmt::Debug>::fmt":["hir::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::WordBoundary as std::clone::Clone>::clone":["hir::WordBoundary"],"<hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::WordBoundary"],"<hir::WordBoundary as std::cmp::PartialEq>::eq":["hir::WordBoundary"],"<hir::WordBoundary as std::fmt::Debug>::fmt":["hir::WordBoundary","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":["hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::literal::Literal as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::literal::Literal as std::ops::Deref>::deref":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::ops::DerefMut>::deref_mut":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literals as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literals as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literals as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::print::Printer as std::fmt::Debug>::fmt":["hir::print::Printer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::print::PrinterBuilder as std::clone::Clone>::clone":["hir::print::PrinterBuilder"],"<hir::print::PrinterBuilder as std::default::Default>::default":["hir::print::PrinterBuilder"],"<hir::print::PrinterBuilder as std::fmt::Debug>::fmt":["hir::print::PrinterBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":["hir::print::Printer","hir::print::Writer","std::marker::Sized","std::result::Result"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":["hir::print::Printer","hir::print::Writer","std::marker::Sized","std::result::Result"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::print::Printer","hir::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::print::Printer","hir::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt":["hir::print::Printer","hir::print::Writer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::Flags as std::clone::Clone>::clone":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"<hir::translate::Flags as std::default::Default>::default":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"<hir::translate::Flags as std::fmt::Debug>::fmt":["hir::translate::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::HirFrame as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::translate::HirFrame as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::Translator as std::clone::Clone>::clone":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<hir::translate::Translator as std::fmt::Debug>::fmt":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::TranslatorBuilder as std::clone::Clone>::clone":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::Parser as std::clone::Clone>::clone":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<parser::Parser as std::fmt::Debug>::fmt":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::ParserBuilder as std::clone::Clone>::clone":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"<parser::ParserBuilder as std::default::Default>::default":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"<parser::ParserBuilder as std::fmt::Debug>::fmt":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<u8 as hir::interval::Bound>::as_u32":[],"<u8 as hir::interval::Bound>::decrement":[],"<u8 as hir::interval::Bound>::increment":[],"<u8 as hir::interval::Bound>::max_value":[],"<u8 as hir::interval::Bound>::min_value":[],"<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq":["unicode::CanonicalClassQuery"],"<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq":["unicode::CanonicalClassQuery"],"<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CanonicalClassQuery"],"<unicode::CaseFoldError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CaseFoldError"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CaseFoldError"],"<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::ClassQuery"],"<unicode::Error as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::Error"],"<unicode::UnicodeWordError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::UnicodeWordError"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::UnicodeWordError"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::ScalarRange"],"<utf8::Utf8Range as std::clone::Clone>::clone":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::PartialEq>::eq":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf8::Utf8Range"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Range"],"<utf8::Utf8Sequence as std::clone::Clone>::clone":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::PartialEq>::eq":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequences as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","utf8::Utf8Sequences"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"ast::Alternation":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Alternation::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"ast::AssertionKind":["ast::AssertionKind"],"ast::Ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::has_subexprs":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::is_empty":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::span":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::CaptureName":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Class":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Class::span":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassAscii":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"ast::ClassAsciiKind":["ast::ClassAsciiKind"],"ast::ClassAsciiKind::from_name":["std::marker::Sized","std::option::Option"],"ast::ClassBracketed":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassPerl":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"ast::ClassPerlKind":["ast::ClassPerlKind"],"ast::ClassSet":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::is_empty":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::span":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::union":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetBinaryOp":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"ast::ClassSetBinaryOpKind":["ast::ClassSetBinaryOpKind"],"ast::ClassSetItem":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetItem::span":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetRange":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::ClassSetRange::is_valid":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::ClassSetUnion":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::ClassSetUnion::into_item":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetUnion::push":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicode":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicode::is_negated":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicodeKind":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicodeOpKind":["ast::ClassUnicodeOpKind"],"ast::ClassUnicodeOpKind::is_equal":["ast::ClassUnicodeOpKind"],"ast::Comment":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Concat":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Concat::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::auxiliary_span":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::kind":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::pattern":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::span":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ErrorKind":["ast::ErrorKind","ast::Position","ast::Span"],"ast::Flag":["ast::Flag"],"ast::Flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Flags::add_item":["alloc::raw_vec::RawVec","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Flags::flag_state":["alloc::raw_vec::RawVec","ast::Flag","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::FlagsItem":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"ast::FlagsItemKind":["ast::Flag","ast::FlagsItemKind"],"ast::FlagsItemKind::is_negation":["ast::Flag","ast::FlagsItemKind"],"ast::Group":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::capture_index":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::flags":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::is_capturing":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::GroupKind":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::HexLiteralKind":["ast::HexLiteralKind"],"ast::HexLiteralKind::digits":["ast::HexLiteralKind"],"ast::Literal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::Literal::byte":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::marker::Sized","std::option::Option"],"ast::LiteralKind":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"ast::Position":["ast::Position"],"ast::Position::new":["ast::Position"],"ast::Repetition":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"ast::RepetitionKind":["ast::RepetitionKind","ast::RepetitionRange"],"ast::RepetitionOp":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"ast::RepetitionRange":["ast::RepetitionRange"],"ast::RepetitionRange::is_valid":["ast::RepetitionRange"],"ast::SetFlags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Span":["ast::Position","ast::Span"],"ast::Span::is_empty":["ast::Position","ast::Span"],"ast::Span::is_one_line":["ast::Position","ast::Span"],"ast::Span::new":["ast::Position","ast::Span"],"ast::Span::splat":["ast::Position","ast::Span"],"ast::Span::with_end":["ast::Position","ast::Span"],"ast::Span::with_start":["ast::Position","ast::Span"],"ast::SpecialLiteralKind":["ast::SpecialLiteralKind"],"ast::WithComments":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ClassState":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::GroupState":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::NestLimiter":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::NestLimiter::<'p, 's, P>::check":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::NestLimiter::<'p, 's, P>::new":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::Parser":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::Parser::new":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::Parser::parse":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"ast::parse::Parser::parse_with_comments":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"ast::parse::Parser::reset":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::ParserBuilder":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::build":["ast::parse::Parser","ast::parse::ParserBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::ParserBuilder::ignore_whitespace":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::nest_limit":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::new":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::octal":["ast::parse::ParserBuilder"],"ast::parse::ParserI":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::add_capture_name":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::bump":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_if":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_space":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::char":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::char_at":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::column":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::is_eof":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::line":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::new":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::next_capture_index":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::offset":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_capture_name":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::parse_decimal":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_escape":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_flag":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_flags":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_group":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["ast::HexLiteralKind","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["ast::HexLiteralKind","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_octal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse_perl_class":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse_primitive":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::RepetitionKind","ast::RepetitionRange","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_with_comments":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parser":["ast::parse::Parser","ast::parse::ParserI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::pattern":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::peek":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::peek_space":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::pop_class":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_class_op":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_group":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_group_end":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pos":["ast::Position","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::push_alternate":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_class_op":["alloc::raw_vec::RawVec","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_class_open":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_group":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::span":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::span_char":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_class_literal":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","ast::parse::Primitive","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_class_set_item":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","ast::parse::Primitive","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::Primitive::span":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::is_capture_char":[],"ast::parse::is_hex":[],"ast::parse::specialize_err":["ast::ErrorKind","ast::Position","ast::Span","std::marker::Sized","std::result::Result"],"ast::print::Printer":["ast::print::Printer"],"ast::print::Printer::new":["ast::print::Printer"],"ast::print::Printer::print":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","std::alloc::Allocator","std::boxed::Box","std::fmt::Write","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::PrinterBuilder":["ast::print::PrinterBuilder"],"ast::print::PrinterBuilder::build":["ast::print::Printer","ast::print::PrinterBuilder"],"ast::print::PrinterBuilder::new":["ast::print::PrinterBuilder"],"ast::print::Writer":["ast::print::Printer","ast::print::Writer","std::marker::Sized"],"ast::print::Writer::<'p, W>::fmt_assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_class_ascii":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_class_perl":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":["ast::ClassSetBinaryOpKind","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_class_unicode":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_group_post":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_group_pre":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<'p, W>::fmt_literal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_repetition":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_repetition_range":["ast::RepetitionRange","ast::print::Printer","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<'p, W>::fmt_set_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","ast::print::Printer","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::visitor::ClassFrame":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassFrame::<'a>::child":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct::<'a>::from_bracketed":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct::<'a>::from_set":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::Frame":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::Frame::<'a>::child":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor":["alloc::raw_vec::RawVec","ast::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::induct":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::induct_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::new":["alloc::raw_vec::RawVec","ast::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::pop":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::pop_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::finish":["std::marker::Sized","std::result::Result"],"ast::visitor::Visitor::start":[],"ast::visitor::Visitor::visit_alternation_in":["std::marker::Sized","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::visit":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"either::Either":["either::Either","std::marker::Sized"],"error::Error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Formatter":["ast::Position","ast::Span","error::Formatter","std::marker::Sized","std::option::Option"],"error::Spans":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::add":["alloc::raw_vec::RawVec","ast::Position","ast::Span","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::from_formatter":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","error::Formatter","error::Spans","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::left_pad_line_number":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::line_number_padding":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::notate":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::notate_line":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::repeat_char":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"escape":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"escape_into":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Anchor":["hir::Anchor"],"hir::Class":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::case_fold_simple":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::is_always_utf8":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::negate":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::difference":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::empty":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::intersect":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::is_all_ascii":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::iter":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesIter","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::ClassBytes::negate":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::new":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::push":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::ranges":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::symmetric_difference":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::union":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytesIter":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::ClassBytesRange":["hir::ClassBytesRange"],"hir::ClassBytesRange::end":["hir::ClassBytesRange"],"hir::ClassBytesRange::new":["hir::ClassBytesRange"],"hir::ClassBytesRange::start":["hir::ClassBytesRange"],"hir::ClassUnicode":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::difference":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::empty":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::intersect":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::is_all_ascii":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::iter":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeIter","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::ClassUnicode::negate":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::new":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::push":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::ranges":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::symmetric_difference":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::try_case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::ClassUnicode::union":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicodeIter":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::ClassUnicodeRange":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::end":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::new":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::start":["hir::ClassUnicodeRange"],"hir::Error":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::kind":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::pattern":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::span":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::ErrorKind":["hir::ErrorKind"],"hir::ErrorKind::description":["hir::ErrorKind"],"hir::Group":["alloc::raw_vec::RawVec","hir::Group","hir::GroupKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::GroupKind":["alloc::raw_vec::RawVec","hir::GroupKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::alternation":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::anchor":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::any":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::class":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::concat":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::dot":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::empty":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::group":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::into_kind":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_all_assertions":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_alternation_literal":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_always_utf8":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_anchored_end":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_anchored_start":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_any_anchored_end":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_any_anchored_start":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_line_anchored_end":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_line_anchored_start":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_literal":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::is_match_empty":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::kind":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::literal":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::repetition":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Hir::word_boundary":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::HirInfo":["hir::HirInfo"],"hir::HirInfo::is_all_assertions":["hir::HirInfo"],"hir::HirInfo::is_alternation_literal":["hir::HirInfo"],"hir::HirInfo::is_always_utf8":["hir::HirInfo"],"hir::HirInfo::is_anchored_end":["hir::HirInfo"],"hir::HirInfo::is_anchored_start":["hir::HirInfo"],"hir::HirInfo::is_any_anchored_end":["hir::HirInfo"],"hir::HirInfo::is_any_anchored_start":["hir::HirInfo"],"hir::HirInfo::is_line_anchored_end":["hir::HirInfo"],"hir::HirInfo::is_line_anchored_start":["hir::HirInfo"],"hir::HirInfo::is_literal":["hir::HirInfo"],"hir::HirInfo::is_match_empty":["hir::HirInfo"],"hir::HirInfo::new":["hir::HirInfo"],"hir::HirInfo::set_all_assertions":["hir::HirInfo"],"hir::HirInfo::set_alternation_literal":["hir::HirInfo"],"hir::HirInfo::set_always_utf8":["hir::HirInfo"],"hir::HirInfo::set_anchored_end":["hir::HirInfo"],"hir::HirInfo::set_anchored_start":["hir::HirInfo"],"hir::HirInfo::set_any_anchored_end":["hir::HirInfo"],"hir::HirInfo::set_any_anchored_start":["hir::HirInfo"],"hir::HirInfo::set_line_anchored_end":["hir::HirInfo"],"hir::HirInfo::set_line_anchored_start":["hir::HirInfo"],"hir::HirInfo::set_literal":["hir::HirInfo"],"hir::HirInfo::set_match_empty":["hir::HirInfo"],"hir::HirKind":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::HirKind::has_subexprs":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::HirKind::is_empty":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Literal":["hir::Literal"],"hir::Literal::is_unicode":["hir::Literal"],"hir::Repetition":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Repetition::is_match_empty":["hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::RepetitionKind":["hir::RepetitionKind","hir::RepetitionRange"],"hir::RepetitionRange":["hir::RepetitionRange"],"hir::WordBoundary":["hir::WordBoundary"],"hir::WordBoundary::is_negated":["hir::WordBoundary"],"hir::interval::Bound::as_u32":[],"hir::interval::Bound::decrement":[],"hir::interval::Bound::increment":[],"hir::interval::Bound::max_value":[],"hir::interval::Bound::min_value":[],"hir::interval::Interval::case_fold_simple":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::interval::Interval::create":[],"hir::interval::Interval::difference":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::intersect":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::is_contiguous":[],"hir::interval::Interval::is_intersection_empty":[],"hir::interval::Interval::is_subset":[],"hir::interval::Interval::lower":[],"hir::interval::Interval::set_lower":[],"hir::interval::Interval::set_upper":[],"hir::interval::Interval::symmetric_difference":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::union":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::upper":[],"hir::interval::IntervalSet":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::canonicalize":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::case_fold_simple":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::interval::IntervalSet::<I>::difference":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::intersect":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::intervals":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::is_canonical":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::iter":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::interval::IntervalSet::<I>::negate":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::new":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::push":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::symmetric_difference":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::union":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSetIter":["hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::literal::Literal":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::cut":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::empty":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::is_cut":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::new":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::_add_char_class":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::add":["alloc::raw_vec::RawVec","hir::literal::Literal","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::add_byte_class":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::add_char_class":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::add_char_class_reverse":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::all_complete":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::any_complete":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::class_exceeds_limits":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::clear":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::contains_empty":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::cross_add":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::cross_product":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::cut":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::empty":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::is_empty":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::limit_class":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::limit_size":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::literals":["alloc::raw_vec::RawVec","hir::literal::Literal","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::longest_common_prefix":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::longest_common_suffix":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::min_len":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::num_bytes":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::prefixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::Literals::remove_complete":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::reverse":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::set_limit_class":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::set_limit_size":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::suffixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::Literals::to_empty":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::trim_suffix":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::unambiguous_prefixes":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::unambiguous_suffixes":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::union":["alloc::raw_vec::RawVec","hir::literal::Literals","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literals::union_prefixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::Literals::union_suffixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::alternate_literals":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::cls_byte_count":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::cls_char_count":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::escape_byte":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::escape_bytes":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::escape_unicode":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::position":["std::marker::Sized","std::option::Option"],"hir::literal::prefixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::repeat_one_or_more_literals":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::repeat_range_literals":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::repeat_zero_or_more_literals":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::repeat_zero_or_one_literals":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::literal::suffixes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::print::Printer":["hir::print::Printer"],"hir::print::Printer::new":["hir::print::Printer"],"hir::print::Printer::print":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::print::Printer","std::alloc::Allocator","std::boxed::Box","std::fmt::Write","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::print::PrinterBuilder":["hir::print::PrinterBuilder"],"hir::print::PrinterBuilder::build":["hir::print::Printer","hir::print::PrinterBuilder"],"hir::print::PrinterBuilder::new":["hir::print::PrinterBuilder"],"hir::print::Writer":["hir::print::Printer","hir::print::Writer","std::marker::Sized"],"hir::print::Writer::<'p, W>::write_literal_byte":["hir::print::Printer","hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::print::Writer::<'p, W>::write_literal_char":["hir::print::Printer","hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::print::Writer::<'p, W>::write_literal_class_byte":["hir::print::Printer","hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::translate::Flags":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::case_insensitive":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::dot_matches_new_line":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::from_ast":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","hir::translate::Flags","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::Flags::merge":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::multi_line":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::swap_greed":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::unicode":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::HirFrame":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::HirFrame::unwrap_class_bytes":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::HirFrame::unwrap_class_unicode":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::HirFrame::unwrap_expr":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::HirFrame::unwrap_group":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::Translator":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::Translator::new":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::Translator::translate":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::translate::TranslatorBuilder":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::allow_invalid_utf8":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::build":["hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::case_insensitive":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::dot_matches_new_line":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::multi_line":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::new":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::swap_greed":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::unicode":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::ClassBytes","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::error":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::flags":["hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_group":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::hir_literal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["alloc::raw_vec::RawVec","ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","hir::ClassBytes","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["alloc::raw_vec::RawVec","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::literal_to_char":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::new":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::pop":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::push":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::trans":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::ClassUnicode","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::translate::ascii_class":["ast::ClassAsciiKind"],"hir::translate::hir_ascii_class_bytes":["alloc::raw_vec::RawVec","ast::ClassAsciiKind","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::Frame":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::visitor::Frame::<'a>::child":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::visitor::HeapVisitor":["alloc::raw_vec::RawVec","hir::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::induct":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::new":["alloc::raw_vec::RawVec","hir::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::pop":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::visitor::Frame","hir::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::visit":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::print::Printer","hir::print::Writer","hir::visitor::HeapVisitor","hir::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::visitor::Visitor::finish":["std::marker::Sized","std::result::Result"],"hir::visitor::Visitor::start":[],"hir::visitor::Visitor::visit_alternation_in":["std::marker::Sized","std::result::Result"],"hir::visitor::Visitor::visit_post":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::visitor::Visitor::visit_pre":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::visitor::visit":["alloc::raw_vec::RawVec","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::print::Printer","hir::print::Writer","hir::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"is_meta_character":[],"is_word_byte":[],"is_word_character":[],"parser::Parser":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"parser::Parser::new":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"parser::Parser::parse":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"parser::ParserBuilder":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::allow_invalid_utf8":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::build":["ast::parse::Parser","ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorBuilder","parser::Parser","parser::ParserBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::case_insensitive":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::dot_matches_new_line":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::ignore_whitespace":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::multi_line":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::nest_limit":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::new":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::octal":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::swap_greed":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::unicode":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"try_is_word_character":["std::marker::Sized","std::result::Result"],"unicode::CanonicalClassQuery":["unicode::CanonicalClassQuery"],"unicode::CaseFoldError":["unicode::CaseFoldError"],"unicode::ClassQuery":["unicode::ClassQuery"],"unicode::ClassQuery::<'a>::canonical_binary":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::ClassQuery::<'a>::canonicalize":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::Error":["unicode::Error"],"unicode::UnicodeWordError":["unicode::UnicodeWordError"],"unicode::ages":["std::marker::Sized","std::result::Result"],"unicode::ages::imp":["std::marker::Sized","std::result::Result"],"unicode::bool_property":["std::marker::Sized","std::result::Result"],"unicode::bool_property::imp":["std::marker::Sized","std::result::Result"],"unicode::canonical_gencat":["std::marker::Sized","std::result::Result"],"unicode::canonical_prop":["std::marker::Sized","std::result::Result"],"unicode::canonical_prop::imp":["std::marker::Sized","std::result::Result"],"unicode::canonical_script":["std::marker::Sized","std::result::Result"],"unicode::canonical_value":["std::marker::Sized","std::option::Option"],"unicode::class":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::contains_simple_case_mapping":["std::marker::Sized","std::result::Result"],"unicode::contains_simple_case_mapping::imp":["std::marker::Sized","std::result::Result"],"unicode::gcb":["std::marker::Sized","std::result::Result"],"unicode::gcb::imp":["std::marker::Sized","std::result::Result"],"unicode::gencat":["std::marker::Sized","std::result::Result"],"unicode::gencat::imp":["std::marker::Sized","std::result::Result"],"unicode::hir_class":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"unicode::is_word_character":["std::marker::Sized","std::result::Result"],"unicode::is_word_character::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_digit":["std::marker::Sized","std::result::Result"],"unicode::perl_digit::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_space":["std::marker::Sized","std::result::Result"],"unicode::perl_space::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_word":["std::marker::Sized","std::result::Result"],"unicode::perl_word::imp":["std::marker::Sized","std::result::Result"],"unicode::property_set":["std::marker::Sized","std::option::Option"],"unicode::property_values":["std::marker::Sized","std::result::Result"],"unicode::property_values::imp":["std::marker::Sized","std::result::Result"],"unicode::sb":["std::marker::Sized","std::result::Result"],"unicode::sb::imp":["std::marker::Sized","std::result::Result"],"unicode::script":["std::marker::Sized","std::result::Result"],"unicode::script::imp":["std::marker::Sized","std::result::Result"],"unicode::script_extension":["std::marker::Sized","std::result::Result"],"unicode::script_extension::imp":["std::marker::Sized","std::result::Result"],"unicode::simple_fold":["std::marker::Sized","std::result::Result"],"unicode::simple_fold::imp":["std::marker::Sized","std::result::Result"],"unicode::symbolic_name_normalize":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"unicode::symbolic_name_normalize_bytes":[],"unicode::wb":["std::marker::Sized","std::result::Result"],"unicode::wb::imp":["std::marker::Sized","std::result::Result"],"utf8::ScalarRange":["utf8::ScalarRange"],"utf8::ScalarRange::as_ascii":["std::marker::Sized","std::option::Option","utf8::ScalarRange"],"utf8::ScalarRange::encode":["utf8::ScalarRange"],"utf8::ScalarRange::is_ascii":["utf8::ScalarRange"],"utf8::ScalarRange::is_valid":["utf8::ScalarRange"],"utf8::ScalarRange::split":["std::marker::Sized","std::option::Option","utf8::ScalarRange"],"utf8::Utf8Range":["utf8::Utf8Range"],"utf8::Utf8Range::matches":["utf8::Utf8Range"],"utf8::Utf8Range::new":["utf8::Utf8Range"],"utf8::Utf8Sequence":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::as_slice":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::from_encoded_range":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::len":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::matches":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::reverse":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequences":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::new":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::push":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::reset":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::max_scalar_value":[]},"glob_path_import":{},"self_to_fn":{"ast::Alternation":["Clone","Debug","Eq","PartialEq","impl Alternation {\n    /// Return this alternation as an AST.\n    ///\n    /// If this alternation contains zero ASTs, then Ast::Empty is\n    /// returned. If this alternation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Alternation is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Alternation(self),\n        }\n    }\n}"],"ast::Assertion":["Clone","Debug","Eq","PartialEq"],"ast::AssertionKind":["Clone","Debug","Eq","PartialEq"],"ast::Ast":["Clone","Debug","Eq","PartialEq","impl Ast {\n    /// Return the span of this abstract syntax tree.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Ast::Empty(ref span) => span,\n            Ast::Flags(ref x) => &x.span,\n            Ast::Literal(ref x) => &x.span,\n            Ast::Dot(ref span) => span,\n            Ast::Assertion(ref x) => &x.span,\n            Ast::Class(ref x) => x.span(),\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this Ast is empty.\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            Ast::Empty(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if and only if this AST has any (including possibly empty)\n    /// subexpressions.\n    fn has_subexprs(&self) -> bool {\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_) => false,\n            Ast::Class(_)\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => true,\n        }\n    }\n}","impl Drop for Ast {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            // Classes are recursive, so they get their own Drop impl.\n            | Ast::Class(_) => return,\n            Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Group(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Alternation(ref x) if x.asts.is_empty() => return,\n            Ast::Concat(ref x) if x.asts.is_empty() => return,\n            _ => {}\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_ast = || Ast::Empty(empty_span());\n        let mut stack = vec![mem::replace(self, empty_ast())];\n        while let Some(mut ast) = stack.pop() {\n            match ast {\n                Ast::Empty(_)\n                | Ast::Flags(_)\n                | Ast::Literal(_)\n                | Ast::Dot(_)\n                | Ast::Assertion(_)\n                // Classes are recursive, so they get their own Drop impl.\n                | Ast::Class(_) => {}\n                Ast::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Alternation(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n                Ast::Concat(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n            }\n        }\n    }\n}","impl fmt::Display for Ast {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use ast::print::Printer;\n        Printer::new().print(self, f)\n    }\n}"],"ast::CaptureName":["Clone","Debug","Eq","PartialEq"],"ast::Class":["Clone","Debug","Eq","PartialEq","impl Class {\n    /// Return the span of this character class.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Class::Perl(ref x) => &x.span,\n            Class::Unicode(ref x) => &x.span,\n            Class::Bracketed(ref x) => &x.span,\n        }\n    }\n}"],"ast::ClassAscii":["Clone","Debug","Eq","PartialEq"],"ast::ClassAsciiKind":["Clone","Debug","Eq","PartialEq","impl ClassAsciiKind {\n    /// Return the corresponding ClassAsciiKind variant for the given name.\n    ///\n    /// The name given should correspond to the lowercase version of the\n    /// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.\n    ///\n    /// If no variant with the corresponding name exists, then `None` is\n    /// returned.\n    pub fn from_name(name: &str) -> Option<ClassAsciiKind> {\n        use self::ClassAsciiKind::*;\n        match name {\n            \"alnum\" => Some(Alnum),\n            \"alpha\" => Some(Alpha),\n            \"ascii\" => Some(Ascii),\n            \"blank\" => Some(Blank),\n            \"cntrl\" => Some(Cntrl),\n            \"digit\" => Some(Digit),\n            \"graph\" => Some(Graph),\n            \"lower\" => Some(Lower),\n            \"print\" => Some(Print),\n            \"punct\" => Some(Punct),\n            \"space\" => Some(Space),\n            \"upper\" => Some(Upper),\n            \"word\" => Some(Word),\n            \"xdigit\" => Some(Xdigit),\n            _ => None,\n        }\n    }\n}"],"ast::ClassBracketed":["Clone","Debug","Eq","PartialEq"],"ast::ClassPerl":["Clone","Debug","Eq","PartialEq"],"ast::ClassPerlKind":["Clone","Debug","Eq","PartialEq"],"ast::ClassSet":["Clone","Debug","Eq","PartialEq","impl ClassSet {\n    /// Build a set from a union.\n    pub fn union(ast: ClassSetUnion) -> ClassSet {\n        ClassSet::Item(ClassSetItem::Union(ast))\n    }\n\n    /// Return the span of this character class set.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSet::Item(ref x) => x.span(),\n            ClassSet::BinaryOp(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this class set is empty.\n    fn is_empty(&self) -> bool {\n        match *self {\n            ClassSet::Item(ClassSetItem::Empty(_)) => true,\n            _ => false,\n        }\n    }\n}","impl Drop for ClassSet {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self {\n            ClassSet::Item(ref item) => match *item {\n                ClassSetItem::Empty(_)\n                | ClassSetItem::Literal(_)\n                | ClassSetItem::Range(_)\n                | ClassSetItem::Ascii(_)\n                | ClassSetItem::Unicode(_)\n                | ClassSetItem::Perl(_) => return,\n                ClassSetItem::Bracketed(ref x) => {\n                    if x.kind.is_empty() {\n                        return;\n                    }\n                }\n                ClassSetItem::Union(ref x) => {\n                    if x.items.is_empty() {\n                        return;\n                    }\n                }\n            },\n            ClassSet::BinaryOp(ref op) => {\n                if op.lhs.is_empty() && op.rhs.is_empty() {\n                    return;\n                }\n            }\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));\n        let mut stack = vec![mem::replace(self, empty_set())];\n        while let Some(mut set) = stack.pop() {\n            match set {\n                ClassSet::Item(ref mut item) => match *item {\n                    ClassSetItem::Empty(_)\n                    | ClassSetItem::Literal(_)\n                    | ClassSetItem::Range(_)\n                    | ClassSetItem::Ascii(_)\n                    | ClassSetItem::Unicode(_)\n                    | ClassSetItem::Perl(_) => {}\n                    ClassSetItem::Bracketed(ref mut x) => {\n                        stack.push(mem::replace(&mut x.kind, empty_set()));\n                    }\n                    ClassSetItem::Union(ref mut x) => {\n                        stack.extend(x.items.drain(..).map(ClassSet::Item));\n                    }\n                },\n                ClassSet::BinaryOp(ref mut op) => {\n                    stack.push(mem::replace(&mut op.lhs, empty_set()));\n                    stack.push(mem::replace(&mut op.rhs, empty_set()));\n                }\n            }\n        }\n    }\n}"],"ast::ClassSetBinaryOp":["Clone","Debug","Eq","PartialEq"],"ast::ClassSetBinaryOpKind":["Clone","Copy","Debug","Eq","PartialEq"],"ast::ClassSetItem":["Clone","Debug","Eq","PartialEq","impl ClassSetItem {\n    /// Return the span of this character class set item.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSetItem::Empty(ref span) => span,\n            ClassSetItem::Literal(ref x) => &x.span,\n            ClassSetItem::Range(ref x) => &x.span,\n            ClassSetItem::Ascii(ref x) => &x.span,\n            ClassSetItem::Perl(ref x) => &x.span,\n            ClassSetItem::Unicode(ref x) => &x.span,\n            ClassSetItem::Bracketed(ref x) => &x.span,\n            ClassSetItem::Union(ref x) => &x.span,\n        }\n    }\n}"],"ast::ClassSetRange":["Clone","Debug","Eq","PartialEq","impl ClassSetRange {\n    /// Returns true if and only if this character class range is valid.\n    ///\n    /// The only case where a range is invalid is if its start is greater than\n    /// its end.\n    pub fn is_valid(&self) -> bool {\n        self.start.c <= self.end.c\n    }\n}"],"ast::ClassSetUnion":["Clone","Debug","Eq","PartialEq","impl ClassSetUnion {\n    /// Push a new item in this union.\n    ///\n    /// The ending position of this union's span is updated to the ending\n    /// position of the span of the item given. If the union is empty, then\n    /// the starting position of this union is set to the starting position\n    /// of this item.\n    ///\n    /// In other words, if you only use this method to add items to a union\n    /// and you set the spans on each item correctly, then you should never\n    /// need to adjust the span of the union directly.\n    pub fn push(&mut self, item: ClassSetItem) {\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }\n\n    /// Return this union as a character class set item.\n    ///\n    /// If this union contains zero items, then an empty union is\n    /// returned. If this concatenation contains exactly 1 item, then the\n    /// corresponding item is returned. Otherwise, ClassSetItem::Union is\n    /// returned.\n    pub fn into_item(mut self) -> ClassSetItem {\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }\n}"],"ast::ClassUnicode":["Clone","Debug","Eq","PartialEq","impl ClassUnicode {\n    /// Returns true if this class has been negated.\n    ///\n    /// Note that this takes the Unicode op into account, if it's present.\n    /// e.g., `is_negated` for `\\P{scx!=Katakana}` will return `false`.\n    pub fn is_negated(&self) -> bool {\n        match self.kind {\n            ClassUnicodeKind::NamedValue {\n                op: ClassUnicodeOpKind::NotEqual,\n                ..\n            } => !self.negated,\n            _ => self.negated,\n        }\n    }\n}"],"ast::ClassUnicodeKind":["Clone","Debug","Eq","PartialEq"],"ast::ClassUnicodeOpKind":["Clone","Debug","Eq","PartialEq","impl ClassUnicodeOpKind {\n    /// Whether the op is an equality op or not.\n    pub fn is_equal(&self) -> bool {\n        match *self {\n            ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,\n            _ => false,\n        }\n    }\n}"],"ast::Comment":["Clone","Debug","Eq","PartialEq"],"ast::Concat":["Clone","Debug","Eq","PartialEq","impl Concat {\n    /// Return this concatenation as an AST.\n    ///\n    /// If this concatenation contains zero ASTs, then Ast::Empty is\n    /// returned. If this concatenation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Concat is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Concat(self),\n        }\n    }\n}"],"ast::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n\n    /// Return an auxiliary span. This span exists only for some errors that\n    /// benefit from being able to point to two locations in the original\n    /// regular expression. For example, \"duplicate\" errors will have the\n    /// main error position set to the duplicate occurrence while its\n    /// auxiliary span will be set to the initial occurrence.\n    pub fn auxiliary_span(&self) -> Option<&Span> {\n        use self::ErrorKind::*;\n        match self.kind {\n            FlagDuplicate { ref original } => Some(original),\n            FlagRepeatedNegation { ref original, .. } => Some(original),\n            GroupNameDuplicate { ref original, .. } => Some(original),\n            _ => None,\n        }\n    }\n}","impl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        use self::ErrorKind::*;\n        match self.kind {\n            CaptureLimitExceeded => \"capture group limit exceeded\",\n            ClassEscapeInvalid => \"invalid escape sequence in character class\",\n            ClassRangeInvalid => \"invalid character class range\",\n            ClassRangeLiteral => \"invalid range boundary, must be a literal\",\n            ClassUnclosed => \"unclosed character class\",\n            DecimalEmpty => \"empty decimal literal\",\n            DecimalInvalid => \"invalid decimal literal\",\n            EscapeHexEmpty => \"empty hexadecimal literal\",\n            EscapeHexInvalid => \"invalid hexadecimal literal\",\n            EscapeHexInvalidDigit => \"invalid hexadecimal digit\",\n            EscapeUnexpectedEof => \"unexpected eof (escape sequence)\",\n            EscapeUnrecognized => \"unrecognized escape sequence\",\n            FlagDanglingNegation => \"dangling flag negation operator\",\n            FlagDuplicate { .. } => \"duplicate flag\",\n            FlagRepeatedNegation { .. } => \"repeated negation\",\n            FlagUnexpectedEof => \"unexpected eof (flag)\",\n            FlagUnrecognized => \"unrecognized flag\",\n            GroupNameDuplicate { .. } => \"duplicate capture group name\",\n            GroupNameEmpty => \"empty capture group name\",\n            GroupNameInvalid => \"invalid capture group name\",\n            GroupNameUnexpectedEof => \"unclosed capture group name\",\n            GroupUnclosed => \"unclosed group\",\n            GroupUnopened => \"unopened group\",\n            NestLimitExceeded(_) => \"nest limit exceeded\",\n            RepetitionCountInvalid => \"invalid repetition count range\",\n            RepetitionCountUnclosed => \"unclosed counted repetition\",\n            RepetitionMissing => \"repetition operator missing expression\",\n            UnicodeClassInvalid => \"invalid Unicode character class\",\n            UnsupportedBackreference => \"backreferences are not supported\",\n            UnsupportedLookAround => \"look-around is not supported\",\n            _ => unreachable!(),\n        }\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        ::error::Formatter::from(self).fmt(f)\n    }\n}"],"ast::ErrorKind":["Clone","Debug","Eq","PartialEq","impl fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => write!(\n                f,\n                \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                ::std::u32::MAX\n            ),\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => write!(\n                f,\n                \"invalid character class range, \\\n                 the start must be <= the end\"\n            ),\n            ClassRangeLiteral => {\n                write!(f, \"invalid range boundary, must be a literal\")\n            }\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => write!(\n                f,\n                \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n            ),\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => {\n                write!(f, \"dangling flag negation operator\")\n            }\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => {\n                write!(f, \"flag negation operator repeated\")\n            }\n            FlagUnexpectedEof => {\n                write!(f, \"expected flag but got end of regex\")\n            }\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => {\n                write!(f, \"duplicate capture group name\")\n            }\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => write!(\n                f,\n                \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                limit\n            ),\n            RepetitionCountInvalid => write!(\n                f,\n                \"invalid repetition count range, \\\n                 the start must be <= the end\"\n            ),\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => {\n                write!(f, \"unclosed counted repetition\")\n            }\n            RepetitionMissing => {\n                write!(f, \"repetition operator missing expression\")\n            }\n            UnicodeClassInvalid => {\n                write!(f, \"invalid Unicode character class\")\n            }\n            UnsupportedBackreference => {\n                write!(f, \"backreferences are not supported\")\n            }\n            UnsupportedLookAround => write!(\n                f,\n                \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n            ),\n            _ => unreachable!(),\n        }\n    }\n}"],"ast::Flag":["Clone","Copy","Debug","Eq","PartialEq"],"ast::Flags":["Clone","Debug","Eq","PartialEq","impl Flags {\n    /// Add the given item to this sequence of flags.\n    ///\n    /// If the item was added successfully, then `None` is returned. If the\n    /// given item is a duplicate, then `Some(i)` is returned, where\n    /// `items[i].kind == item.kind`.\n    pub fn add_item(&mut self, item: FlagsItem) -> Option<usize> {\n        for (i, x) in self.items.iter().enumerate() {\n            if x.kind == item.kind {\n                return Some(i);\n            }\n        }\n        self.items.push(item);\n        None\n    }\n\n    /// Returns the state of the given flag in this set.\n    ///\n    /// If the given flag is in the set but is negated, then `Some(false)` is\n    /// returned.\n    ///\n    /// If the given flag is in the set and is not negated, then `Some(true)`\n    /// is returned.\n    ///\n    /// Otherwise, `None` is returned.\n    pub fn flag_state(&self, flag: Flag) -> Option<bool> {\n        let mut negated = false;\n        for x in &self.items {\n            match x.kind {\n                FlagsItemKind::Negation => {\n                    negated = true;\n                }\n                FlagsItemKind::Flag(ref xflag) if xflag == &flag => {\n                    return Some(!negated);\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n}"],"ast::FlagsItem":["Clone","Debug","Eq","PartialEq"],"ast::FlagsItemKind":["Clone","Debug","Eq","PartialEq","impl FlagsItemKind {\n    /// Returns true if and only if this item is a negation operator.\n    pub fn is_negation(&self) -> bool {\n        match *self {\n            FlagsItemKind::Negation => true,\n            _ => false,\n        }\n    }\n}"],"ast::Group":["Clone","Debug","Eq","PartialEq","impl Group {\n    /// If this group is non-capturing, then this returns the (possibly empty)\n    /// set of flags. Otherwise, `None` is returned.\n    pub fn flags(&self) -> Option<&Flags> {\n        match self.kind {\n            GroupKind::NonCapturing(ref flags) => Some(flags),\n            _ => None,\n        }\n    }\n\n    /// Returns true if and only if this group is capturing.\n    pub fn is_capturing(&self) -> bool {\n        match self.kind {\n            GroupKind::CaptureIndex(_) | GroupKind::CaptureName(_) => true,\n            GroupKind::NonCapturing(_) => false,\n        }\n    }\n\n    /// Returns the capture index of this group, if this is a capturing group.\n    ///\n    /// This returns a capture index precisely when `is_capturing` is `true`.\n    pub fn capture_index(&self) -> Option<u32> {\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName(ref x) => Some(x.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }\n}"],"ast::GroupKind":["Clone","Debug","Eq","PartialEq"],"ast::HexLiteralKind":["Clone","Debug","Eq","PartialEq","impl HexLiteralKind {\n    /// The number of digits that must be used with this literal form when\n    /// used without brackets. When used with brackets, there is no\n    /// restriction on the number of digits.\n    pub fn digits(&self) -> u32 {\n        match *self {\n            HexLiteralKind::X => 2,\n            HexLiteralKind::UnicodeShort => 4,\n            HexLiteralKind::UnicodeLong => 8,\n        }\n    }\n}"],"ast::Literal":["Clone","Debug","Eq","PartialEq","impl Literal {\n    /// If this literal was written as a `\\x` hex escape, then this returns\n    /// the corresponding byte value. Otherwise, this returns `None`.\n    pub fn byte(&self) -> Option<u8> {\n        let short_hex = LiteralKind::HexFixed(HexLiteralKind::X);\n        if self.c as u32 <= 255 && self.kind == short_hex {\n            Some(self.c as u8)\n        } else {\n            None\n        }\n    }\n}"],"ast::LiteralKind":["Clone","Debug","Eq","PartialEq"],"ast::Position":["Clone","Copy","Eq","PartialEq","impl Ord for Position {\n    fn cmp(&self, other: &Position) -> Ordering {\n        self.offset.cmp(&other.offset)\n    }\n}","impl PartialOrd for Position {\n    fn partial_cmp(&self, other: &Position) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Position {\n    /// Create a new position with the given information.\n    ///\n    /// `offset` is the absolute offset of the position, starting at `0` from\n    /// the beginning of the regular expression pattern string.\n    ///\n    /// `line` is the line number, starting at `1`.\n    ///\n    /// `column` is the approximate column number, starting at `1`.\n    pub fn new(offset: usize, line: usize, column: usize) -> Position {\n        Position { offset: offset, line: line, column: column }\n    }\n}","impl fmt::Debug for Position {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Position(o: {:?}, l: {:?}, c: {:?})\",\n            self.offset, self.line, self.column\n        )\n    }\n}"],"ast::Repetition":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionKind":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionOp":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionRange":["Clone","Debug","Eq","PartialEq","impl RepetitionRange {\n    /// Returns true if and only if this repetition range is valid.\n    ///\n    /// The only case where a repetition range is invalid is if it is bounded\n    /// and its start is greater than its end.\n    pub fn is_valid(&self) -> bool {\n        match *self {\n            RepetitionRange::Bounded(s, e) if s > e => false,\n            _ => true,\n        }\n    }\n}"],"ast::SetFlags":["Clone","Debug","Eq","PartialEq"],"ast::Span":["Clone","Copy","Eq","PartialEq","impl Ord for Span {\n    fn cmp(&self, other: &Span) -> Ordering {\n        (&self.start, &self.end).cmp(&(&other.start, &other.end))\n    }\n}","impl PartialOrd for Span {\n    fn partial_cmp(&self, other: &Span) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Span {\n    /// Create a new span with the given positions.\n    pub fn new(start: Position, end: Position) -> Span {\n        Span { start: start, end: end }\n    }\n\n    /// Create a new span using the given position as the start and end.\n    pub fn splat(pos: Position) -> Span {\n        Span::new(pos, pos)\n    }\n\n    /// Create a new span by replacing the starting the position with the one\n    /// given.\n    pub fn with_start(self, pos: Position) -> Span {\n        Span { start: pos, ..self }\n    }\n\n    /// Create a new span by replacing the ending the position with the one\n    /// given.\n    pub fn with_end(self, pos: Position) -> Span {\n        Span { end: pos, ..self }\n    }\n\n    /// Returns true if and only if this span occurs on a single line.\n    pub fn is_one_line(&self) -> bool {\n        self.start.line == self.end.line\n    }\n\n    /// Returns true if and only if this span is empty. That is, it points to\n    /// a single position in the concrete syntax of a regular expression.\n    pub fn is_empty(&self) -> bool {\n        self.start.offset == self.end.offset\n    }\n}","impl fmt::Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Span({:?}, {:?})\", self.start, self.end)\n    }\n}"],"ast::SpecialLiteralKind":["Clone","Debug","Eq","PartialEq"],"ast::WithComments":["Clone","Debug","Eq","PartialEq"],"ast::parse::ClassState":["Clone","Debug"],"ast::parse::GroupState":["Clone","Debug"],"ast::parse::NestLimiter":["Debug","impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {\n    fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {\n        NestLimiter { p: p, depth: 0 }\n    }\n\n    #[inline(never)]\n    fn check(self, ast: &Ast) -> Result<()> {\n        ast::visit(ast, self)\n    }\n\n    fn increment_depth(&mut self, span: &Span) -> Result<()> {\n        let new = self.depth.checked_add(1).ok_or_else(|| {\n            self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(::std::u32::MAX),\n            )\n        })?;\n        let limit = self.p.parser().nest_limit;\n        if new > limit {\n            return Err(self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(limit),\n            ));\n        }\n        self.depth = new;\n        Ok(())\n    }\n\n    fn decrement_depth(&mut self) {\n        // Assuming the correctness of the visitor, this should never drop\n        // below 0.\n        self.depth = self.depth.checked_sub(1).unwrap();\n    }\n}","impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {\n    type Output = ();\n    type Err = ast::Error;\n\n    fn finish(self) -> Result<()> {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        let span = match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            Ast::Class(ast::Class::Bracketed(ref x)) => &x.span,\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            Ast::Class(ast::Class::Bracketed(_))\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        let span = match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            ast::ClassSetItem::Bracketed(ref x) => &x.span,\n            ast::ClassSetItem::Union(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.increment_depth(&ast.span)\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.decrement_depth();\n        Ok(())\n    }\n}"],"ast::parse::Parser":["Clone","Debug","impl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with either the `parse` or `parse_with_comments`\n    /// methods. The parse methods return an abstract syntax tree.\n    ///\n    /// To set configuration options on the parser, use\n    /// [`ParserBuilder`](struct.ParserBuilder.html).\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into an abstract syntax tree.\n    pub fn parse(&mut self, pattern: &str) -> Result<Ast> {\n        ParserI::new(self, pattern).parse()\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    pub fn parse_with_comments(\n        &mut self,\n        pattern: &str,\n    ) -> Result<ast::WithComments> {\n        ParserI::new(self, pattern).parse_with_comments()\n    }\n\n    /// Reset the internal state of a parser.\n    ///\n    /// This is called at the beginning of every parse. This prevents the\n    /// parser from running with inconsistent state (say, if a previous\n    /// invocation returned an error and the parser is reused).\n    fn reset(&self) {\n        // These settings should be in line with the construction\n        // in `ParserBuilder::build`.\n        self.pos.set(Position { offset: 0, line: 1, column: 1 });\n        self.ignore_whitespace.set(self.initial_ignore_whitespace);\n        self.comments.borrow_mut().clear();\n        self.stack_group.borrow_mut().clear();\n        self.stack_class.borrow_mut().clear();\n    }\n}"],"ast::parse::ParserBuilder":["Clone","Debug","impl Default for ParserBuilder {\n    fn default() -> ParserBuilder {\n        ParserBuilder::new()\n    }\n}","impl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder {\n            ignore_whitespace: false,\n            nest_limit: 250,\n            octal: false,\n        }\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser {\n            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),\n            capture_index: Cell::new(0),\n            nest_limit: self.nest_limit,\n            octal: self.octal,\n            initial_ignore_whitespace: self.ignore_whitespace,\n            ignore_whitespace: Cell::new(self.ignore_whitespace),\n            comments: RefCell::new(vec![]),\n            stack_group: RefCell::new(vec![]),\n            stack_class: RefCell::new(vec![]),\n            capture_names: RefCell::new(vec![]),\n            scratch: RefCell::new(String::new()),\n        }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire Ast is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// lenth of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.nest_limit = limit;\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.octal = yes;\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insigificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ignore_whitespace = yes;\n        self\n    }\n}"],"ast::parse::ParserI":["Clone","Debug","impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Build an internal parser from a parser configuration and a pattern.\n    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {\n        ParserI { parser: parser, pattern: pattern }\n    }\n\n    /// Return a reference to the parser state.\n    fn parser(&self) -> &Parser {\n        self.parser.borrow()\n    }\n\n    /// Return a reference to the pattern being parsed.\n    fn pattern(&self) -> &str {\n        self.pattern.borrow()\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {\n        ast::Error {\n            kind: kind,\n            pattern: self.pattern().to_string(),\n            span: span,\n        }\n    }\n\n    /// Return the current offset of the parser.\n    ///\n    /// The offset starts at `0` from the beginning of the regular expression\n    /// pattern string.\n    fn offset(&self) -> usize {\n        self.parser().pos.get().offset\n    }\n\n    /// Return the current line number of the parser.\n    ///\n    /// The line number starts at `1`.\n    fn line(&self) -> usize {\n        self.parser().pos.get().line\n    }\n\n    /// Return the current column of the parser.\n    ///\n    /// The column number starts at `1` and is reset whenever a `\\n` is seen.\n    fn column(&self) -> usize {\n        self.parser().pos.get().column\n    }\n\n    /// Return the next capturing index. Each subsequent call increments the\n    /// internal index.\n    ///\n    /// The span given should correspond to the location of the opening\n    /// parenthesis.\n    ///\n    /// If the capture limit is exceeded, then an error is returned.\n    fn next_capture_index(&self, span: Span) -> Result<u32> {\n        let current = self.parser().capture_index.get();\n        let i = current.checked_add(1).ok_or_else(|| {\n            self.error(span, ast::ErrorKind::CaptureLimitExceeded)\n        })?;\n        self.parser().capture_index.set(i);\n        Ok(i)\n    }\n\n    /// Adds the given capture name to this parser. If this capture name has\n    /// already been used, then an error is returned.\n    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()> {\n        let mut names = self.parser().capture_names.borrow_mut();\n        match names\n            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())\n        {\n            Err(i) => {\n                names.insert(i, cap.clone());\n                Ok(())\n            }\n            Ok(i) => Err(self.error(\n                cap.span,\n                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },\n            )),\n        }\n    }\n\n    /// Return whether the parser should ignore whitespace or not.\n    fn ignore_whitespace(&self) -> bool {\n        self.parser().ignore_whitespace.get()\n    }\n\n    /// Return the character at the current position of the parser.\n    ///\n    /// This panics if the current position does not point to a valid char.\n    fn char(&self) -> char {\n        self.char_at(self.offset())\n    }\n\n    /// Return the character at the given position.\n    ///\n    /// This panics if the given position does not point to a valid char.\n    fn char_at(&self, i: usize) -> char {\n        self.pattern()[i..]\n            .chars()\n            .next()\n            .unwrap_or_else(|| panic!(\"expected char at offset {}\", i))\n    }\n\n    /// Bump the parser to the next Unicode scalar value.\n    ///\n    /// If the end of the input has been reached, then `false` is returned.\n    fn bump(&self) -> bool {\n        if self.is_eof() {\n            return false;\n        }\n        let Position { mut offset, mut line, mut column } = self.pos();\n        if self.char() == '\\n' {\n            line = line.checked_add(1).unwrap();\n            column = 1;\n        } else {\n            column = column.checked_add(1).unwrap();\n        }\n        offset += self.char().len_utf8();\n        self.parser().pos.set(Position {\n            offset: offset,\n            line: line,\n            column: column,\n        });\n        self.pattern()[self.offset()..].chars().next().is_some()\n    }\n\n    /// If the substring starting at the current position of the parser has\n    /// the given prefix, then bump the parser to the character immediately\n    /// following the prefix and return true. Otherwise, don't bump the parser\n    /// and return false.\n    fn bump_if(&self, prefix: &str) -> bool {\n        if self.pattern()[self.offset()..].starts_with(prefix) {\n            for _ in 0..prefix.chars().count() {\n                self.bump();\n            }\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if and only if the parser is positioned at a look-around\n    /// prefix. The conditions under which this returns true must always\n    /// correspond to a regular expression that would otherwise be consider\n    /// invalid.\n    ///\n    /// This should only be called immediately after parsing the opening of\n    /// a group or a set of flags.\n    fn is_lookaround_prefix(&self) -> bool {\n        self.bump_if(\"?=\")\n            || self.bump_if(\"?!\")\n            || self.bump_if(\"?<=\")\n            || self.bump_if(\"?<!\")\n    }\n\n    /// Bump the parser, and if the `x` flag is enabled, bump through any\n    /// subsequent spaces. Return true if and only if the parser is not at\n    /// EOF.\n    fn bump_and_bump_space(&self) -> bool {\n        if !self.bump() {\n            return false;\n        }\n        self.bump_space();\n        !self.is_eof()\n    }\n\n    /// If the `x` flag is enabled (i.e., whitespace insensitivity with\n    /// comments), then this will advance the parser through all whitespace\n    /// and comments to the next non-whitespace non-comment byte.\n    ///\n    /// If the `x` flag is disabled, then this is a no-op.\n    ///\n    /// This should be used selectively throughout the parser where\n    /// arbitrary whitespace is permitted when the `x` flag is enabled. For\n    /// example, `{   5  , 6}` is equivalent to `{5,6}`.\n    fn bump_space(&self) {\n        if !self.ignore_whitespace() {\n            return;\n        }\n        while !self.is_eof() {\n            if self.char().is_whitespace() {\n                self.bump();\n            } else if self.char() == '#' {\n                let start = self.pos();\n                let mut comment_text = String::new();\n                self.bump();\n                while !self.is_eof() {\n                    let c = self.char();\n                    self.bump();\n                    if c == '\\n' {\n                        break;\n                    }\n                    comment_text.push(c);\n                }\n                let comment = ast::Comment {\n                    span: Span::new(start, self.pos()),\n                    comment: comment_text,\n                };\n                self.parser().comments.borrow_mut().push(comment);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// Peek at the next character in the input without advancing the parser.\n    ///\n    /// If the input has been exhausted, then this returns `None`.\n    fn peek(&self) -> Option<char> {\n        if self.is_eof() {\n            return None;\n        }\n        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()\n    }\n\n    /// Like peek, but will ignore spaces when the parser is in whitespace\n    /// insensitive mode.\n    fn peek_space(&self) -> Option<char> {\n        if !self.ignore_whitespace() {\n            return self.peek();\n        }\n        if self.is_eof() {\n            return None;\n        }\n        let mut start = self.offset() + self.char().len_utf8();\n        let mut in_comment = false;\n        for (i, c) in self.pattern()[start..].char_indices() {\n            if c.is_whitespace() {\n                continue;\n            } else if !in_comment && c == '#' {\n                in_comment = true;\n            } else if in_comment && c == '\\n' {\n                in_comment = false;\n            } else {\n                start += i;\n                break;\n            }\n        }\n        self.pattern()[start..].chars().next()\n    }\n\n    /// Returns true if the next call to `bump` would return false.\n    fn is_eof(&self) -> bool {\n        self.offset() == self.pattern().len()\n    }\n\n    /// Return the current position of the parser, which includes the offset,\n    /// line and column.\n    fn pos(&self) -> Position {\n        self.parser().pos.get()\n    }\n\n    /// Create a span at the current position of the parser. Both the start\n    /// and end of the span are set.\n    fn span(&self) -> Span {\n        Span::splat(self.pos())\n    }\n\n    /// Create a span that covers the current character.\n    fn span_char(&self) -> Span {\n        let mut next = Position {\n            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),\n            line: self.line(),\n            column: self.column().checked_add(1).unwrap(),\n        };\n        if self.char() == '\\n' {\n            next.line += 1;\n            next.column = 1;\n        }\n        Span::new(self.pos(), next)\n    }\n\n    /// Parse and push a single alternation on to the parser's internal stack.\n    /// If the top of the stack already has an alternation, then add to that\n    /// instead of pushing a new one.\n    ///\n    /// The concatenation given corresponds to a single alternation branch.\n    /// The concatenation returned starts the next branch and is empty.\n    ///\n    /// This assumes the parser is currently positioned at `|` and will advance\n    /// the parser to the character following `|`.\n    #[inline(never)]\n    fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '|');\n        concat.span.end = self.pos();\n        self.push_or_add_alternation(concat);\n        self.bump();\n        Ok(ast::Concat { span: self.span(), asts: vec![] })\n    }\n\n    /// Pushes or adds the given branch of an alternation to the parser's\n    /// internal stack of state.\n    fn push_or_add_alternation(&self, concat: ast::Concat) {\n        use self::GroupState::*;\n\n        let mut stack = self.parser().stack_group.borrow_mut();\n        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {\n            alts.asts.push(concat.into_ast());\n            return;\n        }\n        stack.push(Alternation(ast::Alternation {\n            span: Span::new(concat.span.start, self.pos()),\n            asts: vec![concat.into_ast()],\n        }));\n    }\n\n    /// Parse and push a group AST (and its parent concatenation) on to the\n    /// parser's internal stack. Return a fresh concatenation corresponding\n    /// to the group's sub-AST.\n    ///\n    /// If a set of flags was found (with no group), then the concatenation\n    /// is returned with that set of flags added.\n    ///\n    /// This assumes that the parser is currently positioned on the opening\n    /// parenthesis. It advances the parser to the character at the start\n    /// of the sub-expression (or adjoining expression).\n    ///\n    /// If there was a problem parsing the start of the group, then an error\n    /// is returned.\n    #[inline(never)]\n    fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '(');\n        match self.parse_group()? {\n            Either::Left(set) => {\n                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);\n                if let Some(v) = ignore {\n                    self.parser().ignore_whitespace.set(v);\n                }\n\n                concat.asts.push(Ast::Flags(set));\n                Ok(concat)\n            }\n            Either::Right(group) => {\n                let old_ignore_whitespace = self.ignore_whitespace();\n                let new_ignore_whitespace = group\n                    .flags()\n                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))\n                    .unwrap_or(old_ignore_whitespace);\n                self.parser().stack_group.borrow_mut().push(\n                    GroupState::Group {\n                        concat: concat,\n                        group: group,\n                        ignore_whitespace: old_ignore_whitespace,\n                    },\n                );\n                self.parser().ignore_whitespace.set(new_ignore_whitespace);\n                Ok(ast::Concat { span: self.span(), asts: vec![] })\n            }\n        }\n    }\n\n    /// Pop a group AST from the parser's internal stack and set the group's\n    /// AST to the given concatenation. Return the concatenation containing\n    /// the group.\n    ///\n    /// This assumes that the parser is currently positioned on the closing\n    /// parenthesis and advances the parser to the character following the `)`.\n    ///\n    /// If no such group could be popped, then an unopened group error is\n    /// returned.\n    #[inline(never)]\n    fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {\n        use self::GroupState::*;\n\n        assert_eq!(self.char(), ')');\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack\n            .pop()\n        {\n            Some(Group { concat, group, ignore_whitespace }) => {\n                (concat, group, ignore_whitespace, None)\n            }\n            Some(Alternation(alt)) => match stack.pop() {\n                Some(Group { concat, group, ignore_whitespace }) => {\n                    (concat, group, ignore_whitespace, Some(alt))\n                }\n                None | Some(Alternation(_)) => {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::GroupUnopened,\n                    ));\n                }\n            },\n            None => {\n                return Err(self\n                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));\n            }\n        };\n        self.parser().ignore_whitespace.set(ignore_whitespace);\n        group_concat.span.end = self.pos();\n        self.bump();\n        group.span.end = self.pos();\n        match alt {\n            Some(mut alt) => {\n                alt.span.end = group_concat.span.end;\n                alt.asts.push(group_concat.into_ast());\n                group.ast = Box::new(alt.into_ast());\n            }\n            None => {\n                group.ast = Box::new(group_concat.into_ast());\n            }\n        }\n        prior_concat.asts.push(Ast::Group(group));\n        Ok(prior_concat)\n    }\n\n    /// Pop the last state from the parser's internal stack, if it exists, and\n    /// add the given concatenation to it. There either must be no state or a\n    /// single alternation item on the stack. Any other scenario produces an\n    /// error.\n    ///\n    /// This assumes that the parser has advanced to the end.\n    #[inline(never)]\n    fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {\n        concat.span.end = self.pos();\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let ast = match stack.pop() {\n            None => Ok(concat.into_ast()),\n            Some(GroupState::Alternation(mut alt)) => {\n                alt.span.end = self.pos();\n                alt.asts.push(concat.into_ast());\n                Ok(Ast::Alternation(alt))\n            }\n            Some(GroupState::Group { group, .. }) => {\n                return Err(\n                    self.error(group.span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n        };\n        // If we try to pop again, there should be nothing.\n        match stack.pop() {\n            None => ast,\n            Some(GroupState::Alternation(_)) => {\n                // This unreachable is unfortunate. This case can't happen\n                // because the only way we can be here is if there were two\n                // `GroupState::Alternation`s adjacent in the parser's stack,\n                // which we guarantee to never happen because we never push a\n                // `GroupState::Alternation` if one is already at the top of\n                // the stack.\n                unreachable!()\n            }\n            Some(GroupState::Group { group, .. }) => {\n                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))\n            }\n        }\n    }\n\n    /// Parse the opening of a character class and push the current class\n    /// parsing context onto the parser's stack. This assumes that the parser\n    /// is positioned at an opening `[`. The given union should correspond to\n    /// the union of set items built up before seeing the `[`.\n    ///\n    /// If there was a problem parsing the opening of the class, then an error\n    /// is returned. Otherwise, a new union of set items for the class is\n    /// returned (which may be populated with either a `]` or a `-`).\n    #[inline(never)]\n    fn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion> {\n        assert_eq!(self.char(), '[');\n\n        let (nested_set, nested_union) = self.parse_set_class_open()?;\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Open { union: parent_union, set: nested_set });\n        Ok(nested_union)\n    }\n\n    /// Parse the end of a character class set and pop the character class\n    /// parser stack. The union given corresponds to the last union built\n    /// before seeing the closing `]`. The union returned corresponds to the\n    /// parent character class set with the nested class added to it.\n    ///\n    /// This assumes that the parser is positioned at a `]` and will advance\n    /// the parser to the byte immediately following the `]`.\n    ///\n    /// If the stack is empty after popping, then this returns the final\n    /// \"top-level\" character class AST (where a \"top-level\" character class\n    /// is one that is not nested inside any other character class).\n    ///\n    /// If there is no corresponding opening bracket on the parser's stack,\n    /// then an error is returned.\n    #[inline(never)]\n    fn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>> {\n        assert_eq!(self.char(), ']');\n\n        let item = ast::ClassSet::Item(nested_union.into_item());\n        let prevset = self.pop_class_op(item);\n        let mut stack = self.parser().stack_class.borrow_mut();\n        match stack.pop() {\n            None => {\n                // We can never observe an empty stack:\n                //\n                // 1) We are guaranteed to start with a non-empty stack since\n                //    the character class parser is only initiated when it sees\n                //    a `[`.\n                // 2) If we ever observe an empty stack while popping after\n                //    seeing a `]`, then we signal the character class parser\n                //    to terminate.\n                panic!(\"unexpected empty character class stack\")\n            }\n            Some(ClassState::Op { .. }) => {\n                // This panic is unfortunate, but this case is impossible\n                // since we already popped the Op state if one exists above.\n                // Namely, every push to the class parser stack is guarded by\n                // whether an existing Op is already on the top of the stack.\n                // If it is, the existing Op is modified. That is, the stack\n                // can never have consecutive Op states.\n                panic!(\"unexpected ClassState::Op\")\n            }\n            Some(ClassState::Open { mut union, mut set }) => {\n                self.bump();\n                set.span.end = self.pos();\n                set.kind = prevset;\n                if stack.is_empty() {\n                    Ok(Either::Right(ast::Class::Bracketed(set)))\n                } else {\n                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                    Ok(Either::Left(union))\n                }\n            }\n        }\n    }\n\n    /// Return an \"unclosed class\" error whose span points to the most\n    /// recently opened class.\n    ///\n    /// This should only be called while parsing a character class.\n    #[inline(never)]\n    fn unclosed_class_error(&self) -> ast::Error {\n        for state in self.parser().stack_class.borrow().iter().rev() {\n            match *state {\n                ClassState::Open { ref set, .. } => {\n                    return self\n                        .error(set.span, ast::ErrorKind::ClassUnclosed);\n                }\n                _ => {}\n            }\n        }\n        // We are guaranteed to have a non-empty stack with at least\n        // one open bracket, so we should never get here.\n        panic!(\"no open character class found\")\n    }\n\n    /// Push the current set of class items on to the class parser's stack as\n    /// the left hand side of the given operator.\n    ///\n    /// A fresh set union is returned, which should be used to build the right\n    /// hand side of this operator.\n    #[inline(never)]\n    fn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion {\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });\n        ast::ClassSetUnion { span: self.span(), items: vec![] }\n    }\n\n    /// Pop a character class set from the character class parser stack. If the\n    /// top of the stack is just an item (not an operation), then return the\n    /// given set unchanged. If the top of the stack is an operation, then the\n    /// given set will be used as the rhs of the operation on the top of the\n    /// stack. In that case, the binary operation is returned as a set.\n    #[inline(never)]\n    fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span: span,\n            kind: kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }\n}","impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Parse the regular expression into an abstract syntax tree.\n    fn parse(&self) -> Result<Ast> {\n        self.parse_with_comments().map(|astc| astc.ast)\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    fn parse_with_comments(&self) -> Result<ast::WithComments> {\n        assert_eq!(self.offset(), 0, \"parser can only be used once\");\n        self.parser().reset();\n        let mut concat = ast::Concat { span: self.span(), asts: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                break;\n            }\n            match self.char() {\n                '(' => concat = self.push_group(concat)?,\n                ')' => concat = self.pop_group(concat)?,\n                '|' => concat = self.push_alternate(concat)?,\n                '[' => {\n                    let class = self.parse_set_class()?;\n                    concat.asts.push(Ast::Class(class));\n                }\n                '?' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrOne,\n                    )?;\n                }\n                '*' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrMore,\n                    )?;\n                }\n                '+' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::OneOrMore,\n                    )?;\n                }\n                '{' => {\n                    concat = self.parse_counted_repetition(concat)?;\n                }\n                _ => concat.asts.push(self.parse_primitive()?.into_ast()),\n            }\n        }\n        let ast = self.pop_group_end(concat)?;\n        NestLimiter::new(self).check(&ast)?;\n        Ok(ast::WithComments {\n            ast: ast,\n            comments: mem::replace(\n                &mut *self.parser().comments.borrow_mut(),\n                vec![],\n            ),\n        })\n    }\n\n    /// Parses an uncounted repetition operation. An uncounted repetition\n    /// operator includes ?, * and +, but does not include the {m,n} syntax.\n    /// The given `kind` should correspond to the operator observed by the\n    /// caller.\n    ///\n    /// This assumes that the paser is currently positioned at the repetition\n    /// operator and advances the parser to the first character after the\n    /// operator. (Note that the operator may include a single additional `?`,\n    /// which makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat> {\n        assert!(\n            self.char() == '?' || self.char() == '*' || self.char() == '+'\n        );\n        let op_start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        let mut greedy = true;\n        if self.bump() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: Span::new(op_start, self.pos()),\n                kind: kind,\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parses a counted repetition operation. A counted repetition operator\n    /// corresponds to the {m,n} syntax, and does not include the ?, * or +\n    /// operators.\n    ///\n    /// This assumes that the paser is currently positioned at the opening `{`\n    /// and advances the parser to the first character after the operator.\n    /// (Note that the operator may include a single additional `?`, which\n    /// makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_counted_repetition(\n        &self,\n        mut concat: ast::Concat,\n    ) -> Result<ast::Concat> {\n        assert!(self.char() == '{');\n        let start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        let count_start = specialize_err(\n            self.parse_decimal(),\n            ast::ErrorKind::DecimalEmpty,\n            ast::ErrorKind::RepetitionCountDecimalEmpty,\n        )?;\n        let mut range = ast::RepetitionRange::Exactly(count_start);\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        if self.char() == ',' {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::RepetitionCountUnclosed,\n                ));\n            }\n            if self.char() != '}' {\n                let count_end = specialize_err(\n                    self.parse_decimal(),\n                    ast::ErrorKind::DecimalEmpty,\n                    ast::ErrorKind::RepetitionCountDecimalEmpty,\n                )?;\n                range = ast::RepetitionRange::Bounded(count_start, count_end);\n            } else {\n                range = ast::RepetitionRange::AtLeast(count_start);\n            }\n        }\n        if self.is_eof() || self.char() != '}' {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n\n        let mut greedy = true;\n        if self.bump_and_bump_space() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n\n        let op_span = Span::new(start, self.pos());\n        if !range.is_valid() {\n            return Err(\n                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)\n            );\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: op_span,\n                kind: ast::RepetitionKind::Range(range),\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parse a group (which contains a sub-expression) or a set of flags.\n    ///\n    /// If a group was found, then it is returned with an empty AST. If a set\n    /// of flags is found, then that set is returned.\n    ///\n    /// The parser should be positioned at the opening parenthesis.\n    ///\n    /// This advances the parser to the character before the start of the\n    /// sub-expression (in the case of a group) or to the closing parenthesis\n    /// immediately following the set of flags.\n    ///\n    /// # Errors\n    ///\n    /// If flags are given and incorrectly specified, then a corresponding\n    /// error is returned.\n    ///\n    /// If a capture name is given and it is incorrectly specified, then a\n    /// corresponding error is returned.\n    #[inline(never)]\n    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {\n        assert_eq!(self.char(), '(');\n        let open_span = self.span_char();\n        self.bump();\n        self.bump_space();\n        if self.is_lookaround_prefix() {\n            return Err(self.error(\n                Span::new(open_span.start, self.span().end),\n                ast::ErrorKind::UnsupportedLookAround,\n            ));\n        }\n        let inner_span = self.span();\n        if self.bump_if(\"?P<\") {\n            let capture_index = self.next_capture_index(open_span)?;\n            let cap = self.parse_capture_name(capture_index)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureName(cap),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        } else if self.bump_if(\"?\") {\n            if self.is_eof() {\n                return Err(\n                    self.error(open_span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n            let flags = self.parse_flags()?;\n            let char_end = self.char();\n            self.bump();\n            if char_end == ')' {\n                // We don't allow empty flags, e.g., `(?)`. We instead\n                // interpret it as a repetition operator missing its argument.\n                if flags.items.is_empty() {\n                    return Err(self.error(\n                        inner_span,\n                        ast::ErrorKind::RepetitionMissing,\n                    ));\n                }\n                Ok(Either::Left(ast::SetFlags {\n                    span: Span { end: self.pos(), ..open_span },\n                    flags: flags,\n                }))\n            } else {\n                assert_eq!(char_end, ':');\n                Ok(Either::Right(ast::Group {\n                    span: open_span,\n                    kind: ast::GroupKind::NonCapturing(flags),\n                    ast: Box::new(Ast::Empty(self.span())),\n                }))\n            }\n        } else {\n            let capture_index = self.next_capture_index(open_span)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureIndex(capture_index),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        }\n    }\n\n    /// Parses a capture group name. Assumes that the parser is positioned at\n    /// the first character in the name following the opening `<` (and may\n    /// possibly be EOF). This advances the parser to the first character\n    /// following the closing `>`.\n    ///\n    /// The caller must provide the capture index of the group for this name.\n    #[inline(never)]\n    fn parse_capture_name(\n        &self,\n        capture_index: u32,\n    ) -> Result<ast::CaptureName> {\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        let start = self.pos();\n        loop {\n            if self.char() == '>' {\n                break;\n            }\n            if !is_capture_char(self.char(), self.pos() == start) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::GroupNameInvalid,\n                ));\n            }\n            if !self.bump() {\n                break;\n            }\n        }\n        let end = self.pos();\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        assert_eq!(self.char(), '>');\n        self.bump();\n        let name = &self.pattern()[start.offset..end.offset];\n        if name.is_empty() {\n            return Err(self.error(\n                Span::new(start, start),\n                ast::ErrorKind::GroupNameEmpty,\n            ));\n        }\n        let capname = ast::CaptureName {\n            span: Span::new(start, end),\n            name: name.to_string(),\n            index: capture_index,\n        };\n        self.add_capture_name(&capname)?;\n        Ok(capname)\n    }\n\n    /// Parse a sequence of flags starting at the current character.\n    ///\n    /// This advances the parser to the character immediately following the\n    /// flags, which is guaranteed to be either `:` or `)`.\n    ///\n    /// # Errors\n    ///\n    /// If any flags are duplicated, then an error is returned.\n    ///\n    /// If the negation operator is used more than once, then an error is\n    /// returned.\n    ///\n    /// If no flags could be found or if the negation operation is not followed\n    /// by any flags, then an error is returned.\n    #[inline(never)]\n    fn parse_flags(&self) -> Result<ast::Flags> {\n        let mut flags = ast::Flags { span: self.span(), items: vec![] };\n        let mut last_was_negation = None;\n        while self.char() != ':' && self.char() != ')' {\n            if self.char() == '-' {\n                last_was_negation = Some(self.span_char());\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Negation,\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagRepeatedNegation {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            } else {\n                last_was_negation = None;\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagDuplicate {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            }\n            if !self.bump() {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)\n                );\n            }\n        }\n        if let Some(span) = last_was_negation {\n            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));\n        }\n        flags.span.end = self.pos();\n        Ok(flags)\n    }\n\n    /// Parse the current character as a flag. Do not advance the parser.\n    ///\n    /// # Errors\n    ///\n    /// If the flag is not recognized, then an error is returned.\n    #[inline(never)]\n    fn parse_flag(&self) -> Result<ast::Flag> {\n        match self.char() {\n            'i' => Ok(ast::Flag::CaseInsensitive),\n            'm' => Ok(ast::Flag::MultiLine),\n            's' => Ok(ast::Flag::DotMatchesNewLine),\n            'U' => Ok(ast::Flag::SwapGreed),\n            'u' => Ok(ast::Flag::Unicode),\n            'x' => Ok(ast::Flag::IgnoreWhitespace),\n            _ => {\n                Err(self\n                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))\n            }\n        }\n    }\n\n    /// Parse a primitive AST. e.g., A literal, non-set character class or\n    /// assertion.\n    ///\n    /// This assumes that the parser expects a primitive at the current\n    /// location. i.e., All other non-primitive cases have been handled.\n    /// For example, if the parser's position is at `|`, then `|` will be\n    /// treated as a literal (e.g., inside a character class).\n    ///\n    /// This advances the parser to the first character immediately following\n    /// the primitive.\n    fn parse_primitive(&self) -> Result<Primitive> {\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }\n\n    /// Parse an escape sequence as a primitive AST.\n    ///\n    /// This assumes the parser is positioned at the start of the escape\n    /// sequence, i.e., `\\`. It advances the parser to the first position\n    /// immediately following the escape sequence.\n    #[inline(never)]\n    fn parse_escape(&self) -> Result<Primitive> {\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let c = self.char();\n        // Put some of the more complicated routines into helpers.\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(self.error(\n                        Span::new(start, self.span_char().end),\n                        ast::ErrorKind::UnsupportedBackreference,\n                    ));\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(self.error(\n                    Span::new(start, self.span_char().end),\n                    ast::ErrorKind::UnsupportedBackreference,\n                ));\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n\n        // Handle all of the one letter sequences inline.\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Punctuation,\n                c: c,\n            }));\n        }\n        let special = |kind, c| {\n            Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Special(kind),\n                c: c,\n            }))\n        };\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            ' ' if self.ignore_whitespace() => {\n                special(ast::SpecialLiteralKind::Space, ' ')\n            }\n            'A' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::StartText,\n            })),\n            'z' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::EndText,\n            })),\n            'b' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::WordBoundary,\n            })),\n            'B' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::NotWordBoundary,\n            })),\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }\n\n    /// Parse an octal representation of a Unicode codepoint up to 3 digits\n    /// long. This expects the parser to be positioned at the first octal\n    /// digit and advances the parser to the first character immediately\n    /// following the octal number. This also assumes that parsing octal\n    /// escapes is enabled.\n    ///\n    /// Assuming the preconditions are met, this routine can never fail.\n    #[inline(never)]\n    fn parse_octal(&self) -> ast::Literal {\n        use std::char;\n        use std::u32;\n\n        assert!(self.parser().octal);\n        assert!('0' <= self.char() && self.char() <= '7');\n        let start = self.pos();\n        // Parse up to two more digits.\n        while self.bump()\n            && '0' <= self.char()\n            && self.char() <= '7'\n            && self.pos().offset - start.offset <= 2\n        {}\n        let end = self.pos();\n        let octal = &self.pattern()[start.offset..end.offset];\n        // Parsing the octal should never fail since the above guarantees a\n        // valid number.\n        let codepoint =\n            u32::from_str_radix(octal, 8).expect(\"valid octal number\");\n        // The max value for 3 digit octal is 0777 = 511 and [0, 511] has no\n        // invalid Unicode scalar values.\n        let c = char::from_u32(codepoint).expect(\"Unicode scalar value\");\n        ast::Literal {\n            span: Span::new(start, end),\n            kind: ast::LiteralKind::Octal,\n            c: c,\n        }\n    }\n\n    /// Parse a hex representation of a Unicode codepoint. This handles both\n    /// hex notations, i.e., `\\xFF` and `\\x{FFFF}`. This expects the parser to\n    /// be positioned at the `x`, `u` or `U` prefix. The parser is advanced to\n    /// the first character immediately following the hexadecimal literal.\n    #[inline(never)]\n    fn parse_hex(&self) -> Result<ast::Literal> {\n        assert!(\n            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'\n        );\n\n        let hex_kind = match self.char() {\n            'x' => ast::HexLiteralKind::X,\n            'u' => ast::HexLiteralKind::UnicodeShort,\n            _ => ast::HexLiteralKind::UnicodeLong,\n        };\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace(hex_kind)\n        } else {\n            self.parse_hex_digits(hex_kind)\n        }\n    }\n\n    /// Parse an N-digit hex representation of a Unicode codepoint. This\n    /// expects the parser to be positioned at the first digit and will advance\n    /// the parser to the first character immediately following the escape\n    /// sequence.\n    ///\n    /// The number of digits given must be 2 (for `\\xNN`), 4 (for `\\uNNNN`)\n    /// or 8 (for `\\UNNNNNNNN`).\n    #[inline(never)]\n    fn parse_hex_digits(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let start = self.pos();\n        for i in 0..kind.digits() {\n            if i > 0 && !self.bump_and_bump_space() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        // The final bump just moves the parser past the literal, which may\n        // be EOF.\n        self.bump_and_bump_space();\n        let end = self.pos();\n        let hex = scratch.as_str();\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, end),\n                kind: ast::LiteralKind::HexFixed(kind),\n                c: c,\n            }),\n        }\n    }\n\n    /// Parse a hex representation of any Unicode scalar value. This expects\n    /// the parser to be positioned at the opening brace `{` and will advance\n    /// the parser to the first character following the closing brace `}`.\n    #[inline(never)]\n    fn parse_hex_brace(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let brace_pos = self.pos();\n        let start = self.span_char().end;\n        while self.bump_and_bump_space() && self.char() != '}' {\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let end = self.pos();\n        let hex = scratch.as_str();\n        assert_eq!(self.char(), '}');\n        self.bump_and_bump_space();\n\n        if hex.is_empty() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeHexEmpty,\n            ));\n        }\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, self.pos()),\n                kind: ast::LiteralKind::HexBrace(kind),\n                c: c,\n            }),\n        }\n    }\n\n    /// Parse a decimal number into a u32 while trimming leading and trailing\n    /// whitespace.\n    ///\n    /// This expects the parser to be positioned at the first position where\n    /// a decimal digit could occur. This will advance the parser to the byte\n    /// immediately following the last contiguous decimal digit.\n    ///\n    /// If no decimal digit could be found or if there was a problem parsing\n    /// the complete set of digits into a u32, then an error is returned.\n    fn parse_decimal(&self) -> Result<u32> {\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump();\n        }\n        let start = self.pos();\n        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        let span = Span::new(start, self.pos());\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump_and_bump_space();\n        }\n        let digits = scratch.as_str();\n        if digits.is_empty() {\n            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));\n        }\n        match u32::from_str_radix(digits, 10).ok() {\n            Some(n) => Ok(n),\n            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),\n        }\n    }\n\n    /// Parse a standard character class consisting primarily of characters or\n    /// character ranges, but can also contain nested character classes of\n    /// any type (sans `.`).\n    ///\n    /// This assumes the parser is positioned at the opening `[`. If parsing\n    /// is successful, then the parser is advanced to the position immediately\n    /// following the closing `]`.\n    #[inline(never)]\n    fn parse_set_class(&self) -> Result<ast::Class> {\n        assert_eq!(self.char(), '[');\n\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    // If we've already parsed the opening bracket, then\n                    // attempt to treat this as the beginning of an ASCII\n                    // class. If ASCII class parsing fails, then the parser\n                    // backs up to `[`.\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => match self.pop_class(union)? {\n                    Either::Left(nested_union) => {\n                        union = nested_union;\n                    }\n                    Either::Right(class) => return Ok(class),\n                },\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Intersection,\n                        union,\n                    );\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Difference,\n                        union,\n                    );\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::SymmetricDifference,\n                        union,\n                    );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }\n\n    /// Parse a single primitive item in a character class set. The item to\n    /// be parsed can either be one of a simple literal character, a range\n    /// between two simple literal characters or a \"primitive\" character\n    /// class like \\w or \\p{Greek}.\n    ///\n    /// If an invalid escape is found, or if a character class is found where\n    /// a simple literal is expected (e.g., in a range), then an error is\n    /// returned.\n    #[inline(never)]\n    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        // If the next char isn't a `-`, then we don't have a range.\n        // There are two exceptions. If the char after a `-` is a `]`, then\n        // `-` is interpreted as a literal `-`. Alternatively, if the char\n        // after a `-` is a `-`, then `--` corresponds to a \"difference\"\n        // operation.\n        if self.char() != '-'\n            || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        // OK, now we're parsing a range, so bump past the `-` and parse the\n        // second half of the range.\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(\n                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)\n            );\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }\n\n    /// Parse a single item in a character class as a primitive, where the\n    /// primitive either consists of a verbatim literal or a single escape\n    /// sequence.\n    ///\n    /// This assumes the parser is positioned at the beginning of a primitive,\n    /// and advances the parser to the first position after the primitive if\n    /// successful.\n    ///\n    /// Note that it is the caller's responsibility to report an error if an\n    /// illegal primitive was parsed.\n    #[inline(never)]\n    fn parse_set_class_item(&self) -> Result<Primitive> {\n        if self.char() == '\\\\' {\n            self.parse_escape()\n        } else {\n            let x = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: self.char(),\n            });\n            self.bump();\n            Ok(x)\n        }\n    }\n\n    /// Parses the opening of a character class set. This includes the opening\n    /// bracket along with `^` if present to indicate negation. This also\n    /// starts parsing the opening set of unioned items if applicable, since\n    /// there are special rules applied to certain characters in the opening\n    /// of a character class. For example, `[^]]` is the class of all\n    /// characters not equal to `]`. (`]` would need to be escaped in any other\n    /// position.) Similarly for `-`.\n    ///\n    /// In all cases, the op inside the returned `ast::ClassBracketed` is an\n    /// empty union. This empty union should be replaced with the actual item\n    /// when it is popped from the parser's stack.\n    ///\n    /// This assumes the parser is positioned at the opening `[` and advances\n    /// the parser to the first non-special byte of the character class.\n    ///\n    /// An error is returned if EOF is found.\n    #[inline(never)]\n    fn parse_set_class_open(\n        &self,\n    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n\n        let negated = if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n        // Accept any number of `-` as literal `-`.\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        while self.char() == '-' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: '-',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        // If `]` is the *first* char in a set, then interpret it as a literal\n        // `]`. That is, an empty class is impossible to write.\n        if union.items.is_empty() && self.char() == ']' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: ']',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        let set = ast::ClassBracketed {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: ast::ClassSet::union(ast::ClassSetUnion {\n                span: Span::new(union.span.start, union.span.start),\n                items: vec![],\n            }),\n        };\n        Ok((set, union))\n    }\n\n    /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.\n    ///\n    /// This assumes the parser is positioned at the opening `[`.\n    ///\n    /// If no valid ASCII character class could be found, then this does not\n    /// advance the parser and `None` is returned. Otherwise, the parser is\n    /// advanced to the first byte following the closing `]` and the\n    /// corresponding ASCII class is returned.\n    #[inline(never)]\n    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {\n        // ASCII character classes are interesting from a parsing perspective\n        // because parsing cannot fail with any interesting error. For example,\n        // in order to use an ASCII character class, it must be enclosed in\n        // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think\n        // of it as \"ASCII character characters have the syntax `[:NAME:]`\n        // which can only appear within character brackets.\" This means that\n        // things like `[[:lower:]A]` are legal constructs.\n        //\n        // However, if one types an incorrect ASCII character class, e.g.,\n        // `[[:loower:]]`, then we treat that as a normal nested character\n        // class containing the characters `:elorw`. One might argue that we\n        // should return an error instead since the repeated colons give away\n        // the intent to write an ASCII class. But what if the user typed\n        // `[[:lower]]` instead? How can we tell that was intended to be an\n        // ASCII class and not just a normal nested class?\n        //\n        // Reasonable people can probably disagree over this, but for better\n        // or worse, we implement semantics that never fails at the expense\n        // of better failure modes.\n        assert_eq!(self.char(), '[');\n        // If parsing fails, then we back up the parser to this starting point.\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind: kind,\n            negated: negated,\n        })\n    }\n\n    /// Parse a Unicode class in either the single character notation, `\\pN`\n    /// or the multi-character bracketed notation, `\\p{Greek}`. This assumes\n    /// the parser is positioned at the `p` (or `P` for negation) and will\n    /// advance the parser to the character immediately following the class.\n    ///\n    /// Note that this does not check whether the class name is valid or not.\n    #[inline(never)]\n    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {\n        assert!(self.char() == 'p' || self.char() == 'P');\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let negated = self.char() == 'P';\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        let (start, kind) = if self.char() == '{' {\n            let start = self.span_char().end;\n            while self.bump_and_bump_space() && self.char() != '}' {\n                scratch.push(self.char());\n            }\n            if self.is_eof() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            assert_eq!(self.char(), '}');\n            self.bump();\n\n            let name = scratch.as_str();\n            if let Some(i) = name.find(\"!=\") {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::NotEqual,\n                        name: name[..i].to_string(),\n                        value: name[i + 2..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find(':') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Colon,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find('=') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Equal,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else {\n                (start, ast::ClassUnicodeKind::Named(name.to_string()))\n            }\n        } else {\n            let start = self.pos();\n            let c = self.char();\n            if c == '\\\\' {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::UnicodeClassInvalid,\n                ));\n            }\n            self.bump_and_bump_space();\n            let kind = ast::ClassUnicodeKind::OneLetter(c);\n            (start, kind)\n        };\n        Ok(ast::ClassUnicode {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: kind,\n        })\n    }\n\n    /// Parse a Perl character class, e.g., `\\d` or `\\W`. This assumes the\n    /// parser is currently at a valid character class name and will be\n    /// advanced to the character immediately following the class.\n    #[inline(never)]\n    fn parse_perl_class(&self) -> ast::ClassPerl {\n        let c = self.char();\n        let span = self.span_char();\n        self.bump();\n        let (negated, kind) = match c {\n            'd' => (false, ast::ClassPerlKind::Digit),\n            'D' => (true, ast::ClassPerlKind::Digit),\n            's' => (false, ast::ClassPerlKind::Space),\n            'S' => (true, ast::ClassPerlKind::Space),\n            'w' => (false, ast::ClassPerlKind::Word),\n            'W' => (true, ast::ClassPerlKind::Word),\n            c => panic!(\"expected valid Perl class but got '{}'\", c),\n        };\n        ast::ClassPerl { span: span, kind: kind, negated: negated }\n    }\n}"],"ast::parse::Primitive":["Clone","Debug","Eq","PartialEq","impl Primitive {\n    /// Return the span of this primitive.\n    fn span(&self) -> &Span {\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }\n\n    /// Convert this primitive into a proper AST.\n    fn into_ast(self) -> Ast {\n        match self {\n            Primitive::Literal(lit) => Ast::Literal(lit),\n            Primitive::Assertion(assert) => Ast::Assertion(assert),\n            Primitive::Dot(span) => Ast::Dot(span),\n            Primitive::Perl(cls) => Ast::Class(ast::Class::Perl(cls)),\n            Primitive::Unicode(cls) => Ast::Class(ast::Class::Unicode(cls)),\n        }\n    }\n\n    /// Convert this primitive into an item in a character class.\n    ///\n    /// If this primitive is not a legal item (i.e., an assertion or a dot),\n    /// then return an error.\n    fn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::ClassSetItem> {\n        use self::Primitive::*;\n        use ast::ClassSetItem;\n\n        match self {\n            Literal(lit) => Ok(ClassSetItem::Literal(lit)),\n            Perl(cls) => Ok(ClassSetItem::Perl(cls)),\n            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),\n        }\n    }\n\n    /// Convert this primitive into a literal in a character class. In\n    /// particular, literals are the only valid items that can appear in\n    /// ranges.\n    ///\n    /// If this primitive is not a legal item (i.e., a class, assertion or a\n    /// dot), then return an error.\n    fn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::Literal> {\n        use self::Primitive::*;\n\n        match self {\n            Literal(lit) => Ok(lit),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),\n        }\n    }\n}"],"ast::print::Printer":["Debug","impl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result {\n        visitor::visit(ast, Writer { printer: self, wtr: wtr })\n    }\n}"],"ast::print::PrinterBuilder":["Clone","Debug","impl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}","impl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}"],"ast::print::Writer":["Debug","impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> fmt::Result {\n        match *ast {\n            Ast::Group(ref x) => self.fmt_group_pre(x),\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> fmt::Result {\n        use ast::Class;\n\n        match *ast {\n            Ast::Empty(_) => Ok(()),\n            Ast::Flags(ref x) => self.fmt_set_flags(x),\n            Ast::Literal(ref x) => self.fmt_literal(x),\n            Ast::Dot(_) => self.wtr.write_str(\".\"),\n            Ast::Assertion(ref x) => self.fmt_assertion(x),\n            Ast::Class(Class::Perl(ref x)) => self.fmt_class_perl(x),\n            Ast::Class(Class::Unicode(ref x)) => self.fmt_class_unicode(x),\n            Ast::Class(Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_post(x)\n            }\n            Ast::Repetition(ref x) => self.fmt_repetition(x),\n            Ast::Group(ref x) => self.fmt_group_post(x),\n            Ast::Alternation(_) => Ok(()),\n            Ast::Concat(_) => Ok(()),\n        }\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(ref x) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        use ast::ClassSetItem::*;\n\n        match *ast {\n            Empty(_) => Ok(()),\n            Literal(ref x) => self.fmt_literal(x),\n            Range(ref x) => {\n                self.fmt_literal(&x.start)?;\n                self.wtr.write_str(\"-\")?;\n                self.fmt_literal(&x.end)?;\n                Ok(())\n            }\n            Ascii(ref x) => self.fmt_class_ascii(x),\n            Unicode(ref x) => self.fmt_class_unicode(x),\n            Perl(ref x) => self.fmt_class_perl(x),\n            Bracketed(ref x) => self.fmt_class_bracketed_post(x),\n            Union(_) => Ok(()),\n        }\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        self.fmt_class_set_binary_op_kind(&ast.kind)\n    }\n}","impl<'p, W: fmt::Write> Writer<'p, W> {\n    fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result {\n        use ast::GroupKind::*;\n        match ast.kind {\n            CaptureIndex(_) => self.wtr.write_str(\"(\"),\n            CaptureName(ref x) => {\n                self.wtr.write_str(\"(?P<\")?;\n                self.wtr.write_str(&x.name)?;\n                self.wtr.write_str(\">\")?;\n                Ok(())\n            }\n            NonCapturing(ref flags) => {\n                self.wtr.write_str(\"(?\")?;\n                self.fmt_flags(flags)?;\n                self.wtr.write_str(\":\")?;\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result {\n        self.wtr.write_str(\")\")\n    }\n\n    fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result {\n        use ast::RepetitionKind::*;\n        match ast.op.kind {\n            ZeroOrOne if ast.greedy => self.wtr.write_str(\"?\"),\n            ZeroOrOne => self.wtr.write_str(\"??\"),\n            ZeroOrMore if ast.greedy => self.wtr.write_str(\"*\"),\n            ZeroOrMore => self.wtr.write_str(\"*?\"),\n            OneOrMore if ast.greedy => self.wtr.write_str(\"+\"),\n            OneOrMore => self.wtr.write_str(\"+?\"),\n            Range(ref x) => {\n                self.fmt_repetition_range(x)?;\n                if !ast.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_repetition_range(\n        &mut self,\n        ast: &ast::RepetitionRange,\n    ) -> fmt::Result {\n        use ast::RepetitionRange::*;\n        match *ast {\n            Exactly(x) => write!(self.wtr, \"{{{}}}\", x),\n            AtLeast(x) => write!(self.wtr, \"{{{},}}\", x),\n            Bounded(x, y) => write!(self.wtr, \"{{{},{}}}\", x, y),\n        }\n    }\n\n    fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result {\n        use ast::LiteralKind::*;\n\n        match ast.kind {\n            Verbatim => self.wtr.write_char(ast.c),\n            Punctuation => write!(self.wtr, r\"\\{}\", ast.c),\n            Octal => write!(self.wtr, r\"\\{:o}\", ast.c as u32),\n            HexFixed(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{:02X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{:04X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{:08X}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{{{:X}}}\", ast.c as u32)\n            }\n            Special(ast::SpecialLiteralKind::Bell) => {\n                self.wtr.write_str(r\"\\a\")\n            }\n            Special(ast::SpecialLiteralKind::FormFeed) => {\n                self.wtr.write_str(r\"\\f\")\n            }\n            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r\"\\t\"),\n            Special(ast::SpecialLiteralKind::LineFeed) => {\n                self.wtr.write_str(r\"\\n\")\n            }\n            Special(ast::SpecialLiteralKind::CarriageReturn) => {\n                self.wtr.write_str(r\"\\r\")\n            }\n            Special(ast::SpecialLiteralKind::VerticalTab) => {\n                self.wtr.write_str(r\"\\v\")\n            }\n            Special(ast::SpecialLiteralKind::Space) => {\n                self.wtr.write_str(r\"\\ \")\n            }\n        }\n    }\n\n    fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result {\n        use ast::AssertionKind::*;\n        match ast.kind {\n            StartLine => self.wtr.write_str(\"^\"),\n            EndLine => self.wtr.write_str(\"$\"),\n            StartText => self.wtr.write_str(r\"\\A\"),\n            EndText => self.wtr.write_str(r\"\\z\"),\n            WordBoundary => self.wtr.write_str(r\"\\b\"),\n            NotWordBoundary => self.wtr.write_str(r\"\\B\"),\n        }\n    }\n\n    fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result {\n        self.wtr.write_str(\"(?\")?;\n        self.fmt_flags(&ast.flags)?;\n        self.wtr.write_str(\")\")?;\n        Ok(())\n    }\n\n    fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result {\n        use ast::{Flag, FlagsItemKind};\n\n        for item in &ast.items {\n            match item.kind {\n                FlagsItemKind::Negation => self.wtr.write_str(\"-\"),\n                FlagsItemKind::Flag(ref flag) => match *flag {\n                    Flag::CaseInsensitive => self.wtr.write_str(\"i\"),\n                    Flag::MultiLine => self.wtr.write_str(\"m\"),\n                    Flag::DotMatchesNewLine => self.wtr.write_str(\"s\"),\n                    Flag::SwapGreed => self.wtr.write_str(\"U\"),\n                    Flag::Unicode => self.wtr.write_str(\"u\"),\n                    Flag::IgnoreWhitespace => self.wtr.write_str(\"x\"),\n                },\n            }?;\n        }\n        Ok(())\n    }\n\n    fn fmt_class_bracketed_pre(\n        &mut self,\n        ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        if ast.negated {\n            self.wtr.write_str(\"[^\")\n        } else {\n            self.wtr.write_str(\"[\")\n        }\n    }\n\n    fn fmt_class_bracketed_post(\n        &mut self,\n        _ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        self.wtr.write_str(\"]\")\n    }\n\n    fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result {\n        use ast::ClassSetBinaryOpKind::*;\n        match *ast {\n            Intersection => self.wtr.write_str(\"&&\"),\n            Difference => self.wtr.write_str(\"--\"),\n            SymmetricDifference => self.wtr.write_str(\"~~\"),\n        }\n    }\n\n    fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result {\n        use ast::ClassPerlKind::*;\n        match ast.kind {\n            Digit if ast.negated => self.wtr.write_str(r\"\\D\"),\n            Digit => self.wtr.write_str(r\"\\d\"),\n            Space if ast.negated => self.wtr.write_str(r\"\\S\"),\n            Space => self.wtr.write_str(r\"\\s\"),\n            Word if ast.negated => self.wtr.write_str(r\"\\W\"),\n            Word => self.wtr.write_str(r\"\\w\"),\n        }\n    }\n\n    fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result {\n        use ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }\n\n    fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result {\n        use ast::ClassUnicodeKind::*;\n        use ast::ClassUnicodeOpKind::*;\n\n        if ast.negated {\n            self.wtr.write_str(r\"\\P\")?;\n        } else {\n            self.wtr.write_str(r\"\\p\")?;\n        }\n        match ast.kind {\n            OneLetter(c) => self.wtr.write_char(c),\n            Named(ref x) => write!(self.wtr, \"{{{}}}\", x),\n            NamedValue { op: Equal, ref name, ref value } => {\n                write!(self.wtr, \"{{{}={}}}\", name, value)\n            }\n            NamedValue { op: Colon, ref name, ref value } => {\n                write!(self.wtr, \"{{{}:{}}}\", name, value)\n            }\n            NamedValue { op: NotEqual, ref name, ref value } => {\n                write!(self.wtr, \"{{{}!={}}}\", name, value)\n            }\n        }\n    }\n}"],"ast::visitor::ClassFrame":["impl<'a> ClassFrame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child class node to visit.\n    fn child(&self) -> ClassInduct<'a> {\n        match *self {\n            ClassFrame::Union { head, .. } => ClassInduct::Item(head),\n            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),\n            ClassFrame::BinaryLHS { ref lhs, .. } => {\n                ClassInduct::from_set(lhs)\n            }\n            ClassFrame::BinaryRHS { ref rhs, .. } => {\n                ClassInduct::from_set(rhs)\n            }\n        }\n    }\n}","impl<'a> fmt::Debug for ClassFrame<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let x = match *self {\n            ClassFrame::Union { .. } => \"Union\",\n            ClassFrame::Binary { .. } => \"Binary\",\n            ClassFrame::BinaryLHS { .. } => \"BinaryLHS\",\n            ClassFrame::BinaryRHS { .. } => \"BinaryRHS\",\n        };\n        write!(f, \"{}\", x)\n    }\n}"],"ast::visitor::ClassInduct":["impl<'a> ClassInduct<'a> {\n    fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {\n        ClassInduct::from_set(&ast.kind)\n    }\n\n    fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {\n        match *ast {\n            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),\n            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),\n        }\n    }\n}","impl<'a> fmt::Debug for ClassInduct<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let x = match *self {\n            ClassInduct::Item(it) => match *it {\n                ast::ClassSetItem::Empty(_) => \"Item(Empty)\",\n                ast::ClassSetItem::Literal(_) => \"Item(Literal)\",\n                ast::ClassSetItem::Range(_) => \"Item(Range)\",\n                ast::ClassSetItem::Ascii(_) => \"Item(Ascii)\",\n                ast::ClassSetItem::Perl(_) => \"Item(Perl)\",\n                ast::ClassSetItem::Unicode(_) => \"Item(Unicode)\",\n                ast::ClassSetItem::Bracketed(_) => \"Item(Bracketed)\",\n                ast::ClassSetItem::Union(_) => \"Item(Union)\",\n            },\n            ClassInduct::BinaryOp(it) => match it.kind {\n                ast::ClassSetBinaryOpKind::Intersection => {\n                    \"BinaryOp(Intersection)\"\n                }\n                ast::ClassSetBinaryOpKind::Difference => {\n                    \"BinaryOp(Difference)\"\n                }\n                ast::ClassSetBinaryOpKind::SymmetricDifference => {\n                    \"BinaryOp(SymmetricDifference)\"\n                }\n            },\n        };\n        write!(f, \"{}\", x)\n    }\n}"],"ast::visitor::Frame":["impl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child AST node to visit.\n    fn child(&self) -> &'a Ast {\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}"],"ast::visitor::HeapVisitor":["impl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![], stack_class: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n        self.stack_class.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(ast)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this AST, so we can post visit it now.\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given AST if one is needed (which occurs if\n    /// and only if there are child nodes in the AST). Otherwise, return None.\n    ///\n    /// If this visits a class, then the underlying visitor implementation may\n    /// return an error which will be passed on here.\n    fn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err> {\n        Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => Some(Frame::Alternation {\n                head: &x.asts[0],\n                tail: &x.asts[1..],\n            }),\n            _ => None,\n        })\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n\n    fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        let mut ast = ClassInduct::from_bracketed(ast);\n        loop {\n            self.visit_class_pre(&ast, visitor)?;\n            if let Some(x) = self.induct_class(&ast) {\n                let child = x.child();\n                self.stack_class.push((ast, x));\n                ast = child;\n                continue;\n            }\n            self.visit_class_post(&ast, visitor)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack_class.pop() {\n                    None => return Ok(()),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a union or a binary op, then we might have\n                // additional inductive steps to process.\n                if let Some(x) = self.pop_class(frame) {\n                    if let ClassFrame::BinaryRHS { ref op, .. } = x {\n                        visitor.visit_class_set_binary_op_in(op)?;\n                    }\n                    ast = x.child();\n                    self.stack_class.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this class node, so we can post visit it now.\n                self.visit_class_post(&post_ast, visitor)?;\n            }\n        }\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_pre(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_pre(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_post(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_post(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Build a stack frame for the given class node if one is needed (which\n    /// occurs if and only if there are child nodes). Otherwise, return None.\n    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {\n        match *ast {\n            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {\n                match x.kind {\n                    ast::ClassSet::Item(ref item) => {\n                        Some(ClassFrame::Union { head: item, tail: &[] })\n                    }\n                    ast::ClassSet::BinaryOp(ref op) => {\n                        Some(ClassFrame::Binary { op: op })\n                    }\n                }\n            }\n            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {\n                if x.items.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n                }\n            }\n            ClassInduct::BinaryOp(op) => Some(ClassFrame::BinaryLHS {\n                op: op,\n                lhs: &op.lhs,\n                rhs: &op.rhs,\n            }),\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {\n        match induct {\n            ClassFrame::Union { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            ClassFrame::Binary { .. } => None,\n            ClassFrame::BinaryLHS { op, rhs, .. } => {\n                Some(ClassFrame::BinaryRHS { op: op, rhs: rhs })\n            }\n            ClassFrame::BinaryRHS { .. } => None,\n        }\n    }\n}"],"either::Either":["Clone","Debug","Eq","PartialEq"],"error::Error":["Clone","Debug","Eq","PartialEq","impl From<ast::Error> for Error {\n    fn from(err: ast::Error) -> Error {\n        Error::Parse(err)\n    }\n}","impl From<hir::Error> for Error {\n    fn from(err: hir::Error) -> Error {\n        Error::Translate(err)\n    }\n}","impl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        match *self {\n            Error::Parse(ref x) => x.description(),\n            Error::Translate(ref x) => x.description(),\n            _ => unreachable!(),\n        }\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Error::Parse(ref x) => x.fmt(f),\n            Error::Translate(ref x) => x.fmt(f),\n            _ => unreachable!(),\n        }\n    }\n}"],"error::Formatter":["Debug","impl<'e, E: fmt::Display> fmt::Display for Formatter<'e, E> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let spans = Spans::from_formatter(self);\n        if self.pattern.contains('\\n') {\n            let divider = repeat_char('~', 79);\n\n            writeln!(f, \"regex parse error:\")?;\n            writeln!(f, \"{}\", divider)?;\n            let notated = spans.notate();\n            write!(f, \"{}\", notated)?;\n            writeln!(f, \"{}\", divider)?;\n            // If we have error spans that cover multiple lines, then we just\n            // note the line numbers.\n            if !spans.multi_line.is_empty() {\n                let mut notes = vec![];\n                for span in &spans.multi_line {\n                    notes.push(format!(\n                        \"on line {} (column {}) through line {} (column {})\",\n                        span.start.line,\n                        span.start.column,\n                        span.end.line,\n                        span.end.column - 1\n                    ));\n                }\n                writeln!(f, \"{}\", notes.join(\"\\n\"))?;\n            }\n            write!(f, \"error: {}\", self.err)?;\n        } else {\n            writeln!(f, \"regex parse error:\")?;\n            let notated = Spans::from_formatter(self).notate();\n            write!(f, \"{}\", notated)?;\n            write!(f, \"error: {}\", self.err)?;\n        }\n        Ok(())\n    }\n}","impl<'e> From<&'e ast::Error> for Formatter<'e, ast::ErrorKind> {\n    fn from(err: &'e ast::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: err.auxiliary_span(),\n        }\n    }\n}","impl<'e> From<&'e hir::Error> for Formatter<'e, hir::ErrorKind> {\n    fn from(err: &'e hir::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: None,\n        }\n    }\n}"],"error::Spans":["impl<'p> Spans<'p> {\n    /// Build a sequence of spans from a formatter.\n    fn from_formatter<'e, E: fmt::Display>(\n        fmter: &'p Formatter<'e, E>,\n    ) -> Spans<'p> {\n        let mut line_count = fmter.pattern.lines().count();\n        // If the pattern ends with a `\\n` literal, then our line count is\n        // off by one, since a span can occur immediately after the last `\\n`,\n        // which is consider to be an additional line.\n        if fmter.pattern.ends_with('\\n') {\n            line_count += 1;\n        }\n        let line_number_width =\n            if line_count <= 1 { 0 } else { line_count.to_string().len() };\n        let mut spans = Spans {\n            pattern: &fmter.pattern,\n            line_number_width: line_number_width,\n            by_line: vec![vec![]; line_count],\n            multi_line: vec![],\n        };\n        spans.add(fmter.span.clone());\n        if let Some(span) = fmter.aux_span {\n            spans.add(span.clone());\n        }\n        spans\n    }\n\n    /// Add the given span to this sequence, putting it in the right place.\n    fn add(&mut self, span: ast::Span) {\n        // This is grossly inefficient since we sort after each add, but right\n        // now, we only ever add two spans at most.\n        if span.is_one_line() {\n            let i = span.start.line - 1; // because lines are 1-indexed\n            self.by_line[i].push(span);\n            self.by_line[i].sort();\n        } else {\n            self.multi_line.push(span);\n            self.multi_line.sort();\n        }\n    }\n\n    /// Notate the pattern string with carents (`^`) pointing at each span\n    /// location. This only applies to spans that occur within a single line.\n    fn notate(&self) -> String {\n        let mut notated = String::new();\n        for (i, line) in self.pattern.lines().enumerate() {\n            if self.line_number_width > 0 {\n                notated.push_str(&self.left_pad_line_number(i + 1));\n                notated.push_str(\": \");\n            } else {\n                notated.push_str(\"    \");\n            }\n            notated.push_str(line);\n            notated.push('\\n');\n            if let Some(notes) = self.notate_line(i) {\n                notated.push_str(&notes);\n                notated.push('\\n');\n            }\n        }\n        notated\n    }\n\n    /// Return notes for the line indexed at `i` (zero-based). If there are no\n    /// spans for the given line, then `None` is returned. Otherwise, an\n    /// appropriately space padded string with correctly positioned `^` is\n    /// returned, accounting for line numbers.\n    fn notate_line(&self, i: usize) -> Option<String> {\n        let spans = &self.by_line[i];\n        if spans.is_empty() {\n            return None;\n        }\n        let mut notes = String::new();\n        for _ in 0..self.line_number_padding() {\n            notes.push(' ');\n        }\n        let mut pos = 0;\n        for span in spans {\n            for _ in pos..(span.start.column - 1) {\n                notes.push(' ');\n                pos += 1;\n            }\n            let note_len = span.end.column.saturating_sub(span.start.column);\n            for _ in 0..cmp::max(1, note_len) {\n                notes.push('^');\n                pos += 1;\n            }\n        }\n        Some(notes)\n    }\n\n    /// Left pad the given line number with spaces such that it is aligned with\n    /// other line numbers.\n    fn left_pad_line_number(&self, n: usize) -> String {\n        let n = n.to_string();\n        let pad = self.line_number_width.checked_sub(n.len()).unwrap();\n        let mut result = repeat_char(' ', pad);\n        result.push_str(&n);\n        result\n    }\n\n    /// Return the line number padding beginning at the start of each line of\n    /// the pattern.\n    ///\n    /// If the pattern is only one line, then this returns a fixed padding\n    /// for visual indentation.\n    fn line_number_padding(&self) -> usize {\n        if self.line_number_width == 0 {\n            4\n        } else {\n            2 + self.line_number_width\n        }\n    }\n}"],"hir::Anchor":["Clone","Debug","Eq","PartialEq"],"hir::Class":["Clone","Debug","Eq","PartialEq","impl Class {\n    /// Apply Unicode simple case folding to this character class, in place.\n    /// The character class will be expanded to include all simple case folded\n    /// character variants.\n    ///\n    /// If this is a byte oriented character class, then this will be limited\n    /// to the ASCII ranges `A-Z` and `a-z`.\n    pub fn case_fold_simple(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.case_fold_simple(),\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n    }\n\n    /// Negate this character class in place.\n    ///\n    /// After completion, this character class will contain precisely the\n    /// characters that weren't previously in the class.\n    pub fn negate(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.negate(),\n            Class::Bytes(ref mut x) => x.negate(),\n        }\n    }\n\n    /// Returns true if and only if this character class will only ever match\n    /// valid UTF-8.\n    ///\n    /// A character class can match invalid UTF-8 only when the following\n    /// conditions are met:\n    ///\n    /// 1. The translator was configured to permit generating an expression\n    ///    that can match invalid UTF-8. (By default, this is disabled.)\n    /// 2. Unicode mode (via the `u` flag) was disabled either in the concrete\n    ///    syntax or in the parser builder. By default, Unicode mode is\n    ///    enabled.\n    pub fn is_always_utf8(&self) -> bool {\n        match *self {\n            Class::Unicode(_) => true,\n            Class::Bytes(ref x) => x.is_all_ascii(),\n        }\n    }\n}"],"hir::ClassBytes":["Clone","Debug","Eq","PartialEq","impl ClassBytes {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {\n        ClassBytes { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    pub fn empty() -> ClassBytes {\n        ClassBytes::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassBytesRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassBytesIter {\n        ClassBytesIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassBytesRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// Note that this only applies ASCII case folding, which is limited to the\n    /// characters `a-z` and `A-Z`.\n    pub fn case_fold_simple(&mut self) {\n        self.set.case_fold_simple().expect(\"ASCII case folding never fails\");\n    }\n\n    /// Negate this byte class.\n    ///\n    /// For all `b` where `b` is a any byte, if `b` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this byte class with the given byte class, in place.\n    pub fn union(&mut self, other: &ClassBytes) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this byte class with the given byte class, in place.\n    pub fn intersect(&mut self, other: &ClassBytes) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given byte class from this byte class, in place.\n    pub fn difference(&mut self, other: &ClassBytes) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given byte classes, in place.\n    ///\n    /// This computes the symmetric difference of two byte classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII byte.\n    pub fn is_all_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)\n    }\n}"],"hir::ClassBytesIter":["Debug","impl<'a> Iterator for ClassBytesIter<'a> {\n    type Item = &'a ClassBytesRange;\n\n    fn next(&mut self) -> Option<&'a ClassBytesRange> {\n        self.0.next()\n    }\n}"],"hir::ClassBytesRange":["Clone","Copy","Default","Eq","Ord","PartialEq","PartialOrd","impl ClassBytesRange {\n    /// Create a new byte range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {\n        ClassBytesRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> u8 {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> u8 {\n        self.end\n    }\n}","impl Interval for ClassBytesRange {\n    type Bound = u8;\n\n    #[inline]\n    fn lower(&self) -> u8 {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> u8 {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: u8) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: u8) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this byte range. Only ASCII case mappings\n    /// (for a-z) are applied.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassBytesRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'a');\n            let upper = cmp::min(self.end, b'z');\n            ranges.push(ClassBytesRange::new(lower - 32, upper - 32));\n        }\n        if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'A');\n            let upper = cmp::min(self.end, b'Z');\n            ranges.push(ClassBytesRange::new(lower + 32, upper + 32));\n        }\n        Ok(())\n    }\n}","impl fmt::Debug for ClassBytesRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = f.debug_struct(\"ClassBytesRange\");\n        if self.start <= 0x7F {\n            debug.field(\"start\", &(self.start as char));\n        } else {\n            debug.field(\"start\", &self.start);\n        }\n        if self.end <= 0x7F {\n            debug.field(\"end\", &(self.end as char));\n        } else {\n            debug.field(\"end\", &self.end);\n        }\n        debug.finish()\n    }\n}"],"hir::ClassUnicode":["Clone","Debug","Eq","PartialEq","impl ClassUnicode {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {\n        ClassUnicode { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    pub fn empty() -> ClassUnicode {\n        ClassUnicode::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassUnicodeRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassUnicodeIter {\n        ClassUnicodeIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Panics\n    ///\n    /// This routine panics when the case mapping data necessary for this\n    /// routine to complete is unavailable. This occurs when the `unicode-case`\n    /// feature is not enabled.\n    ///\n    /// Callers should prefer using `try_case_fold_simple` instead, which will\n    /// return an error instead of panicking.\n    pub fn case_fold_simple(&mut self) {\n        self.set\n            .case_fold_simple()\n            .expect(\"unicode-case feature must be enabled\");\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Error\n    ///\n    /// This routine returns an error when the case mapping data necessary\n    /// for this routine to complete is unavailable. This occurs when the\n    /// `unicode-case` feature is not enabled.\n    pub fn try_case_fold_simple(\n        &mut self,\n    ) -> result::Result<(), CaseFoldError> {\n        self.set.case_fold_simple()\n    }\n\n    /// Negate this character class.\n    ///\n    /// For all `c` where `c` is a Unicode scalar value, if `c` was in this\n    /// set, then it will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this character class with the given character class, in place.\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this character class with the given character class, in\n    /// place.\n    pub fn intersect(&mut self, other: &ClassUnicode) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given character class from this character class, in place.\n    pub fn difference(&mut self, other: &ClassUnicode) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given character classes, in\n    /// place.\n    ///\n    /// This computes the symmetric difference of two character classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII codepoint.\n    pub fn is_all_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }\n}"],"hir::ClassUnicodeIter":["Debug","impl<'a> Iterator for ClassUnicodeIter<'a> {\n    type Item = &'a ClassUnicodeRange;\n\n    fn next(&mut self) -> Option<&'a ClassUnicodeRange> {\n        self.0.next()\n    }\n}"],"hir::ClassUnicodeRange":["Clone","Copy","Default","Eq","Ord","PartialEq","PartialOrd","impl ClassUnicodeRange {\n    /// Create a new Unicode scalar value range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {\n        ClassUnicodeRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> char {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> char {\n        self.end\n    }\n}","impl Interval for ClassUnicodeRange {\n    type Bound = char;\n\n    #[inline]\n    fn lower(&self) -> char {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> char {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: char) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: char) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this Unicode scalar value range.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassUnicodeRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        if !unicode::contains_simple_case_mapping(self.start, self.end)? {\n            return Ok(());\n        }\n        let start = self.start as u32;\n        let end = (self.end as u32).saturating_add(1);\n        let mut next_simple_cp = None;\n        for cp in (start..end).filter_map(char::from_u32) {\n            if next_simple_cp.map_or(false, |next| cp < next) {\n                continue;\n            }\n            let it = match unicode::simple_fold(cp)? {\n                Ok(it) => it,\n                Err(next) => {\n                    next_simple_cp = next;\n                    continue;\n                }\n            };\n            for cp_folded in it {\n                ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));\n            }\n        }\n        Ok(())\n    }\n}","impl fmt::Debug for ClassUnicodeRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let start = if !self.start.is_whitespace() && !self.start.is_control()\n        {\n            self.start.to_string()\n        } else {\n            format!(\"0x{:X}\", self.start as u32)\n        };\n        let end = if !self.end.is_whitespace() && !self.end.is_control() {\n            self.end.to_string()\n        } else {\n            format!(\"0x{:X}\", self.end as u32)\n        };\n        f.debug_struct(\"ClassUnicodeRange\")\n            .field(\"start\", &start)\n            .field(\"end\", &end)\n            .finish()\n    }\n}"],"hir::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n}","impl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.kind.description()\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        ::error::Formatter::from(self).fmt(f)\n    }\n}"],"hir::ErrorKind":["Clone","Debug","Eq","PartialEq","impl ErrorKind {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        use self::ErrorKind::*;\n        match *self {\n            UnicodeNotAllowed => \"Unicode not allowed here\",\n            InvalidUtf8 => \"pattern can match invalid UTF-8\",\n            UnicodePropertyNotFound => \"Unicode property not found\",\n            UnicodePropertyValueNotFound => \"Unicode property value not found\",\n            UnicodePerlClassNotFound => {\n                \"Unicode-aware Perl class not found \\\n                 (make sure the unicode-perl feature is enabled)\"\n            }\n            UnicodeCaseUnavailable => {\n                \"Unicode-aware case insensitivity matching is not available \\\n                 (make sure the unicode-case feature is enabled)\"\n            }\n            EmptyClassNotAllowed => \"empty character classes are not allowed\",\n            __Nonexhaustive => unreachable!(),\n        }\n    }\n}","impl fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // TODO: Remove this on the next breaking semver release.\n        #[allow(deprecated)]\n        f.write_str(self.description())\n    }\n}"],"hir::Group":["Clone","Debug","Eq","PartialEq"],"hir::GroupKind":["Clone","Debug","Eq","PartialEq"],"hir::Hir":["Clone","Debug","Eq","PartialEq","impl Drop for Hir {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => return,\n            HirKind::Group(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Repetition(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Concat(ref x) if x.is_empty() => return,\n            HirKind::Alternation(ref x) if x.is_empty() => return,\n            _ => {}\n        }\n\n        let mut stack = vec![mem::replace(self, Hir::empty())];\n        while let Some(mut expr) = stack.pop() {\n            match expr.kind {\n                HirKind::Empty\n                | HirKind::Literal(_)\n                | HirKind::Class(_)\n                | HirKind::Anchor(_)\n                | HirKind::WordBoundary(_) => {}\n                HirKind::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Concat(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n                HirKind::Alternation(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n            }\n        }\n    }\n}","impl Hir {\n    /// Returns a reference to the underlying HIR kind.\n    pub fn kind(&self) -> &HirKind {\n        &self.kind\n    }\n\n    /// Consumes ownership of this HIR expression and returns its underlying\n    /// `HirKind`.\n    pub fn into_kind(mut self) -> HirKind {\n        use std::mem;\n        mem::replace(&mut self.kind, HirKind::Empty)\n    }\n\n    /// Returns an empty HIR expression.\n    ///\n    /// An empty HIR expression always matches, including the empty string.\n    pub fn empty() -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Empty, info: info }\n    }\n\n    /// Creates a literal HIR expression.\n    ///\n    /// If the given literal has a `Byte` variant with an ASCII byte, then this\n    /// method panics. This enforces the invariant that `Byte` variants are\n    /// only used to express matching of invalid UTF-8.\n    pub fn literal(lit: Literal) -> Hir {\n        if let Literal::Byte(b) = lit {\n            assert!(b > 0x7F);\n        }\n\n        let mut info = HirInfo::new();\n        info.set_always_utf8(lit.is_unicode());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(true);\n        info.set_alternation_literal(true);\n        Hir { kind: HirKind::Literal(lit), info: info }\n    }\n\n    /// Creates a class HIR expression.\n    pub fn class(class: Class) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(class.is_always_utf8());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Class(class), info: info }\n    }\n\n    /// Creates an anchor assertion HIR expression.\n    pub fn anchor(anchor: Anchor) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        if let Anchor::StartText = anchor {\n            info.set_anchored_start(true);\n            info.set_line_anchored_start(true);\n            info.set_any_anchored_start(true);\n        }\n        if let Anchor::EndText = anchor {\n            info.set_anchored_end(true);\n            info.set_line_anchored_end(true);\n            info.set_any_anchored_end(true);\n        }\n        if let Anchor::StartLine = anchor {\n            info.set_line_anchored_start(true);\n        }\n        if let Anchor::EndLine = anchor {\n            info.set_line_anchored_end(true);\n        }\n        Hir { kind: HirKind::Anchor(anchor), info: info }\n    }\n\n    /// Creates a word boundary assertion HIR expression.\n    pub fn word_boundary(word_boundary: WordBoundary) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        // A negated word boundary matches the empty string, but a normal\n        // word boundary does not!\n        info.set_match_empty(word_boundary.is_negated());\n        // Negated ASCII word boundaries can match invalid UTF-8.\n        if let WordBoundary::AsciiNegate = word_boundary {\n            info.set_always_utf8(false);\n        }\n        Hir { kind: HirKind::WordBoundary(word_boundary), info: info }\n    }\n\n    /// Creates a repetition HIR expression.\n    pub fn repetition(rep: Repetition) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(rep.hir.is_always_utf8());\n        info.set_all_assertions(rep.hir.is_all_assertions());\n        // If this operator can match the empty string, then it can never\n        // be anchored.\n        info.set_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_line_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_line_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_any_anchored_start(rep.hir.is_any_anchored_start());\n        info.set_any_anchored_end(rep.hir.is_any_anchored_end());\n        info.set_match_empty(rep.is_match_empty() || rep.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Repetition(rep), info: info }\n    }\n\n    /// Creates a group HIR expression.\n    pub fn group(group: Group) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(group.hir.is_always_utf8());\n        info.set_all_assertions(group.hir.is_all_assertions());\n        info.set_anchored_start(group.hir.is_anchored_start());\n        info.set_anchored_end(group.hir.is_anchored_end());\n        info.set_line_anchored_start(group.hir.is_line_anchored_start());\n        info.set_line_anchored_end(group.hir.is_line_anchored_end());\n        info.set_any_anchored_start(group.hir.is_any_anchored_start());\n        info.set_any_anchored_end(group.hir.is_any_anchored_end());\n        info.set_match_empty(group.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Group(group), info: info }\n    }\n\n    /// Returns the concatenation of the given expressions.\n    ///\n    /// This flattens the concatenation as appropriate.\n    pub fn concat(mut exprs: Vec<Hir>) -> Hir {\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(true);\n                info.set_literal(true);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() && e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_literal() && e.is_literal();\n                    info.set_literal(x);\n\n                    let x = info.is_alternation_literal()\n                        && e.is_alternation_literal();\n                    info.set_alternation_literal(x);\n                }\n                // Anchored attributes require something slightly more\n                // sophisticated. Normally, WLOG, to determine whether an\n                // expression is anchored to the start, we'd only need to check\n                // the first expression of a concatenation. However,\n                // expressions like `$\\b^` are still anchored to the start,\n                // but the first expression in the concatenation *isn't*\n                // anchored to the start. So the \"first\" expression to look at\n                // is actually one that is either not an assertion or is\n                // specifically the StartText assertion.\n                info.set_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_start()),\n                );\n                // Similarly for the end anchor, but in reverse.\n                info.set_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_end()),\n                );\n                // Repeat the process for line anchors.\n                info.set_line_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_line_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_start()),\n                );\n                info.set_line_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_line_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_end()),\n                );\n                Hir { kind: HirKind::Concat(exprs), info: info }\n            }\n        }\n    }\n\n    /// Returns the alternation of the given expressions.\n    ///\n    /// This flattens the alternation as appropriate.\n    pub fn alternation(mut exprs: Vec<Hir>) -> Hir {\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_anchored_start(true);\n                info.set_anchored_end(true);\n                info.set_line_anchored_start(true);\n                info.set_line_anchored_end(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(false);\n                info.set_literal(false);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_anchored_start() && e.is_anchored_start();\n                    info.set_anchored_start(x);\n\n                    let x = info.is_anchored_end() && e.is_anchored_end();\n                    info.set_anchored_end(x);\n\n                    let x = info.is_line_anchored_start()\n                        && e.is_line_anchored_start();\n                    info.set_line_anchored_start(x);\n\n                    let x = info.is_line_anchored_end()\n                        && e.is_line_anchored_end();\n                    info.set_line_anchored_end(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() || e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_alternation_literal() && e.is_literal();\n                    info.set_alternation_literal(x);\n                }\n                Hir { kind: HirKind::Alternation(exprs), info: info }\n            }\n        }\n    }\n\n    /// Build an HIR expression for `.`.\n    ///\n    /// A `.` expression matches any character except for `\\n`. To build an\n    /// expression that matches any character, including `\\n`, use the `any`\n    /// method.\n    ///\n    /// If `bytes` is `true`, then this assumes characters are limited to a\n    /// single byte.\n    pub fn dot(bytes: bool) -> Hir {\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n            cls.push(ClassBytesRange::new(b'\\x0B', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n            cls.push(ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }\n\n    /// Build an HIR expression for `(?s).`.\n    ///\n    /// A `(?s).` expression matches any character, including `\\n`. To build an\n    /// expression that matches any character except for `\\n`, then use the\n    /// `dot` method.\n    ///\n    /// If `bytes` is `true`, then this assumes characters are limited to a\n    /// single byte.\n    pub fn any(bytes: bool) -> Hir {\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }\n\n    /// Return true if and only if this HIR will always match valid UTF-8.\n    ///\n    /// When this returns false, then it is possible for this HIR expression\n    /// to match invalid UTF-8.\n    pub fn is_always_utf8(&self) -> bool {\n        self.info.is_always_utf8()\n    }\n\n    /// Returns true if and only if this entire HIR expression is made up of\n    /// zero-width assertions.\n    ///\n    /// This includes expressions like `^$\\b\\A\\z` and even `((\\b)+())*^`, but\n    /// not `^a`.\n    pub fn is_all_assertions(&self) -> bool {\n        self.info.is_all_assertions()\n    }\n\n    /// Return true if and only if this HIR is required to match from the\n    /// beginning of text. This includes expressions like `^foo`, `^(foo|bar)`,\n    /// `^foo|^bar` but not `^foo|bar`.\n    pub fn is_anchored_start(&self) -> bool {\n        self.info.is_anchored_start()\n    }\n\n    /// Return true if and only if this HIR is required to match at the end\n    /// of text. This includes expressions like `foo$`, `(foo|bar)$`,\n    /// `foo$|bar$` but not `foo$|bar`.\n    pub fn is_anchored_end(&self) -> bool {\n        self.info.is_anchored_end()\n    }\n\n    /// Return true if and only if this HIR is required to match from the\n    /// beginning of text or the beginning of a line. This includes expressions\n    /// like `^foo`, `(?m)^foo`, `^(foo|bar)`, `^(foo|bar)`, `(?m)^foo|^bar`\n    /// but not `^foo|bar` or `(?m)^foo|bar`.\n    ///\n    /// Note that if `is_anchored_start` is `true`, then\n    /// `is_line_anchored_start` will also be `true`. The reverse implication\n    /// is not true. For example, `(?m)^foo` is line anchored, but not\n    /// `is_anchored_start`.\n    pub fn is_line_anchored_start(&self) -> bool {\n        self.info.is_line_anchored_start()\n    }\n\n    /// Return true if and only if this HIR is required to match at the\n    /// end of text or the end of a line. This includes expressions like\n    /// `foo$`, `(?m)foo$`, `(foo|bar)$`, `(?m)(foo|bar)$`, `foo$|bar$`,\n    /// `(?m)(foo|bar)$`, but not `foo$|bar` or `(?m)foo$|bar`.\n    ///\n    /// Note that if `is_anchored_end` is `true`, then\n    /// `is_line_anchored_end` will also be `true`. The reverse implication\n    /// is not true. For example, `(?m)foo$` is line anchored, but not\n    /// `is_anchored_end`.\n    pub fn is_line_anchored_end(&self) -> bool {\n        self.info.is_line_anchored_end()\n    }\n\n    /// Return true if and only if this HIR contains any sub-expression that\n    /// is required to match at the beginning of text. Specifically, this\n    /// returns true if the `^` symbol (when multiline mode is disabled) or the\n    /// `\\A` escape appear anywhere in the regex.\n    pub fn is_any_anchored_start(&self) -> bool {\n        self.info.is_any_anchored_start()\n    }\n\n    /// Return true if and only if this HIR contains any sub-expression that is\n    /// required to match at the end of text. Specifically, this returns true\n    /// if the `$` symbol (when multiline mode is disabled) or the `\\z` escape\n    /// appear anywhere in the regex.\n    pub fn is_any_anchored_end(&self) -> bool {\n        self.info.is_any_anchored_end()\n    }\n\n    /// Return true if and only if the empty string is part of the language\n    /// matched by this regular expression.\n    ///\n    /// This includes `a*`, `a?b*`, `a{0}`, `()`, `()+`, `^$`, `a|b?`, `\\B`,\n    /// but not `a`, `a+` or `\\b`.\n    pub fn is_match_empty(&self) -> bool {\n        self.info.is_match_empty()\n    }\n\n    /// Return true if and only if this HIR is a simple literal. This is only\n    /// true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s.\n    ///\n    /// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()`,\n    /// `` are not (even though that contain sub-expressions that are literals).\n    pub fn is_literal(&self) -> bool {\n        self.info.is_literal()\n    }\n\n    /// Return true if and only if this HIR is either a simple literal or an\n    /// alternation of simple literals. This is only\n    /// true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s or an alternation of only `Literal`s.\n    ///\n    /// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation\n    /// literals, but `f+`, `(foo)`, `foo()`, ``\n    /// are not (even though that contain sub-expressions that are literals).\n    pub fn is_alternation_literal(&self) -> bool {\n        self.info.is_alternation_literal()\n    }\n}","impl fmt::Display for Hir {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use hir::print::Printer;\n        Printer::new().print(self, f)\n    }\n}"],"hir::HirInfo":["Clone","Debug","Eq","PartialEq","impl HirInfo {\n    fn new() -> HirInfo {\n        HirInfo { bools: 0 }\n    }\n\n    define_bool!(0, is_always_utf8, set_always_utf8);\n    define_bool!(1, is_all_assertions, set_all_assertions);\n    define_bool!(2, is_anchored_start, set_anchored_start);\n    define_bool!(3, is_anchored_end, set_anchored_end);\n    define_bool!(4, is_line_anchored_start, set_line_anchored_start);\n    define_bool!(5, is_line_anchored_end, set_line_anchored_end);\n    define_bool!(6, is_any_anchored_start, set_any_anchored_start);\n    define_bool!(7, is_any_anchored_end, set_any_anchored_end);\n    define_bool!(8, is_match_empty, set_match_empty);\n    define_bool!(9, is_literal, set_literal);\n    define_bool!(10, is_alternation_literal, set_alternation_literal);\n}"],"hir::HirKind":["Clone","Debug","Eq","PartialEq","impl HirKind {\n    /// Return true if and only if this HIR is the empty regular expression.\n    ///\n    /// Note that this is not defined inductively. That is, it only tests if\n    /// this kind is the `Empty` variant. To get the inductive definition,\n    /// use the `is_match_empty` method on [`Hir`](struct.Hir.html).\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            HirKind::Empty => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if and only if this kind has any (including possibly\n    /// empty) subexpressions.\n    pub fn has_subexprs(&self) -> bool {\n        match *self {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => false,\n            HirKind::Group(_)\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => true,\n        }\n    }\n}"],"hir::Literal":["Clone","Debug","Eq","PartialEq","impl Literal {\n    /// Returns true if and only if this literal corresponds to a Unicode\n    /// scalar value.\n    pub fn is_unicode(&self) -> bool {\n        match *self {\n            Literal::Unicode(_) => true,\n            Literal::Byte(b) if b <= 0x7F => true,\n            Literal::Byte(_) => false,\n        }\n    }\n}"],"hir::Repetition":["Clone","Debug","Eq","PartialEq","impl Repetition {\n    /// Returns true if and only if this repetition operator makes it possible\n    /// to match the empty string.\n    ///\n    /// Note that this is not defined inductively. For example, while `a*`\n    /// will report `true`, `()+` will not, even though `()` matches the empty\n    /// string and one or more occurrences of something that matches the empty\n    /// string will always match the empty string. In order to get the\n    /// inductive definition, see the corresponding method on\n    /// [`Hir`](struct.Hir.html).\n    pub fn is_match_empty(&self) -> bool {\n        match self.kind {\n            RepetitionKind::ZeroOrOne => true,\n            RepetitionKind::ZeroOrMore => true,\n            RepetitionKind::OneOrMore => false,\n            RepetitionKind::Range(RepetitionRange::Exactly(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::AtLeast(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::Bounded(m, _)) => m == 0,\n        }\n    }\n}"],"hir::RepetitionKind":["Clone","Debug","Eq","PartialEq"],"hir::RepetitionRange":["Clone","Debug","Eq","PartialEq"],"hir::WordBoundary":["Clone","Debug","Eq","PartialEq","impl WordBoundary {\n    /// Returns true if and only if this word boundary assertion is negated.\n    pub fn is_negated(&self) -> bool {\n        match *self {\n            WordBoundary::Unicode | WordBoundary::Ascii => false,\n            WordBoundary::UnicodeNegate | WordBoundary::AsciiNegate => true,\n        }\n    }\n}"],"hir::interval::IntervalSet":["Clone","Debug","Eq","PartialEq","impl<I: Interval> IntervalSet<I> {\n    /// Create a new set from a sequence of intervals. Each interval is\n    /// specified as a pair of bounds, where both bounds are inclusive.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {\n        let mut set = IntervalSet { ranges: intervals.into_iter().collect() };\n        set.canonicalize();\n        set\n    }\n\n    /// Add a new interval to this set.\n    pub fn push(&mut self, interval: I) {\n        // TODO: This could be faster. e.g., Push the interval such that\n        // it preserves canonicalization.\n        self.ranges.push(interval);\n        self.canonicalize();\n    }\n\n    /// Return an iterator over all intervals in this set.\n    ///\n    /// The iterator yields intervals in ascending order.\n    pub fn iter(&self) -> IntervalSetIter<I> {\n        IntervalSetIter(self.ranges.iter())\n    }\n\n    /// Return an immutable slice of intervals in this set.\n    ///\n    /// The sequence returned is in canonical ordering.\n    pub fn intervals(&self) -> &[I] {\n        &self.ranges\n    }\n\n    /// Expand this interval set such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// This returns an error if the necessary case mapping data is not\n    /// available.\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {\n        let len = self.ranges.len();\n        for i in 0..len {\n            let range = self.ranges[i];\n            if let Err(err) = range.case_fold_simple(&mut self.ranges) {\n                self.canonicalize();\n                return Err(err);\n            }\n        }\n        self.canonicalize();\n        Ok(())\n    }\n\n    /// Union this set with the given set, in place.\n    pub fn union(&mut self, other: &IntervalSet<I>) {\n        // This could almost certainly be done more efficiently.\n        self.ranges.extend(&other.ranges);\n        self.canonicalize();\n    }\n\n    /// Intersect this set with the given set, in place.\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() {\n            return;\n        }\n        if other.ranges.is_empty() {\n            self.ranges.clear();\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the intersection to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        let mut ita = (0..drain_end).into_iter();\n        let mut itb = (0..other.ranges.len()).into_iter();\n        let mut a = ita.next().unwrap();\n        let mut b = itb.next().unwrap();\n        loop {\n            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {\n                self.ranges.push(ab);\n            }\n            let (it, aorb) =\n                if self.ranges[a].upper() < other.ranges[b].upper() {\n                    (&mut ita, &mut a)\n                } else {\n                    (&mut itb, &mut b)\n                };\n            match it.next() {\n                Some(v) => *aorb = v,\n                None => break,\n            }\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Subtract the given set from this set, in place.\n    pub fn difference(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n\n        // This algorithm is (to me) surprisingly complex. A search of the\n        // interwebs indicate that this is a potentially interesting problem.\n        // Folks seem to suggest interval or segment trees, but I'd like to\n        // avoid the overhead (both runtime and conceptual) of that.\n        //\n        // The following is basically my Shitty First Draft. Therefore, in\n        // order to grok it, you probably need to read each line carefully.\n        // Simplifications are most welcome!\n        //\n        // Remember, we can assume the canonical format invariant here, which\n        // says that all ranges are sorted, not overlapping and not adjacent in\n        // each class.\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            // Basically, the easy cases are when neither range overlaps with\n            // each other. If the `b` range is less than our current `a`\n            // range, then we can skip it and move on.\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            // ... similarly for the `a` range. If it's less than the smallest\n            // `b` range, then we can add it as-is.\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            // Otherwise, we have overlapping ranges.\n            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n\n            // This part is tricky and was non-obvious to me without looking\n            // at explicit examples (see the tests). The trickiness stems from\n            // two things: 1) subtracting a range from another range could\n            // yield two ranges and 2) after subtracting a range, it's possible\n            // that future ranges can have an impact. The loop below advances\n            // the `b` ranges until they can't possible impact the current\n            // range.\n            //\n            // For example, if our `a` range is `a-t` and our next three `b`\n            // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n            // subtraction three times before moving on to the next `a` range.\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        // We lost the entire range, so move on to the next\n                        // without adding this one.\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                // It's possible that the `b` range has more to contribute\n                // here. In particular, if it is greater than the original\n                // range, then it might impact the next `a` range *and* it\n                // has impacted the current `a` range as much as possible,\n                // so we can quit. We don't bump `b` so that the next `a`\n                // range can apply it.\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                // Otherwise, the next `b` range might apply to the current\n                // `a` range.\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Compute the symmetric difference of the two sets, in place.\n    ///\n    /// This computes the symmetric difference of two interval sets. This\n    /// removes all elements in this set that are also in the given set,\n    /// but also adds all elements from the given set that aren't in this\n    /// set. That is, the set will contain all elements in either set,\n    /// but will not contain any elements that are in both sets.\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {\n        // TODO(burntsushi): Fix this so that it amortizes allocation.\n        let mut intersection = self.clone();\n        intersection.intersect(other);\n        self.union(other);\n        self.difference(&intersection);\n    }\n\n    /// Negate this interval set.\n    ///\n    /// For all `x` where `x` is any element, if `x` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the negation to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        // We do checked arithmetic below because of the canonical ordering\n        // invariant.\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Converts this set into a canonical ordering.\n    fn canonicalize(&mut self) {\n        if self.is_canonical() {\n            return;\n        }\n        self.ranges.sort();\n        assert!(!self.ranges.is_empty());\n\n        // Is there a way to do this in-place with constant memory? I couldn't\n        // figure out a way to do it. So just append the canonicalization to\n        // the end of this range, and then drain it before we're done.\n        let drain_end = self.ranges.len();\n        for oldi in 0..drain_end {\n            // If we've added at least one new range, then check if we can\n            // merge this range in the previously added range.\n            if self.ranges.len() > drain_end {\n                let (last, rest) = self.ranges.split_last_mut().unwrap();\n                if let Some(union) = last.union(&rest[oldi]) {\n                    *last = union;\n                    continue;\n                }\n            }\n            let range = self.ranges[oldi];\n            self.ranges.push(range);\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Returns true if and only if this class is in a canonical ordering.\n    fn is_canonical(&self) -> bool {\n        for pair in self.ranges.windows(2) {\n            if pair[0] >= pair[1] {\n                return false;\n            }\n            if pair[0].is_contiguous(&pair[1]) {\n                return false;\n            }\n        }\n        true\n    }\n}"],"hir::interval::IntervalSetIter":["Debug","impl<'a, I> Iterator for IntervalSetIter<'a, I> {\n    type Item = &'a I;\n\n    fn next(&mut self) -> Option<&'a I> {\n        self.0.next()\n    }\n}"],"hir::literal::Literal":["Clone","Eq","Ord","impl AsRef<[u8]> for Literal {\n    fn as_ref(&self) -> &[u8] {\n        &self.v\n    }\n}","impl Literal {\n    /// Returns a new complete literal with the bytes given.\n    pub fn new(bytes: Vec<u8>) -> Literal {\n        Literal { v: bytes, cut: false }\n    }\n\n    /// Returns a new complete empty literal.\n    pub fn empty() -> Literal {\n        Literal { v: vec![], cut: false }\n    }\n\n    /// Returns true if this literal was \"cut.\"\n    pub fn is_cut(&self) -> bool {\n        self.cut\n    }\n\n    /// Cuts this literal.\n    pub fn cut(&mut self) {\n        self.cut = true;\n    }\n}","impl PartialEq for Literal {\n    fn eq(&self, other: &Literal) -> bool {\n        self.v == other.v\n    }\n}","impl PartialOrd for Literal {\n    fn partial_cmp(&self, other: &Literal) -> Option<cmp::Ordering> {\n        self.v.partial_cmp(&other.v)\n    }\n}","impl fmt::Debug for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.is_cut() {\n            write!(f, \"Cut({})\", escape_unicode(&self.v))\n        } else {\n            write!(f, \"Complete({})\", escape_unicode(&self.v))\n        }\n    }\n}","impl ops::Deref for Literal {\n    type Target = Vec<u8>;\n    fn deref(&self) -> &Vec<u8> {\n        &self.v\n    }\n}","impl ops::DerefMut for Literal {\n    fn deref_mut(&mut self) -> &mut Vec<u8> {\n        &mut self.v\n    }\n}"],"hir::literal::Literals":["Clone","Eq","PartialEq","impl Literals {\n    /// Returns a new empty set of literals using default limits.\n    pub fn empty() -> Literals {\n        Literals { lits: vec![], limit_size: 250, limit_class: 10 }\n    }\n\n    /// Returns a set of literal prefixes extracted from the given `Hir`.\n    pub fn prefixes(expr: &Hir) -> Literals {\n        let mut lits = Literals::empty();\n        lits.union_prefixes(expr);\n        lits\n    }\n\n    /// Returns a set of literal suffixes extracted from the given `Hir`.\n    pub fn suffixes(expr: &Hir) -> Literals {\n        let mut lits = Literals::empty();\n        lits.union_suffixes(expr);\n        lits\n    }\n\n    /// Get the approximate size limit (in bytes) of this set.\n    pub fn limit_size(&self) -> usize {\n        self.limit_size\n    }\n\n    /// Set the approximate size limit (in bytes) of this set.\n    ///\n    /// If extracting a literal would put the set over this limit, then\n    /// extraction stops.\n    ///\n    /// The new limits will only apply to additions to this set. Existing\n    /// members remain unchanged, even if the set exceeds the new limit.\n    pub fn set_limit_size(&mut self, size: usize) -> &mut Literals {\n        self.limit_size = size;\n        self\n    }\n\n    /// Get the character class size limit for this set.\n    pub fn limit_class(&self) -> usize {\n        self.limit_class\n    }\n\n    /// Limits the size of character(or byte) classes considered.\n    ///\n    /// A value of `0` prevents all character classes from being considered.\n    ///\n    /// This limit also applies to case insensitive literals, since each\n    /// character in the case insensitive literal is converted to a class, and\n    /// then case folded.\n    ///\n    /// The new limits will only apply to additions to this set. Existing\n    /// members remain unchanged, even if the set exceeds the new limit.\n    pub fn set_limit_class(&mut self, size: usize) -> &mut Literals {\n        self.limit_class = size;\n        self\n    }\n\n    /// Returns the set of literals as a slice. Its order is unspecified.\n    pub fn literals(&self) -> &[Literal] {\n        &self.lits\n    }\n\n    /// Returns the length of the smallest literal.\n    ///\n    /// Returns None is there are no literals in the set.\n    pub fn min_len(&self) -> Option<usize> {\n        let mut min = None;\n        for lit in &self.lits {\n            match min {\n                None => min = Some(lit.len()),\n                Some(m) if lit.len() < m => min = Some(lit.len()),\n                _ => {}\n            }\n        }\n        min\n    }\n\n    /// Returns true if all members in this set are complete.\n    pub fn all_complete(&self) -> bool {\n        !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())\n    }\n\n    /// Returns true if any member in this set is complete.\n    pub fn any_complete(&self) -> bool {\n        self.lits.iter().any(|lit| !lit.is_cut())\n    }\n\n    /// Returns true if this set contains an empty literal.\n    pub fn contains_empty(&self) -> bool {\n        self.lits.iter().any(|lit| lit.is_empty())\n    }\n\n    /// Returns true if this set is empty or if all of its members is empty.\n    pub fn is_empty(&self) -> bool {\n        self.lits.is_empty() || self.lits.iter().all(|lit| lit.is_empty())\n    }\n\n    /// Returns a new empty set of literals using this set's limits.\n    pub fn to_empty(&self) -> Literals {\n        let mut lits = Literals::empty();\n        lits.set_limit_size(self.limit_size).set_limit_class(self.limit_class);\n        lits\n    }\n\n    /// Returns the longest common prefix of all members in this set.\n    pub fn longest_common_prefix(&self) -> &[u8] {\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter().zip(lit0).take_while(|&(a, b)| a == b).count(),\n            );\n        }\n        &self.lits[0][..len]\n    }\n\n    /// Returns the longest common suffix of all members in this set.\n    pub fn longest_common_suffix(&self) -> &[u8] {\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter()\n                    .rev()\n                    .zip(lit0.iter().rev())\n                    .take_while(|&(a, b)| a == b)\n                    .count(),\n            );\n        }\n        &self.lits[0][self.lits[0].len() - len..]\n    }\n\n    /// Returns a new set of literals with the given number of bytes trimmed\n    /// from the suffix of each literal.\n    ///\n    /// If any literal would be cut out completely by trimming, then None is\n    /// returned.\n    ///\n    /// Any duplicates that are created as a result of this transformation are\n    /// removed.\n    pub fn trim_suffix(&self, num_bytes: usize) -> Option<Literals> {\n        if self.min_len().map(|len| len <= num_bytes).unwrap_or(true) {\n            return None;\n        }\n        let mut new = self.to_empty();\n        for mut lit in self.lits.iter().cloned() {\n            let new_len = lit.len() - num_bytes;\n            lit.truncate(new_len);\n            lit.cut();\n            new.lits.push(lit);\n        }\n        new.lits.sort();\n        new.lits.dedup();\n        Some(new)\n    }\n\n    /// Returns a new set of prefixes of this set of literals that are\n    /// guaranteed to be unambiguous.\n    ///\n    /// Any substring match with a member of the set is returned is guaranteed\n    /// to never overlap with a substring match of another member of the set\n    /// at the same starting position.\n    ///\n    /// Given any two members of the returned set, neither is a substring of\n    /// the other.\n    pub fn unambiguous_prefixes(&self) -> Literals {\n        if self.lits.is_empty() {\n            return self.to_empty();\n        }\n        let mut old: Vec<Literal> = self.lits.iter().cloned().collect();\n        let mut new = self.to_empty();\n        'OUTER: while let Some(mut candidate) = old.pop() {\n            if candidate.is_empty() {\n                continue;\n            }\n            if new.lits.is_empty() {\n                new.lits.push(candidate);\n                continue;\n            }\n            for lit2 in &mut new.lits {\n                if lit2.is_empty() {\n                    continue;\n                }\n                if &candidate == lit2 {\n                    // If the literal is already in the set, then we can\n                    // just drop it. But make sure that cut literals are\n                    // infectious!\n                    candidate.cut = candidate.cut || lit2.cut;\n                    lit2.cut = candidate.cut;\n                    continue 'OUTER;\n                }\n                if candidate.len() < lit2.len() {\n                    if let Some(i) = position(&candidate, &lit2) {\n                        candidate.cut();\n                        let mut lit3 = lit2.clone();\n                        lit3.truncate(i);\n                        lit3.cut();\n                        old.push(lit3);\n                        lit2.clear();\n                    }\n                } else {\n                    if let Some(i) = position(&lit2, &candidate) {\n                        lit2.cut();\n                        let mut new_candidate = candidate.clone();\n                        new_candidate.truncate(i);\n                        new_candidate.cut();\n                        old.push(new_candidate);\n                        candidate.clear();\n                    }\n                }\n                // Oops, the candidate is already represented in the set.\n                if candidate.is_empty() {\n                    continue 'OUTER;\n                }\n            }\n            new.lits.push(candidate);\n        }\n        new.lits.retain(|lit| !lit.is_empty());\n        new.lits.sort();\n        new.lits.dedup();\n        new\n    }\n\n    /// Returns a new set of suffixes of this set of literals that are\n    /// guaranteed to be unambiguous.\n    ///\n    /// Any substring match with a member of the set is returned is guaranteed\n    /// to never overlap with a substring match of another member of the set\n    /// at the same ending position.\n    ///\n    /// Given any two members of the returned set, neither is a substring of\n    /// the other.\n    pub fn unambiguous_suffixes(&self) -> Literals {\n        // This is a touch wasteful...\n        let mut lits = self.clone();\n        lits.reverse();\n        let mut unamb = lits.unambiguous_prefixes();\n        unamb.reverse();\n        unamb\n    }\n\n    /// Unions the prefixes from the given expression to this set.\n    ///\n    /// If prefixes could not be added (for example, this set would exceed its\n    /// size limits or the set of prefixes from `expr` includes the empty\n    /// string), then false is returned.\n    ///\n    /// Note that prefix literals extracted from `expr` are said to be complete\n    /// if and only if the literal extends from the beginning of `expr` to the\n    /// end of `expr`.\n    pub fn union_prefixes(&mut self, expr: &Hir) -> bool {\n        let mut lits = self.to_empty();\n        prefixes(expr, &mut lits);\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }\n\n    /// Unions the suffixes from the given expression to this set.\n    ///\n    /// If suffixes could not be added (for example, this set would exceed its\n    /// size limits or the set of suffixes from `expr` includes the empty\n    /// string), then false is returned.\n    ///\n    /// Note that prefix literals extracted from `expr` are said to be complete\n    /// if and only if the literal extends from the end of `expr` to the\n    /// beginning of `expr`.\n    pub fn union_suffixes(&mut self, expr: &Hir) -> bool {\n        let mut lits = self.to_empty();\n        suffixes(expr, &mut lits);\n        lits.reverse();\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }\n\n    /// Unions this set with another set.\n    ///\n    /// If the union would cause the set to exceed its limits, then the union\n    /// is skipped and it returns false. Otherwise, if the union succeeds, it\n    /// returns true.\n    pub fn union(&mut self, lits: Literals) -> bool {\n        if self.num_bytes() + lits.num_bytes() > self.limit_size {\n            return false;\n        }\n        if lits.is_empty() {\n            self.lits.push(Literal::empty());\n        } else {\n            self.lits.extend(lits.lits);\n        }\n        true\n    }\n\n    /// Extends this set with another set.\n    ///\n    /// The set of literals is extended via a cross product.\n    ///\n    /// If a cross product would cause this set to exceed its limits, then the\n    /// cross product is skipped and it returns false. Otherwise, if the cross\n    /// product succeeds, it returns true.\n    pub fn cross_product(&mut self, lits: &Literals) -> bool {\n        if lits.is_empty() {\n            return true;\n        }\n        // Check that we make sure we stay in our limits.\n        let mut size_after;\n        if self.is_empty() || !self.any_complete() {\n            size_after = self.num_bytes();\n            for lits_lit in lits.literals() {\n                size_after += lits_lit.len();\n            }\n        } else {\n            size_after = self.lits.iter().fold(0, |accum, lit| {\n                accum + if lit.is_cut() { lit.len() } else { 0 }\n            });\n            for lits_lit in lits.literals() {\n                for self_lit in self.literals() {\n                    if !self_lit.is_cut() {\n                        size_after += self_lit.len() + lits_lit.len();\n                    }\n                }\n            }\n        }\n        if size_after > self.limit_size {\n            return false;\n        }\n\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for lits_lit in lits.literals() {\n            for mut self_lit in base.clone() {\n                self_lit.extend(&**lits_lit);\n                self_lit.cut = lits_lit.cut;\n                self.lits.push(self_lit);\n            }\n        }\n        true\n    }\n\n    /// Extends each literal in this set with the bytes given.\n    ///\n    /// If the set is empty, then the given literal is added to the set.\n    ///\n    /// If adding any number of bytes to all members of this set causes a limit\n    /// to be exceeded, then no bytes are added and false is returned. If a\n    /// prefix of `bytes` can be fit into this set, then it is used and all\n    /// resulting literals are cut.\n    pub fn cross_add(&mut self, bytes: &[u8]) -> bool {\n        // N.B. This could be implemented by simply calling cross_product with\n        // a literal set containing just `bytes`, but we can be smarter about\n        // taking shorter prefixes of `bytes` if they'll fit.\n        if bytes.is_empty() {\n            return true;\n        }\n        if self.lits.is_empty() {\n            let i = cmp::min(self.limit_size, bytes.len());\n            self.lits.push(Literal::new(bytes[..i].to_owned()));\n            self.lits[0].cut = i < bytes.len();\n            return !self.lits[0].is_cut();\n        }\n        let size = self.num_bytes();\n        if size + self.lits.len() >= self.limit_size {\n            return false;\n        }\n        let mut i = 1;\n        while size + (i * self.lits.len()) <= self.limit_size\n            && i < bytes.len()\n        {\n            i += 1;\n        }\n        for lit in &mut self.lits {\n            if !lit.is_cut() {\n                lit.extend(&bytes[..i]);\n                if i < bytes.len() {\n                    lit.cut();\n                }\n            }\n        }\n        true\n    }\n\n    /// Adds the given literal to this set.\n    ///\n    /// Returns false if adding this literal would cause the class to be too\n    /// big.\n    pub fn add(&mut self, lit: Literal) -> bool {\n        if self.num_bytes() + lit.len() > self.limit_size {\n            return false;\n        }\n        self.lits.push(lit);\n        true\n    }\n\n    /// Extends each literal in this set with the character class given.\n    ///\n    /// Returns false if the character class was too big to add.\n    pub fn add_char_class(&mut self, cls: &hir::ClassUnicode) -> bool {\n        self._add_char_class(cls, false)\n    }\n\n    /// Extends each literal in this set with the character class given,\n    /// writing the bytes of each character in reverse.\n    ///\n    /// Returns false if the character class was too big to add.\n    fn add_char_class_reverse(&mut self, cls: &hir::ClassUnicode) -> bool {\n        self._add_char_class(cls, true)\n    }\n\n    fn _add_char_class(\n        &mut self,\n        cls: &hir::ClassUnicode,\n        reverse: bool,\n    ) -> bool {\n        use std::char;\n\n        if self.class_exceeds_limits(cls_char_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for c in (s..e).filter_map(char::from_u32) {\n                for mut lit in base.clone() {\n                    let mut bytes = c.to_string().into_bytes();\n                    if reverse {\n                        bytes.reverse();\n                    }\n                    lit.extend(&bytes);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }\n\n    /// Extends each literal in this set with the byte class given.\n    ///\n    /// Returns false if the byte class was too big to add.\n    pub fn add_byte_class(&mut self, cls: &hir::ClassBytes) -> bool {\n        if self.class_exceeds_limits(cls_byte_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for b in (s..e).map(|b| b as u8) {\n                for mut lit in base.clone() {\n                    lit.push(b);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }\n\n    /// Cuts every member of this set. When a member is cut, it can never\n    /// be extended.\n    pub fn cut(&mut self) {\n        for lit in &mut self.lits {\n            lit.cut();\n        }\n    }\n\n    /// Reverses all members in place.\n    pub fn reverse(&mut self) {\n        for lit in &mut self.lits {\n            lit.reverse();\n        }\n    }\n\n    /// Clears this set of all members.\n    pub fn clear(&mut self) {\n        self.lits.clear();\n    }\n\n    /// Pops all complete literals out of this set.\n    fn remove_complete(&mut self) -> Vec<Literal> {\n        let mut base = vec![];\n        for lit in mem::replace(&mut self.lits, vec![]) {\n            if lit.is_cut() {\n                self.lits.push(lit);\n            } else {\n                base.push(lit);\n            }\n        }\n        base\n    }\n\n    /// Returns the total number of bytes in this set.\n    fn num_bytes(&self) -> usize {\n        self.lits.iter().fold(0, |accum, lit| accum + lit.len())\n    }\n\n    /// Returns true if a character class with the given size would cause this\n    /// set to exceed its limits.\n    ///\n    /// The size given should correspond to the number of items in the class.\n    fn class_exceeds_limits(&self, size: usize) -> bool {\n        if size > self.limit_class {\n            return true;\n        }\n        // This is an approximation since codepoints in a char class can encode\n        // to 1-4 bytes.\n        let new_byte_count = if self.lits.is_empty() {\n            size\n        } else {\n            self.lits.iter().fold(0, |accum, lit| {\n                accum\n                    + if lit.is_cut() {\n                        // If the literal is cut, then we'll never add\n                        // anything to it, so don't count it.\n                        0\n                    } else {\n                        (lit.len() + 1) * size\n                    }\n            })\n        };\n        new_byte_count > self.limit_size\n    }\n}","impl fmt::Debug for Literals {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Literals\")\n            .field(\"lits\", &self.lits)\n            .field(\"limit_size\", &self.limit_size)\n            .field(\"limit_class\", &self.limit_class)\n            .finish()\n    }\n}"],"hir::print::Printer":["Debug","impl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result {\n        visitor::visit(hir, Writer { printer: self, wtr: wtr })\n    }\n}"],"hir::print::PrinterBuilder":["Clone","Debug","impl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}","impl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}"],"hir::print::Writer":["Debug","impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            HirKind::Empty\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Literal(hir::Literal::Unicode(c)) => {\n                self.write_literal_char(c)?;\n            }\n            HirKind::Literal(hir::Literal::Byte(b)) => {\n                self.write_literal_byte(b)?;\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartLine) => {\n                self.wtr.write_str(\"(?m:^)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndLine) => {\n                self.wtr.write_str(\"(?m:$)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartText) => {\n                self.wtr.write_str(r\"\\A\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndText) => {\n                self.wtr.write_str(r\"\\z\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Unicode) => {\n                self.wtr.write_str(r\"\\b\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                self.wtr.write_str(r\"\\B\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Ascii) => {\n                self.wtr.write_str(r\"(?-u:\\b)\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.wtr.write_str(r\"(?-u:\\B)\")?;\n            }\n            HirKind::Group(ref x) => match x.kind {\n                hir::GroupKind::CaptureIndex(_) => {\n                    self.wtr.write_str(\"(\")?;\n                }\n                hir::GroupKind::CaptureName { ref name, .. } => {\n                    write!(self.wtr, \"(?P<{}>\", name)?;\n                }\n                hir::GroupKind::NonCapturing => {\n                    self.wtr.write_str(\"(?:\")?;\n                }\n            },\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            // Handled during visit_pre\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Repetition(ref x) => {\n                match x.kind {\n                    hir::RepetitionKind::ZeroOrOne => {\n                        self.wtr.write_str(\"?\")?;\n                    }\n                    hir::RepetitionKind::ZeroOrMore => {\n                        self.wtr.write_str(\"*\")?;\n                    }\n                    hir::RepetitionKind::OneOrMore => {\n                        self.wtr.write_str(\"+\")?;\n                    }\n                    hir::RepetitionKind::Range(ref x) => match *x {\n                        hir::RepetitionRange::Exactly(m) => {\n                            write!(self.wtr, \"{{{}}}\", m)?;\n                        }\n                        hir::RepetitionRange::AtLeast(m) => {\n                            write!(self.wtr, \"{{{},}}\", m)?;\n                        }\n                        hir::RepetitionRange::Bounded(m, n) => {\n                            write!(self.wtr, \"{{{},{}}}\", m, n)?;\n                        }\n                    },\n                }\n                if !x.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n            }\n            HirKind::Group(_) => {\n                self.wtr.write_str(\")\")?;\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n}","impl<'p, W: fmt::Write> Writer<'p, W> {\n    fn write_literal_char(&mut self, c: char) -> fmt::Result {\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }\n\n    fn write_literal_byte(&mut self, b: u8) -> fmt::Result {\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }\n\n    fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result {\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }\n}"],"hir::translate::Flags":["Clone","Copy","Debug","Default","impl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {\n        let mut flags = Flags::default();\n        let mut enable = true;\n        for item in &ast.items {\n            match item.kind {\n                ast::FlagsItemKind::Negation => {\n                    enable = false;\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {\n                    flags.case_insensitive = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {\n                    flags.multi_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {\n                    flags.dot_matches_new_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {\n                    flags.swap_greed = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => {\n                    flags.unicode = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}\n            }\n        }\n        flags\n    }\n\n    fn merge(&mut self, previous: &Flags) {\n        if self.case_insensitive.is_none() {\n            self.case_insensitive = previous.case_insensitive;\n        }\n        if self.multi_line.is_none() {\n            self.multi_line = previous.multi_line;\n        }\n        if self.dot_matches_new_line.is_none() {\n            self.dot_matches_new_line = previous.dot_matches_new_line;\n        }\n        if self.swap_greed.is_none() {\n            self.swap_greed = previous.swap_greed;\n        }\n        if self.unicode.is_none() {\n            self.unicode = previous.unicode;\n        }\n    }\n\n    fn case_insensitive(&self) -> bool {\n        self.case_insensitive.unwrap_or(false)\n    }\n\n    fn multi_line(&self) -> bool {\n        self.multi_line.unwrap_or(false)\n    }\n\n    fn dot_matches_new_line(&self) -> bool {\n        self.dot_matches_new_line.unwrap_or(false)\n    }\n\n    fn swap_greed(&self) -> bool {\n        self.swap_greed.unwrap_or(false)\n    }\n\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n}"],"hir::translate::HirFrame":["Clone","Debug","impl HirFrame {\n    /// Assert that the current stack frame is an Hir expression and return it.\n    fn unwrap_expr(self) -> Hir {\n        match self {\n            HirFrame::Expr(expr) => expr,\n            _ => panic!(\"tried to unwrap expr from HirFrame, got: {:?}\", self),\n        }\n    }\n\n    /// Assert that the current stack frame is a Unicode class expression and\n    /// return it.\n    fn unwrap_class_unicode(self) -> hir::ClassUnicode {\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a byte class expression and\n    /// return it.\n    fn unwrap_class_bytes(self) -> hir::ClassBytes {\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a group indicator and return\n    /// its corresponding flags (the flags that were active at the time the\n    /// group was entered).\n    fn unwrap_group(self) -> Flags {\n        match self {\n            HirFrame::Group { old_flags } => old_flags,\n            _ => {\n                panic!(\"tried to unwrap group from HirFrame, got: {:?}\", self)\n            }\n        }\n    }\n}"],"hir::translate::Translator":["Clone","Debug","impl Translator {\n    /// Create a new translator using the default configuration.\n    pub fn new() -> Translator {\n        TranslatorBuilder::new().build()\n    }\n\n    /// Translate the given abstract syntax tree (AST) into a high level\n    /// intermediate representation (HIR).\n    ///\n    /// If there was a problem doing the translation, then an HIR-specific\n    /// error is returned.\n    ///\n    /// The original pattern string used to produce the `Ast` *must* also be\n    /// provided. The translator does not use the pattern string during any\n    /// correct translation, but is used for error reporting.\n    pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {\n        ast::visit(ast, TranslatorI::new(self, pattern))\n    }\n}"],"hir::translate::TranslatorBuilder":["Clone","Debug","impl Default for TranslatorBuilder {\n    fn default() -> TranslatorBuilder {\n        TranslatorBuilder::new()\n    }\n}","impl TranslatorBuilder {\n    /// Create a new translator builder with a default c onfiguration.\n    pub fn new() -> TranslatorBuilder {\n        TranslatorBuilder {\n            allow_invalid_utf8: false,\n            flags: Flags::default(),\n        }\n    }\n\n    /// Build a translator using the current configuration.\n    pub fn build(&self) -> Translator {\n        Translator {\n            stack: RefCell::new(vec![]),\n            flags: Cell::new(self.flags),\n            allow_invalid_utf8: self.allow_invalid_utf8,\n        }\n    }\n\n    /// When enabled, translation will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When disabled (the default), the translator is guaranteed to produce\n    /// an expression that will only ever match valid UTF-8 (otherwise, the\n    /// translator will return an error).\n    ///\n    /// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n    /// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n    /// the parser to return an error. Namely, a negated ASCII word boundary\n    /// can result in matching positions that aren't valid UTF-8 boundaries.\n    pub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.allow_invalid_utf8 = yes;\n        self\n    }\n\n    /// Enable or disable the case insensitive flag (`i`) by default.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.case_insensitive = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag (`m`) by default.\n    pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.multi_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag (`s`) by\n    /// default.\n    pub fn dot_matches_new_line(\n        &mut self,\n        yes: bool,\n    ) -> &mut TranslatorBuilder {\n        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag (`U`) by default.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.swap_greed = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.unicode = if yes { None } else { Some(false) };\n        self\n    }\n}"],"hir::translate::TranslatorI":["Clone","Debug","impl<'t, 'p> TranslatorI<'t, 'p> {\n    /// Build a new internal translator.\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n        TranslatorI { trans: trans, pattern: pattern }\n    }\n\n    /// Return a reference to the underlying translator.\n    fn trans(&self) -> &Translator {\n        &self.trans\n    }\n\n    /// Push the given frame on to the call stack.\n    fn push(&self, frame: HirFrame) {\n        self.trans().stack.borrow_mut().push(frame);\n    }\n\n    /// Pop the top of the call stack. If the call stack is empty, return None.\n    fn pop(&self) -> Option<HirFrame> {\n        self.trans().stack.borrow_mut().pop()\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {\n        Error { kind: kind, pattern: self.pattern.to_string(), span: span }\n    }\n\n    /// Return a copy of the active flags.\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n\n    /// Set the flags of this translator from the flags set in the given AST.\n    /// Then, return the old flags.\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {\n        let old_flags = self.flags();\n        let mut new_flags = Flags::from_ast(ast_flags);\n        new_flags.merge(&old_flags);\n        self.trans().flags.set(new_flags);\n        old_flags\n    }\n\n    fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir> {\n        let ch = match self.literal_to_char(lit)? {\n            byte @ hir::Literal::Byte(_) => return Ok(Hir::literal(byte)),\n            hir::Literal::Unicode(ch) => ch,\n        };\n        if self.flags().case_insensitive() {\n            self.hir_from_char_case_insensitive(lit.span, ch)\n        } else {\n            self.hir_from_char(lit.span, ch)\n        }\n    }\n\n    /// Convert an Ast literal to its scalar representation.\n    ///\n    /// When Unicode mode is enabled, then this always succeeds and returns a\n    /// `char` (Unicode scalar value).\n    ///\n    /// When Unicode mode is disabled, then a raw byte is returned. If that\n    /// byte is not ASCII and invalid UTF-8 is not allowed, then this returns\n    /// an error.\n    fn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal> {\n        if self.flags().unicode() {\n            return Ok(hir::Literal::Unicode(lit.c));\n        }\n        let byte = match lit.byte() {\n            None => return Ok(hir::Literal::Unicode(lit.c)),\n            Some(byte) => byte,\n        };\n        if byte <= 0x7F {\n            return Ok(hir::Literal::Unicode(byte as char));\n        }\n        if !self.trans().allow_invalid_utf8 {\n            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(hir::Literal::Byte(byte))\n    }\n\n    fn hir_from_char(&self, span: Span, c: char) -> Result<Hir> {\n        if !self.flags().unicode() && c.len_utf8() > 1 {\n            return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n        }\n        Ok(Hir::literal(hir::Literal::Unicode(c)))\n    }\n\n    fn hir_from_char_case_insensitive(\n        &self,\n        span: Span,\n        c: char,\n    ) -> Result<Hir> {\n        if self.flags().unicode() {\n            // If case folding won't do anything, then don't bother trying.\n            let map =\n                unicode::contains_simple_case_mapping(c, c).map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?;\n            if !map {\n                return self.hir_from_char(span, c);\n            }\n            let mut cls =\n                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(\n                    c, c,\n                )]);\n            cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?;\n            Ok(Hir::class(hir::Class::Unicode(cls)))\n        } else {\n            if c.len_utf8() > 1 {\n                return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n            }\n            // If case folding won't do anything, then don't bother trying.\n            match c {\n                'A'..='Z' | 'a'..='z' => {}\n                _ => return self.hir_from_char(span, c),\n            }\n            let mut cls =\n                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(\n                    c as u8, c as u8,\n                )]);\n            cls.case_fold_simple();\n            Ok(Hir::class(hir::Class::Bytes(cls)))\n        }\n    }\n\n    fn hir_dot(&self, span: Span) -> Result<Hir> {\n        let unicode = self.flags().unicode();\n        if !unicode && !self.trans().allow_invalid_utf8 {\n            return Err(self.error(span, ErrorKind::InvalidUtf8));\n        }\n        Ok(if self.flags().dot_matches_new_line() {\n            Hir::any(!unicode)\n        } else {\n            Hir::dot(!unicode)\n        })\n    }\n\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {\n        let unicode = self.flags().unicode();\n        let multi_line = self.flags().multi_line();\n        Ok(match asst.kind {\n            ast::AssertionKind::StartLine => Hir::anchor(if multi_line {\n                hir::Anchor::StartLine\n            } else {\n                hir::Anchor::StartText\n            }),\n            ast::AssertionKind::EndLine => Hir::anchor(if multi_line {\n                hir::Anchor::EndLine\n            } else {\n                hir::Anchor::EndText\n            }),\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => Hir::anchor(hir::Anchor::EndText),\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(\n                            self.error(asst.span, ErrorKind::InvalidUtf8)\n                        );\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n    }\n\n    fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir {\n        let kind = match group.kind {\n            ast::GroupKind::CaptureIndex(idx) => {\n                hir::GroupKind::CaptureIndex(idx)\n            }\n            ast::GroupKind::CaptureName(ref capname) => {\n                hir::GroupKind::CaptureName {\n                    name: capname.name.clone(),\n                    index: capname.index,\n                }\n            }\n            ast::GroupKind::NonCapturing(_) => hir::GroupKind::NonCapturing,\n        };\n        Hir::group(hir::Group { kind: kind, hir: Box::new(expr) })\n    }\n\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {\n        let kind = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => hir::RepetitionKind::ZeroOrOne,\n            ast::RepetitionKind::ZeroOrMore => hir::RepetitionKind::ZeroOrMore,\n            ast::RepetitionKind::OneOrMore => hir::RepetitionKind::OneOrMore,\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(\n                m,\n                n,\n            )) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(m, n))\n            }\n        };\n        let greedy =\n            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            kind: kind,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {\n        use ast::ClassUnicodeKind::*;\n\n        if !self.flags().unicode() {\n            return Err(\n                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)\n            );\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {\n                property_name: name,\n                property_value: value,\n            },\n        };\n        let mut result = self.convert_unicode_class_error(\n            &ast_class.span,\n            unicode::class(query),\n        );\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(\n                &ast_class.span,\n                ast_class.negated,\n                class,\n            )?;\n            if class.ranges().is_empty() {\n                let err = self\n                    .error(ast_class.span, ErrorKind::EmptyClassNotAllowed);\n                return Err(err);\n            }\n        }\n        result\n    }\n\n    fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode> {\n        use ast::ClassPerlKind::*;\n\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class =\n            self.convert_unicode_class_error(&ast_class.span, result)?;\n        // We needn't apply case folding here because the Perl Unicode classes\n        // are already closed under Unicode simple case folding.\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }\n\n    fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> hir::ClassBytes {\n        use ast::ClassPerlKind::*;\n\n        assert!(!self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        // We needn't apply case folding here because the Perl ASCII classes\n        // are already closed (under ASCII case folding).\n        if ast_class.negated {\n            class.negate();\n        }\n        class\n    }\n\n    /// Converts the given Unicode specific error to an HIR translation error.\n    ///\n    /// The span given should approximate the position at which an error would\n    /// occur.\n    fn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: unicode::Result<hir::ClassUnicode>,\n    ) -> Result<hir::ClassUnicode> {\n        result.map_err(|err| {\n            let sp = span.clone();\n            match err {\n                unicode::Error::PropertyNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyNotFound)\n                }\n                unicode::Error::PropertyValueNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyValueNotFound)\n                }\n                unicode::Error::PerlClassNotFound => {\n                    self.error(sp, ErrorKind::UnicodePerlClassNotFound)\n                }\n            }\n        })\n    }\n\n    fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.try_case_fold_simple().map_err(|_| {\n                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n            })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }\n\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if !self.trans().allow_invalid_utf8 && !class.is_all_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }\n\n    /// Return a scalar byte value suitable for use as a literal in a byte\n    /// character class.\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {\n        match self.literal_to_char(ast)? {\n            hir::Literal::Byte(byte) => Ok(byte),\n            hir::Literal::Unicode(ch) => {\n                if ch <= 0x7F as char {\n                    Ok(ch as u8)\n                } else {\n                    // We can't feasibly support Unicode in\n                    // byte oriented classes. Byte classes don't\n                    // do Unicode case folding.\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }\n}","impl<'t, 'p> Visitor for TranslatorI<'t, 'p> {\n    type Output = Hir;\n    type Err = Error;\n\n    fn finish(self) -> Result<Hir> {\n        // ... otherwise, we should have exactly one HIR on the stack.\n        assert_eq!(self.trans().stack.borrow().len(), 1);\n        Ok(self.pop().unwrap().unwrap_expr())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Class(ast::Class::Bracketed(_)) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            Ast::Group(ref x) => {\n                let old_flags = x\n                    .flags()\n                    .map(|ast| self.set_flags(ast))\n                    .unwrap_or_else(|| self.flags());\n                self.push(HirFrame::Group { old_flags });\n            }\n            Ast::Concat(ref x) if x.asts.is_empty() => {}\n            Ast::Concat(_) => {\n                self.push(HirFrame::Concat);\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => {}\n            Ast::Alternation(_) => {\n                self.push(HirFrame::Alternation);\n            }\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_) => {\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Flags(ref x) => {\n                self.set_flags(&x.flags);\n                // Flags in the AST are generally considered directives and\n                // not actual sub-expressions. However, they can be used in\n                // the concrete syntax like `((?i))`, and we need some kind of\n                // indication of an expression there, and Empty is the correct\n                // choice.\n                //\n                // There can also be things like `(?i)+`, but we rule those out\n                // in the parser. In the future, we might allow them for\n                // consistency sake.\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Literal(ref x) => {\n                self.push(HirFrame::Expr(self.hir_literal(x)?));\n            }\n            Ast::Dot(span) => {\n                self.push(HirFrame::Expr(self.hir_dot(span)?));\n            }\n            Ast::Assertion(ref x) => {\n                self.push(HirFrame::Expr(self.hir_assertion(x)?));\n            }\n            Ast::Class(ast::Class::Perl(ref x)) => {\n                if self.flags().unicode() {\n                    let cls = self.hir_perl_unicode_class(x)?;\n                    let hcls = hir::Class::Unicode(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                } else {\n                    let cls = self.hir_perl_byte_class(x);\n                    let hcls = hir::Class::Bytes(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                }\n            }\n            Ast::Class(ast::Class::Unicode(ref x)) => {\n                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);\n                self.push(HirFrame::Expr(Hir::class(cls)));\n            }\n            Ast::Class(ast::Class::Bracketed(ref ast)) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.ranges().is_empty() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n                    let expr = Hir::class(hir::Class::Unicode(cls));\n                    self.push(HirFrame::Expr(expr));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.ranges().is_empty() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n\n                    let expr = Hir::class(hir::Class::Bytes(cls));\n                    self.push(HirFrame::Expr(expr));\n                }\n            }\n            Ast::Repetition(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));\n            }\n            Ast::Group(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                let old_flags = self.pop().unwrap().unwrap_group();\n                self.trans().flags.set(old_flags);\n                self.push(HirFrame::Expr(self.hir_group(x, expr)));\n            }\n            Ast::Concat(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    if !expr.kind().is_empty() {\n                        exprs.push(expr);\n                    }\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::concat(exprs)));\n            }\n            Ast::Alternation(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    exprs.push(expr);\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::alternation(exprs)));\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(_) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            // We needn't handle the Union case here since the visitor will\n            // do it for us.\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.unicode_fold_and_negate(\n                        &x.span, x.negated, &mut cls,\n                    )?;\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassBytesRange::new(s as u8, e as u8));\n                    }\n                    self.bytes_fold_and_negate(&x.span, x.negated, &mut cls)?;\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x);\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            // This is handled automatically by the visitor.\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        use ast::ClassSetBinaryOpKind::*;\n\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.rhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n                lhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.lhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n}"],"hir::visitor::Frame":["impl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child HIR node to visit.\n    fn child(&self) -> &'a Hir {\n        match *self {\n            Frame::Repetition(rep) => &rep.hir,\n            Frame::Group(group) => &group.hir,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}"],"hir::visitor::HeapVisitor":["impl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(hir)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this HIR, so we can post visit it now.\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given HIR if one is needed (which occurs if\n    /// and only if there are child nodes in the HIR). Otherwise, return None.\n    fn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>> {\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Group(ref x) => Some(Frame::Group(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat { head: &x[0], tail: &x[1..] })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })\n            }\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n}"],"parser::Parser":["Clone","Debug","impl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with `parse` method. The parse method returns\n    /// a high level intermediate representation of the given regular\n    /// expression.\n    ///\n    /// To set configuration options on the parser, use\n    /// [`ParserBuilder`](struct.ParserBuilder.html).\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into a high level intermediate\n    /// representation.\n    pub fn parse(&mut self, pattern: &str) -> Result<hir::Hir> {\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }\n}"],"parser::ParserBuilder":["Clone","Debug","Default","impl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder::default()\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser { ast: self.ast.build(), hir: self.hir.build() }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire Ast is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// lenth of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.ast.nest_limit(limit);\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.octal(yes);\n        self\n    }\n\n    /// When enabled, the parser will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When disabled (the default), the parser is guaranteed to produce\n    /// an expression that will only ever match valid UTF-8 (otherwise, the\n    /// parser will return an error).\n    ///\n    /// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n    /// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n    /// the parser to return an error. Namely, a negated ASCII word boundary\n    /// can result in matching positions that aren't valid UTF-8 boundaries.\n    pub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.allow_invalid_utf8(yes);\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insigificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.ignore_whitespace(yes);\n        self\n    }\n\n    /// Enable or disable the case insensitive flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `i` flag.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.case_insensitive(yes);\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `m` flag.\n    pub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.multi_line(yes);\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `s` flag.\n    pub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.dot_matches_new_line(yes);\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `U` flag.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.swap_greed(yes);\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    ///\n    /// By default this is **enabled**. It may alternatively be selectively\n    /// disabled in the regular expression itself via the `u` flag.\n    ///\n    /// Note that unless `allow_invalid_utf8` is enabled (it's disabled by\n    /// default), a regular expression will fail to parse if Unicode mode is\n    /// disabled and a sub-expression could possibly match invalid UTF-8.\n    pub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.unicode(yes);\n        self\n    }\n}"],"unicode::CanonicalClassQuery":["Debug","Eq","PartialEq"],"unicode::CaseFoldError":["Debug","impl error::Error for CaseFoldError {}","impl fmt::Display for CaseFoldError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware case folding is not available \\\n             (probably because the unicode-case feature is not enabled)\"\n        )\n    }\n}"],"unicode::ClassQuery":["Debug","impl<'a> ClassQuery<'a> {\n    fn canonicalize(&self) -> Result<CanonicalClassQuery> {\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(match canon_name {\n                    \"General_Category\" => {\n                        let canon = match canonical_gencat(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::GeneralCategory(canon)\n                    }\n                    \"Script\" => {\n                        let canon = match canonical_script(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::Script(canon)\n                    }\n                    _ => {\n                        let vals = match property_values(canon_name)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(vals) => vals,\n                        };\n                        let canon_val =\n                            match canonical_value(vals, &property_value) {\n                                None => {\n                                    return Err(Error::PropertyValueNotFound)\n                                }\n                                Some(canon_val) => canon_val,\n                            };\n                        CanonicalClassQuery::ByValue {\n                            property_name: canon_name,\n                            property_value: canon_val,\n                        }\n                    }\n                })\n            }\n        }\n    }\n\n    fn canonical_binary(&self, name: &str) -> Result<CanonicalClassQuery> {\n        let norm = symbolic_name_normalize(name);\n\n        // This is a special case where 'cf' refers to the 'Format' general\n        // category, but where the 'cf' abbreviation is also an abbreviation\n        // for the 'Case_Folding' property. But we want to treat it as\n        // a general category. (Currently, we don't even support the\n        // 'Case_Folding' property. But if we do in the future, users will be\n        // required to spell it out.)\n        if norm != \"cf\" {\n            if let Some(canon) = canonical_prop(&norm)? {\n                return Ok(CanonicalClassQuery::Binary(canon));\n            }\n        }\n        if let Some(canon) = canonical_gencat(&norm)? {\n            return Ok(CanonicalClassQuery::GeneralCategory(canon));\n        }\n        if let Some(canon) = canonical_script(&norm)? {\n            return Ok(CanonicalClassQuery::Script(canon));\n        }\n        Err(Error::PropertyNotFound)\n    }\n}"],"unicode::Error":["Debug"],"unicode::UnicodeWordError":["Debug","impl error::Error for UnicodeWordError {}","impl fmt::Display for UnicodeWordError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware \\\\w class is not available \\\n             (probably because the unicode-perl feature is not enabled)\"\n        )\n    }\n}"],"utf8::ScalarRange":["impl ScalarRange {\n    /// split splits this range if it overlaps with a surrogate codepoint.\n    ///\n    /// Either or both ranges may be invalid.\n    fn split(&self) -> Option<(ScalarRange, ScalarRange)> {\n        if self.start < 0xE000 && self.end > 0xD7FF {\n            Some((\n                ScalarRange { start: self.start, end: 0xD7FF },\n                ScalarRange { start: 0xE000, end: self.end },\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// is_valid returns true if and only if start <= end.\n    fn is_valid(&self) -> bool {\n        self.start <= self.end\n    }\n\n    /// as_ascii returns this range as a Utf8Range if and only if all scalar\n    /// values in this range can be encoded as a single byte.\n    fn as_ascii(&self) -> Option<Utf8Range> {\n        if self.is_ascii() {\n            Some(Utf8Range::new(self.start as u8, self.end as u8))\n        } else {\n            None\n        }\n    }\n\n    /// is_ascii returns true if the range is ASCII only (i.e., takes a single\n    /// byte to encode any scalar value).\n    fn is_ascii(&self) -> bool {\n        self.is_valid() && self.end <= 0x7f\n    }\n\n    /// encode writes the UTF-8 encoding of the start and end of this range\n    /// to the corresponding destination slices, and returns the number of\n    /// bytes written.\n    ///\n    /// The slices should have room for at least `MAX_UTF8_BYTES`.\n    fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize {\n        let cs = char::from_u32(self.start).unwrap();\n        let ce = char::from_u32(self.end).unwrap();\n        let ss = cs.encode_utf8(start);\n        let se = ce.encode_utf8(end);\n        assert_eq!(ss.len(), se.len());\n        ss.len()\n    }\n}","impl fmt::Debug for ScalarRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"ScalarRange({:X}, {:X})\", self.start, self.end)\n    }\n}"],"utf8::Utf8Range":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd","impl Utf8Range {\n    fn new(start: u8, end: u8) -> Self {\n        Utf8Range { start, end }\n    }\n\n    /// Returns true if and only if the given byte is in this range.\n    pub fn matches(&self, b: u8) -> bool {\n        self.start <= b && b <= self.end\n    }\n}","impl fmt::Debug for Utf8Range {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.start == self.end {\n            write!(f, \"[{:X}]\", self.start)\n        } else {\n            write!(f, \"[{:X}-{:X}]\", self.start, self.end)\n        }\n    }\n}"],"utf8::Utf8Sequence":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd","impl Utf8Sequence {\n    /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value\n    /// range.\n    ///\n    /// This assumes that `start` and `end` have the same length.\n    fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {\n        assert_eq!(start.len(), end.len());\n        match start.len() {\n            2 => Utf8Sequence::Two([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n            ]),\n            3 => Utf8Sequence::Three([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n            ]),\n            4 => Utf8Sequence::Four([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n                Utf8Range::new(start[3], end[3]),\n            ]),\n            n => unreachable!(\"invalid encoded length: {}\", n),\n        }\n    }\n\n    /// Returns the underlying sequence of byte ranges as a slice.\n    pub fn as_slice(&self) -> &[Utf8Range] {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => slice::from_ref(r),\n            Two(ref r) => &r[..],\n            Three(ref r) => &r[..],\n            Four(ref r) => &r[..],\n        }\n    }\n\n    /// Returns the number of byte ranges in this sequence.\n    ///\n    /// The length is guaranteed to be in the closed interval `[1, 4]`.\n    pub fn len(&self) -> usize {\n        self.as_slice().len()\n    }\n\n    /// Reverses the ranges in this sequence.\n    ///\n    /// For example, if this corresponds to the following sequence:\n    ///\n    /// ```ignore\n    /// [D0-D3][80-BF]\n    /// ```\n    ///\n    /// Then after reversal, it will be\n    ///\n    /// ```ignore\n    /// [80-BF][D0-D3]\n    /// ```\n    ///\n    /// This is useful when one is constructing a UTF-8 automaton to match\n    /// character classes in reverse.\n    pub fn reverse(&mut self) {\n        match *self {\n            Utf8Sequence::One(_) => {}\n            Utf8Sequence::Two(ref mut x) => x.reverse(),\n            Utf8Sequence::Three(ref mut x) => x.reverse(),\n            Utf8Sequence::Four(ref mut x) => x.reverse(),\n        }\n    }\n\n    /// Returns true if and only if a prefix of `bytes` matches this sequence\n    /// of byte ranges.\n    pub fn matches(&self, bytes: &[u8]) -> bool {\n        if bytes.len() < self.len() {\n            return false;\n        }\n        for (&b, r) in bytes.iter().zip(self) {\n            if !r.matches(b) {\n                return false;\n            }\n        }\n        true\n    }\n}","impl fmt::Debug for Utf8Sequence {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => write!(f, \"{:?}\", r),\n            Two(ref r) => write!(f, \"{:?}{:?}\", r[0], r[1]),\n            Three(ref r) => write!(f, \"{:?}{:?}{:?}\", r[0], r[1], r[2]),\n            Four(ref r) => {\n                write!(f, \"{:?}{:?}{:?}{:?}\", r[0], r[1], r[2], r[3])\n            }\n        }\n    }\n}"],"utf8::Utf8Sequences":["Debug","impl FusedIterator for Utf8Sequences {}","impl Iterator for Utf8Sequences {\n    type Item = Utf8Sequence;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'TOP: while let Some(mut r) = self.range_stack.pop() {\n            'INNER: loop {\n                if let Some((r1, r2)) = r.split() {\n                    self.push(r2.start, r2.end);\n                    r.start = r1.start;\n                    r.end = r1.end;\n                    continue 'INNER;\n                }\n                if !r.is_valid() {\n                    continue 'TOP;\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let max = max_scalar_value(i);\n                    if r.start <= max && max < r.end {\n                        self.push(max + 1, r.end);\n                        r.end = max;\n                        continue 'INNER;\n                    }\n                }\n                if let Some(ascii_range) = r.as_ascii() {\n                    return Some(Utf8Sequence::One(ascii_range));\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let m = (1 << (6 * i)) - 1;\n                    if (r.start & !m) != (r.end & !m) {\n                        if (r.start & m) != 0 {\n                            self.push((r.start | m) + 1, r.end);\n                            r.end = r.start | m;\n                            continue 'INNER;\n                        }\n                        if (r.end & m) != m {\n                            self.push(r.end & !m, r.end);\n                            r.end = (r.end & !m) - 1;\n                            continue 'INNER;\n                        }\n                    }\n                }\n                let mut start = [0; MAX_UTF8_BYTES];\n                let mut end = [0; MAX_UTF8_BYTES];\n                let n = r.encode(&mut start, &mut end);\n                return Some(Utf8Sequence::from_encoded_range(\n                    &start[0..n],\n                    &end[0..n],\n                ));\n            }\n        }\n        None\n    }\n}","impl Utf8Sequences {\n    /// Create a new iterator over UTF-8 byte ranges for the scalar value range\n    /// given.\n    pub fn new(start: char, end: char) -> Self {\n        let mut it = Utf8Sequences { range_stack: vec![] };\n        it.push(start as u32, end as u32);\n        it\n    }\n\n    /// reset resets the scalar value range.\n    /// Any existing state is cleared, but resources may be reused.\n    ///\n    /// N.B. Benchmarks say that this method is dubious.\n    #[doc(hidden)]\n    pub fn reset(&mut self, start: char, end: char) {\n        self.range_stack.clear();\n        self.push(start as u32, end as u32);\n    }\n\n    fn push(&mut self, start: u32, end: u32) {\n        self.range_stack.push(ScalarRange { start, end });\n    }\n}"]},"single_path_import":{"ast::visitor::Visitor":"ast::Visitor","ast::visitor::visit":"ast::visit","error::Error":"Error","error::Result":"Result","hir::visitor::Visitor":"hir::Visitor","hir::visitor::visit":"hir::visit","parser::Parser":"Parser","parser::ParserBuilder":"ParserBuilder","unicode::CaseFoldError":"hir::CaseFoldError","unicode::UnicodeWordError":"UnicodeWordError"},"srcs":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.as_slice().into_iter()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<ast::Ast as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use ast::print::Printer;\n        Printer::new().print(self, f)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Ast as std::ops::Drop>::drop":["fn drop(&mut self){\n        use std::mem;\n\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            // Classes are recursive, so they get their own Drop impl.\n            | Ast::Class(_) => return,\n            Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Group(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Alternation(ref x) if x.asts.is_empty() => return,\n            Ast::Concat(ref x) if x.asts.is_empty() => return,\n            _ => {}\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_ast = || Ast::Empty(empty_span());\n        let mut stack = vec![mem::replace(self, empty_ast())];\n        while let Some(mut ast) = stack.pop() {\n            match ast {\n                Ast::Empty(_)\n                | Ast::Flags(_)\n                | Ast::Literal(_)\n                | Ast::Dot(_)\n                | Ast::Assertion(_)\n                // Classes are recursive, so they get their own Drop impl.\n                | Ast::Class(_) => {}\n                Ast::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Alternation(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n                Ast::Concat(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::ClassSet as std::ops::Drop>::drop":["fn drop(&mut self){\n        use std::mem;\n\n        match *self {\n            ClassSet::Item(ref item) => match *item {\n                ClassSetItem::Empty(_)\n                | ClassSetItem::Literal(_)\n                | ClassSetItem::Range(_)\n                | ClassSetItem::Ascii(_)\n                | ClassSetItem::Unicode(_)\n                | ClassSetItem::Perl(_) => return,\n                ClassSetItem::Bracketed(ref x) => {\n                    if x.kind.is_empty() {\n                        return;\n                    }\n                }\n                ClassSetItem::Union(ref x) => {\n                    if x.items.is_empty() {\n                        return;\n                    }\n                }\n            },\n            ClassSet::BinaryOp(ref op) => {\n                if op.lhs.is_empty() && op.rhs.is_empty() {\n                    return;\n                }\n            }\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));\n        let mut stack = vec![mem::replace(self, empty_set())];\n        while let Some(mut set) = stack.pop() {\n            match set {\n                ClassSet::Item(ref mut item) => match *item {\n                    ClassSetItem::Empty(_)\n                    | ClassSetItem::Literal(_)\n                    | ClassSetItem::Range(_)\n                    | ClassSetItem::Ascii(_)\n                    | ClassSetItem::Unicode(_)\n                    | ClassSetItem::Perl(_) => {}\n                    ClassSetItem::Bracketed(ref mut x) => {\n                        stack.push(mem::replace(&mut x.kind, empty_set()));\n                    }\n                    ClassSetItem::Union(ref mut x) => {\n                        stack.extend(x.items.drain(..).map(ClassSet::Item));\n                    }\n                },\n                ClassSet::BinaryOp(ref mut op) => {\n                    stack.push(mem::replace(&mut op.lhs, empty_set()));\n                    stack.push(mem::replace(&mut op.rhs, empty_set()));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Error as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        use self::ErrorKind::*;\n        match self.kind {\n            CaptureLimitExceeded => \"capture group limit exceeded\",\n            ClassEscapeInvalid => \"invalid escape sequence in character class\",\n            ClassRangeInvalid => \"invalid character class range\",\n            ClassRangeLiteral => \"invalid range boundary, must be a literal\",\n            ClassUnclosed => \"unclosed character class\",\n            DecimalEmpty => \"empty decimal literal\",\n            DecimalInvalid => \"invalid decimal literal\",\n            EscapeHexEmpty => \"empty hexadecimal literal\",\n            EscapeHexInvalid => \"invalid hexadecimal literal\",\n            EscapeHexInvalidDigit => \"invalid hexadecimal digit\",\n            EscapeUnexpectedEof => \"unexpected eof (escape sequence)\",\n            EscapeUnrecognized => \"unrecognized escape sequence\",\n            FlagDanglingNegation => \"dangling flag negation operator\",\n            FlagDuplicate { .. } => \"duplicate flag\",\n            FlagRepeatedNegation { .. } => \"repeated negation\",\n            FlagUnexpectedEof => \"unexpected eof (flag)\",\n            FlagUnrecognized => \"unrecognized flag\",\n            GroupNameDuplicate { .. } => \"duplicate capture group name\",\n            GroupNameEmpty => \"empty capture group name\",\n            GroupNameInvalid => \"invalid capture group name\",\n            GroupNameUnexpectedEof => \"unclosed capture group name\",\n            GroupUnclosed => \"unclosed group\",\n            GroupUnopened => \"unopened group\",\n            NestLimitExceeded(_) => \"nest limit exceeded\",\n            RepetitionCountInvalid => \"invalid repetition count range\",\n            RepetitionCountUnclosed => \"unclosed counted repetition\",\n            RepetitionMissing => \"repetition operator missing expression\",\n            UnicodeClassInvalid => \"invalid Unicode character class\",\n            UnsupportedBackreference => \"backreferences are not supported\",\n            UnsupportedLookAround => \"look-around is not supported\",\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        ::error::Formatter::from(self).fmt(f)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::ErrorKind as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => write!(\n                f,\n                \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                ::std::u32::MAX\n            ),\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => write!(\n                f,\n                \"invalid character class range, \\\n                 the start must be <= the end\"\n            ),\n            ClassRangeLiteral => {\n                write!(f, \"invalid range boundary, must be a literal\")\n            }\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => write!(\n                f,\n                \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n            ),\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => {\n                write!(f, \"dangling flag negation operator\")\n            }\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => {\n                write!(f, \"flag negation operator repeated\")\n            }\n            FlagUnexpectedEof => {\n                write!(f, \"expected flag but got end of regex\")\n            }\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => {\n                write!(f, \"duplicate capture group name\")\n            }\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => write!(\n                f,\n                \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                limit\n            ),\n            RepetitionCountInvalid => write!(\n                f,\n                \"invalid repetition count range, \\\n                 the start must be <= the end\"\n            ),\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => {\n                write!(f, \"unclosed counted repetition\")\n            }\n            RepetitionMissing => {\n                write!(f, \"repetition operator missing expression\")\n            }\n            UnicodeClassInvalid => {\n                write!(f, \"invalid Unicode character class\")\n            }\n            UnsupportedBackreference => {\n                write!(f, \"backreferences are not supported\")\n            }\n            UnsupportedLookAround => write!(\n                f,\n                \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n            ),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Position) -> Ordering{\n        self.offset.cmp(&other.offset)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Position) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Position(o: {:?}, l: {:?}, c: {:?})\",\n            self.offset, self.line, self.column\n        )\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Span) -> Ordering{\n        (&self.start, &self.end).cmp(&(&other.start, &other.end))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Span) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Span({:?}, {:?})\", self.start, self.end)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["fn finish(self) -> Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        self.decrement_depth();\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["fn visit_class_set_binary_op_pre(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        self.increment_depth(&ast.span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        let span = match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            ast::ClassSetItem::Bracketed(ref x) => &x.span,\n            ast::ClassSetItem::Union(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            Ast::Class(ast::Class::Bracketed(_))\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> Result<()>{\n        let span = match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            Ast::Class(ast::Class::Bracketed(ref x)) => &x.span,\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::ParserBuilder as std::default::Default>::default":["fn default() -> ParserBuilder{\n        ParserBuilder::new()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::print::PrinterBuilder as std::default::Default>::default":["fn default() -> PrinterBuilder{\n        PrinterBuilder::new()\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":["fn finish(self) -> fmt::Result{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":["fn visit_alternation_in(&mut self) -> fmt::Result{\n        self.wtr.write_str(\"|\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["fn visit_class_set_binary_op_in(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        self.fmt_class_set_binary_op_kind(&ast.kind)\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        use ast::ClassSetItem::*;\n\n        match *ast {\n            Empty(_) => Ok(()),\n            Literal(ref x) => self.fmt_literal(x),\n            Range(ref x) => {\n                self.fmt_literal(&x.start)?;\n                self.wtr.write_str(\"-\")?;\n                self.fmt_literal(&x.end)?;\n                Ok(())\n            }\n            Ascii(ref x) => self.fmt_class_ascii(x),\n            Unicode(ref x) => self.fmt_class_unicode(x),\n            Perl(ref x) => self.fmt_class_perl(x),\n            Bracketed(ref x) => self.fmt_class_bracketed_post(x),\n            Union(_) => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        match *ast {\n            ast::ClassSetItem::Bracketed(ref x) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> fmt::Result{\n        use ast::Class;\n\n        match *ast {\n            Ast::Empty(_) => Ok(()),\n            Ast::Flags(ref x) => self.fmt_set_flags(x),\n            Ast::Literal(ref x) => self.fmt_literal(x),\n            Ast::Dot(_) => self.wtr.write_str(\".\"),\n            Ast::Assertion(ref x) => self.fmt_assertion(x),\n            Ast::Class(Class::Perl(ref x)) => self.fmt_class_perl(x),\n            Ast::Class(Class::Unicode(ref x)) => self.fmt_class_unicode(x),\n            Ast::Class(Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_post(x)\n            }\n            Ast::Repetition(ref x) => self.fmt_repetition(x),\n            Ast::Group(ref x) => self.fmt_group_post(x),\n            Ast::Alternation(_) => Ok(()),\n            Ast::Concat(_) => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> fmt::Result{\n        match *ast {\n            Ast::Group(ref x) => self.fmt_group_pre(x),\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let x = match *self {\n            ClassFrame::Union { .. } => \"Union\",\n            ClassFrame::Binary { .. } => \"Binary\",\n            ClassFrame::BinaryLHS { .. } => \"BinaryLHS\",\n            ClassFrame::BinaryRHS { .. } => \"BinaryRHS\",\n        };\n        write!(f, \"{}\", x)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let x = match *self {\n            ClassInduct::Item(it) => match *it {\n                ast::ClassSetItem::Empty(_) => \"Item(Empty)\",\n                ast::ClassSetItem::Literal(_) => \"Item(Literal)\",\n                ast::ClassSetItem::Range(_) => \"Item(Range)\",\n                ast::ClassSetItem::Ascii(_) => \"Item(Ascii)\",\n                ast::ClassSetItem::Perl(_) => \"Item(Perl)\",\n                ast::ClassSetItem::Unicode(_) => \"Item(Unicode)\",\n                ast::ClassSetItem::Bracketed(_) => \"Item(Bracketed)\",\n                ast::ClassSetItem::Union(_) => \"Item(Union)\",\n            },\n            ClassInduct::BinaryOp(it) => match it.kind {\n                ast::ClassSetBinaryOpKind::Intersection => {\n                    \"BinaryOp(Intersection)\"\n                }\n                ast::ClassSetBinaryOpKind::Difference => {\n                    \"BinaryOp(Difference)\"\n                }\n                ast::ClassSetBinaryOpKind::SymmetricDifference => {\n                    \"BinaryOp(SymmetricDifference)\"\n                }\n            },\n        };\n        write!(f, \"{}\", x)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"<char as hir::interval::Bound>::as_u32":["fn as_u32(self) -> u32{\n        self as u32\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::decrement":["fn decrement(self) -> Self{\n        match self {\n            '\\u{E000}' => '\\u{D7FF}',\n            c => char::from_u32((c as u32).checked_sub(1).unwrap()).unwrap(),\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::increment":["fn increment(self) -> Self{\n        match self {\n            '\\u{D7FF}' => '\\u{E000}',\n            c => char::from_u32((c as u32).checked_add(1).unwrap()).unwrap(),\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::max_value":["fn max_value() -> Self{\n        '\\u{10FFFF}'\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::min_value":["fn min_value() -> Self{\n        '\\x00'\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<error::Error as std::convert::From<ast::Error>>::from":["fn from(err: ast::Error) -> Error{\n        Error::Parse(err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<hir::Error>>::from":["fn from(err: hir::Error) -> Error{\n        Error::Translate(err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        match *self {\n            Error::Parse(ref x) => x.description(),\n            Error::Translate(ref x) => x.description(),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Error::Parse(ref x) => x.fmt(f),\n            Error::Translate(ref x) => x.fmt(f),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let spans = Spans::from_formatter(self);\n        if self.pattern.contains('\\n') {\n            let divider = repeat_char('~', 79);\n\n            writeln!(f, \"regex parse error:\")?;\n            writeln!(f, \"{}\", divider)?;\n            let notated = spans.notate();\n            write!(f, \"{}\", notated)?;\n            writeln!(f, \"{}\", divider)?;\n            // If we have error spans that cover multiple lines, then we just\n            // note the line numbers.\n            if !spans.multi_line.is_empty() {\n                let mut notes = vec![];\n                for span in &spans.multi_line {\n                    notes.push(format!(\n                        \"on line {} (column {}) through line {} (column {})\",\n                        span.start.line,\n                        span.start.column,\n                        span.end.line,\n                        span.end.column - 1\n                    ));\n                }\n                writeln!(f, \"{}\", notes.join(\"\\n\"))?;\n            }\n            write!(f, \"error: {}\", self.err)?;\n        } else {\n            writeln!(f, \"regex parse error:\")?;\n            let notated = Spans::from_formatter(self).notate();\n            write!(f, \"{}\", notated)?;\n            write!(f, \"error: {}\", self.err)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["fn from(err: &'e ast::Error) -> Self{\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: err.auxiliary_span(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["fn from(err: &'e hir::Error) -> Self{\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: None,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a ClassBytesRange>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["/// Apply simple case folding to this byte range. Only ASCII case mappings\n/// (for a-z) are applied.\n///\n/// Additional ranges are appended to the given vector. Canonical ordering\n/// is *not* maintained in the given vector.\nfn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassBytesRange>,\n    ) -> Result<(), unicode::CaseFoldError>{\n        if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'a');\n            let upper = cmp::min(self.end, b'z');\n            ranges.push(ClassBytesRange::new(lower - 32, upper - 32));\n        }\n        if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'A');\n            let upper = cmp::min(self.end, b'Z');\n            ranges.push(ClassBytesRange::new(lower + 32, upper + 32));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["#[inline]\nfn lower(&self) -> u8{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["#[inline]\nfn set_lower(&mut self, bound: u8){\n        self.start = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["#[inline]\nfn set_upper(&mut self, bound: u8){\n        self.end = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["#[inline]\nfn upper(&self) -> u8{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = f.debug_struct(\"ClassBytesRange\");\n        if self.start <= 0x7F {\n            debug.field(\"start\", &(self.start as char));\n        } else {\n            debug.field(\"start\", &self.start);\n        }\n        if self.end <= 0x7F {\n            debug.field(\"end\", &(self.end as char));\n        } else {\n            debug.field(\"end\", &self.end);\n        }\n        debug.finish()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a ClassUnicodeRange>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["/// Apply simple case folding to this Unicode scalar value range.\n///\n/// Additional ranges are appended to the given vector. Canonical ordering\n/// is *not* maintained in the given vector.\nfn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassUnicodeRange>,\n    ) -> Result<(), unicode::CaseFoldError>{\n        if !unicode::contains_simple_case_mapping(self.start, self.end)? {\n            return Ok(());\n        }\n        let start = self.start as u32;\n        let end = (self.end as u32).saturating_add(1);\n        let mut next_simple_cp = None;\n        for cp in (start..end).filter_map(char::from_u32) {\n            if next_simple_cp.map_or(false, |next| cp < next) {\n                continue;\n            }\n            let it = match unicode::simple_fold(cp)? {\n                Ok(it) => it,\n                Err(next) => {\n                    next_simple_cp = next;\n                    continue;\n                }\n            };\n            for cp_folded in it {\n                ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["#[inline]\nfn lower(&self) -> char{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["#[inline]\nfn set_lower(&mut self, bound: char){\n        self.start = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["#[inline]\nfn set_upper(&mut self, bound: char){\n        self.end = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["#[inline]\nfn upper(&self) -> char{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let start = if !self.start.is_whitespace() && !self.start.is_control()\n        {\n            self.start.to_string()\n        } else {\n            format!(\"0x{:X}\", self.start as u32)\n        };\n        let end = if !self.end.is_whitespace() && !self.end.is_control() {\n            self.end.to_string()\n        } else {\n            format!(\"0x{:X}\", self.end as u32)\n        };\n        f.debug_struct(\"ClassUnicodeRange\")\n            .field(\"start\", &start)\n            .field(\"end\", &end)\n            .finish()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Error as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        self.kind.description()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        ::error::Formatter::from(self).fmt(f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ErrorKind as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        // TODO: Remove this on the next breaking semver release.\n        #[allow(deprecated)]\n        f.write_str(self.description())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Hir as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use hir::print::Printer;\n        Printer::new().print(self, f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Hir as std::ops::Drop>::drop":["fn drop(&mut self){\n        use std::mem;\n\n        match *self.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => return,\n            HirKind::Group(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Repetition(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Concat(ref x) if x.is_empty() => return,\n            HirKind::Alternation(ref x) if x.is_empty() => return,\n            _ => {}\n        }\n\n        let mut stack = vec![mem::replace(self, Hir::empty())];\n        while let Some(mut expr) = stack.pop() {\n            match expr.kind {\n                HirKind::Empty\n                | HirKind::Literal(_)\n                | HirKind::Class(_)\n                | HirKind::Anchor(_)\n                | HirKind::WordBoundary(_) => {}\n                HirKind::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Concat(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n                HirKind::Alternation(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a I>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<hir::literal::Literal as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Literal) -> bool{\n        self.v == other.v\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Literal) -> Option<cmp::Ordering>{\n        self.v.partial_cmp(&other.v)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["fn as_ref(&self) -> &[u8]{\n        &self.v\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.is_cut() {\n            write!(f, \"Cut({})\", escape_unicode(&self.v))\n        } else {\n            write!(f, \"Complete({})\", escape_unicode(&self.v))\n        }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literal as std::ops::Deref>::deref":["fn deref(&self) -> &Vec<u8>{\n        &self.v\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literal as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut Vec<u8>{\n        &mut self.v\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::literal::Literals as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Literals\")\n            .field(\"lits\", &self.lits)\n            .field(\"limit_size\", &self.limit_size)\n            .field(\"limit_class\", &self.limit_class)\n            .finish()\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"<hir::print::PrinterBuilder as std::default::Default>::default":["fn default() -> PrinterBuilder{\n        PrinterBuilder::new()\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":["fn finish(self) -> fmt::Result{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":["fn visit_alternation_in(&mut self) -> fmt::Result{\n        self.wtr.write_str(\"|\")\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":["fn visit_post(&mut self, hir: &Hir) -> fmt::Result{\n        match *hir.kind() {\n            // Handled during visit_pre\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Repetition(ref x) => {\n                match x.kind {\n                    hir::RepetitionKind::ZeroOrOne => {\n                        self.wtr.write_str(\"?\")?;\n                    }\n                    hir::RepetitionKind::ZeroOrMore => {\n                        self.wtr.write_str(\"*\")?;\n                    }\n                    hir::RepetitionKind::OneOrMore => {\n                        self.wtr.write_str(\"+\")?;\n                    }\n                    hir::RepetitionKind::Range(ref x) => match *x {\n                        hir::RepetitionRange::Exactly(m) => {\n                            write!(self.wtr, \"{{{}}}\", m)?;\n                        }\n                        hir::RepetitionRange::AtLeast(m) => {\n                            write!(self.wtr, \"{{{},}}\", m)?;\n                        }\n                        hir::RepetitionRange::Bounded(m, n) => {\n                            write!(self.wtr, \"{{{},{}}}\", m, n)?;\n                        }\n                    },\n                }\n                if !x.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n            }\n            HirKind::Group(_) => {\n                self.wtr.write_str(\")\")?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, hir: &Hir) -> fmt::Result{\n        match *hir.kind() {\n            HirKind::Empty\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Literal(hir::Literal::Unicode(c)) => {\n                self.write_literal_char(c)?;\n            }\n            HirKind::Literal(hir::Literal::Byte(b)) => {\n                self.write_literal_byte(b)?;\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartLine) => {\n                self.wtr.write_str(\"(?m:^)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndLine) => {\n                self.wtr.write_str(\"(?m:$)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartText) => {\n                self.wtr.write_str(r\"\\A\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndText) => {\n                self.wtr.write_str(r\"\\z\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Unicode) => {\n                self.wtr.write_str(r\"\\b\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                self.wtr.write_str(r\"\\B\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Ascii) => {\n                self.wtr.write_str(r\"(?-u:\\b)\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.wtr.write_str(r\"(?-u:\\B)\")?;\n            }\n            HirKind::Group(ref x) => match x.kind {\n                hir::GroupKind::CaptureIndex(_) => {\n                    self.wtr.write_str(\"(\")?;\n                }\n                hir::GroupKind::CaptureName { ref name, .. } => {\n                    write!(self.wtr, \"(?P<{}>\", name)?;\n                }\n                hir::GroupKind::NonCapturing => {\n                    self.wtr.write_str(\"(?:\")?;\n                }\n            },\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["fn default() -> TranslatorBuilder{\n        TranslatorBuilder::new()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["fn finish(self) -> Result<Hir>{\n        // ... otherwise, we should have exactly one HIR on the stack.\n        assert_eq!(self.trans().stack.borrow().len(), 1);\n        Ok(self.pop().unwrap().unwrap_expr())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        use ast::ClassSetBinaryOpKind::*;\n\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.rhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n                lhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.lhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.unicode_fold_and_negate(\n                        &x.span, x.negated, &mut cls,\n                    )?;\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassBytesRange::new(s as u8, e as u8));\n                    }\n                    self.bytes_fold_and_negate(&x.span, x.negated, &mut cls)?;\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x);\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            // This is handled automatically by the visitor.\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Bracketed(_) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            // We needn't handle the Union case here since the visitor will\n            // do it for us.\n            _ => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Empty(_) => {\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Flags(ref x) => {\n                self.set_flags(&x.flags);\n                // Flags in the AST are generally considered directives and\n                // not actual sub-expressions. However, they can be used in\n                // the concrete syntax like `((?i))`, and we need some kind of\n                // indication of an expression there, and Empty is the correct\n                // choice.\n                //\n                // There can also be things like `(?i)+`, but we rule those out\n                // in the parser. In the future, we might allow them for\n                // consistency sake.\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Literal(ref x) => {\n                self.push(HirFrame::Expr(self.hir_literal(x)?));\n            }\n            Ast::Dot(span) => {\n                self.push(HirFrame::Expr(self.hir_dot(span)?));\n            }\n            Ast::Assertion(ref x) => {\n                self.push(HirFrame::Expr(self.hir_assertion(x)?));\n            }\n            Ast::Class(ast::Class::Perl(ref x)) => {\n                if self.flags().unicode() {\n                    let cls = self.hir_perl_unicode_class(x)?;\n                    let hcls = hir::Class::Unicode(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                } else {\n                    let cls = self.hir_perl_byte_class(x);\n                    let hcls = hir::Class::Bytes(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                }\n            }\n            Ast::Class(ast::Class::Unicode(ref x)) => {\n                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);\n                self.push(HirFrame::Expr(Hir::class(cls)));\n            }\n            Ast::Class(ast::Class::Bracketed(ref ast)) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.ranges().is_empty() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n                    let expr = Hir::class(hir::Class::Unicode(cls));\n                    self.push(HirFrame::Expr(expr));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.ranges().is_empty() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n\n                    let expr = Hir::class(hir::Class::Bytes(cls));\n                    self.push(HirFrame::Expr(expr));\n                }\n            }\n            Ast::Repetition(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));\n            }\n            Ast::Group(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                let old_flags = self.pop().unwrap().unwrap_group();\n                self.trans().flags.set(old_flags);\n                self.push(HirFrame::Expr(self.hir_group(x, expr)));\n            }\n            Ast::Concat(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    if !expr.kind().is_empty() {\n                        exprs.push(expr);\n                    }\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::concat(exprs)));\n            }\n            Ast::Alternation(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    exprs.push(expr);\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::alternation(exprs)));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Class(ast::Class::Bracketed(_)) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            Ast::Group(ref x) => {\n                let old_flags = x\n                    .flags()\n                    .map(|ast| self.set_flags(ast))\n                    .unwrap_or_else(|| self.flags());\n                self.push(HirFrame::Group { old_flags });\n            }\n            Ast::Concat(ref x) if x.asts.is_empty() => {}\n            Ast::Concat(_) => {\n                self.push(HirFrame::Concat);\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => {}\n            Ast::Alternation(_) => {\n                self.push(HirFrame::Alternation);\n            }\n            _ => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<u8 as hir::interval::Bound>::as_u32":["fn as_u32(self) -> u32{\n        self as u32\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::decrement":["fn decrement(self) -> Self{\n        self.checked_sub(1).unwrap()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::increment":["fn increment(self) -> Self{\n        self.checked_add(1).unwrap()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::max_value":["fn max_value() -> Self{\n        u8::MAX\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::min_value":["fn min_value() -> Self{\n        u8::MIN\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Unicode-aware case folding is not available \\\n             (probably because the unicode-case feature is not enabled)\"\n        )\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Unicode-aware \\\\w class is not available \\\n             (probably because the unicode-perl feature is not enabled)\"\n        )\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"ScalarRange({:X}, {:X})\", self.start, self.end)\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.start == self.end {\n            write!(f, \"[{:X}]\", self.start)\n        } else {\n            write!(f, \"[{:X}-{:X}]\", self.start, self.end)\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => write!(f, \"{:?}\", r),\n            Two(ref r) => write!(f, \"{:?}{:?}\", r[0], r[1]),\n            Three(ref r) => write!(f, \"{:?}{:?}{:?}\", r[0], r[1], r[2]),\n            Four(ref r) => {\n                write!(f, \"{:?}{:?}{:?}{:?}\", r[0], r[1], r[2], r[3])\n            }\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        'TOP: while let Some(mut r) = self.range_stack.pop() {\n            'INNER: loop {\n                if let Some((r1, r2)) = r.split() {\n                    self.push(r2.start, r2.end);\n                    r.start = r1.start;\n                    r.end = r1.end;\n                    continue 'INNER;\n                }\n                if !r.is_valid() {\n                    continue 'TOP;\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let max = max_scalar_value(i);\n                    if r.start <= max && max < r.end {\n                        self.push(max + 1, r.end);\n                        r.end = max;\n                        continue 'INNER;\n                    }\n                }\n                if let Some(ascii_range) = r.as_ascii() {\n                    return Some(Utf8Sequence::One(ascii_range));\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let m = (1 << (6 * i)) - 1;\n                    if (r.start & !m) != (r.end & !m) {\n                        if (r.start & m) != 0 {\n                            self.push((r.start | m) + 1, r.end);\n                            r.end = r.start | m;\n                            continue 'INNER;\n                        }\n                        if (r.end & m) != m {\n                            self.push(r.end & !m, r.end);\n                            r.end = (r.end & !m) - 1;\n                            continue 'INNER;\n                        }\n                    }\n                }\n                let mut start = [0; MAX_UTF8_BYTES];\n                let mut end = [0; MAX_UTF8_BYTES];\n                let n = r.encode(&mut start, &mut end);\n                return Some(Utf8Sequence::from_encoded_range(\n                    &start[0..n],\n                    &end[0..n],\n                ));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"ast::Alternation":["/// An alternation of regular expressions.\npub struct Alternation {\n    /// The span of this alternation.\n    pub span: Span,\n    /// The alternate regular expressions.\n    pub asts: Vec<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Alternation::into_ast":["/// Return this alternation as an AST.\n///\n/// If this alternation contains zero ASTs, then Ast::Empty is\n/// returned. If this alternation contains exactly 1 AST, then the\n/// corresponding AST is returned. Otherwise, Ast::Alternation is returned.\npub fn into_ast(mut self) -> Ast{\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Alternation(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Assertion":["/// A single zero-width assertion.\npub struct Assertion {\n    /// The span of this assertion.\n    pub span: Span,\n    /// The assertion kind, e.g., `\\b` or `^`.\n    pub kind: AssertionKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::AssertionKind":["/// An assertion kind.\npub enum AssertionKind {\n    /// `^`\n    StartLine,\n    /// `$`\n    EndLine,\n    /// `\\A`\n    StartText,\n    /// `\\z`\n    EndText,\n    /// `\\b`\n    WordBoundary,\n    /// `\\B`\n    NotWordBoundary,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast":["/// An abstract syntax tree for a single regular expression.\n///\n/// An `Ast`'s `fmt::Display` implementation uses constant stack space and heap\n/// space proportional to the size of the `Ast`.\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the `Ast`.\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Span),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(SetFlags),\n    /// A single character literal, which includes escape sequences.\n    Literal(Literal),\n    /// The \"any character\" class.\n    Dot(Span),\n    /// A single zero-width assertion.\n    Assertion(Assertion),\n    /// A single character class. This includes all forms of character classes\n    /// except for `.`. e.g., `\\d`, `\\pN`, `[a-z]` and `[[:alpha:]]`.\n    Class(Class),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Repetition),\n    /// A grouped regular expression.\n    Group(Group),\n    /// An alternation of regular expressions.\n    Alternation(Alternation),\n    /// A concatenation of regular expressions.\n    Concat(Concat),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::has_subexprs":["/// Returns true if and only if this AST has any (including possibly empty)\n/// subexpressions.\nfn has_subexprs(&self) -> bool{\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_) => false,\n            Ast::Class(_)\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => true,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::is_empty":["/// Return true if and only if this Ast is empty.\npub fn is_empty(&self) -> bool{\n        match *self {\n            Ast::Empty(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::span":["/// Return the span of this abstract syntax tree.\npub fn span(&self) -> &Span{\n        match *self {\n            Ast::Empty(ref span) => span,\n            Ast::Flags(ref x) => &x.span,\n            Ast::Literal(ref x) => &x.span,\n            Ast::Dot(ref span) => span,\n            Ast::Assertion(ref x) => &x.span,\n            Ast::Class(ref x) => x.span(),\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::CaptureName":["/// A capture name.\n///\n/// This corresponds to the name itself between the angle brackets in, e.g.,\n/// `(?P<foo>expr)`.\npub struct CaptureName {\n    /// The span of this capture name.\n    pub span: Span,\n    /// The capture name.\n    pub name: String,\n    /// The capture index.\n    pub index: u32,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Class":["/// A single character class expression.\npub enum Class {\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(ClassBracketed),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Class::span":["/// Return the span of this character class.\npub fn span(&self) -> &Span{\n        match *self {\n            Class::Perl(ref x) => &x.span,\n            Class::Unicode(ref x) => &x.span,\n            Class::Bracketed(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAscii":["/// An ASCII character class.\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAsciiKind":["/// The available ASCII character classes.\npub enum ClassAsciiKind {\n    /// `[0-9A-Za-z]`\n    Alnum,\n    /// `[A-Za-z]`\n    Alpha,\n    /// `[\\x00-\\x7F]`\n    Ascii,\n    /// `[ \\t]`\n    Blank,\n    /// `[\\x00-\\x1F\\x7F]`\n    Cntrl,\n    /// `[0-9]`\n    Digit,\n    /// `[!-~]`\n    Graph,\n    /// `[a-z]`\n    Lower,\n    /// `[ -~]`\n    Print,\n    /// `[!-/:-@\\[-`{-~]`\n    Punct,\n    /// `[\\t\\n\\v\\f\\r ]`\n    Space,\n    /// `[A-Z]`\n    Upper,\n    /// `[0-9A-Za-z_]`\n    Word,\n    /// `[0-9A-Fa-f]`\n    Xdigit,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAsciiKind::from_name":["/// Return the corresponding ClassAsciiKind variant for the given name.\n///\n/// The name given should correspond to the lowercase version of the\n/// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.\n///\n/// If no variant with the corresponding name exists, then `None` is\n/// returned.\npub fn from_name(name: &str) -> Option<ClassAsciiKind>{\n        use self::ClassAsciiKind::*;\n        match name {\n            \"alnum\" => Some(Alnum),\n            \"alpha\" => Some(Alpha),\n            \"ascii\" => Some(Ascii),\n            \"blank\" => Some(Blank),\n            \"cntrl\" => Some(Cntrl),\n            \"digit\" => Some(Digit),\n            \"graph\" => Some(Graph),\n            \"lower\" => Some(Lower),\n            \"print\" => Some(Print),\n            \"punct\" => Some(Punct),\n            \"space\" => Some(Space),\n            \"upper\" => Some(Upper),\n            \"word\" => Some(Word),\n            \"xdigit\" => Some(Xdigit),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassBracketed":["/// A bracketed character class, e.g., `[a-z0-9]`.\npub struct ClassBracketed {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not. e.g., `[a]` is not negated but\n    /// `[^a]` is.\n    pub negated: bool,\n    /// The type of this set. A set is either a normal union of things, e.g.,\n    /// `[abc]` or a result of applying set operations, e.g., `[\\pL--c]`.\n    pub kind: ClassSet,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassPerl":["/// A Perl character class.\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassPerlKind":["/// The available Perl character classes.\npub enum ClassPerlKind {\n    /// Decimal numbers.\n    Digit,\n    /// Whitespace.\n    Space,\n    /// Word characters.\n    Word,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet":["/// A character class set.\n///\n/// This type corresponds to the internal structure of a bracketed character\n/// class. That is, every bracketed character is one of two types: a union of\n/// items (literals, ranges, other bracketed classes) or a tree of binary set\n/// operations.\npub enum ClassSet {\n    /// An item, which can be a single literal, range, nested character class\n    /// or a union of items.\n    Item(ClassSetItem),\n    /// A single binary operation (i.e., &&, -- or ~~).\n    BinaryOp(ClassSetBinaryOp),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::is_empty":["/// Return true if and only if this class set is empty.\nfn is_empty(&self) -> bool{\n        match *self {\n            ClassSet::Item(ClassSetItem::Empty(_)) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::span":["/// Return the span of this character class set.\npub fn span(&self) -> &Span{\n        match *self {\n            ClassSet::Item(ref x) => x.span(),\n            ClassSet::BinaryOp(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::union":["/// Build a set from a union.\npub fn union(ast: ClassSetUnion) -> ClassSet{\n        ClassSet::Item(ClassSetItem::Union(ast))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetBinaryOp":["/// A Unicode character class set operation.\npub struct ClassSetBinaryOp {\n    /// The span of this operation. e.g., the `a-z--[h-p]` in `[a-z--h-p]`.\n    pub span: Span,\n    /// The type of this set operation.\n    pub kind: ClassSetBinaryOpKind,\n    /// The left hand side of the operation.\n    pub lhs: Box<ClassSet>,\n    /// The right hand side of the operation.\n    pub rhs: Box<ClassSet>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetBinaryOpKind":["/// The type of a Unicode character class set operation.\n///\n/// Note that this doesn't explicitly represent union since there is no\n/// explicit union operator. Concatenation inside a character class corresponds\n/// to the union operation.\npub enum ClassSetBinaryOpKind {\n    /// The intersection of two sets, e.g., `\\pN&&[a-z]`.\n    Intersection,\n    /// The difference of two sets, e.g., `\\pN--[0-9]`.\n    Difference,\n    /// The symmetric difference of two sets. The symmetric difference is the\n    /// set of elements belonging to one but not both sets.\n    /// e.g., `[\\pL~~[:ascii:]]`.\n    SymmetricDifference,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetItem":["/// A single component of a character class set.\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetItem::span":["/// Return the span of this character class set item.\npub fn span(&self) -> &Span{\n        match *self {\n            ClassSetItem::Empty(ref span) => span,\n            ClassSetItem::Literal(ref x) => &x.span,\n            ClassSetItem::Range(ref x) => &x.span,\n            ClassSetItem::Ascii(ref x) => &x.span,\n            ClassSetItem::Perl(ref x) => &x.span,\n            ClassSetItem::Unicode(ref x) => &x.span,\n            ClassSetItem::Bracketed(ref x) => &x.span,\n            ClassSetItem::Union(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetRange":["/// A single character class range in a set.\npub struct ClassSetRange {\n    /// The span of this range.\n    pub span: Span,\n    /// The start of this range.\n    pub start: Literal,\n    /// The end of this range.\n    pub end: Literal,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetRange::is_valid":["/// Returns true if and only if this character class range is valid.\n///\n/// The only case where a range is invalid is if its start is greater than\n/// its end.\npub fn is_valid(&self) -> bool{\n        self.start.c <= self.end.c\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion":["/// A union of items inside a character class set.\npub struct ClassSetUnion {\n    /// The span of the items in this operation. e.g., the `a-z0-9` in\n    /// `[^a-z0-9]`\n    pub span: Span,\n    /// The sequence of items that make up this union.\n    pub items: Vec<ClassSetItem>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion::into_item":["/// Return this union as a character class set item.\n///\n/// If this union contains zero items, then an empty union is\n/// returned. If this concatenation contains exactly 1 item, then the\n/// corresponding item is returned. Otherwise, ClassSetItem::Union is\n/// returned.\npub fn into_item(mut self) -> ClassSetItem{\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion::push":["/// Push a new item in this union.\n///\n/// The ending position of this union's span is updated to the ending\n/// position of the span of the item given. If the union is empty, then\n/// the starting position of this union is set to the starting position\n/// of this item.\n///\n/// In other words, if you only use this method to add items to a union\n/// and you set the spans on each item correctly, then you should never\n/// need to adjust the span of the union directly.\npub fn push(&mut self, item: ClassSetItem){\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicode":["/// A Unicode character class.\npub struct ClassUnicode {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not.\n    ///\n    /// Note: be careful when using this attribute. This specifically refers\n    /// to whether the class is written as `\\p` or `\\P`, where the latter\n    /// is `negated = true`. However, it also possible to write something like\n    /// `\\P{scx!=Katakana}` which is actually equivalent to\n    /// `\\p{scx=Katakana}` and is therefore not actually negated even though\n    /// `negated = true` here. To test whether this class is truly negated\n    /// or not, use the `is_negated` method.\n    pub negated: bool,\n    /// The kind of Unicode class.\n    pub kind: ClassUnicodeKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicode::is_negated":["/// Returns true if this class has been negated.\n///\n/// Note that this takes the Unicode op into account, if it's present.\n/// e.g., `is_negated` for `\\P{scx!=Katakana}` will return `false`.\npub fn is_negated(&self) -> bool{\n        match self.kind {\n            ClassUnicodeKind::NamedValue {\n                op: ClassUnicodeOpKind::NotEqual,\n                ..\n            } => !self.negated,\n            _ => self.negated,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeKind":["/// The available forms of Unicode character classes.\npub enum ClassUnicodeKind {\n    /// A one letter abbreviated class, e.g., `\\pN`.\n    OneLetter(char),\n    /// A binary property, general category or script. The string may be\n    /// empty.\n    Named(String),\n    /// A property name and an associated value.\n    NamedValue {\n        /// The type of Unicode op used to associate `name` with `value`.\n        op: ClassUnicodeOpKind,\n        /// The property name (which may be empty).\n        name: String,\n        /// The property value (which may be empty).\n        value: String,\n    },\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeOpKind":["/// The type of op used in a Unicode character class.\npub enum ClassUnicodeOpKind {\n    /// A property set to a specific value, e.g., `\\p{scx=Katakana}`.\n    Equal,\n    /// A property set to a specific value using a colon, e.g.,\n    /// `\\p{scx:Katakana}`.\n    Colon,\n    /// A property that isn't a particular value, e.g., `\\p{scx!=Katakana}`.\n    NotEqual,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeOpKind::is_equal":["/// Whether the op is an equality op or not.\npub fn is_equal(&self) -> bool{\n        match *self {\n            ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Comment":["/// A comment from a regular expression with an associated span.\n///\n/// A regular expression can only contain comments when the `x` flag is\n/// enabled.\npub struct Comment {\n    /// The span of this comment, including the beginning `#` and ending `\\n`.\n    pub span: Span,\n    /// The comment text, starting with the first character following the `#`\n    /// and ending with the last character preceding the `\\n`.\n    pub comment: String,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Concat":["/// A concatenation of regular expressions.\npub struct Concat {\n    /// The span of this concatenation.\n    pub span: Span,\n    /// The concatenation regular expressions.\n    pub asts: Vec<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Concat::into_ast":["/// Return this concatenation as an AST.\n///\n/// If this concatenation contains zero ASTs, then Ast::Empty is\n/// returned. If this concatenation contains exactly 1 AST, then the\n/// corresponding AST is returned. Otherwise, Ast::Concat is returned.\npub fn into_ast(mut self) -> Ast{\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Concat(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error":["/// An error that occurred while parsing a regular expression into an abstract\n/// syntax tree.\n///\n/// Note that note all ASTs represents a valid regular expression. For example,\n/// an AST is constructed without error for `\\p{Quux}`, but `Quux` is not a\n/// valid Unicode property name. That particular error is reported when\n/// translating an AST to the high-level intermediate representation (`HIR`).\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::auxiliary_span":["/// Return an auxiliary span. This span exists only for some errors that\n/// benefit from being able to point to two locations in the original\n/// regular expression. For example, \"duplicate\" errors will have the\n/// main error position set to the duplicate occurrence while its\n/// auxiliary span will be set to the initial occurrence.\npub fn auxiliary_span(&self) -> Option<&Span>{\n        use self::ErrorKind::*;\n        match self.kind {\n            FlagDuplicate { ref original } => Some(original),\n            FlagRepeatedNegation { ref original, .. } => Some(original),\n            GroupNameDuplicate { ref original, .. } => Some(original),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::kind":["/// Return the type of this error.\npub fn kind(&self) -> &ErrorKind{\n        &self.kind\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::pattern":["/// The original pattern string in which this error occurred.\n///\n/// Every span reported by this error is reported in terms of this string.\npub fn pattern(&self) -> &str{\n        &self.pattern\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::span":["/// Return the span at which this error occurred.\npub fn span(&self) -> &Span{\n        &self.span\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ErrorKind":["/// The type of an error that occurred while building an AST.\npub enum ErrorKind {\n    /// The capturing group limit was exceeded.\n    ///\n    /// Note that this represents a limit on the total number of capturing\n    /// groups in a regex and not necessarily the number of nested capturing\n    /// groups. That is, the nest limit can be low and it is still possible for\n    /// this error to occur.\n    CaptureLimitExceeded,\n    /// An invalid escape sequence was found in a character class set.\n    ClassEscapeInvalid,\n    /// An invalid character class range was found. An invalid range is any\n    /// range where the start is greater than the end.\n    ClassRangeInvalid,\n    /// An invalid range boundary was found in a character class. Range\n    /// boundaries must be a single literal codepoint, but this error indicates\n    /// that something else was found, such as a nested class.\n    ClassRangeLiteral,\n    /// An opening `[` was found with no corresponding closing `]`.\n    ClassUnclosed,\n    /// Note that this error variant is no longer used. Namely, a decimal\n    /// number can only appear as a repetition quantifier. When the number\n    /// in a repetition quantifier is empty, then it gets its own specialized\n    /// error, `RepetitionCountDecimalEmpty`.\n    DecimalEmpty,\n    /// An invalid decimal number was given where one was expected.\n    DecimalInvalid,\n    /// A bracketed hex literal was empty.\n    EscapeHexEmpty,\n    /// A bracketed hex literal did not correspond to a Unicode scalar value.\n    EscapeHexInvalid,\n    /// An invalid hexadecimal digit was found.\n    EscapeHexInvalidDigit,\n    /// EOF was found before an escape sequence was completed.\n    EscapeUnexpectedEof,\n    /// An unrecognized escape sequence.\n    EscapeUnrecognized,\n    /// A dangling negation was used when setting flags, e.g., `i-`.\n    FlagDanglingNegation,\n    /// A flag was used twice, e.g., `i-i`.\n    FlagDuplicate {\n        /// The position of the original flag. The error position\n        /// points to the duplicate flag.\n        original: Span,\n    },\n    /// The negation operator was used twice, e.g., `-i-s`.\n    FlagRepeatedNegation {\n        /// The position of the original negation operator. The error position\n        /// points to the duplicate negation operator.\n        original: Span,\n    },\n    /// Expected a flag but got EOF, e.g., `(?`.\n    FlagUnexpectedEof,\n    /// Unrecognized flag, e.g., `a`.\n    FlagUnrecognized,\n    /// A duplicate capture name was found.\n    GroupNameDuplicate {\n        /// The position of the initial occurrence of the capture name. The\n        /// error position itself points to the duplicate occurrence.\n        original: Span,\n    },\n    /// A capture group name is empty, e.g., `(?P<>abc)`.\n    GroupNameEmpty,\n    /// An invalid character was seen for a capture group name. This includes\n    /// errors where the first character is a digit (even though subsequent\n    /// characters are allowed to be digits).\n    GroupNameInvalid,\n    /// A closing `>` could not be found for a capture group name.\n    GroupNameUnexpectedEof,\n    /// An unclosed group, e.g., `(ab`.\n    ///\n    /// The span of this error corresponds to the unclosed parenthesis.\n    GroupUnclosed,\n    /// An unopened group, e.g., `ab)`.\n    GroupUnopened,\n    /// The nest limit was exceeded. The limit stored here is the limit\n    /// configured in the parser.\n    NestLimitExceeded(u32),\n    /// The range provided in a counted repetition operator is invalid. The\n    /// range is invalid if the start is greater than the end.\n    RepetitionCountInvalid,\n    /// An opening `{` was not followed by a valid decimal value.\n    /// For example, `x{}` or `x{]}` would fail.\n    RepetitionCountDecimalEmpty,\n    /// An opening `{` was found with no corresponding closing `}`.\n    RepetitionCountUnclosed,\n    /// A repetition operator was applied to a missing sub-expression. This\n    /// occurs, for example, in the regex consisting of just a `*` or even\n    /// `(?i)*`. It is, however, possible to create a repetition operating on\n    /// an empty sub-expression. For example, `()*` is still considered valid.\n    RepetitionMissing,\n    /// The Unicode class is not valid. This typically occurs when a `\\p` is\n    /// followed by something other than a `{`.\n    UnicodeClassInvalid,\n    /// When octal support is disabled, this error is produced when an octal\n    /// escape is used. The octal escape is assumed to be an invocation of\n    /// a backreference, which is the common case.\n    UnsupportedBackreference,\n    /// When syntax similar to PCRE's look-around is used, this error is\n    /// returned. Some example syntaxes that are rejected include, but are\n    /// not necessarily limited to, `(?=re)`, `(?!re)`, `(?<=re)` and\n    /// `(?<!re)`. Note that all of these syntaxes are otherwise invalid; this\n    /// error is used to improve the user experience.\n    UnsupportedLookAround,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flag":["/// A single flag.\npub enum Flag {\n    /// `i`\n    CaseInsensitive,\n    /// `m`\n    MultiLine,\n    /// `s`\n    DotMatchesNewLine,\n    /// `U`\n    SwapGreed,\n    /// `u`\n    Unicode,\n    /// `x`\n    IgnoreWhitespace,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags":["/// A group of flags.\n///\n/// This corresponds only to the sequence of flags themselves, e.g., `is-u`.\npub struct Flags {\n    /// The span of this group of flags.\n    pub span: Span,\n    /// A sequence of flag items. Each item is either a flag or a negation\n    /// operator.\n    pub items: Vec<FlagsItem>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags::add_item":["/// Add the given item to this sequence of flags.\n///\n/// If the item was added successfully, then `None` is returned. If the\n/// given item is a duplicate, then `Some(i)` is returned, where\n/// `items[i].kind == item.kind`.\npub fn add_item(&mut self, item: FlagsItem) -> Option<usize>{\n        for (i, x) in self.items.iter().enumerate() {\n            if x.kind == item.kind {\n                return Some(i);\n            }\n        }\n        self.items.push(item);\n        None\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags::flag_state":["/// Returns the state of the given flag in this set.\n///\n/// If the given flag is in the set but is negated, then `Some(false)` is\n/// returned.\n///\n/// If the given flag is in the set and is not negated, then `Some(true)`\n/// is returned.\n///\n/// Otherwise, `None` is returned.\npub fn flag_state(&self, flag: Flag) -> Option<bool>{\n        let mut negated = false;\n        for x in &self.items {\n            match x.kind {\n                FlagsItemKind::Negation => {\n                    negated = true;\n                }\n                FlagsItemKind::Flag(ref xflag) if xflag == &flag => {\n                    return Some(!negated);\n                }\n                _ => {}\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItem":["/// A single item in a group of flags.\npub struct FlagsItem {\n    /// The span of this item.\n    pub span: Span,\n    /// The kind of this item.\n    pub kind: FlagsItemKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItemKind":["/// The kind of an item in a group of flags.\npub enum FlagsItemKind {\n    /// A negation operator applied to all subsequent flags in the enclosing\n    /// group.\n    Negation,\n    /// A single flag in a group.\n    Flag(Flag),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItemKind::is_negation":["/// Returns true if and only if this item is a negation operator.\npub fn is_negation(&self) -> bool{\n        match *self {\n            FlagsItemKind::Negation => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group":["/// A grouped regular expression.\n///\n/// This includes both capturing and non-capturing groups. This does **not**\n/// include flag-only groups like `(?is)`, but does contain any group that\n/// contains a sub-expression, e.g., `(a)`, `(?P<name>a)`, `(?:a)` and\n/// `(?is:a)`.\npub struct Group {\n    /// The span of this group.\n    pub span: Span,\n    /// The kind of this group.\n    pub kind: GroupKind,\n    /// The regular expression in this group.\n    pub ast: Box<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::capture_index":["/// Returns the capture index of this group, if this is a capturing group.\n///\n/// This returns a capture index precisely when `is_capturing` is `true`.\npub fn capture_index(&self) -> Option<u32>{\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName(ref x) => Some(x.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::flags":["/// If this group is non-capturing, then this returns the (possibly empty)\n/// set of flags. Otherwise, `None` is returned.\npub fn flags(&self) -> Option<&Flags>{\n        match self.kind {\n            GroupKind::NonCapturing(ref flags) => Some(flags),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::is_capturing":["/// Returns true if and only if this group is capturing.\npub fn is_capturing(&self) -> bool{\n        match self.kind {\n            GroupKind::CaptureIndex(_) | GroupKind::CaptureName(_) => true,\n            GroupKind::NonCapturing(_) => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::GroupKind":["/// The kind of a group.\npub enum GroupKind {\n    /// `(a)`\n    CaptureIndex(u32),\n    /// `(?P<name>a)`\n    CaptureName(CaptureName),\n    /// `(?:a)` and `(?i:a)`\n    NonCapturing(Flags),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::HexLiteralKind":["/// The type of a Unicode hex literal.\n///\n/// Note that all variants behave the same when used with brackets. They only\n/// differ when used without brackets in the number of hex digits that must\n/// follow.\npub enum HexLiteralKind {\n    /// A `\\x` prefix. When used without brackets, this form is limited to\n    /// two digits.\n    X,\n    /// A `\\u` prefix. When used without brackets, this form is limited to\n    /// four digits.\n    UnicodeShort,\n    /// A `\\U` prefix. When used without brackets, this form is limited to\n    /// eight digits.\n    UnicodeLong,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::HexLiteralKind::digits":["/// The number of digits that must be used with this literal form when\n/// used without brackets. When used with brackets, there is no\n/// restriction on the number of digits.\npub fn digits(&self) -> u32{\n        match *self {\n            HexLiteralKind::X => 2,\n            HexLiteralKind::UnicodeShort => 4,\n            HexLiteralKind::UnicodeLong => 8,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Literal":["/// A single literal expression.\n///\n/// A literal corresponds to a single Unicode scalar value. Literals may be\n/// represented in their literal form, e.g., `a` or in their escaped form,\n/// e.g., `\\x61`.\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Literal::byte":["/// If this literal was written as a `\\x` hex escape, then this returns\n/// the corresponding byte value. Otherwise, this returns `None`.\npub fn byte(&self) -> Option<u8>{\n        let short_hex = LiteralKind::HexFixed(HexLiteralKind::X);\n        if self.c as u32 <= 255 && self.kind == short_hex {\n            Some(self.c as u8)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::LiteralKind":["/// The kind of a single literal expression.\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or ``.\n    Verbatim,\n    /// The literal is written as an escape because it is punctuation, e.g.,\n    /// `\\*` or `\\[`.\n    Punctuation,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Position":["/// A single position in a regular expression.\n///\n/// A position encodes one half of a span, and include the byte offset, line\n/// number and column number.\npub struct Position {\n    /// The absolute offset of this position, starting at `0` from the\n    /// beginning of the regular expression pattern string.\n    pub offset: usize,\n    /// The line number, starting at `1`.\n    pub line: usize,\n    /// The approximate column number, starting at `1`.\n    pub column: usize,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Position::new":["/// Create a new position with the given information.\n///\n/// `offset` is the absolute offset of the position, starting at `0` from\n/// the beginning of the regular expression pattern string.\n///\n/// `line` is the line number, starting at `1`.\n///\n/// `column` is the approximate column number, starting at `1`.\npub fn new(offset: usize, line: usize, column: usize) -> Position{\n        Position { offset: offset, line: line, column: column }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Repetition":["/// A repetition operation applied to a regular expression.\npub struct Repetition {\n    /// The span of this operation.\n    pub span: Span,\n    /// The actual operation.\n    pub op: RepetitionOp,\n    /// Whether this operation was applied greedily or not.\n    pub greedy: bool,\n    /// The regular expression under repetition.\n    pub ast: Box<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionKind":["/// The kind of a repetition operator.\npub enum RepetitionKind {\n    /// `?`\n    ZeroOrOne,\n    /// `*`\n    ZeroOrMore,\n    /// `+`\n    OneOrMore,\n    /// `{m,n}`\n    Range(RepetitionRange),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionOp":["/// The repetition operator itself.\npub struct RepetitionOp {\n    /// The span of this operator. This includes things like `+`, `*?` and\n    /// `{m,n}`.\n    pub span: Span,\n    /// The type of operation.\n    pub kind: RepetitionKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionRange":["/// A range repetition operator.\npub enum RepetitionRange {\n    /// `{m}`\n    Exactly(u32),\n    /// `{m,}`\n    AtLeast(u32),\n    /// `{m,n}`\n    Bounded(u32, u32),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionRange::is_valid":["/// Returns true if and only if this repetition range is valid.\n///\n/// The only case where a repetition range is invalid is if it is bounded\n/// and its start is greater than its end.\npub fn is_valid(&self) -> bool{\n        match *self {\n            RepetitionRange::Bounded(s, e) if s > e => false,\n            _ => true,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::SetFlags":["/// A group of flags that is not applied to a particular regular expression.\npub struct SetFlags {\n    /// The span of these flags, including the grouping parentheses.\n    pub span: Span,\n    /// The actual sequence of flags.\n    pub flags: Flags,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span":["/// Span represents the position information of a single AST item.\n///\n/// All span positions are absolute byte offsets that can be used on the\n/// original regular expression that was parsed.\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::is_empty":["/// Returns true if and only if this span is empty. That is, it points to\n/// a single position in the concrete syntax of a regular expression.\npub fn is_empty(&self) -> bool{\n        self.start.offset == self.end.offset\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::is_one_line":["/// Returns true if and only if this span occurs on a single line.\npub fn is_one_line(&self) -> bool{\n        self.start.line == self.end.line\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::new":["/// Create a new span with the given positions.\npub fn new(start: Position, end: Position) -> Span{\n        Span { start: start, end: end }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::splat":["/// Create a new span using the given position as the start and end.\npub fn splat(pos: Position) -> Span{\n        Span::new(pos, pos)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::with_end":["/// Create a new span by replacing the ending the position with the one\n/// given.\npub fn with_end(self, pos: Position) -> Span{\n        Span { end: pos, ..self }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::with_start":["/// Create a new span by replacing the starting the position with the one\n/// given.\npub fn with_start(self, pos: Position) -> Span{\n        Span { start: pos, ..self }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::SpecialLiteralKind":["/// The type of a special literal.\n///\n/// A special literal is a special escape sequence recognized by the regex\n/// parser, e.g., `\\f` or `\\n`.\npub enum SpecialLiteralKind {\n    /// Bell, spelled `\\a` (`\\x07`).\n    Bell,\n    /// Form feed, spelled `\\f` (`\\x0C`).\n    FormFeed,\n    /// Tab, spelled `\\t` (`\\x09`).\n    Tab,\n    /// Line feed, spelled `\\n` (`\\x0A`).\n    LineFeed,\n    /// Carriage return, spelled `\\r` (`\\x0D`).\n    CarriageReturn,\n    /// Vertical tab, spelled `\\v` (`\\x0B`).\n    VerticalTab,\n    /// Space, spelled `\\ ` (`\\x20`). Note that this can only appear when\n    /// parsing in verbose mode.\n    Space,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::WithComments":["/// An abstract syntax tree for a singular expression along with comments\n/// found.\n///\n/// Comments are not stored in the tree itself to avoid complexity. Each\n/// comment contains a span of precisely where it occurred in the original\n/// regular expression.\npub struct WithComments {\n    /// The actual ast.\n    pub ast: Ast,\n    /// All comments found in the original regular expression.\n    pub comments: Vec<Comment>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::parse::ClassState":["/// ClassState represents a single stack frame while parsing character classes.\n/// Each frame records the state up to an intersection, difference, symmetric\n/// difference or nested class.\n///\n/// Note that a parser's character class stack is only non-empty when parsing\n/// a character class. In all other cases, it is empty.\nenum ClassState {\n    /// This state is pushed whenever an opening bracket is found.\n    Open {\n        /// The union of class items immediately preceding this class.\n        union: ast::ClassSetUnion,\n        /// The class that has been opened. Typically this just corresponds\n        /// to the `[`, but it can also include `[^` since `^` indicates\n        /// negation of the class.\n        set: ast::ClassBracketed,\n    },\n    /// This state is pushed when a operator is seen. When popped, the stored\n    /// set becomes the left hand side of the operator.\n    Op {\n        /// The type of the operation, i.e., &&, -- or ~~.\n        kind: ast::ClassSetBinaryOpKind,\n        /// The left-hand side of the operator.\n        lhs: ast::ClassSet,\n    },\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::GroupState":["/// GroupState represents a single stack frame while parsing nested groups\n/// and alternations. Each frame records the state up to an opening parenthesis\n/// or a alternating bracket `|`.\nenum GroupState {\n    /// This state is pushed whenever an opening group is found.\n    Group {\n        /// The concatenation immediately preceding the opening group.\n        concat: ast::Concat,\n        /// The group that has been opened. Its sub-AST is always empty.\n        group: ast::Group,\n        /// Whether this group has the `x` flag enabled or not.\n        ignore_whitespace: bool,\n    },\n    /// This state is pushed whenever a new alternation branch is found. If\n    /// an alternation branch is found and this state is at the top of the\n    /// stack, then this state should be modified to include the new\n    /// alternation.\n    Alternation(ast::Alternation),\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter":["/// A type that traverses a fully parsed Ast and checks whether its depth\n/// exceeds the specified nesting limit. If it does, then an error is returned.\nstruct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n    /// The parser that is checking the nest limit.\n    p: &'p ParserI<'s, P>,\n    /// The current depth while walking an Ast.\n    depth: u32,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::check":["#[inline(never)]\nfn check(self, ast: &Ast) -> Result<()>{\n        ast::visit(ast, self)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["fn decrement_depth(&mut self){\n        // Assuming the correctness of the visitor, this should never drop\n        // below 0.\n        self.depth = self.depth.checked_sub(1).unwrap();\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["fn increment_depth(&mut self, span: &Span) -> Result<()>{\n        let new = self.depth.checked_add(1).ok_or_else(|| {\n            self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(::std::u32::MAX),\n            )\n        })?;\n        let limit = self.p.parser().nest_limit;\n        if new > limit {\n            return Err(self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(limit),\n            ));\n        }\n        self.depth = new;\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::new":["fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P>{\n        NestLimiter { p: p, depth: 0 }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser":["/// A regular expression parser.\n///\n/// This parses a string representation of a regular expression into an\n/// abstract syntax tree. The size of the tree is proportional to the length\n/// of the regular expression pattern.\n///\n/// A `Parser` can be configured in more detail via a\n/// [`ParserBuilder`](struct.ParserBuilder.html).\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// Th`ParserBuilder`. is is used when reseting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::new":["/// Create a new parser with a default configuration.\n///\n/// The parser can be run with either the `parse` or `parse_with_comments`\n/// methods. The parse methods return an abstract syntax tree.\n///\n/// To set configuration options on the parser, use\n/// [`ParserBuilder`](struct.ParserBuilder.html).\npub fn new() -> Parser{\n        ParserBuilder::new().build()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::parse":["/// Parse the regular expression into an abstract syntax tree.\npub fn parse(&mut self, pattern: &str) -> Result<Ast>{\n        ParserI::new(self, pattern).parse()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::parse_with_comments":["/// Parse the regular expression and return an abstract syntax tree with\n/// all of the comments found in the pattern.\npub fn parse_with_comments(\n        &mut self,\n        pattern: &str,\n    ) -> Result<ast::WithComments>{\n        ParserI::new(self, pattern).parse_with_comments()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::reset":["/// Reset the internal state of a parser.\n///\n/// This is called at the beginning of every parse. This prevents the\n/// parser from running with inconsistent state (say, if a previous\n/// invocation returned an error and the parser is reused).\nfn reset(&self){\n        // These settings should be in line with the construction\n        // in `ParserBuilder::build`.\n        self.pos.set(Position { offset: 0, line: 1, column: 1 });\n        self.ignore_whitespace.set(self.initial_ignore_whitespace);\n        self.comments.borrow_mut().clear();\n        self.stack_group.borrow_mut().clear();\n        self.stack_class.borrow_mut().clear();\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder":["/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\npub struct ParserBuilder {\n    ignore_whitespace: bool,\n    nest_limit: u32,\n    octal: bool,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::build":["/// Build a parser from this configuration with the given pattern.\npub fn build(&self) -> Parser{\n        Parser {\n            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),\n            capture_index: Cell::new(0),\n            nest_limit: self.nest_limit,\n            octal: self.octal,\n            initial_ignore_whitespace: self.ignore_whitespace,\n            ignore_whitespace: Cell::new(self.ignore_whitespace),\n            comments: RefCell::new(vec![]),\n            stack_group: RefCell::new(vec![]),\n            stack_class: RefCell::new(vec![]),\n            capture_names: RefCell::new(vec![]),\n            scratch: RefCell::new(String::new()),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::ignore_whitespace":["/// Enable verbose mode in the regular expression.\n///\n/// When enabled, verbose mode permits insigificant whitespace in many\n/// places in the regular expression, as well as comments. Comments are\n/// started using `#` and continue until the end of the line.\n///\n/// By default, this is disabled. It may be selectively enabled in the\n/// regular expression by using the `x` flag regardless of this setting.\npub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ignore_whitespace = yes;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// lenth of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder{\n        self.nest_limit = limit;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::new":["/// Create a new parser builder with a default configuration.\npub fn new() -> ParserBuilder{\n        ParserBuilder {\n            ignore_whitespace: false,\n            nest_limit: 250,\n            octal: false,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.octal = yes;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI":["/// ParserI is the internal parser implementation.\n///\n/// We use this separate type so that we can carry the provided pattern string\n/// along with us. In particular, a `Parser` internal state is not tied to any\n/// one pattern, but `ParserI` is.\n///\n/// This type also lets us use `ParserI<&Parser>` in production code while\n/// retaining the convenience of `ParserI<Parser>` for tests, which sometimes\n/// work against the internal interface of the parser.\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::add_capture_name":["/// Adds the given capture name to this parser. If this capture name has\n/// already been used, then an error is returned.\nfn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()>{\n        let mut names = self.parser().capture_names.borrow_mut();\n        match names\n            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())\n        {\n            Err(i) => {\n                names.insert(i, cap.clone());\n                Ok(())\n            }\n            Ok(i) => Err(self.error(\n                cap.span,\n                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },\n            )),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump":["/// Bump the parser to the next Unicode scalar value.\n///\n/// If the end of the input has been reached, then `false` is returned.\nfn bump(&self) -> bool{\n        if self.is_eof() {\n            return false;\n        }\n        let Position { mut offset, mut line, mut column } = self.pos();\n        if self.char() == '\\n' {\n            line = line.checked_add(1).unwrap();\n            column = 1;\n        } else {\n            column = column.checked_add(1).unwrap();\n        }\n        offset += self.char().len_utf8();\n        self.parser().pos.set(Position {\n            offset: offset,\n            line: line,\n            column: column,\n        });\n        self.pattern()[self.offset()..].chars().next().is_some()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["/// Bump the parser, and if the `x` flag is enabled, bump through any\n/// subsequent spaces. Return true if and only if the parser is not at\n/// EOF.\nfn bump_and_bump_space(&self) -> bool{\n        if !self.bump() {\n            return false;\n        }\n        self.bump_space();\n        !self.is_eof()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_if":["/// If the substring starting at the current position of the parser has\n/// the given prefix, then bump the parser to the character immediately\n/// following the prefix and return true. Otherwise, don't bump the parser\n/// and return false.\nfn bump_if(&self, prefix: &str) -> bool{\n        if self.pattern()[self.offset()..].starts_with(prefix) {\n            for _ in 0..prefix.chars().count() {\n                self.bump();\n            }\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_space":["/// If the `x` flag is enabled (i.e., whitespace insensitivity with\n/// comments), then this will advance the parser through all whitespace\n/// and comments to the next non-whitespace non-comment byte.\n///\n/// If the `x` flag is disabled, then this is a no-op.\n///\n/// This should be used selectively throughout the parser where\n/// arbitrary whitespace is permitted when the `x` flag is enabled. For\n/// example, `{   5  , 6}` is equivalent to `{5,6}`.\nfn bump_space(&self){\n        if !self.ignore_whitespace() {\n            return;\n        }\n        while !self.is_eof() {\n            if self.char().is_whitespace() {\n                self.bump();\n            } else if self.char() == '#' {\n                let start = self.pos();\n                let mut comment_text = String::new();\n                self.bump();\n                while !self.is_eof() {\n                    let c = self.char();\n                    self.bump();\n                    if c == '\\n' {\n                        break;\n                    }\n                    comment_text.push(c);\n                }\n                let comment = ast::Comment {\n                    span: Span::new(start, self.pos()),\n                    comment: comment_text,\n                };\n                self.parser().comments.borrow_mut().push(comment);\n            } else {\n                break;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::char":["/// Return the character at the current position of the parser.\n///\n/// This panics if the current position does not point to a valid char.\nfn char(&self) -> char{\n        self.char_at(self.offset())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::char_at":["/// Return the character at the given position.\n///\n/// This panics if the given position does not point to a valid char.\nfn char_at(&self, i: usize) -> char{\n        self.pattern()[i..]\n            .chars()\n            .next()\n            .unwrap_or_else(|| panic!(\"expected char at offset {}\", i))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::column":["/// Return the current column of the parser.\n///\n/// The column number starts at `1` and is reset whenever a `\\n` is seen.\nfn column(&self) -> usize{\n        self.parser().pos.get().column\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::error":["/// Create a new error with the given span and error type.\nfn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error{\n        ast::Error {\n            kind: kind,\n            pattern: self.pattern().to_string(),\n            span: span,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["/// Return whether the parser should ignore whitespace or not.\nfn ignore_whitespace(&self) -> bool{\n        self.parser().ignore_whitespace.get()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::is_eof":["/// Returns true if the next call to `bump` would return false.\nfn is_eof(&self) -> bool{\n        self.offset() == self.pattern().len()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["/// Returns true if and only if the parser is positioned at a look-around\n/// prefix. The conditions under which this returns true must always\n/// correspond to a regular expression that would otherwise be consider\n/// invalid.\n///\n/// This should only be called immediately after parsing the opening of\n/// a group or a set of flags.\nfn is_lookaround_prefix(&self) -> bool{\n        self.bump_if(\"?=\")\n            || self.bump_if(\"?!\")\n            || self.bump_if(\"?<=\")\n            || self.bump_if(\"?<!\")\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::line":["/// Return the current line number of the parser.\n///\n/// The line number starts at `1`.\nfn line(&self) -> usize{\n        self.parser().pos.get().line\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["/// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.\n///\n/// This assumes the parser is positioned at the opening `[`.\n///\n/// If no valid ASCII character class could be found, then this does not\n/// advance the parser and `None` is returned. Otherwise, the parser is\n/// advanced to the first byte following the closing `]` and the\n/// corresponding ASCII class is returned.\n#[inline(never)]\nfn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii>{\n        // ASCII character classes are interesting from a parsing perspective\n        // because parsing cannot fail with any interesting error. For example,\n        // in order to use an ASCII character class, it must be enclosed in\n        // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think\n        // of it as \"ASCII character characters have the syntax `[:NAME:]`\n        // which can only appear within character brackets.\" This means that\n        // things like `[[:lower:]A]` are legal constructs.\n        //\n        // However, if one types an incorrect ASCII character class, e.g.,\n        // `[[:loower:]]`, then we treat that as a normal nested character\n        // class containing the characters `:elorw`. One might argue that we\n        // should return an error instead since the repeated colons give away\n        // the intent to write an ASCII class. But what if the user typed\n        // `[[:lower]]` instead? How can we tell that was intended to be an\n        // ASCII class and not just a normal nested class?\n        //\n        // Reasonable people can probably disagree over this, but for better\n        // or worse, we implement semantics that never fails at the expense\n        // of better failure modes.\n        assert_eq!(self.char(), '[');\n        // If parsing fails, then we back up the parser to this starting point.\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind: kind,\n            negated: negated,\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::new":["/// Build an internal parser from a parser configuration and a pattern.\nfn new(parser: P, pattern: &'s str) -> ParserI<'s, P>{\n        ParserI { parser: parser, pattern: pattern }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::next_capture_index":["/// Return the next capturing index. Each subsequent call increments the\n/// internal index.\n///\n/// The span given should correspond to the location of the opening\n/// parenthesis.\n///\n/// If the capture limit is exceeded, then an error is returned.\nfn next_capture_index(&self, span: Span) -> Result<u32>{\n        let current = self.parser().capture_index.get();\n        let i = current.checked_add(1).ok_or_else(|| {\n            self.error(span, ast::ErrorKind::CaptureLimitExceeded)\n        })?;\n        self.parser().capture_index.set(i);\n        Ok(i)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::offset":["/// Return the current offset of the parser.\n///\n/// The offset starts at `0` from the beginning of the regular expression\n/// pattern string.\nfn offset(&self) -> usize{\n        self.parser().pos.get().offset\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse":["/// Parse the regular expression into an abstract syntax tree.\nfn parse(&self) -> Result<Ast>{\n        self.parse_with_comments().map(|astc| astc.ast)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_capture_name":["/// Parses a capture group name. Assumes that the parser is positioned at\n/// the first character in the name following the opening `<` (and may\n/// possibly be EOF). This advances the parser to the first character\n/// following the closing `>`.\n///\n/// The caller must provide the capture index of the group for this name.\n#[inline(never)]\nfn parse_capture_name(\n        &self,\n        capture_index: u32,\n    ) -> Result<ast::CaptureName>{\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        let start = self.pos();\n        loop {\n            if self.char() == '>' {\n                break;\n            }\n            if !is_capture_char(self.char(), self.pos() == start) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::GroupNameInvalid,\n                ));\n            }\n            if !self.bump() {\n                break;\n            }\n        }\n        let end = self.pos();\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        assert_eq!(self.char(), '>');\n        self.bump();\n        let name = &self.pattern()[start.offset..end.offset];\n        if name.is_empty() {\n            return Err(self.error(\n                Span::new(start, start),\n                ast::ErrorKind::GroupNameEmpty,\n            ));\n        }\n        let capname = ast::CaptureName {\n            span: Span::new(start, end),\n            name: name.to_string(),\n            index: capture_index,\n        };\n        self.add_capture_name(&capname)?;\n        Ok(capname)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["/// Parses a counted repetition operation. A counted repetition operator\n/// corresponds to the {m,n} syntax, and does not include the ?, * or +\n/// operators.\n///\n/// This assumes that the paser is currently positioned at the opening `{`\n/// and advances the parser to the first character after the operator.\n/// (Note that the operator may include a single additional `?`, which\n/// makes the operator ungreedy.)\n///\n/// The caller should include the concatenation that is being built. The\n/// concatenation returned includes the repetition operator applied to the\n/// last expression in the given concatenation.\n#[inline(never)]\nfn parse_counted_repetition(\n        &self,\n        mut concat: ast::Concat,\n    ) -> Result<ast::Concat>{\n        assert!(self.char() == '{');\n        let start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        let count_start = specialize_err(\n            self.parse_decimal(),\n            ast::ErrorKind::DecimalEmpty,\n            ast::ErrorKind::RepetitionCountDecimalEmpty,\n        )?;\n        let mut range = ast::RepetitionRange::Exactly(count_start);\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        if self.char() == ',' {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::RepetitionCountUnclosed,\n                ));\n            }\n            if self.char() != '}' {\n                let count_end = specialize_err(\n                    self.parse_decimal(),\n                    ast::ErrorKind::DecimalEmpty,\n                    ast::ErrorKind::RepetitionCountDecimalEmpty,\n                )?;\n                range = ast::RepetitionRange::Bounded(count_start, count_end);\n            } else {\n                range = ast::RepetitionRange::AtLeast(count_start);\n            }\n        }\n        if self.is_eof() || self.char() != '}' {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n\n        let mut greedy = true;\n        if self.bump_and_bump_space() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n\n        let op_span = Span::new(start, self.pos());\n        if !range.is_valid() {\n            return Err(\n                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)\n            );\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: op_span,\n                kind: ast::RepetitionKind::Range(range),\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_decimal":["/// Parse a decimal number into a u32 while trimming leading and trailing\n/// whitespace.\n///\n/// This expects the parser to be positioned at the first position where\n/// a decimal digit could occur. This will advance the parser to the byte\n/// immediately following the last contiguous decimal digit.\n///\n/// If no decimal digit could be found or if there was a problem parsing\n/// the complete set of digits into a u32, then an error is returned.\nfn parse_decimal(&self) -> Result<u32>{\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump();\n        }\n        let start = self.pos();\n        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        let span = Span::new(start, self.pos());\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump_and_bump_space();\n        }\n        let digits = scratch.as_str();\n        if digits.is_empty() {\n            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));\n        }\n        match u32::from_str_radix(digits, 10).ok() {\n            Some(n) => Ok(n),\n            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_escape":["/// Parse an escape sequence as a primitive AST.\n///\n/// This assumes the parser is positioned at the start of the escape\n/// sequence, i.e., `\\`. It advances the parser to the first position\n/// immediately following the escape sequence.\n#[inline(never)]\nfn parse_escape(&self) -> Result<Primitive>{\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let c = self.char();\n        // Put some of the more complicated routines into helpers.\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(self.error(\n                        Span::new(start, self.span_char().end),\n                        ast::ErrorKind::UnsupportedBackreference,\n                    ));\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(self.error(\n                    Span::new(start, self.span_char().end),\n                    ast::ErrorKind::UnsupportedBackreference,\n                ));\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n\n        // Handle all of the one letter sequences inline.\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Punctuation,\n                c: c,\n            }));\n        }\n        let special = |kind, c| {\n            Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Special(kind),\n                c: c,\n            }))\n        };\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            ' ' if self.ignore_whitespace() => {\n                special(ast::SpecialLiteralKind::Space, ' ')\n            }\n            'A' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::StartText,\n            })),\n            'z' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::EndText,\n            })),\n            'b' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::WordBoundary,\n            })),\n            'B' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::NotWordBoundary,\n            })),\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_flag":["/// Parse the current character as a flag. Do not advance the parser.\n///\n/// # Errors\n///\n/// If the flag is not recognized, then an error is returned.\n#[inline(never)]\nfn parse_flag(&self) -> Result<ast::Flag>{\n        match self.char() {\n            'i' => Ok(ast::Flag::CaseInsensitive),\n            'm' => Ok(ast::Flag::MultiLine),\n            's' => Ok(ast::Flag::DotMatchesNewLine),\n            'U' => Ok(ast::Flag::SwapGreed),\n            'u' => Ok(ast::Flag::Unicode),\n            'x' => Ok(ast::Flag::IgnoreWhitespace),\n            _ => {\n                Err(self\n                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_flags":["/// Parse a sequence of flags starting at the current character.\n///\n/// This advances the parser to the character immediately following the\n/// flags, which is guaranteed to be either `:` or `)`.\n///\n/// # Errors\n///\n/// If any flags are duplicated, then an error is returned.\n///\n/// If the negation operator is used more than once, then an error is\n/// returned.\n///\n/// If no flags could be found or if the negation operation is not followed\n/// by any flags, then an error is returned.\n#[inline(never)]\nfn parse_flags(&self) -> Result<ast::Flags>{\n        let mut flags = ast::Flags { span: self.span(), items: vec![] };\n        let mut last_was_negation = None;\n        while self.char() != ':' && self.char() != ')' {\n            if self.char() == '-' {\n                last_was_negation = Some(self.span_char());\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Negation,\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagRepeatedNegation {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            } else {\n                last_was_negation = None;\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagDuplicate {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            }\n            if !self.bump() {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)\n                );\n            }\n        }\n        if let Some(span) = last_was_negation {\n            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));\n        }\n        flags.span.end = self.pos();\n        Ok(flags)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_group":["/// Parse a group (which contains a sub-expression) or a set of flags.\n///\n/// If a group was found, then it is returned with an empty AST. If a set\n/// of flags is found, then that set is returned.\n///\n/// The parser should be positioned at the opening parenthesis.\n///\n/// This advances the parser to the character before the start of the\n/// sub-expression (in the case of a group) or to the closing parenthesis\n/// immediately following the set of flags.\n///\n/// # Errors\n///\n/// If flags are given and incorrectly specified, then a corresponding\n/// error is returned.\n///\n/// If a capture name is given and it is incorrectly specified, then a\n/// corresponding error is returned.\n#[inline(never)]\nfn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>>{\n        assert_eq!(self.char(), '(');\n        let open_span = self.span_char();\n        self.bump();\n        self.bump_space();\n        if self.is_lookaround_prefix() {\n            return Err(self.error(\n                Span::new(open_span.start, self.span().end),\n                ast::ErrorKind::UnsupportedLookAround,\n            ));\n        }\n        let inner_span = self.span();\n        if self.bump_if(\"?P<\") {\n            let capture_index = self.next_capture_index(open_span)?;\n            let cap = self.parse_capture_name(capture_index)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureName(cap),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        } else if self.bump_if(\"?\") {\n            if self.is_eof() {\n                return Err(\n                    self.error(open_span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n            let flags = self.parse_flags()?;\n            let char_end = self.char();\n            self.bump();\n            if char_end == ')' {\n                // We don't allow empty flags, e.g., `(?)`. We instead\n                // interpret it as a repetition operator missing its argument.\n                if flags.items.is_empty() {\n                    return Err(self.error(\n                        inner_span,\n                        ast::ErrorKind::RepetitionMissing,\n                    ));\n                }\n                Ok(Either::Left(ast::SetFlags {\n                    span: Span { end: self.pos(), ..open_span },\n                    flags: flags,\n                }))\n            } else {\n                assert_eq!(char_end, ':');\n                Ok(Either::Right(ast::Group {\n                    span: open_span,\n                    kind: ast::GroupKind::NonCapturing(flags),\n                    ast: Box::new(Ast::Empty(self.span())),\n                }))\n            }\n        } else {\n            let capture_index = self.next_capture_index(open_span)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureIndex(capture_index),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex":["/// Parse a hex representation of a Unicode codepoint. This handles both\n/// hex notations, i.e., `\\xFF` and `\\x{FFFF}`. This expects the parser to\n/// be positioned at the `x`, `u` or `U` prefix. The parser is advanced to\n/// the first character immediately following the hexadecimal literal.\n#[inline(never)]\nfn parse_hex(&self) -> Result<ast::Literal>{\n        assert!(\n            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'\n        );\n\n        let hex_kind = match self.char() {\n            'x' => ast::HexLiteralKind::X,\n            'u' => ast::HexLiteralKind::UnicodeShort,\n            _ => ast::HexLiteralKind::UnicodeLong,\n        };\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace(hex_kind)\n        } else {\n            self.parse_hex_digits(hex_kind)\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["/// Parse a hex representation of any Unicode scalar value. This expects\n/// the parser to be positioned at the opening brace `{` and will advance\n/// the parser to the first character following the closing brace `}`.\n#[inline(never)]\nfn parse_hex_brace(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal>{\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let brace_pos = self.pos();\n        let start = self.span_char().end;\n        while self.bump_and_bump_space() && self.char() != '}' {\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let end = self.pos();\n        let hex = scratch.as_str();\n        assert_eq!(self.char(), '}');\n        self.bump_and_bump_space();\n\n        if hex.is_empty() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeHexEmpty,\n            ));\n        }\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, self.pos()),\n                kind: ast::LiteralKind::HexBrace(kind),\n                c: c,\n            }),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["/// Parse an N-digit hex representation of a Unicode codepoint. This\n/// expects the parser to be positioned at the first digit and will advance\n/// the parser to the first character immediately following the escape\n/// sequence.\n///\n/// The number of digits given must be 2 (for `\\xNN`), 4 (for `\\uNNNN`)\n/// or 8 (for `\\UNNNNNNNN`).\n#[inline(never)]\nfn parse_hex_digits(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal>{\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let start = self.pos();\n        for i in 0..kind.digits() {\n            if i > 0 && !self.bump_and_bump_space() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        // The final bump just moves the parser past the literal, which may\n        // be EOF.\n        self.bump_and_bump_space();\n        let end = self.pos();\n        let hex = scratch.as_str();\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, end),\n                kind: ast::LiteralKind::HexFixed(kind),\n                c: c,\n            }),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_octal":["/// Parse an octal representation of a Unicode codepoint up to 3 digits\n/// long. This expects the parser to be positioned at the first octal\n/// digit and advances the parser to the first character immediately\n/// following the octal number. This also assumes that parsing octal\n/// escapes is enabled.\n///\n/// Assuming the preconditions are met, this routine can never fail.\n#[inline(never)]\nfn parse_octal(&self) -> ast::Literal{\n        use std::char;\n        use std::u32;\n\n        assert!(self.parser().octal);\n        assert!('0' <= self.char() && self.char() <= '7');\n        let start = self.pos();\n        // Parse up to two more digits.\n        while self.bump()\n            && '0' <= self.char()\n            && self.char() <= '7'\n            && self.pos().offset - start.offset <= 2\n        {}\n        let end = self.pos();\n        let octal = &self.pattern()[start.offset..end.offset];\n        // Parsing the octal should never fail since the above guarantees a\n        // valid number.\n        let codepoint =\n            u32::from_str_radix(octal, 8).expect(\"valid octal number\");\n        // The max value for 3 digit octal is 0777 = 511 and [0, 511] has no\n        // invalid Unicode scalar values.\n        let c = char::from_u32(codepoint).expect(\"Unicode scalar value\");\n        ast::Literal {\n            span: Span::new(start, end),\n            kind: ast::LiteralKind::Octal,\n            c: c,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_perl_class":["/// Parse a Perl character class, e.g., `\\d` or `\\W`. This assumes the\n/// parser is currently at a valid character class name and will be\n/// advanced to the character immediately following the class.\n#[inline(never)]\nfn parse_perl_class(&self) -> ast::ClassPerl{\n        let c = self.char();\n        let span = self.span_char();\n        self.bump();\n        let (negated, kind) = match c {\n            'd' => (false, ast::ClassPerlKind::Digit),\n            'D' => (true, ast::ClassPerlKind::Digit),\n            's' => (false, ast::ClassPerlKind::Space),\n            'S' => (true, ast::ClassPerlKind::Space),\n            'w' => (false, ast::ClassPerlKind::Word),\n            'W' => (true, ast::ClassPerlKind::Word),\n            c => panic!(\"expected valid Perl class but got '{}'\", c),\n        };\n        ast::ClassPerl { span: span, kind: kind, negated: negated }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_primitive":["/// Parse a primitive AST. e.g., A literal, non-set character class or\n/// assertion.\n///\n/// This assumes that the parser expects a primitive at the current\n/// location. i.e., All other non-primitive cases have been handled.\n/// For example, if the parser's position is at `|`, then `|` will be\n/// treated as a literal (e.g., inside a character class).\n///\n/// This advances the parser to the first character immediately following\n/// the primitive.\nfn parse_primitive(&self) -> Result<Primitive>{\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class":["/// Parse a standard character class consisting primarily of characters or\n/// character ranges, but can also contain nested character classes of\n/// any type (sans `.`).\n///\n/// This assumes the parser is positioned at the opening `[`. If parsing\n/// is successful, then the parser is advanced to the position immediately\n/// following the closing `]`.\n#[inline(never)]\nfn parse_set_class(&self) -> Result<ast::Class>{\n        assert_eq!(self.char(), '[');\n\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    // If we've already parsed the opening bracket, then\n                    // attempt to treat this as the beginning of an ASCII\n                    // class. If ASCII class parsing fails, then the parser\n                    // backs up to `[`.\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => match self.pop_class(union)? {\n                    Either::Left(nested_union) => {\n                        union = nested_union;\n                    }\n                    Either::Right(class) => return Ok(class),\n                },\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Intersection,\n                        union,\n                    );\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Difference,\n                        union,\n                    );\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::SymmetricDifference,\n                        union,\n                    );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["/// Parse a single item in a character class as a primitive, where the\n/// primitive either consists of a verbatim literal or a single escape\n/// sequence.\n///\n/// This assumes the parser is positioned at the beginning of a primitive,\n/// and advances the parser to the first position after the primitive if\n/// successful.\n///\n/// Note that it is the caller's responsibility to report an error if an\n/// illegal primitive was parsed.\n#[inline(never)]\nfn parse_set_class_item(&self) -> Result<Primitive>{\n        if self.char() == '\\\\' {\n            self.parse_escape()\n        } else {\n            let x = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: self.char(),\n            });\n            self.bump();\n            Ok(x)\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["/// Parses the opening of a character class set. This includes the opening\n/// bracket along with `^` if present to indicate negation. This also\n/// starts parsing the opening set of unioned items if applicable, since\n/// there are special rules applied to certain characters in the opening\n/// of a character class. For example, `[^]]` is the class of all\n/// characters not equal to `]`. (`]` would need to be escaped in any other\n/// position.) Similarly for `-`.\n///\n/// In all cases, the op inside the returned `ast::ClassBracketed` is an\n/// empty union. This empty union should be replaced with the actual item\n/// when it is popped from the parser's stack.\n///\n/// This assumes the parser is positioned at the opening `[` and advances\n/// the parser to the first non-special byte of the character class.\n///\n/// An error is returned if EOF is found.\n#[inline(never)]\nfn parse_set_class_open(\n        &self,\n    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)>{\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n\n        let negated = if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n        // Accept any number of `-` as literal `-`.\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        while self.char() == '-' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: '-',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        // If `]` is the *first* char in a set, then interpret it as a literal\n        // `]`. That is, an empty class is impossible to write.\n        if union.items.is_empty() && self.char() == ']' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: ']',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        let set = ast::ClassBracketed {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: ast::ClassSet::union(ast::ClassSetUnion {\n                span: Span::new(union.span.start, union.span.start),\n                items: vec![],\n            }),\n        };\n        Ok((set, union))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["/// Parse a single primitive item in a character class set. The item to\n/// be parsed can either be one of a simple literal character, a range\n/// between two simple literal characters or a \"primitive\" character\n/// class like \\w or \\p{Greek}.\n///\n/// If an invalid escape is found, or if a character class is found where\n/// a simple literal is expected (e.g., in a range), then an error is\n/// returned.\n#[inline(never)]\nfn parse_set_class_range(&self) -> Result<ast::ClassSetItem>{\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        // If the next char isn't a `-`, then we don't have a range.\n        // There are two exceptions. If the char after a `-` is a `]`, then\n        // `-` is interpreted as a literal `-`. Alternatively, if the char\n        // after a `-` is a `-`, then `--` corresponds to a \"difference\"\n        // operation.\n        if self.char() != '-'\n            || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        // OK, now we're parsing a range, so bump past the `-` and parse the\n        // second half of the range.\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(\n                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)\n            );\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["/// Parses an uncounted repetition operation. An uncounted repetition\n/// operator includes ?, * and +, but does not include the {m,n} syntax.\n/// The given `kind` should correspond to the operator observed by the\n/// caller.\n///\n/// This assumes that the paser is currently positioned at the repetition\n/// operator and advances the parser to the first character after the\n/// operator. (Note that the operator may include a single additional `?`,\n/// which makes the operator ungreedy.)\n///\n/// The caller should include the concatenation that is being built. The\n/// concatenation returned includes the repetition operator applied to the\n/// last expression in the given concatenation.\n#[inline(never)]\nfn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat>{\n        assert!(\n            self.char() == '?' || self.char() == '*' || self.char() == '+'\n        );\n        let op_start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        let mut greedy = true;\n        if self.bump() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: Span::new(op_start, self.pos()),\n                kind: kind,\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["/// Parse a Unicode class in either the single character notation, `\\pN`\n/// or the multi-character bracketed notation, `\\p{Greek}`. This assumes\n/// the parser is positioned at the `p` (or `P` for negation) and will\n/// advance the parser to the character immediately following the class.\n///\n/// Note that this does not check whether the class name is valid or not.\n#[inline(never)]\nfn parse_unicode_class(&self) -> Result<ast::ClassUnicode>{\n        assert!(self.char() == 'p' || self.char() == 'P');\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let negated = self.char() == 'P';\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        let (start, kind) = if self.char() == '{' {\n            let start = self.span_char().end;\n            while self.bump_and_bump_space() && self.char() != '}' {\n                scratch.push(self.char());\n            }\n            if self.is_eof() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            assert_eq!(self.char(), '}');\n            self.bump();\n\n            let name = scratch.as_str();\n            if let Some(i) = name.find(\"!=\") {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::NotEqual,\n                        name: name[..i].to_string(),\n                        value: name[i + 2..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find(':') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Colon,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find('=') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Equal,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else {\n                (start, ast::ClassUnicodeKind::Named(name.to_string()))\n            }\n        } else {\n            let start = self.pos();\n            let c = self.char();\n            if c == '\\\\' {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::UnicodeClassInvalid,\n                ));\n            }\n            self.bump_and_bump_space();\n            let kind = ast::ClassUnicodeKind::OneLetter(c);\n            (start, kind)\n        };\n        Ok(ast::ClassUnicode {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: kind,\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_with_comments":["/// Parse the regular expression and return an abstract syntax tree with\n/// all of the comments found in the pattern.\nfn parse_with_comments(&self) -> Result<ast::WithComments>{\n        assert_eq!(self.offset(), 0, \"parser can only be used once\");\n        self.parser().reset();\n        let mut concat = ast::Concat { span: self.span(), asts: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                break;\n            }\n            match self.char() {\n                '(' => concat = self.push_group(concat)?,\n                ')' => concat = self.pop_group(concat)?,\n                '|' => concat = self.push_alternate(concat)?,\n                '[' => {\n                    let class = self.parse_set_class()?;\n                    concat.asts.push(Ast::Class(class));\n                }\n                '?' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrOne,\n                    )?;\n                }\n                '*' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrMore,\n                    )?;\n                }\n                '+' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::OneOrMore,\n                    )?;\n                }\n                '{' => {\n                    concat = self.parse_counted_repetition(concat)?;\n                }\n                _ => concat.asts.push(self.parse_primitive()?.into_ast()),\n            }\n        }\n        let ast = self.pop_group_end(concat)?;\n        NestLimiter::new(self).check(&ast)?;\n        Ok(ast::WithComments {\n            ast: ast,\n            comments: mem::replace(\n                &mut *self.parser().comments.borrow_mut(),\n                vec![],\n            ),\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parser":["/// Return a reference to the parser state.\nfn parser(&self) -> &Parser{\n        self.parser.borrow()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pattern":["/// Return a reference to the pattern being parsed.\nfn pattern(&self) -> &str{\n        self.pattern.borrow()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::peek":["/// Peek at the next character in the input without advancing the parser.\n///\n/// If the input has been exhausted, then this returns `None`.\nfn peek(&self) -> Option<char>{\n        if self.is_eof() {\n            return None;\n        }\n        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::peek_space":["/// Like peek, but will ignore spaces when the parser is in whitespace\n/// insensitive mode.\nfn peek_space(&self) -> Option<char>{\n        if !self.ignore_whitespace() {\n            return self.peek();\n        }\n        if self.is_eof() {\n            return None;\n        }\n        let mut start = self.offset() + self.char().len_utf8();\n        let mut in_comment = false;\n        for (i, c) in self.pattern()[start..].char_indices() {\n            if c.is_whitespace() {\n                continue;\n            } else if !in_comment && c == '#' {\n                in_comment = true;\n            } else if in_comment && c == '\\n' {\n                in_comment = false;\n            } else {\n                start += i;\n                break;\n            }\n        }\n        self.pattern()[start..].chars().next()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_class":["/// Parse the end of a character class set and pop the character class\n/// parser stack. The union given corresponds to the last union built\n/// before seeing the closing `]`. The union returned corresponds to the\n/// parent character class set with the nested class added to it.\n///\n/// This assumes that the parser is positioned at a `]` and will advance\n/// the parser to the byte immediately following the `]`.\n///\n/// If the stack is empty after popping, then this returns the final\n/// \"top-level\" character class AST (where a \"top-level\" character class\n/// is one that is not nested inside any other character class).\n///\n/// If there is no corresponding opening bracket on the parser's stack,\n/// then an error is returned.\n#[inline(never)]\nfn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>>{\n        assert_eq!(self.char(), ']');\n\n        let item = ast::ClassSet::Item(nested_union.into_item());\n        let prevset = self.pop_class_op(item);\n        let mut stack = self.parser().stack_class.borrow_mut();\n        match stack.pop() {\n            None => {\n                // We can never observe an empty stack:\n                //\n                // 1) We are guaranteed to start with a non-empty stack since\n                //    the character class parser is only initiated when it sees\n                //    a `[`.\n                // 2) If we ever observe an empty stack while popping after\n                //    seeing a `]`, then we signal the character class parser\n                //    to terminate.\n                panic!(\"unexpected empty character class stack\")\n            }\n            Some(ClassState::Op { .. }) => {\n                // This panic is unfortunate, but this case is impossible\n                // since we already popped the Op state if one exists above.\n                // Namely, every push to the class parser stack is guarded by\n                // whether an existing Op is already on the top of the stack.\n                // If it is, the existing Op is modified. That is, the stack\n                // can never have consecutive Op states.\n                panic!(\"unexpected ClassState::Op\")\n            }\n            Some(ClassState::Open { mut union, mut set }) => {\n                self.bump();\n                set.span.end = self.pos();\n                set.kind = prevset;\n                if stack.is_empty() {\n                    Ok(Either::Right(ast::Class::Bracketed(set)))\n                } else {\n                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                    Ok(Either::Left(union))\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_class_op":["/// Pop a character class set from the character class parser stack. If the\n/// top of the stack is just an item (not an operation), then return the\n/// given set unchanged. If the top of the stack is an operation, then the\n/// given set will be used as the rhs of the operation on the top of the\n/// stack. In that case, the binary operation is returned as a set.\n#[inline(never)]\nfn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet{\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span: span,\n            kind: kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_group":["/// Pop a group AST from the parser's internal stack and set the group's\n/// AST to the given concatenation. Return the concatenation containing\n/// the group.\n///\n/// This assumes that the parser is currently positioned on the closing\n/// parenthesis and advances the parser to the character following the `)`.\n///\n/// If no such group could be popped, then an unopened group error is\n/// returned.\n#[inline(never)]\nfn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat>{\n        use self::GroupState::*;\n\n        assert_eq!(self.char(), ')');\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack\n            .pop()\n        {\n            Some(Group { concat, group, ignore_whitespace }) => {\n                (concat, group, ignore_whitespace, None)\n            }\n            Some(Alternation(alt)) => match stack.pop() {\n                Some(Group { concat, group, ignore_whitespace }) => {\n                    (concat, group, ignore_whitespace, Some(alt))\n                }\n                None | Some(Alternation(_)) => {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::GroupUnopened,\n                    ));\n                }\n            },\n            None => {\n                return Err(self\n                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));\n            }\n        };\n        self.parser().ignore_whitespace.set(ignore_whitespace);\n        group_concat.span.end = self.pos();\n        self.bump();\n        group.span.end = self.pos();\n        match alt {\n            Some(mut alt) => {\n                alt.span.end = group_concat.span.end;\n                alt.asts.push(group_concat.into_ast());\n                group.ast = Box::new(alt.into_ast());\n            }\n            None => {\n                group.ast = Box::new(group_concat.into_ast());\n            }\n        }\n        prior_concat.asts.push(Ast::Group(group));\n        Ok(prior_concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_group_end":["/// Pop the last state from the parser's internal stack, if it exists, and\n/// add the given concatenation to it. There either must be no state or a\n/// single alternation item on the stack. Any other scenario produces an\n/// error.\n///\n/// This assumes that the parser has advanced to the end.\n#[inline(never)]\nfn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast>{\n        concat.span.end = self.pos();\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let ast = match stack.pop() {\n            None => Ok(concat.into_ast()),\n            Some(GroupState::Alternation(mut alt)) => {\n                alt.span.end = self.pos();\n                alt.asts.push(concat.into_ast());\n                Ok(Ast::Alternation(alt))\n            }\n            Some(GroupState::Group { group, .. }) => {\n                return Err(\n                    self.error(group.span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n        };\n        // If we try to pop again, there should be nothing.\n        match stack.pop() {\n            None => ast,\n            Some(GroupState::Alternation(_)) => {\n                // This unreachable is unfortunate. This case can't happen\n                // because the only way we can be here is if there were two\n                // `GroupState::Alternation`s adjacent in the parser's stack,\n                // which we guarantee to never happen because we never push a\n                // `GroupState::Alternation` if one is already at the top of\n                // the stack.\n                unreachable!()\n            }\n            Some(GroupState::Group { group, .. }) => {\n                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pos":["/// Return the current position of the parser, which includes the offset,\n/// line and column.\nfn pos(&self) -> Position{\n        self.parser().pos.get()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_alternate":["/// Parse and push a single alternation on to the parser's internal stack.\n/// If the top of the stack already has an alternation, then add to that\n/// instead of pushing a new one.\n///\n/// The concatenation given corresponds to a single alternation branch.\n/// The concatenation returned starts the next branch and is empty.\n///\n/// This assumes the parser is currently positioned at `|` and will advance\n/// the parser to the character following `|`.\n#[inline(never)]\nfn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat>{\n        assert_eq!(self.char(), '|');\n        concat.span.end = self.pos();\n        self.push_or_add_alternation(concat);\n        self.bump();\n        Ok(ast::Concat { span: self.span(), asts: vec![] })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_class_op":["/// Push the current set of class items on to the class parser's stack as\n/// the left hand side of the given operator.\n///\n/// A fresh set union is returned, which should be used to build the right\n/// hand side of this operator.\n#[inline(never)]\nfn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion{\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });\n        ast::ClassSetUnion { span: self.span(), items: vec![] }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_class_open":["/// Parse the opening of a character class and push the current class\n/// parsing context onto the parser's stack. This assumes that the parser\n/// is positioned at an opening `[`. The given union should correspond to\n/// the union of set items built up before seeing the `[`.\n///\n/// If there was a problem parsing the opening of the class, then an error\n/// is returned. Otherwise, a new union of set items for the class is\n/// returned (which may be populated with either a `]` or a `-`).\n#[inline(never)]\nfn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion>{\n        assert_eq!(self.char(), '[');\n\n        let (nested_set, nested_union) = self.parse_set_class_open()?;\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Open { union: parent_union, set: nested_set });\n        Ok(nested_union)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_group":["/// Parse and push a group AST (and its parent concatenation) on to the\n/// parser's internal stack. Return a fresh concatenation corresponding\n/// to the group's sub-AST.\n///\n/// If a set of flags was found (with no group), then the concatenation\n/// is returned with that set of flags added.\n///\n/// This assumes that the parser is currently positioned on the opening\n/// parenthesis. It advances the parser to the character at the start\n/// of the sub-expression (or adjoining expression).\n///\n/// If there was a problem parsing the start of the group, then an error\n/// is returned.\n#[inline(never)]\nfn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat>{\n        assert_eq!(self.char(), '(');\n        match self.parse_group()? {\n            Either::Left(set) => {\n                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);\n                if let Some(v) = ignore {\n                    self.parser().ignore_whitespace.set(v);\n                }\n\n                concat.asts.push(Ast::Flags(set));\n                Ok(concat)\n            }\n            Either::Right(group) => {\n                let old_ignore_whitespace = self.ignore_whitespace();\n                let new_ignore_whitespace = group\n                    .flags()\n                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))\n                    .unwrap_or(old_ignore_whitespace);\n                self.parser().stack_group.borrow_mut().push(\n                    GroupState::Group {\n                        concat: concat,\n                        group: group,\n                        ignore_whitespace: old_ignore_whitespace,\n                    },\n                );\n                self.parser().ignore_whitespace.set(new_ignore_whitespace);\n                Ok(ast::Concat { span: self.span(), asts: vec![] })\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["/// Pushes or adds the given branch of an alternation to the parser's\n/// internal stack of state.\nfn push_or_add_alternation(&self, concat: ast::Concat){\n        use self::GroupState::*;\n\n        let mut stack = self.parser().stack_group.borrow_mut();\n        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {\n            alts.asts.push(concat.into_ast());\n            return;\n        }\n        stack.push(Alternation(ast::Alternation {\n            span: Span::new(concat.span.start, self.pos()),\n            asts: vec![concat.into_ast()],\n        }));\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::span":["/// Create a span at the current position of the parser. Both the start\n/// and end of the span are set.\nfn span(&self) -> Span{\n        Span::splat(self.pos())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::span_char":["/// Create a span that covers the current character.\nfn span_char(&self) -> Span{\n        let mut next = Position {\n            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),\n            line: self.line(),\n            column: self.column().checked_add(1).unwrap(),\n        };\n        if self.char() == '\\n' {\n            next.line += 1;\n            next.column = 1;\n        }\n        Span::new(self.pos(), next)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["/// Return an \"unclosed class\" error whose span points to the most\n/// recently opened class.\n///\n/// This should only be called while parsing a character class.\n#[inline(never)]\nfn unclosed_class_error(&self) -> ast::Error{\n        for state in self.parser().stack_class.borrow().iter().rev() {\n            match *state {\n                ClassState::Open { ref set, .. } => {\n                    return self\n                        .error(set.span, ast::ErrorKind::ClassUnclosed);\n                }\n                _ => {}\n            }\n        }\n        // We are guaranteed to have a non-empty stack with at least\n        // one open bracket, so we should never get here.\n        panic!(\"no open character class found\")\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive":["/// A primitive is an expression with no sub-expressions. This includes\n/// literals, assertions and non-set character classes. This representation\n/// is used as intermediate state in the parser.\n///\n/// This does not include ASCII character classes, since they can only appear\n/// within a set character class.\nenum Primitive {\n    Literal(ast::Literal),\n    Assertion(ast::Assertion),\n    Dot(Span),\n    Perl(ast::ClassPerl),\n    Unicode(ast::ClassUnicode),\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_ast":["/// Convert this primitive into a proper AST.\nfn into_ast(self) -> Ast{\n        match self {\n            Primitive::Literal(lit) => Ast::Literal(lit),\n            Primitive::Assertion(assert) => Ast::Assertion(assert),\n            Primitive::Dot(span) => Ast::Dot(span),\n            Primitive::Perl(cls) => Ast::Class(ast::Class::Perl(cls)),\n            Primitive::Unicode(cls) => Ast::Class(ast::Class::Unicode(cls)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_class_literal":["/// Convert this primitive into a literal in a character class. In\n/// particular, literals are the only valid items that can appear in\n/// ranges.\n///\n/// If this primitive is not a legal item (i.e., a class, assertion or a\n/// dot), then return an error.\nfn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::Literal>{\n        use self::Primitive::*;\n\n        match self {\n            Literal(lit) => Ok(lit),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_class_set_item":["/// Convert this primitive into an item in a character class.\n///\n/// If this primitive is not a legal item (i.e., an assertion or a dot),\n/// then return an error.\nfn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::ClassSetItem>{\n        use self::Primitive::*;\n        use ast::ClassSetItem;\n\n        match self {\n            Literal(lit) => Ok(ClassSetItem::Literal(lit)),\n            Perl(cls) => Ok(ClassSetItem::Perl(cls)),\n            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::span":["/// Return the span of this primitive.\nfn span(&self) -> &Span{\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::is_capture_char":["/// Returns true if the given character is a valid in a capture group name.\n///\n/// If `first` is true, then `c` is treated as the first character in the\n/// group name (which must be alphabetic or underscore).\nfn is_capture_char(c: char, first: bool) -> bool{\n    c == '_'\n        || (!first\n            && (('0' <= c && c <= '9') || c == '.' || c == '[' || c == ']'))\n        || ('A' <= c && c <= 'Z')\n        || ('a' <= c && c <= 'z')\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::is_hex":["/// Returns true if the given character is a hexadecimal digit.\nfn is_hex(c: char) -> bool{\n    ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::specialize_err":["/// When the result is an error, transforms the ast::ErrorKind from the source\n/// Result into another one. This function is used to return clearer error\n/// messages when possible.\nfn specialize_err<T>(\n    result: Result<T>,\n    from: ast::ErrorKind,\n    to: ast::ErrorKind,\n) -> Result<T>{\n    if let Err(e) = result {\n        if e.kind == from {\n            Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })\n        } else {\n            Err(e)\n        }\n    } else {\n        result\n    }\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::print::Printer":["/// A printer for a regular expression abstract syntax tree.\n///\n/// A printer converts an abstract syntax tree (AST) to a regular expression\n/// pattern string. This particular printer uses constant stack space and heap\n/// space proportional to the size of the AST.\n///\n/// This printer will not necessarily preserve the original formatting of the\n/// regular expression pattern string. For example, all whitespace and comments\n/// are ignored.\npub struct Printer {\n    _priv: (),\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Printer::new":["/// Create a new printer.\npub fn new() -> Printer{\n        PrinterBuilder::new().build()\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Printer::print":["/// Print the given `Ast` to the given writer. The writer must implement\n/// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n/// here are a `fmt::Formatter` (which is available in `fmt::Display`\n/// implementations) or a `&mut String`.\npub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result{\n        visitor::visit(ast, Writer { printer: self, wtr: wtr })\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder":["/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\nstruct PrinterBuilder {\n    _priv: (),\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder::build":["fn build(&self) -> Printer{\n        Printer { _priv: () }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder::new":["fn new() -> PrinterBuilder{\n        PrinterBuilder { _priv: () }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer":["struct Writer<'p, W> {\n    printer: &'p mut Printer,\n    wtr: W,\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_assertion":["fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result{\n        use ast::AssertionKind::*;\n        match ast.kind {\n            StartLine => self.wtr.write_str(\"^\"),\n            EndLine => self.wtr.write_str(\"$\"),\n            StartText => self.wtr.write_str(r\"\\A\"),\n            EndText => self.wtr.write_str(r\"\\z\"),\n            WordBoundary => self.wtr.write_str(r\"\\b\"),\n            NotWordBoundary => self.wtr.write_str(r\"\\B\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_ascii":["fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result{\n        use ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":["fn fmt_class_bracketed_post(\n        &mut self,\n        _ast: &ast::ClassBracketed,\n    ) -> fmt::Result{\n        self.wtr.write_str(\"]\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":["fn fmt_class_bracketed_pre(\n        &mut self,\n        ast: &ast::ClassBracketed,\n    ) -> fmt::Result{\n        if ast.negated {\n            self.wtr.write_str(\"[^\")\n        } else {\n            self.wtr.write_str(\"[\")\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_perl":["fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result{\n        use ast::ClassPerlKind::*;\n        match ast.kind {\n            Digit if ast.negated => self.wtr.write_str(r\"\\D\"),\n            Digit => self.wtr.write_str(r\"\\d\"),\n            Space if ast.negated => self.wtr.write_str(r\"\\S\"),\n            Space => self.wtr.write_str(r\"\\s\"),\n            Word if ast.negated => self.wtr.write_str(r\"\\W\"),\n            Word => self.wtr.write_str(r\"\\w\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":["fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result{\n        use ast::ClassSetBinaryOpKind::*;\n        match *ast {\n            Intersection => self.wtr.write_str(\"&&\"),\n            Difference => self.wtr.write_str(\"--\"),\n            SymmetricDifference => self.wtr.write_str(\"~~\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_class_unicode":["fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result{\n        use ast::ClassUnicodeKind::*;\n        use ast::ClassUnicodeOpKind::*;\n\n        if ast.negated {\n            self.wtr.write_str(r\"\\P\")?;\n        } else {\n            self.wtr.write_str(r\"\\p\")?;\n        }\n        match ast.kind {\n            OneLetter(c) => self.wtr.write_char(c),\n            Named(ref x) => write!(self.wtr, \"{{{}}}\", x),\n            NamedValue { op: Equal, ref name, ref value } => {\n                write!(self.wtr, \"{{{}={}}}\", name, value)\n            }\n            NamedValue { op: Colon, ref name, ref value } => {\n                write!(self.wtr, \"{{{}:{}}}\", name, value)\n            }\n            NamedValue { op: NotEqual, ref name, ref value } => {\n                write!(self.wtr, \"{{{}!={}}}\", name, value)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_flags":["fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result{\n        use ast::{Flag, FlagsItemKind};\n\n        for item in &ast.items {\n            match item.kind {\n                FlagsItemKind::Negation => self.wtr.write_str(\"-\"),\n                FlagsItemKind::Flag(ref flag) => match *flag {\n                    Flag::CaseInsensitive => self.wtr.write_str(\"i\"),\n                    Flag::MultiLine => self.wtr.write_str(\"m\"),\n                    Flag::DotMatchesNewLine => self.wtr.write_str(\"s\"),\n                    Flag::SwapGreed => self.wtr.write_str(\"U\"),\n                    Flag::Unicode => self.wtr.write_str(\"u\"),\n                    Flag::IgnoreWhitespace => self.wtr.write_str(\"x\"),\n                },\n            }?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_group_post":["fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result{\n        self.wtr.write_str(\")\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_group_pre":["fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result{\n        use ast::GroupKind::*;\n        match ast.kind {\n            CaptureIndex(_) => self.wtr.write_str(\"(\"),\n            CaptureName(ref x) => {\n                self.wtr.write_str(\"(?P<\")?;\n                self.wtr.write_str(&x.name)?;\n                self.wtr.write_str(\">\")?;\n                Ok(())\n            }\n            NonCapturing(ref flags) => {\n                self.wtr.write_str(\"(?\")?;\n                self.fmt_flags(flags)?;\n                self.wtr.write_str(\":\")?;\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_literal":["fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result{\n        use ast::LiteralKind::*;\n\n        match ast.kind {\n            Verbatim => self.wtr.write_char(ast.c),\n            Punctuation => write!(self.wtr, r\"\\{}\", ast.c),\n            Octal => write!(self.wtr, r\"\\{:o}\", ast.c as u32),\n            HexFixed(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{:02X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{:04X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{:08X}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{{{:X}}}\", ast.c as u32)\n            }\n            Special(ast::SpecialLiteralKind::Bell) => {\n                self.wtr.write_str(r\"\\a\")\n            }\n            Special(ast::SpecialLiteralKind::FormFeed) => {\n                self.wtr.write_str(r\"\\f\")\n            }\n            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r\"\\t\"),\n            Special(ast::SpecialLiteralKind::LineFeed) => {\n                self.wtr.write_str(r\"\\n\")\n            }\n            Special(ast::SpecialLiteralKind::CarriageReturn) => {\n                self.wtr.write_str(r\"\\r\")\n            }\n            Special(ast::SpecialLiteralKind::VerticalTab) => {\n                self.wtr.write_str(r\"\\v\")\n            }\n            Special(ast::SpecialLiteralKind::Space) => {\n                self.wtr.write_str(r\"\\ \")\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_repetition":["fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result{\n        use ast::RepetitionKind::*;\n        match ast.op.kind {\n            ZeroOrOne if ast.greedy => self.wtr.write_str(\"?\"),\n            ZeroOrOne => self.wtr.write_str(\"??\"),\n            ZeroOrMore if ast.greedy => self.wtr.write_str(\"*\"),\n            ZeroOrMore => self.wtr.write_str(\"*?\"),\n            OneOrMore if ast.greedy => self.wtr.write_str(\"+\"),\n            OneOrMore => self.wtr.write_str(\"+?\"),\n            Range(ref x) => {\n                self.fmt_repetition_range(x)?;\n                if !ast.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_repetition_range":["fn fmt_repetition_range(\n        &mut self,\n        ast: &ast::RepetitionRange,\n    ) -> fmt::Result{\n        use ast::RepetitionRange::*;\n        match *ast {\n            Exactly(x) => write!(self.wtr, \"{{{}}}\", x),\n            AtLeast(x) => write!(self.wtr, \"{{{},}}\", x),\n            Bounded(x, y) => write!(self.wtr, \"{{{},{}}}\", x, y),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<'p, W>::fmt_set_flags":["fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result{\n        self.wtr.write_str(\"(?\")?;\n        self.fmt_flags(&ast.flags)?;\n        self.wtr.write_str(\")\")?;\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::visitor::ClassFrame":["/// Represents a single stack frame while performing structural induction over\n/// a character class.\nenum ClassFrame<'a> {\n    /// The stack frame used while visiting every child node of a union of\n    /// character class items.\n    Union {\n        /// The child node we are currently visiting.\n        head: &'a ast::ClassSetItem,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [ast::ClassSetItem],\n    },\n    /// The stack frame used while a binary class operation.\n    Binary { op: &'a ast::ClassSetBinaryOp },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// left hand child node.\n    BinaryLHS {\n        op: &'a ast::ClassSetBinaryOp,\n        lhs: &'a ast::ClassSet,\n        rhs: &'a ast::ClassSet,\n    },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// right hand child node.\n    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassFrame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child class node to visit.\nfn child(&self) -> ClassInduct<'a>{\n        match *self {\n            ClassFrame::Union { head, .. } => ClassInduct::Item(head),\n            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),\n            ClassFrame::BinaryLHS { ref lhs, .. } => {\n                ClassInduct::from_set(lhs)\n            }\n            ClassFrame::BinaryRHS { ref rhs, .. } => {\n                ClassInduct::from_set(rhs)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct":["/// A representation of the inductive step when performing structural induction\n/// over a character class.\n///\n/// Note that there is no analogous explicit type for the inductive step for\n/// `Ast` nodes because the inductive step is just an `Ast`. For character\n/// classes, the inductive step can produce one of two possible child nodes:\n/// an item or a binary operation. (An item cannot be a binary operation\n/// because that would imply binary operations can be unioned in the concrete\n/// syntax, which is not possible.)\nenum ClassInduct<'a> {\n    Item(&'a ast::ClassSetItem),\n    BinaryOp(&'a ast::ClassSetBinaryOp),\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct::<'a>::from_bracketed":["fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a>{\n        ClassInduct::from_set(&ast.kind)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct::<'a>::from_set":["fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a>{\n        match *ast {\n            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),\n            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Frame":["/// Represents a single stack frame while performing structural induction over\n/// an `Ast`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a ast::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a ast::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Frame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child AST node to visit.\nfn child(&self) -> &'a Ast{\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor":["/// HeapVisitor visits every item in an `Ast` recursively using constant stack\n/// size and a heap size proportional to the size of the `Ast`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Ast` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Ast, Frame<'a>)>,\n    /// Similar to the `Ast` stack above, but is used only for character\n    /// classes. In particular, character classes embed their own mini\n    /// recursive syntax.\n    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::induct":["/// Build a stack frame for the given AST if one is needed (which occurs if\n/// and only if there are child nodes in the AST). Otherwise, return None.\n///\n/// If this visits a class, then the underlying visitor implementation may\n/// return an error which will be passed on here.\nfn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err>{\n        Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => Some(Frame::Alternation {\n                head: &x.asts[0],\n                tail: &x.asts[1..],\n            }),\n            _ => None,\n        })\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::induct_class":["/// Build a stack frame for the given class node if one is needed (which\n/// occurs if and only if there are child nodes). Otherwise, return None.\nfn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>>{\n        match *ast {\n            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {\n                match x.kind {\n                    ast::ClassSet::Item(ref item) => {\n                        Some(ClassFrame::Union { head: item, tail: &[] })\n                    }\n                    ast::ClassSet::BinaryOp(ref op) => {\n                        Some(ClassFrame::Binary { op: op })\n                    }\n                }\n            }\n            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {\n                if x.items.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n                }\n            }\n            ClassInduct::BinaryOp(op) => Some(ClassFrame::BinaryLHS {\n                op: op,\n                lhs: &op.lhs,\n                rhs: &op.rhs,\n            }),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::new":["fn new() -> HeapVisitor<'a>{\n        HeapVisitor { stack: vec![], stack_class: vec![] }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::pop":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>>{\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::pop_class":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>>{\n        match induct {\n            ClassFrame::Union { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            ClassFrame::Binary { .. } => None,\n            ClassFrame::BinaryLHS { op, rhs, .. } => {\n                Some(ClassFrame::BinaryRHS { op: op, rhs: rhs })\n            }\n            ClassFrame::BinaryRHS { .. } => None,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit":["fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err>{\n        self.stack.clear();\n        self.stack_class.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(ast)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this AST, so we can post visit it now.\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class":["fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        let mut ast = ClassInduct::from_bracketed(ast);\n        loop {\n            self.visit_class_pre(&ast, visitor)?;\n            if let Some(x) = self.induct_class(&ast) {\n                let child = x.child();\n                self.stack_class.push((ast, x));\n                ast = child;\n                continue;\n            }\n            self.visit_class_post(&ast, visitor)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack_class.pop() {\n                    None => return Ok(()),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a union or a binary op, then we might have\n                // additional inductive steps to process.\n                if let Some(x) = self.pop_class(frame) {\n                    if let ClassFrame::BinaryRHS { ref op, .. } = x {\n                        visitor.visit_class_set_binary_op_in(op)?;\n                    }\n                    ast = x.child();\n                    self.stack_class.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this class node, so we can post visit it now.\n                self.visit_class_post(&post_ast, visitor)?;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["/// Call the appropriate `Visitor` methods given an inductive step.\nfn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_post(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_post(op)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["/// Call the appropriate `Visitor` methods given an inductive step.\nfn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_pre(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_pre(op)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor":["/// A trait for visiting an abstract syntax tree (AST) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on an abstract syntax tree without necessarily using recursion.\n/// In particular, this permits callers to do case analysis with constant stack\n/// usage, which can be important since the size of an abstract syntax tree\n/// may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`](fn.visit.html) function.\n///\n/// Note that the abstract syntax tree for a regular expression is quite\n/// complex. Unless you specifically need it, you might be able to use the\n/// much simpler\n/// [high-level intermediate representation](../hir/struct.Hir.html)\n/// and its\n/// [corresponding `Visitor` trait](../hir/trait.Visitor.html)\n/// instead.\npub trait Visitor {\n    /// The result of visiting an AST.\n    type Output;\n    /// An error that visiting an AST might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the AST or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the AST.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Ast` before descending into child `Ast`\n    /// nodes.\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Ast` after descending all of its child\n    /// `Ast` nodes.\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an\n    /// [`Alternation`](struct.Alternation.html).\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetItem`](enum.ClassSetItem.html)\n    /// before descending into child nodes.\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetItem`](enum.ClassSetItem.html)\n    /// after descending into child nodes.\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n    /// before descending into child nodes.\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n    /// after descending into child nodes.\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between the left hand and right hand child nodes\n    /// of a [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html).\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::start":["/// This method is called before beginning traversal of the AST.\nfn start(&mut self){}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_alternation_in":["/// This method is called between child nodes of an\n/// [`Alternation`](struct.Alternation.html).\nfn visit_alternation_in(&mut self) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_in":["/// This method is called between the left hand and right hand child nodes\n/// of a [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html).\nfn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_post":["/// This method is called on every\n/// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n/// after descending into child nodes.\nfn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["/// This method is called on every\n/// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n/// before descending into child nodes.\nfn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_item_post":["/// This method is called on every\n/// [`ClassSetItem`](enum.ClassSetItem.html)\n/// after descending into child nodes.\nfn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_item_pre":["/// This method is called on every\n/// [`ClassSetItem`](enum.ClassSetItem.html)\n/// before descending into child nodes.\nfn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_post":["/// This method is called on an `Ast` after descending all of its child\n/// `Ast` nodes.\nfn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_pre":["/// This method is called on an `Ast` before descending into child `Ast`\n/// nodes.\nfn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::visit":["/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Ast` while calling the\n/// appropriate methods provided by the\n/// [`Visitor`](trait.Visitor.html) trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Ast` without using a stack size proportional to the depth\n/// of the `Ast`. Namely, this method will instead use constant stack size, but\n/// will use heap space proportional to the size of the `Ast`. This may be\n/// desirable in cases where the size of `Ast` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err>{\n    HeapVisitor::new().visit(ast, visitor)\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"either::Either":["/// A simple binary sum type.\n///\n/// This is occasionally useful in an ad hoc fashion.\npub enum Either<Left, Right> {\n    Left(Left),\n    Right(Right),\n}","Real(LocalPath(\"src/either.rs\"))"],"error::Error":["/// This error type encompasses any error that can be returned by this crate.\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Formatter":["/// A helper type for formatting nice error messages.\n///\n/// This type is responsible for reporting regex parse errors in a nice human\n/// readable format. Most of its complexity is from interspersing notational\n/// markers pointing out the position where an error occurred.\npub struct Formatter<'e, E: 'e> {\n    /// The original regex pattern in which the error occurred.\n    pattern: &'e str,\n    /// The error kind. It must impl fmt::Display.\n    err: &'e E,\n    /// The primary span of the error.\n    span: &'e ast::Span,\n    /// An auxiliary and optional span, in case the error needs to point to\n    /// two locations (e.g., when reporting a duplicate capture group name).\n    aux_span: Option<&'e ast::Span>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Spans":["/// This type represents an arbitrary number of error spans in a way that makes\n/// it convenient to notate the regex pattern. (\"Notate\" means \"point out\n/// exactly where the error occurred in the regex pattern.\")\n///\n/// Technically, we can only ever have two spans given our current error\n/// structure. However, after toiling with a specific algorithm for handling\n/// two spans, it became obvious that an algorithm to handle an arbitrary\n/// number of spans was actually much simpler.\nstruct Spans<'p> {\n    /// The original regex pattern string.\n    pattern: &'p str,\n    /// The total width that should be used for line numbers. The width is\n    /// used for left padding the line numbers for alignment.\n    ///\n    /// A value of `0` means line numbers should not be displayed. That is,\n    /// the pattern is itself only one line.\n    line_number_width: usize,\n    /// All error spans that occur on a single line. This sequence always has\n    /// length equivalent to the number of lines in `pattern`, where the index\n    /// of the sequence represents a line number, starting at `0`. The spans\n    /// in each line are sorted in ascending order.\n    by_line: Vec<Vec<ast::Span>>,\n    /// All error spans that occur over one or more lines. That is, the start\n    /// and end position of the span have different line numbers. The spans are\n    /// sorted in ascending order.\n    multi_line: Vec<ast::Span>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::add":["/// Add the given span to this sequence, putting it in the right place.\nfn add(&mut self, span: ast::Span){\n        // This is grossly inefficient since we sort after each add, but right\n        // now, we only ever add two spans at most.\n        if span.is_one_line() {\n            let i = span.start.line - 1; // because lines are 1-indexed\n            self.by_line[i].push(span);\n            self.by_line[i].sort();\n        } else {\n            self.multi_line.push(span);\n            self.multi_line.sort();\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::from_formatter":["/// Build a sequence of spans from a formatter.\nfn from_formatter<'e, E: fmt::Display>(\n        fmter: &'p Formatter<'e, E>,\n    ) -> Spans<'p>{\n        let mut line_count = fmter.pattern.lines().count();\n        // If the pattern ends with a `\\n` literal, then our line count is\n        // off by one, since a span can occur immediately after the last `\\n`,\n        // which is consider to be an additional line.\n        if fmter.pattern.ends_with('\\n') {\n            line_count += 1;\n        }\n        let line_number_width =\n            if line_count <= 1 { 0 } else { line_count.to_string().len() };\n        let mut spans = Spans {\n            pattern: &fmter.pattern,\n            line_number_width: line_number_width,\n            by_line: vec![vec![]; line_count],\n            multi_line: vec![],\n        };\n        spans.add(fmter.span.clone());\n        if let Some(span) = fmter.aux_span {\n            spans.add(span.clone());\n        }\n        spans\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::left_pad_line_number":["/// Left pad the given line number with spaces such that it is aligned with\n/// other line numbers.\nfn left_pad_line_number(&self, n: usize) -> String{\n        let n = n.to_string();\n        let pad = self.line_number_width.checked_sub(n.len()).unwrap();\n        let mut result = repeat_char(' ', pad);\n        result.push_str(&n);\n        result\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::line_number_padding":["/// Return the line number padding beginning at the start of each line of\n/// the pattern.\n///\n/// If the pattern is only one line, then this returns a fixed padding\n/// for visual indentation.\nfn line_number_padding(&self) -> usize{\n        if self.line_number_width == 0 {\n            4\n        } else {\n            2 + self.line_number_width\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::notate":["/// Notate the pattern string with carents (`^`) pointing at each span\n/// location. This only applies to spans that occur within a single line.\nfn notate(&self) -> String{\n        let mut notated = String::new();\n        for (i, line) in self.pattern.lines().enumerate() {\n            if self.line_number_width > 0 {\n                notated.push_str(&self.left_pad_line_number(i + 1));\n                notated.push_str(\": \");\n            } else {\n                notated.push_str(\"    \");\n            }\n            notated.push_str(line);\n            notated.push('\\n');\n            if let Some(notes) = self.notate_line(i) {\n                notated.push_str(&notes);\n                notated.push('\\n');\n            }\n        }\n        notated\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::notate_line":["/// Return notes for the line indexed at `i` (zero-based). If there are no\n/// spans for the given line, then `None` is returned. Otherwise, an\n/// appropriately space padded string with correctly positioned `^` is\n/// returned, accounting for line numbers.\nfn notate_line(&self, i: usize) -> Option<String>{\n        let spans = &self.by_line[i];\n        if spans.is_empty() {\n            return None;\n        }\n        let mut notes = String::new();\n        for _ in 0..self.line_number_padding() {\n            notes.push(' ');\n        }\n        let mut pos = 0;\n        for span in spans {\n            for _ in pos..(span.start.column - 1) {\n                notes.push(' ');\n                pos += 1;\n            }\n            let note_len = span.end.column.saturating_sub(span.start.column);\n            for _ in 0..cmp::max(1, note_len) {\n                notes.push('^');\n                pos += 1;\n            }\n        }\n        Some(notes)\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::repeat_char":["fn repeat_char(c: char, count: usize) -> String{\n    ::std::iter::repeat(c).take(count).collect()\n}","Real(LocalPath(\"src/error.rs\"))"],"escape":["/// Escapes all regular expression meta characters in `text`.\n///\n/// The string returned may be safely used as a literal in a regular\n/// expression.\npub fn escape(text: &str) -> String{\n    let mut quoted = String::new();\n    escape_into(text, &mut quoted);\n    quoted\n}","Real(LocalPath(\"src/lib.rs\"))"],"escape_into":["/// Escapes all meta characters in `text` and writes the result into `buf`.\n///\n/// This will append escape characters into the given buffer. The characters\n/// that are appended are safe to use as a literal in a regular expression.\npub fn escape_into(text: &str, buf: &mut String){\n    buf.reserve(text.len());\n    for c in text.chars() {\n        if is_meta_character(c) {\n            buf.push('\\\\');\n        }\n        buf.push(c);\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"hir::Anchor":["/// The high-level intermediate representation for an anchor assertion.\n///\n/// A matching anchor assertion is always zero-length.\npub enum Anchor {\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLine,\n    /// Match the end of a line or the end of text. Specifically,\n    /// this matches at the end position of the input, or at the position\n    /// immediately preceding a `\\n` character.\n    EndLine,\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    StartText,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    EndText,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class":["/// The high-level intermediate representation of a character class.\n///\n/// A character class corresponds to a set of characters. A character is either\n/// defined by a Unicode scalar value or a byte. Unicode characters are used\n/// by default, while bytes are used when Unicode mode (via the `u` flag) is\n/// disabled.\n///\n/// A character class, regardless of its character type, is represented by a\n/// sequence of non-overlapping non-adjacent ranges of characters.\n///\n/// Note that unlike [`Literal`](enum.Literal.html), a `Bytes` variant may\n/// be produced even when it exclusively matches valid UTF-8. This is because\n/// a `Bytes` variant represents an intention by the author of the regular\n/// expression to disable Unicode mode, which in turn impacts the semantics of\n/// case insensitive matching. For example, `(?i)k` and `(?i-u)k` will not\n/// match the same set of strings.\npub enum Class {\n    /// A set of characters represented by Unicode scalar values.\n    Unicode(ClassUnicode),\n    /// A set of characters represented by arbitrary bytes (one byte per\n    /// character).\n    Bytes(ClassBytes),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::case_fold_simple":["/// Apply Unicode simple case folding to this character class, in place.\n/// The character class will be expanded to include all simple case folded\n/// character variants.\n///\n/// If this is a byte oriented character class, then this will be limited\n/// to the ASCII ranges `A-Z` and `a-z`.\npub fn case_fold_simple(&mut self){\n        match *self {\n            Class::Unicode(ref mut x) => x.case_fold_simple(),\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::is_always_utf8":["/// Returns true if and only if this character class will only ever match\n/// valid UTF-8.\n///\n/// A character class can match invalid UTF-8 only when the following\n/// conditions are met:\n///\n/// 1. The translator was configured to permit generating an expression\n///    that can match invalid UTF-8. (By default, this is disabled.)\n/// 2. Unicode mode (via the `u` flag) was disabled either in the concrete\n///    syntax or in the parser builder. By default, Unicode mode is\n///    enabled.\npub fn is_always_utf8(&self) -> bool{\n        match *self {\n            Class::Unicode(_) => true,\n            Class::Bytes(ref x) => x.is_all_ascii(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::negate":["/// Negate this character class in place.\n///\n/// After completion, this character class will contain precisely the\n/// characters that weren't previously in the class.\npub fn negate(&mut self){\n        match *self {\n            Class::Unicode(ref mut x) => x.negate(),\n            Class::Bytes(ref mut x) => x.negate(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes":["/// A set of characters represented by arbitrary bytes (where one byte\n/// corresponds to one character).\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters. For example, if this class consists of the range `a-z`,\n/// then applying case folding will result in the class containing both the\n/// ranges `a-z` and `A-Z`.\n///\n/// Note that this only applies ASCII case folding, which is limited to the\n/// characters `a-z` and `A-Z`.\npub fn case_fold_simple(&mut self){\n        self.set.case_fold_simple().expect(\"ASCII case folding never fails\");\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::difference":["/// Subtract the given byte class from this byte class, in place.\npub fn difference(&mut self, other: &ClassBytes){\n        self.set.difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::empty":["/// Create a new class with no ranges.\npub fn empty() -> ClassBytes{\n        ClassBytes::new(vec![])\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::intersect":["/// Intersect this byte class with the given byte class, in place.\npub fn intersect(&mut self, other: &ClassBytes){\n        self.set.intersect(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::is_all_ascii":["/// Returns true if and only if this character class will either match\n/// nothing or only ASCII bytes. Stated differently, this returns false\n/// if and only if this class contains a non-ASCII byte.\npub fn is_all_ascii(&self) -> bool{\n        self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::iter":["/// Return an iterator over all ranges in this class.\n///\n/// The iterator yields ranges in ascending order.\npub fn iter(&self) -> ClassBytesIter{\n        ClassBytesIter(self.set.iter())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::negate":["/// Negate this byte class.\n///\n/// For all `b` where `b` is a any byte, if `b` was in this set, then it\n/// will not be in this set after negation.\npub fn negate(&mut self){\n        self.set.negate();\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::new":["/// Create a new class from a sequence of ranges.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap.\npub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,{\n        ClassBytes { set: IntervalSet::new(ranges) }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::push":["/// Add a new range to this set.\npub fn push(&mut self, range: ClassBytesRange){\n        self.set.push(range);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::ranges":["/// Return the underlying ranges as a slice.\npub fn ranges(&self) -> &[ClassBytesRange]{\n        self.set.intervals()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::symmetric_difference":["/// Compute the symmetric difference of the given byte classes, in place.\n///\n/// This computes the symmetric difference of two byte classes. This\n/// removes all elements in this class that are also in the given class,\n/// but all adds all elements from the given class that aren't in this\n/// class. That is, the class will contain all elements in either class,\n/// but will not contain any elements that are in both classes.\npub fn symmetric_difference(&mut self, other: &ClassBytes){\n        self.set.symmetric_difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::union":["/// Union this byte class with the given byte class, in place.\npub fn union(&mut self, other: &ClassBytes){\n        self.set.union(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesIter":["/// An iterator over all ranges in a byte character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\npub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange":["/// A single range of characters represented by arbitrary bytes.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::end":["/// Return the end of this range.\n///\n/// The end of a range is always greater than or equal to the start of the\n/// range.\npub fn end(&self) -> u8{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::new":["/// Create a new byte range for a character class.\n///\n/// The returned range is always in a canonical form. That is, the range\n/// returned always satisfies the invariant that `start <= end`.\npub fn new(start: u8, end: u8) -> ClassBytesRange{\n        ClassBytesRange::create(start, end)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::start":["/// Return the start of this range.\n///\n/// The start of a range is always less than or equal to the end of the\n/// range.\npub fn start(&self) -> u8{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode":["/// A set of characters represented by Unicode scalar values.\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters, according to Unicode's \"simple\" mapping. For example, if\n/// this class consists of the range `a-z`, then applying case folding will\n/// result in the class containing both the ranges `a-z` and `A-Z`.\n///\n/// # Panics\n///\n/// This routine panics when the case mapping data necessary for this\n/// routine to complete is unavailable. This occurs when the `unicode-case`\n/// feature is not enabled.\n///\n/// Callers should prefer using `try_case_fold_simple` instead, which will\n/// return an error instead of panicking.\npub fn case_fold_simple(&mut self){\n        self.set\n            .case_fold_simple()\n            .expect(\"unicode-case feature must be enabled\");\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::difference":["/// Subtract the given character class from this character class, in place.\npub fn difference(&mut self, other: &ClassUnicode){\n        self.set.difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::empty":["/// Create a new class with no ranges.\npub fn empty() -> ClassUnicode{\n        ClassUnicode::new(vec![])\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::intersect":["/// Intersect this character class with the given character class, in\n/// place.\npub fn intersect(&mut self, other: &ClassUnicode){\n        self.set.intersect(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::is_all_ascii":["/// Returns true if and only if this character class will either match\n/// nothing or only ASCII bytes. Stated differently, this returns false\n/// if and only if this class contains a non-ASCII codepoint.\npub fn is_all_ascii(&self) -> bool{\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::iter":["/// Return an iterator over all ranges in this class.\n///\n/// The iterator yields ranges in ascending order.\npub fn iter(&self) -> ClassUnicodeIter{\n        ClassUnicodeIter(self.set.iter())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::negate":["/// Negate this character class.\n///\n/// For all `c` where `c` is a Unicode scalar value, if `c` was in this\n/// set, then it will not be in this set after negation.\npub fn negate(&mut self){\n        self.set.negate();\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::new":["/// Create a new class from a sequence of ranges.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap.\npub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,{\n        ClassUnicode { set: IntervalSet::new(ranges) }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::push":["/// Add a new range to this set.\npub fn push(&mut self, range: ClassUnicodeRange){\n        self.set.push(range);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::ranges":["/// Return the underlying ranges as a slice.\npub fn ranges(&self) -> &[ClassUnicodeRange]{\n        self.set.intervals()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::symmetric_difference":["/// Compute the symmetric difference of the given character classes, in\n/// place.\n///\n/// This computes the symmetric difference of two character classes. This\n/// removes all elements in this class that are also in the given class,\n/// but all adds all elements from the given class that aren't in this\n/// class. That is, the class will contain all elements in either class,\n/// but will not contain any elements that are in both classes.\npub fn symmetric_difference(&mut self, other: &ClassUnicode){\n        self.set.symmetric_difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::try_case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters, according to Unicode's \"simple\" mapping. For example, if\n/// this class consists of the range `a-z`, then applying case folding will\n/// result in the class containing both the ranges `a-z` and `A-Z`.\n///\n/// # Error\n///\n/// This routine returns an error when the case mapping data necessary\n/// for this routine to complete is unavailable. This occurs when the\n/// `unicode-case` feature is not enabled.\npub fn try_case_fold_simple(\n        &mut self,\n    ) -> result::Result<(), CaseFoldError>{\n        self.set.case_fold_simple()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::union":["/// Union this character class with the given character class, in place.\npub fn union(&mut self, other: &ClassUnicode){\n        self.set.union(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeIter":["/// An iterator over all ranges in a Unicode character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\npub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange":["/// A single range of characters represented by Unicode scalar values.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::end":["/// Return the end of this range.\n///\n/// The end of a range is always greater than or equal to the start of the\n/// range.\npub fn end(&self) -> char{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::new":["/// Create a new Unicode scalar value range for a character class.\n///\n/// The returned range is always in a canonical form. That is, the range\n/// returned always satisfies the invariant that `start <= end`.\npub fn new(start: char, end: char) -> ClassUnicodeRange{\n        ClassUnicodeRange::create(start, end)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::start":["/// Return the start of this range.\n///\n/// The start of a range is always less than or equal to the end of the\n/// range.\npub fn start(&self) -> char{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error":["/// An error that can occur while translating an `Ast` to a `Hir`.\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::kind":["/// Return the type of this error.\npub fn kind(&self) -> &ErrorKind{\n        &self.kind\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::pattern":["/// The original pattern string in which this error occurred.\n///\n/// Every span reported by this error is reported in terms of this string.\npub fn pattern(&self) -> &str{\n        &self.pattern\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::span":["/// Return the span at which this error occurred.\npub fn span(&self) -> &Span{\n        &self.span\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ErrorKind":["/// The type of an error that occurred while building an `Hir`.\npub enum ErrorKind {\n    /// This error occurs when a Unicode feature is used when Unicode\n    /// support is disabled. For example `(?-u:\\pL)` would trigger this error.\n    UnicodeNotAllowed,\n    /// This error occurs when translating a pattern that could match a byte\n    /// sequence that isn't UTF-8 and `allow_invalid_utf8` was disabled.\n    InvalidUtf8,\n    /// This occurs when an unrecognized Unicode property name could not\n    /// be found.\n    UnicodePropertyNotFound,\n    /// This occurs when an unrecognized Unicode property value could not\n    /// be found.\n    UnicodePropertyValueNotFound,\n    /// This occurs when a Unicode-aware Perl character class (`\\w`, `\\s` or\n    /// `\\d`) could not be found. This can occur when the `unicode-perl`\n    /// crate feature is not enabled.\n    UnicodePerlClassNotFound,\n    /// This occurs when the Unicode simple case mapping tables are not\n    /// available, and the regular expression required Unicode aware case\n    /// insensitivity.\n    UnicodeCaseUnavailable,\n    /// This occurs when the translator attempts to construct a character class\n    /// that is empty.\n    ///\n    /// Note that this restriction in the translator may be removed in the\n    /// future.\n    EmptyClassNotAllowed,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ErrorKind::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        use self::ErrorKind::*;\n        match *self {\n            UnicodeNotAllowed => \"Unicode not allowed here\",\n            InvalidUtf8 => \"pattern can match invalid UTF-8\",\n            UnicodePropertyNotFound => \"Unicode property not found\",\n            UnicodePropertyValueNotFound => \"Unicode property value not found\",\n            UnicodePerlClassNotFound => {\n                \"Unicode-aware Perl class not found \\\n                 (make sure the unicode-perl feature is enabled)\"\n            }\n            UnicodeCaseUnavailable => {\n                \"Unicode-aware case insensitivity matching is not available \\\n                 (make sure the unicode-case feature is enabled)\"\n            }\n            EmptyClassNotAllowed => \"empty character classes are not allowed\",\n            __Nonexhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Group":["/// The high-level intermediate representation for a group.\n///\n/// This represents one of three possible group types:\n///\n/// 1. A non-capturing group (e.g., `(?:expr)`).\n/// 2. A capturing group (e.g., `(expr)`).\n/// 3. A named capturing group (e.g., `(?P<name>expr)`).\npub struct Group {\n    /// The kind of this group. If it is a capturing group, then the kind\n    /// contains the capture group index (and the name, if it is a named\n    /// group).\n    pub kind: GroupKind,\n    /// The expression inside the capturing group, which may be empty.\n    pub hir: Box<Hir>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::GroupKind":["/// The kind of group.\npub enum GroupKind {\n    /// A normal unnamed capturing group.\n    ///\n    /// The value is the capture index of the group.\n    CaptureIndex(u32),\n    /// A named capturing group.\n    CaptureName {\n        /// The name of the group.\n        name: String,\n        /// The capture index of the group.\n        index: u32,\n    },\n    /// A non-capturing group.\n    NonCapturing,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir":["/// A high-level intermediate representation (HIR) for a regular expression.\n///\n/// The HIR of a regular expression represents an intermediate step between its\n/// abstract syntax (a structured description of the concrete syntax) and\n/// compiled byte codes. The purpose of HIR is to make regular expressions\n/// easier to analyze. In particular, the AST is much more complex than the\n/// HIR. For example, while an AST supports arbitrarily nested character\n/// classes, the HIR will flatten all nested classes into a single set. The HIR\n/// will also \"compile away\" every flag present in the concrete syntax. For\n/// example, users of HIR expressions never need to worry about case folding;\n/// it is handled automatically by the translator (e.g., by translating `(?i)A`\n/// to `[aA]`).\n///\n/// If the HIR was produced by a translator that disallows invalid UTF-8, then\n/// the HIR is guaranteed to match UTF-8 exclusively.\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the HIR.\n///\n/// The specific type of an HIR expression can be accessed via its `kind`\n/// or `into_kind` methods. This extra level of indirection exists for two\n/// reasons:\n///\n/// 1. Construction of an HIR expression *must* use the constructor methods\n///    on this `Hir` type instead of building the `HirKind` values directly.\n///    This permits construction to enforce invariants like \"concatenations\n///    always consist of two or more sub-expressions.\"\n/// 2. Every HIR expression contains attributes that are defined inductively,\n///    and can be computed cheaply during the construction process. For\n///    example, one such attribute is whether the expression must match at the\n///    beginning of the text.\n///\n/// Also, an `Hir`'s `fmt::Display` implementation prints an HIR as a regular\n/// expression pattern string, and uses constant stack space and heap space\n/// proportional to the size of the `Hir`.\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    info: HirInfo,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::alternation":["/// Returns the alternation of the given expressions.\n///\n/// This flattens the alternation as appropriate.\npub fn alternation(mut exprs: Vec<Hir>) -> Hir{\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_anchored_start(true);\n                info.set_anchored_end(true);\n                info.set_line_anchored_start(true);\n                info.set_line_anchored_end(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(false);\n                info.set_literal(false);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_anchored_start() && e.is_anchored_start();\n                    info.set_anchored_start(x);\n\n                    let x = info.is_anchored_end() && e.is_anchored_end();\n                    info.set_anchored_end(x);\n\n                    let x = info.is_line_anchored_start()\n                        && e.is_line_anchored_start();\n                    info.set_line_anchored_start(x);\n\n                    let x = info.is_line_anchored_end()\n                        && e.is_line_anchored_end();\n                    info.set_line_anchored_end(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() || e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_alternation_literal() && e.is_literal();\n                    info.set_alternation_literal(x);\n                }\n                Hir { kind: HirKind::Alternation(exprs), info: info }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::anchor":["/// Creates an anchor assertion HIR expression.\npub fn anchor(anchor: Anchor) -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        if let Anchor::StartText = anchor {\n            info.set_anchored_start(true);\n            info.set_line_anchored_start(true);\n            info.set_any_anchored_start(true);\n        }\n        if let Anchor::EndText = anchor {\n            info.set_anchored_end(true);\n            info.set_line_anchored_end(true);\n            info.set_any_anchored_end(true);\n        }\n        if let Anchor::StartLine = anchor {\n            info.set_line_anchored_start(true);\n        }\n        if let Anchor::EndLine = anchor {\n            info.set_line_anchored_end(true);\n        }\n        Hir { kind: HirKind::Anchor(anchor), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::any":["/// Build an HIR expression for `(?s).`.\n///\n/// A `(?s).` expression matches any character, including `\\n`. To build an\n/// expression that matches any character except for `\\n`, then use the\n/// `dot` method.\n///\n/// If `bytes` is `true`, then this assumes characters are limited to a\n/// single byte.\npub fn any(bytes: bool) -> Hir{\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::class":["/// Creates a class HIR expression.\npub fn class(class: Class) -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(class.is_always_utf8());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Class(class), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::concat":["/// Returns the concatenation of the given expressions.\n///\n/// This flattens the concatenation as appropriate.\npub fn concat(mut exprs: Vec<Hir>) -> Hir{\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(true);\n                info.set_literal(true);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() && e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_literal() && e.is_literal();\n                    info.set_literal(x);\n\n                    let x = info.is_alternation_literal()\n                        && e.is_alternation_literal();\n                    info.set_alternation_literal(x);\n                }\n                // Anchored attributes require something slightly more\n                // sophisticated. Normally, WLOG, to determine whether an\n                // expression is anchored to the start, we'd only need to check\n                // the first expression of a concatenation. However,\n                // expressions like `$\\b^` are still anchored to the start,\n                // but the first expression in the concatenation *isn't*\n                // anchored to the start. So the \"first\" expression to look at\n                // is actually one that is either not an assertion or is\n                // specifically the StartText assertion.\n                info.set_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_start()),\n                );\n                // Similarly for the end anchor, but in reverse.\n                info.set_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_end()),\n                );\n                // Repeat the process for line anchors.\n                info.set_line_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_line_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_start()),\n                );\n                info.set_line_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_line_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_end()),\n                );\n                Hir { kind: HirKind::Concat(exprs), info: info }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::dot":["/// Build an HIR expression for `.`.\n///\n/// A `.` expression matches any character except for `\\n`. To build an\n/// expression that matches any character, including `\\n`, use the `any`\n/// method.\n///\n/// If `bytes` is `true`, then this assumes characters are limited to a\n/// single byte.\npub fn dot(bytes: bool) -> Hir{\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n            cls.push(ClassBytesRange::new(b'\\x0B', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n            cls.push(ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::empty":["/// Returns an empty HIR expression.\n///\n/// An empty HIR expression always matches, including the empty string.\npub fn empty() -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Empty, info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::group":["/// Creates a group HIR expression.\npub fn group(group: Group) -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(group.hir.is_always_utf8());\n        info.set_all_assertions(group.hir.is_all_assertions());\n        info.set_anchored_start(group.hir.is_anchored_start());\n        info.set_anchored_end(group.hir.is_anchored_end());\n        info.set_line_anchored_start(group.hir.is_line_anchored_start());\n        info.set_line_anchored_end(group.hir.is_line_anchored_end());\n        info.set_any_anchored_start(group.hir.is_any_anchored_start());\n        info.set_any_anchored_end(group.hir.is_any_anchored_end());\n        info.set_match_empty(group.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Group(group), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::into_kind":["/// Consumes ownership of this HIR expression and returns its underlying\n/// `HirKind`.\npub fn into_kind(mut self) -> HirKind{\n        use std::mem;\n        mem::replace(&mut self.kind, HirKind::Empty)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_all_assertions":["/// Returns true if and only if this entire HIR expression is made up of\n/// zero-width assertions.\n///\n/// This includes expressions like `^$\\b\\A\\z` and even `((\\b)+())*^`, but\n/// not `^a`.\npub fn is_all_assertions(&self) -> bool{\n        self.info.is_all_assertions()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_alternation_literal":["/// Return true if and only if this HIR is either a simple literal or an\n/// alternation of simple literals. This is only\n/// true when this HIR expression is either itself a `Literal` or a\n/// concatenation of only `Literal`s or an alternation of only `Literal`s.\n///\n/// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation\n/// literals, but `f+`, `(foo)`, `foo()`, ``\n/// are not (even though that contain sub-expressions that are literals).\npub fn is_alternation_literal(&self) -> bool{\n        self.info.is_alternation_literal()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_always_utf8":["/// Return true if and only if this HIR will always match valid UTF-8.\n///\n/// When this returns false, then it is possible for this HIR expression\n/// to match invalid UTF-8.\npub fn is_always_utf8(&self) -> bool{\n        self.info.is_always_utf8()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_anchored_end":["/// Return true if and only if this HIR is required to match at the end\n/// of text. This includes expressions like `foo$`, `(foo|bar)$`,\n/// `foo$|bar$` but not `foo$|bar`.\npub fn is_anchored_end(&self) -> bool{\n        self.info.is_anchored_end()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_anchored_start":["/// Return true if and only if this HIR is required to match from the\n/// beginning of text. This includes expressions like `^foo`, `^(foo|bar)`,\n/// `^foo|^bar` but not `^foo|bar`.\npub fn is_anchored_start(&self) -> bool{\n        self.info.is_anchored_start()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_any_anchored_end":["/// Return true if and only if this HIR contains any sub-expression that is\n/// required to match at the end of text. Specifically, this returns true\n/// if the `$` symbol (when multiline mode is disabled) or the `\\z` escape\n/// appear anywhere in the regex.\npub fn is_any_anchored_end(&self) -> bool{\n        self.info.is_any_anchored_end()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_any_anchored_start":["/// Return true if and only if this HIR contains any sub-expression that\n/// is required to match at the beginning of text. Specifically, this\n/// returns true if the `^` symbol (when multiline mode is disabled) or the\n/// `\\A` escape appear anywhere in the regex.\npub fn is_any_anchored_start(&self) -> bool{\n        self.info.is_any_anchored_start()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_line_anchored_end":["/// Return true if and only if this HIR is required to match at the\n/// end of text or the end of a line. This includes expressions like\n/// `foo$`, `(?m)foo$`, `(foo|bar)$`, `(?m)(foo|bar)$`, `foo$|bar$`,\n/// `(?m)(foo|bar)$`, but not `foo$|bar` or `(?m)foo$|bar`.\n///\n/// Note that if `is_anchored_end` is `true`, then\n/// `is_line_anchored_end` will also be `true`. The reverse implication\n/// is not true. For example, `(?m)foo$` is line anchored, but not\n/// `is_anchored_end`.\npub fn is_line_anchored_end(&self) -> bool{\n        self.info.is_line_anchored_end()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_line_anchored_start":["/// Return true if and only if this HIR is required to match from the\n/// beginning of text or the beginning of a line. This includes expressions\n/// like `^foo`, `(?m)^foo`, `^(foo|bar)`, `^(foo|bar)`, `(?m)^foo|^bar`\n/// but not `^foo|bar` or `(?m)^foo|bar`.\n///\n/// Note that if `is_anchored_start` is `true`, then\n/// `is_line_anchored_start` will also be `true`. The reverse implication\n/// is not true. For example, `(?m)^foo` is line anchored, but not\n/// `is_anchored_start`.\npub fn is_line_anchored_start(&self) -> bool{\n        self.info.is_line_anchored_start()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_literal":["/// Return true if and only if this HIR is a simple literal. This is only\n/// true when this HIR expression is either itself a `Literal` or a\n/// concatenation of only `Literal`s.\n///\n/// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()`,\n/// `` are not (even though that contain sub-expressions that are literals).\npub fn is_literal(&self) -> bool{\n        self.info.is_literal()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::is_match_empty":["/// Return true if and only if the empty string is part of the language\n/// matched by this regular expression.\n///\n/// This includes `a*`, `a?b*`, `a{0}`, `()`, `()+`, `^$`, `a|b?`, `\\B`,\n/// but not `a`, `a+` or `\\b`.\npub fn is_match_empty(&self) -> bool{\n        self.info.is_match_empty()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::kind":["/// Returns a reference to the underlying HIR kind.\npub fn kind(&self) -> &HirKind{\n        &self.kind\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::literal":["/// Creates a literal HIR expression.\n///\n/// If the given literal has a `Byte` variant with an ASCII byte, then this\n/// method panics. This enforces the invariant that `Byte` variants are\n/// only used to express matching of invalid UTF-8.\npub fn literal(lit: Literal) -> Hir{\n        if let Literal::Byte(b) = lit {\n            assert!(b > 0x7F);\n        }\n\n        let mut info = HirInfo::new();\n        info.set_always_utf8(lit.is_unicode());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(true);\n        info.set_alternation_literal(true);\n        Hir { kind: HirKind::Literal(lit), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::repetition":["/// Creates a repetition HIR expression.\npub fn repetition(rep: Repetition) -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(rep.hir.is_always_utf8());\n        info.set_all_assertions(rep.hir.is_all_assertions());\n        // If this operator can match the empty string, then it can never\n        // be anchored.\n        info.set_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_line_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_line_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_any_anchored_start(rep.hir.is_any_anchored_start());\n        info.set_any_anchored_end(rep.hir.is_any_anchored_end());\n        info.set_match_empty(rep.is_match_empty() || rep.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Repetition(rep), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::word_boundary":["/// Creates a word boundary assertion HIR expression.\npub fn word_boundary(word_boundary: WordBoundary) -> Hir{\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        // A negated word boundary matches the empty string, but a normal\n        // word boundary does not!\n        info.set_match_empty(word_boundary.is_negated());\n        // Negated ASCII word boundaries can match invalid UTF-8.\n        if let WordBoundary::AsciiNegate = word_boundary {\n            info.set_always_utf8(false);\n        }\n        Hir { kind: HirKind::WordBoundary(word_boundary), info: info }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo":["/// A type that documents various attributes of an HIR expression.\n///\n/// These attributes are typically defined inductively on the HIR.\nstruct HirInfo {\n    /// Represent yes/no questions by a bitfield to conserve space, since\n    /// this is included in every HIR expression.\n    ///\n    /// If more attributes need to be added, it is OK to increase the size of\n    /// this as appropriate.\n    bools: u16,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_all_assertions":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_alternation_literal":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_always_utf8":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_anchored_end":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_anchored_start":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_any_anchored_end":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_any_anchored_start":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_line_anchored_end":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_line_anchored_start":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_literal":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::is_match_empty":["fn $is_fn_name(&self) -> bool{\n            self.bools & (0b1 << $bit) > 0\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::new":["fn new() -> HirInfo{\n        HirInfo { bools: 0 }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_all_assertions":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_alternation_literal":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_always_utf8":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_anchored_end":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_anchored_start":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_any_anchored_end":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_any_anchored_start":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_line_anchored_end":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_line_anchored_start":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_literal":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirInfo::set_match_empty":["fn $set_fn_name(&mut self, yes: bool){\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirKind":["/// The kind of an arbitrary `Hir` expression.\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A single literal character that matches exactly this character.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    Class(Class),\n    /// An anchor assertion. An anchor assertion match always has zero length.\n    Anchor(Anchor),\n    /// A word boundary assertion, which may or may not be Unicode aware. A\n    /// word boundary assertion match always has zero length.\n    WordBoundary(WordBoundary),\n    /// A repetition operation applied to a child expression.\n    Repetition(Repetition),\n    /// A possibly capturing group, which contains a child expression.\n    Group(Group),\n    /// A concatenation of expressions. A concatenation always has at least two\n    /// child expressions.\n    ///\n    /// A concatenation matches only if each of its child expression matches\n    /// one after the other.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions. An alternation always has at least two\n    /// child expressions.\n    ///\n    /// An alternation matches only if at least one of its child expression\n    /// matches. If multiple expressions match, then the leftmost is preferred.\n    Alternation(Vec<Hir>),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirKind::has_subexprs":["/// Returns true if and only if this kind has any (including possibly\n/// empty) subexpressions.\npub fn has_subexprs(&self) -> bool{\n        match *self {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => false,\n            HirKind::Group(_)\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => true,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirKind::is_empty":["/// Return true if and only if this HIR is the empty regular expression.\n///\n/// Note that this is not defined inductively. That is, it only tests if\n/// this kind is the `Empty` variant. To get the inductive definition,\n/// use the `is_match_empty` method on [`Hir`](struct.Hir.html).\npub fn is_empty(&self) -> bool{\n        match *self {\n            HirKind::Empty => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Literal":["/// The high-level intermediate representation of a literal.\n///\n/// A literal corresponds to a single character, where a character is either\n/// defined by a Unicode scalar value or an arbitrary byte. Unicode characters\n/// are preferred whenever possible. In particular, a `Byte` variant is only\n/// ever produced when it could match invalid UTF-8.\npub enum Literal {\n    /// A single character represented by a Unicode scalar value.\n    Unicode(char),\n    /// A single character represented by an arbitrary byte.\n    Byte(u8),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Literal::is_unicode":["/// Returns true if and only if this literal corresponds to a Unicode\n/// scalar value.\npub fn is_unicode(&self) -> bool{\n        match *self {\n            Literal::Unicode(_) => true,\n            Literal::Byte(b) if b <= 0x7F => true,\n            Literal::Byte(_) => false,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Repetition":["/// The high-level intermediate representation of a repetition operator.\n///\n/// A repetition operator permits the repetition of an arbitrary\n/// sub-expression.\npub struct Repetition {\n    /// The kind of this repetition operator.\n    pub kind: RepetitionKind,\n    /// Whether this repetition operator is greedy or not. A greedy operator\n    /// will match as much as it can. A non-greedy operator will match as\n    /// little as it can.\n    ///\n    /// Typically, operators are greedy by default and are only non-greedy when\n    /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is\n    /// not. However, this can be inverted via the `U` \"ungreedy\" flag.\n    pub greedy: bool,\n    /// The expression being repeated.\n    pub hir: Box<Hir>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Repetition::is_match_empty":["/// Returns true if and only if this repetition operator makes it possible\n/// to match the empty string.\n///\n/// Note that this is not defined inductively. For example, while `a*`\n/// will report `true`, `()+` will not, even though `()` matches the empty\n/// string and one or more occurrences of something that matches the empty\n/// string will always match the empty string. In order to get the\n/// inductive definition, see the corresponding method on\n/// [`Hir`](struct.Hir.html).\npub fn is_match_empty(&self) -> bool{\n        match self.kind {\n            RepetitionKind::ZeroOrOne => true,\n            RepetitionKind::ZeroOrMore => true,\n            RepetitionKind::OneOrMore => false,\n            RepetitionKind::Range(RepetitionRange::Exactly(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::AtLeast(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::Bounded(m, _)) => m == 0,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::RepetitionKind":["/// The kind of a repetition operator.\npub enum RepetitionKind {\n    /// Matches a sub-expression zero or one times.\n    ZeroOrOne,\n    /// Matches a sub-expression zero or more times.\n    ZeroOrMore,\n    /// Matches a sub-expression one or more times.\n    OneOrMore,\n    /// Matches a sub-expression within a bounded range of times.\n    Range(RepetitionRange),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::RepetitionRange":["/// The kind of a counted repetition operator.\npub enum RepetitionRange {\n    /// Matches a sub-expression exactly this many times.\n    Exactly(u32),\n    /// Matches a sub-expression at least this many times.\n    AtLeast(u32),\n    /// Matches a sub-expression at least `m` times and at most `n` times.\n    Bounded(u32, u32),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::WordBoundary":["/// The high-level intermediate representation for a word-boundary assertion.\n///\n/// A matching word boundary assertion is always zero-length.\npub enum WordBoundary {\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Unicode,\n    /// Match a Unicode-aware negation of a word boundary.\n    UnicodeNegate,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Ascii,\n    /// Match an ASCII-only negation of a word boundary.\n    AsciiNegate,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::WordBoundary::is_negated":["/// Returns true if and only if this word boundary assertion is negated.\npub fn is_negated(&self) -> bool{\n        match *self {\n            WordBoundary::Unicode | WordBoundary::Ascii => false,\n            WordBoundary::UnicodeNegate | WordBoundary::AsciiNegate => true,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::interval::Bound":["pub trait Bound:\n    Copy + Clone + Debug + Eq + PartialEq + PartialOrd + Ord\n{\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn as_u32(self) -> u32;\n    fn increment(self) -> Self;\n    fn decrement(self) -> Self;\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval":["pub trait Interval:\n    Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n{\n    type Bound: Bound;\n\n    fn lower(&self) -> Self::Bound;\n    fn upper(&self) -> Self::Bound;\n    fn set_lower(&mut self, bound: Self::Bound);\n    fn set_upper(&mut self, bound: Self::Bound);\n    fn case_fold_simple(\n        &self,\n        intervals: &mut Vec<Self>,\n    ) -> Result<(), unicode::CaseFoldError>;\n\n    /// Create a new interval.\n    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }\n\n    /// Union the given overlapping range into this range.\n    ///\n    /// If the two ranges aren't contiguous, then this returns `None`.\n    fn union(&self, other: &Self) -> Option<Self> {\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }\n\n    /// Intersect this range with the given range and return the result.\n    ///\n    /// If the intersection is empty, then this returns `None`.\n    fn intersect(&self, other: &Self) -> Option<Self> {\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper {\n            Some(Self::create(lower, upper))\n        } else {\n            None\n        }\n    }\n\n    /// Subtract the given range from this range and return the resulting\n    /// ranges.\n    ///\n    /// If subtraction would result in an empty range, then no ranges are\n    /// returned.\n    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        // We know this because !self.is_subset(other) and the ranges have\n        // a non-empty intersection.\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }\n\n    /// Compute the symmetric difference the given range from this range. This\n    /// returns the union of the two ranges minus its intersection.\n    fn symmetric_difference(\n        &self,\n        other: &Self,\n    ) -> (Option<Self>, Option<Self>) {\n        let union = match self.union(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(union) => union,\n        };\n        let intersection = match self.intersect(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(intersection) => intersection,\n        };\n        union.difference(&intersection)\n    }\n\n    /// Returns true if and only if the two ranges are contiguous. Two ranges\n    /// are contiguous if and only if the ranges are either overlapping or\n    /// adjacent.\n    fn is_contiguous(&self, other: &Self) -> bool {\n        let lower1 = self.lower().as_u32();\n        let upper1 = self.upper().as_u32();\n        let lower2 = other.lower().as_u32();\n        let upper2 = other.upper().as_u32();\n        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)\n    }\n\n    /// Returns true if and only if the intersection of this range and the\n    /// other range is empty.\n    fn is_intersection_empty(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)\n    }\n\n    /// Returns true if and only if this range is a subset of the other range.\n    fn is_subset(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        (lower2 <= lower1 && lower1 <= upper2)\n            && (lower2 <= upper1 && upper1 <= upper2)\n    }\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::create":["/// Create a new interval.\nfn create(lower: Self::Bound, upper: Self::Bound) -> Self{\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::difference":["/// Subtract the given range from this range and return the resulting\n/// ranges.\n///\n/// If subtraction would result in an empty range, then no ranges are\n/// returned.\nfn difference(&self, other: &Self) -> (Option<Self>, Option<Self>){\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        // We know this because !self.is_subset(other) and the ranges have\n        // a non-empty intersection.\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::intersect":["/// Intersect this range with the given range and return the result.\n///\n/// If the intersection is empty, then this returns `None`.\nfn intersect(&self, other: &Self) -> Option<Self>{\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper {\n            Some(Self::create(lower, upper))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_contiguous":["/// Returns true if and only if the two ranges are contiguous. Two ranges\n/// are contiguous if and only if the ranges are either overlapping or\n/// adjacent.\nfn is_contiguous(&self, other: &Self) -> bool{\n        let lower1 = self.lower().as_u32();\n        let upper1 = self.upper().as_u32();\n        let lower2 = other.lower().as_u32();\n        let upper2 = other.upper().as_u32();\n        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_intersection_empty":["/// Returns true if and only if the intersection of this range and the\n/// other range is empty.\nfn is_intersection_empty(&self, other: &Self) -> bool{\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_subset":["/// Returns true if and only if this range is a subset of the other range.\nfn is_subset(&self, other: &Self) -> bool{\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        (lower2 <= lower1 && lower1 <= upper2)\n            && (lower2 <= upper1 && upper1 <= upper2)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::symmetric_difference":["/// Compute the symmetric difference the given range from this range. This\n/// returns the union of the two ranges minus its intersection.\nfn symmetric_difference(\n        &self,\n        other: &Self,\n    ) -> (Option<Self>, Option<Self>){\n        let union = match self.union(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(union) => union,\n        };\n        let intersection = match self.intersect(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(intersection) => intersection,\n        };\n        union.difference(&intersection)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::union":["/// Union the given overlapping range into this range.\n///\n/// If the two ranges aren't contiguous, then this returns `None`.\nfn union(&self, other: &Self) -> Option<Self>{\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet":["pub struct IntervalSet<I> {\n    ranges: Vec<I>,\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::canonicalize":["/// Converts this set into a canonical ordering.\nfn canonicalize(&mut self){\n        if self.is_canonical() {\n            return;\n        }\n        self.ranges.sort();\n        assert!(!self.ranges.is_empty());\n\n        // Is there a way to do this in-place with constant memory? I couldn't\n        // figure out a way to do it. So just append the canonicalization to\n        // the end of this range, and then drain it before we're done.\n        let drain_end = self.ranges.len();\n        for oldi in 0..drain_end {\n            // If we've added at least one new range, then check if we can\n            // merge this range in the previously added range.\n            if self.ranges.len() > drain_end {\n                let (last, rest) = self.ranges.split_last_mut().unwrap();\n                if let Some(union) = last.union(&rest[oldi]) {\n                    *last = union;\n                    continue;\n                }\n            }\n            let range = self.ranges[oldi];\n            self.ranges.push(range);\n        }\n        self.ranges.drain(..drain_end);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::case_fold_simple":["/// Expand this interval set such that it contains all case folded\n/// characters. For example, if this class consists of the range `a-z`,\n/// then applying case folding will result in the class containing both the\n/// ranges `a-z` and `A-Z`.\n///\n/// This returns an error if the necessary case mapping data is not\n/// available.\npub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError>{\n        let len = self.ranges.len();\n        for i in 0..len {\n            let range = self.ranges[i];\n            if let Err(err) = range.case_fold_simple(&mut self.ranges) {\n                self.canonicalize();\n                return Err(err);\n            }\n        }\n        self.canonicalize();\n        Ok(())\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::difference":["/// Subtract the given set from this set, in place.\npub fn difference(&mut self, other: &IntervalSet<I>){\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n\n        // This algorithm is (to me) surprisingly complex. A search of the\n        // interwebs indicate that this is a potentially interesting problem.\n        // Folks seem to suggest interval or segment trees, but I'd like to\n        // avoid the overhead (both runtime and conceptual) of that.\n        //\n        // The following is basically my Shitty First Draft. Therefore, in\n        // order to grok it, you probably need to read each line carefully.\n        // Simplifications are most welcome!\n        //\n        // Remember, we can assume the canonical format invariant here, which\n        // says that all ranges are sorted, not overlapping and not adjacent in\n        // each class.\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            // Basically, the easy cases are when neither range overlaps with\n            // each other. If the `b` range is less than our current `a`\n            // range, then we can skip it and move on.\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            // ... similarly for the `a` range. If it's less than the smallest\n            // `b` range, then we can add it as-is.\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            // Otherwise, we have overlapping ranges.\n            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n\n            // This part is tricky and was non-obvious to me without looking\n            // at explicit examples (see the tests). The trickiness stems from\n            // two things: 1) subtracting a range from another range could\n            // yield two ranges and 2) after subtracting a range, it's possible\n            // that future ranges can have an impact. The loop below advances\n            // the `b` ranges until they can't possible impact the current\n            // range.\n            //\n            // For example, if our `a` range is `a-t` and our next three `b`\n            // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n            // subtraction three times before moving on to the next `a` range.\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        // We lost the entire range, so move on to the next\n                        // without adding this one.\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                // It's possible that the `b` range has more to contribute\n                // here. In particular, if it is greater than the original\n                // range, then it might impact the next `a` range *and* it\n                // has impacted the current `a` range as much as possible,\n                // so we can quit. We don't bump `b` so that the next `a`\n                // range can apply it.\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                // Otherwise, the next `b` range might apply to the current\n                // `a` range.\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::intersect":["/// Intersect this set with the given set, in place.\npub fn intersect(&mut self, other: &IntervalSet<I>){\n        if self.ranges.is_empty() {\n            return;\n        }\n        if other.ranges.is_empty() {\n            self.ranges.clear();\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the intersection to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        let mut ita = (0..drain_end).into_iter();\n        let mut itb = (0..other.ranges.len()).into_iter();\n        let mut a = ita.next().unwrap();\n        let mut b = itb.next().unwrap();\n        loop {\n            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {\n                self.ranges.push(ab);\n            }\n            let (it, aorb) =\n                if self.ranges[a].upper() < other.ranges[b].upper() {\n                    (&mut ita, &mut a)\n                } else {\n                    (&mut itb, &mut b)\n                };\n            match it.next() {\n                Some(v) => *aorb = v,\n                None => break,\n            }\n        }\n        self.ranges.drain(..drain_end);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::intervals":["/// Return an immutable slice of intervals in this set.\n///\n/// The sequence returned is in canonical ordering.\npub fn intervals(&self) -> &[I]{\n        &self.ranges\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::is_canonical":["/// Returns true if and only if this class is in a canonical ordering.\nfn is_canonical(&self) -> bool{\n        for pair in self.ranges.windows(2) {\n            if pair[0] >= pair[1] {\n                return false;\n            }\n            if pair[0].is_contiguous(&pair[1]) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::iter":["/// Return an iterator over all intervals in this set.\n///\n/// The iterator yields intervals in ascending order.\npub fn iter(&self) -> IntervalSetIter<I>{\n        IntervalSetIter(self.ranges.iter())\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::negate":["/// Negate this interval set.\n///\n/// For all `x` where `x` is any element, if `x` was in this set, then it\n/// will not be in this set after negation.\npub fn negate(&mut self){\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the negation to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        // We do checked arithmetic below because of the canonical ordering\n        // invariant.\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::new":["/// Create a new set from a sequence of intervals. Each interval is\n/// specified as a pair of bounds, where both bounds are inclusive.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap.\npub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I>{\n        let mut set = IntervalSet { ranges: intervals.into_iter().collect() };\n        set.canonicalize();\n        set\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::push":["/// Add a new interval to this set.\npub fn push(&mut self, interval: I){\n        // TODO: This could be faster. e.g., Push the interval such that\n        // it preserves canonicalization.\n        self.ranges.push(interval);\n        self.canonicalize();\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::symmetric_difference":["/// Compute the symmetric difference of the two sets, in place.\n///\n/// This computes the symmetric difference of two interval sets. This\n/// removes all elements in this set that are also in the given set,\n/// but also adds all elements from the given set that aren't in this\n/// set. That is, the set will contain all elements in either set,\n/// but will not contain any elements that are in both sets.\npub fn symmetric_difference(&mut self, other: &IntervalSet<I>){\n        // TODO(burntsushi): Fix this so that it amortizes allocation.\n        let mut intersection = self.clone();\n        intersection.intersect(other);\n        self.union(other);\n        self.difference(&intersection);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::union":["/// Union this set with the given set, in place.\npub fn union(&mut self, other: &IntervalSet<I>){\n        // This could almost certainly be done more efficiently.\n        self.ranges.extend(&other.ranges);\n        self.canonicalize();\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSetIter":["/// An iterator over intervals.\npub struct IntervalSetIter<'a, I: 'a>(slice::Iter<'a, I>);","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::literal::Literal":["/// A single member of a set of literals extracted from a regular expression.\n///\n/// This type has `Deref` and `DerefMut` impls to `Vec<u8>` so that all slice\n/// and `Vec` operations are available.\npub struct Literal {\n    v: Vec<u8>,\n    cut: bool,\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literal::cut":["/// Cuts this literal.\npub fn cut(&mut self){\n        self.cut = true;\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literal::empty":["/// Returns a new complete empty literal.\npub fn empty() -> Literal{\n        Literal { v: vec![], cut: false }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literal::is_cut":["/// Returns true if this literal was \"cut.\"\npub fn is_cut(&self) -> bool{\n        self.cut\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literal::new":["/// Returns a new complete literal with the bytes given.\npub fn new(bytes: Vec<u8>) -> Literal{\n        Literal { v: bytes, cut: false }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals":["/// A set of literal byte strings extracted from a regular expression.\n///\n/// Every member of the set is a `Literal`, which is represented by a\n/// `Vec<u8>`. (Notably, it may contain invalid UTF-8.) Every member is\n/// said to be either *complete* or *cut*. A complete literal means that\n/// it extends until the beginning (or end) of the regular expression. In\n/// some circumstances, this can be used to indicate a match in the regular\n/// expression.\n///\n/// A key aspect of literal extraction is knowing when to stop. It is not\n/// feasible to blindly extract all literals from a regular expression, even if\n/// there are finitely many. For example, the regular expression `[0-9]{10}`\n/// has `10^10` distinct literals. For this reason, literal extraction is\n/// bounded to some low number by default using heuristics, but the limits can\n/// be tweaked.\n///\n/// **WARNING**: Literal extraction uses stack space proportional to the size\n/// of the `Hir` expression. At some point, this drawback will be eliminated.\n/// To protect yourself, set a reasonable\n/// [`nest_limit` on your `Parser`](../../struct.ParserBuilder.html#method.nest_limit).\n/// This is done for you by default.\npub struct Literals {\n    lits: Vec<Literal>,\n    limit_size: usize,\n    limit_class: usize,\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::_add_char_class":["fn _add_char_class(\n        &mut self,\n        cls: &hir::ClassUnicode,\n        reverse: bool,\n    ) -> bool{\n        use std::char;\n\n        if self.class_exceeds_limits(cls_char_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for c in (s..e).filter_map(char::from_u32) {\n                for mut lit in base.clone() {\n                    let mut bytes = c.to_string().into_bytes();\n                    if reverse {\n                        bytes.reverse();\n                    }\n                    lit.extend(&bytes);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::add":["/// Adds the given literal to this set.\n///\n/// Returns false if adding this literal would cause the class to be too\n/// big.\npub fn add(&mut self, lit: Literal) -> bool{\n        if self.num_bytes() + lit.len() > self.limit_size {\n            return false;\n        }\n        self.lits.push(lit);\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::add_byte_class":["/// Extends each literal in this set with the byte class given.\n///\n/// Returns false if the byte class was too big to add.\npub fn add_byte_class(&mut self, cls: &hir::ClassBytes) -> bool{\n        if self.class_exceeds_limits(cls_byte_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for b in (s..e).map(|b| b as u8) {\n                for mut lit in base.clone() {\n                    lit.push(b);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::add_char_class":["/// Extends each literal in this set with the character class given.\n///\n/// Returns false if the character class was too big to add.\npub fn add_char_class(&mut self, cls: &hir::ClassUnicode) -> bool{\n        self._add_char_class(cls, false)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::add_char_class_reverse":["/// Extends each literal in this set with the character class given,\n/// writing the bytes of each character in reverse.\n///\n/// Returns false if the character class was too big to add.\nfn add_char_class_reverse(&mut self, cls: &hir::ClassUnicode) -> bool{\n        self._add_char_class(cls, true)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::all_complete":["/// Returns true if all members in this set are complete.\npub fn all_complete(&self) -> bool{\n        !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::any_complete":["/// Returns true if any member in this set is complete.\npub fn any_complete(&self) -> bool{\n        self.lits.iter().any(|lit| !lit.is_cut())\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::class_exceeds_limits":["/// Returns true if a character class with the given size would cause this\n/// set to exceed its limits.\n///\n/// The size given should correspond to the number of items in the class.\nfn class_exceeds_limits(&self, size: usize) -> bool{\n        if size > self.limit_class {\n            return true;\n        }\n        // This is an approximation since codepoints in a char class can encode\n        // to 1-4 bytes.\n        let new_byte_count = if self.lits.is_empty() {\n            size\n        } else {\n            self.lits.iter().fold(0, |accum, lit| {\n                accum\n                    + if lit.is_cut() {\n                        // If the literal is cut, then we'll never add\n                        // anything to it, so don't count it.\n                        0\n                    } else {\n                        (lit.len() + 1) * size\n                    }\n            })\n        };\n        new_byte_count > self.limit_size\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::clear":["/// Clears this set of all members.\npub fn clear(&mut self){\n        self.lits.clear();\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::contains_empty":["/// Returns true if this set contains an empty literal.\npub fn contains_empty(&self) -> bool{\n        self.lits.iter().any(|lit| lit.is_empty())\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::cross_add":["/// Extends each literal in this set with the bytes given.\n///\n/// If the set is empty, then the given literal is added to the set.\n///\n/// If adding any number of bytes to all members of this set causes a limit\n/// to be exceeded, then no bytes are added and false is returned. If a\n/// prefix of `bytes` can be fit into this set, then it is used and all\n/// resulting literals are cut.\npub fn cross_add(&mut self, bytes: &[u8]) -> bool{\n        // N.B. This could be implemented by simply calling cross_product with\n        // a literal set containing just `bytes`, but we can be smarter about\n        // taking shorter prefixes of `bytes` if they'll fit.\n        if bytes.is_empty() {\n            return true;\n        }\n        if self.lits.is_empty() {\n            let i = cmp::min(self.limit_size, bytes.len());\n            self.lits.push(Literal::new(bytes[..i].to_owned()));\n            self.lits[0].cut = i < bytes.len();\n            return !self.lits[0].is_cut();\n        }\n        let size = self.num_bytes();\n        if size + self.lits.len() >= self.limit_size {\n            return false;\n        }\n        let mut i = 1;\n        while size + (i * self.lits.len()) <= self.limit_size\n            && i < bytes.len()\n        {\n            i += 1;\n        }\n        for lit in &mut self.lits {\n            if !lit.is_cut() {\n                lit.extend(&bytes[..i]);\n                if i < bytes.len() {\n                    lit.cut();\n                }\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::cross_product":["/// Extends this set with another set.\n///\n/// The set of literals is extended via a cross product.\n///\n/// If a cross product would cause this set to exceed its limits, then the\n/// cross product is skipped and it returns false. Otherwise, if the cross\n/// product succeeds, it returns true.\npub fn cross_product(&mut self, lits: &Literals) -> bool{\n        if lits.is_empty() {\n            return true;\n        }\n        // Check that we make sure we stay in our limits.\n        let mut size_after;\n        if self.is_empty() || !self.any_complete() {\n            size_after = self.num_bytes();\n            for lits_lit in lits.literals() {\n                size_after += lits_lit.len();\n            }\n        } else {\n            size_after = self.lits.iter().fold(0, |accum, lit| {\n                accum + if lit.is_cut() { lit.len() } else { 0 }\n            });\n            for lits_lit in lits.literals() {\n                for self_lit in self.literals() {\n                    if !self_lit.is_cut() {\n                        size_after += self_lit.len() + lits_lit.len();\n                    }\n                }\n            }\n        }\n        if size_after > self.limit_size {\n            return false;\n        }\n\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for lits_lit in lits.literals() {\n            for mut self_lit in base.clone() {\n                self_lit.extend(&**lits_lit);\n                self_lit.cut = lits_lit.cut;\n                self.lits.push(self_lit);\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::cut":["/// Cuts every member of this set. When a member is cut, it can never\n/// be extended.\npub fn cut(&mut self){\n        for lit in &mut self.lits {\n            lit.cut();\n        }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::empty":["/// Returns a new empty set of literals using default limits.\npub fn empty() -> Literals{\n        Literals { lits: vec![], limit_size: 250, limit_class: 10 }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::is_empty":["/// Returns true if this set is empty or if all of its members is empty.\npub fn is_empty(&self) -> bool{\n        self.lits.is_empty() || self.lits.iter().all(|lit| lit.is_empty())\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::limit_class":["/// Get the character class size limit for this set.\npub fn limit_class(&self) -> usize{\n        self.limit_class\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::limit_size":["/// Get the approximate size limit (in bytes) of this set.\npub fn limit_size(&self) -> usize{\n        self.limit_size\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::literals":["/// Returns the set of literals as a slice. Its order is unspecified.\npub fn literals(&self) -> &[Literal]{\n        &self.lits\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::longest_common_prefix":["/// Returns the longest common prefix of all members in this set.\npub fn longest_common_prefix(&self) -> &[u8]{\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter().zip(lit0).take_while(|&(a, b)| a == b).count(),\n            );\n        }\n        &self.lits[0][..len]\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::longest_common_suffix":["/// Returns the longest common suffix of all members in this set.\npub fn longest_common_suffix(&self) -> &[u8]{\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter()\n                    .rev()\n                    .zip(lit0.iter().rev())\n                    .take_while(|&(a, b)| a == b)\n                    .count(),\n            );\n        }\n        &self.lits[0][self.lits[0].len() - len..]\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::min_len":["/// Returns the length of the smallest literal.\n///\n/// Returns None is there are no literals in the set.\npub fn min_len(&self) -> Option<usize>{\n        let mut min = None;\n        for lit in &self.lits {\n            match min {\n                None => min = Some(lit.len()),\n                Some(m) if lit.len() < m => min = Some(lit.len()),\n                _ => {}\n            }\n        }\n        min\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::num_bytes":["/// Returns the total number of bytes in this set.\nfn num_bytes(&self) -> usize{\n        self.lits.iter().fold(0, |accum, lit| accum + lit.len())\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::prefixes":["/// Returns a set of literal prefixes extracted from the given `Hir`.\npub fn prefixes(expr: &Hir) -> Literals{\n        let mut lits = Literals::empty();\n        lits.union_prefixes(expr);\n        lits\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::remove_complete":["/// Pops all complete literals out of this set.\nfn remove_complete(&mut self) -> Vec<Literal>{\n        let mut base = vec![];\n        for lit in mem::replace(&mut self.lits, vec![]) {\n            if lit.is_cut() {\n                self.lits.push(lit);\n            } else {\n                base.push(lit);\n            }\n        }\n        base\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::reverse":["/// Reverses all members in place.\npub fn reverse(&mut self){\n        for lit in &mut self.lits {\n            lit.reverse();\n        }\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::set_limit_class":["/// Limits the size of character(or byte) classes considered.\n///\n/// A value of `0` prevents all character classes from being considered.\n///\n/// This limit also applies to case insensitive literals, since each\n/// character in the case insensitive literal is converted to a class, and\n/// then case folded.\n///\n/// The new limits will only apply to additions to this set. Existing\n/// members remain unchanged, even if the set exceeds the new limit.\npub fn set_limit_class(&mut self, size: usize) -> &mut Literals{\n        self.limit_class = size;\n        self\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::set_limit_size":["/// Set the approximate size limit (in bytes) of this set.\n///\n/// If extracting a literal would put the set over this limit, then\n/// extraction stops.\n///\n/// The new limits will only apply to additions to this set. Existing\n/// members remain unchanged, even if the set exceeds the new limit.\npub fn set_limit_size(&mut self, size: usize) -> &mut Literals{\n        self.limit_size = size;\n        self\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::suffixes":["/// Returns a set of literal suffixes extracted from the given `Hir`.\npub fn suffixes(expr: &Hir) -> Literals{\n        let mut lits = Literals::empty();\n        lits.union_suffixes(expr);\n        lits\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::to_empty":["/// Returns a new empty set of literals using this set's limits.\npub fn to_empty(&self) -> Literals{\n        let mut lits = Literals::empty();\n        lits.set_limit_size(self.limit_size).set_limit_class(self.limit_class);\n        lits\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::trim_suffix":["/// Returns a new set of literals with the given number of bytes trimmed\n/// from the suffix of each literal.\n///\n/// If any literal would be cut out completely by trimming, then None is\n/// returned.\n///\n/// Any duplicates that are created as a result of this transformation are\n/// removed.\npub fn trim_suffix(&self, num_bytes: usize) -> Option<Literals>{\n        if self.min_len().map(|len| len <= num_bytes).unwrap_or(true) {\n            return None;\n        }\n        let mut new = self.to_empty();\n        for mut lit in self.lits.iter().cloned() {\n            let new_len = lit.len() - num_bytes;\n            lit.truncate(new_len);\n            lit.cut();\n            new.lits.push(lit);\n        }\n        new.lits.sort();\n        new.lits.dedup();\n        Some(new)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::unambiguous_prefixes":["/// Returns a new set of prefixes of this set of literals that are\n/// guaranteed to be unambiguous.\n///\n/// Any substring match with a member of the set is returned is guaranteed\n/// to never overlap with a substring match of another member of the set\n/// at the same starting position.\n///\n/// Given any two members of the returned set, neither is a substring of\n/// the other.\npub fn unambiguous_prefixes(&self) -> Literals{\n        if self.lits.is_empty() {\n            return self.to_empty();\n        }\n        let mut old: Vec<Literal> = self.lits.iter().cloned().collect();\n        let mut new = self.to_empty();\n        'OUTER: while let Some(mut candidate) = old.pop() {\n            if candidate.is_empty() {\n                continue;\n            }\n            if new.lits.is_empty() {\n                new.lits.push(candidate);\n                continue;\n            }\n            for lit2 in &mut new.lits {\n                if lit2.is_empty() {\n                    continue;\n                }\n                if &candidate == lit2 {\n                    // If the literal is already in the set, then we can\n                    // just drop it. But make sure that cut literals are\n                    // infectious!\n                    candidate.cut = candidate.cut || lit2.cut;\n                    lit2.cut = candidate.cut;\n                    continue 'OUTER;\n                }\n                if candidate.len() < lit2.len() {\n                    if let Some(i) = position(&candidate, &lit2) {\n                        candidate.cut();\n                        let mut lit3 = lit2.clone();\n                        lit3.truncate(i);\n                        lit3.cut();\n                        old.push(lit3);\n                        lit2.clear();\n                    }\n                } else {\n                    if let Some(i) = position(&lit2, &candidate) {\n                        lit2.cut();\n                        let mut new_candidate = candidate.clone();\n                        new_candidate.truncate(i);\n                        new_candidate.cut();\n                        old.push(new_candidate);\n                        candidate.clear();\n                    }\n                }\n                // Oops, the candidate is already represented in the set.\n                if candidate.is_empty() {\n                    continue 'OUTER;\n                }\n            }\n            new.lits.push(candidate);\n        }\n        new.lits.retain(|lit| !lit.is_empty());\n        new.lits.sort();\n        new.lits.dedup();\n        new\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::unambiguous_suffixes":["/// Returns a new set of suffixes of this set of literals that are\n/// guaranteed to be unambiguous.\n///\n/// Any substring match with a member of the set is returned is guaranteed\n/// to never overlap with a substring match of another member of the set\n/// at the same ending position.\n///\n/// Given any two members of the returned set, neither is a substring of\n/// the other.\npub fn unambiguous_suffixes(&self) -> Literals{\n        // This is a touch wasteful...\n        let mut lits = self.clone();\n        lits.reverse();\n        let mut unamb = lits.unambiguous_prefixes();\n        unamb.reverse();\n        unamb\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::union":["/// Unions this set with another set.\n///\n/// If the union would cause the set to exceed its limits, then the union\n/// is skipped and it returns false. Otherwise, if the union succeeds, it\n/// returns true.\npub fn union(&mut self, lits: Literals) -> bool{\n        if self.num_bytes() + lits.num_bytes() > self.limit_size {\n            return false;\n        }\n        if lits.is_empty() {\n            self.lits.push(Literal::empty());\n        } else {\n            self.lits.extend(lits.lits);\n        }\n        true\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::union_prefixes":["/// Unions the prefixes from the given expression to this set.\n///\n/// If prefixes could not be added (for example, this set would exceed its\n/// size limits or the set of prefixes from `expr` includes the empty\n/// string), then false is returned.\n///\n/// Note that prefix literals extracted from `expr` are said to be complete\n/// if and only if the literal extends from the beginning of `expr` to the\n/// end of `expr`.\npub fn union_prefixes(&mut self, expr: &Hir) -> bool{\n        let mut lits = self.to_empty();\n        prefixes(expr, &mut lits);\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::Literals::union_suffixes":["/// Unions the suffixes from the given expression to this set.\n///\n/// If suffixes could not be added (for example, this set would exceed its\n/// size limits or the set of suffixes from `expr` includes the empty\n/// string), then false is returned.\n///\n/// Note that prefix literals extracted from `expr` are said to be complete\n/// if and only if the literal extends from the end of `expr` to the\n/// beginning of `expr`.\npub fn union_suffixes(&mut self, expr: &Hir) -> bool{\n        let mut lits = self.to_empty();\n        suffixes(expr, &mut lits);\n        lits.reverse();\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::alternate_literals":["fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n    es: &[Hir],\n    lits: &mut Literals,\n    mut f: F,\n){\n    let mut lits2 = lits.to_empty();\n    for e in es {\n        let mut lits3 = lits.to_empty();\n        lits3.set_limit_size(lits.limit_size() / 5);\n        f(e, &mut lits3);\n        if lits3.is_empty() || !lits2.union(lits3) {\n            // If we couldn't find suffixes for *any* of the\n            // alternates, then the entire alternation has to be thrown\n            // away and any existing members must be frozen. Similarly,\n            // if the union couldn't complete, stop and freeze.\n            lits.cut();\n            return;\n        }\n    }\n    if !lits.cross_product(&lits2) {\n        lits.cut();\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::cls_byte_count":["fn cls_byte_count(cls: &hir::ClassBytes) -> usize{\n    cls.iter().map(|&r| 1 + (r.end as u32) - (r.start as u32)).sum::<u32>()\n        as usize\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::cls_char_count":["fn cls_char_count(cls: &hir::ClassUnicode) -> usize{\n    cls.iter().map(|&r| 1 + (r.end as u32) - (r.start as u32)).sum::<u32>()\n        as usize\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::escape_byte":["fn escape_byte(byte: u8) -> String{\n    use std::ascii::escape_default;\n\n    let escaped: Vec<u8> = escape_default(byte).collect();\n    String::from_utf8_lossy(&escaped).into_owned()\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::escape_bytes":["fn escape_bytes(bytes: &[u8]) -> String{\n    let mut s = String::new();\n    for &b in bytes {\n        s.push_str(&escape_byte(b));\n    }\n    s\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::escape_unicode":["fn escape_unicode(bytes: &[u8]) -> String{\n    let show = match ::std::str::from_utf8(bytes) {\n        Ok(v) => v.to_string(),\n        Err(_) => escape_bytes(bytes),\n    };\n    let mut space_escaped = String::new();\n    for c in show.chars() {\n        if c.is_whitespace() {\n            let escaped = if c as u32 <= 0x7F {\n                escape_byte(c as u8)\n            } else {\n                if c as u32 <= 0xFFFF {\n                    format!(r\"\\u{{{:04x}}}\", c as u32)\n                } else {\n                    format!(r\"\\U{{{:08x}}}\", c as u32)\n                }\n            };\n            space_escaped.push_str(&escaped);\n        } else {\n            space_escaped.push(c);\n        }\n    }\n    space_escaped\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::position":["fn position(needle: &[u8], mut haystack: &[u8]) -> Option<usize>{\n    let mut i = 0;\n    while haystack.len() >= needle.len() {\n        if needle == &haystack[..needle.len()] {\n            return Some(i);\n        }\n        i += 1;\n        haystack = &haystack[1..];\n    }\n    None\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::prefixes":["fn prefixes(expr: &Hir, lits: &mut Literals){\n    match *expr.kind() {\n        HirKind::Literal(hir::Literal::Unicode(c)) => {\n            let mut buf = [0; 4];\n            lits.cross_add(c.encode_utf8(&mut buf).as_bytes());\n        }\n        HirKind::Literal(hir::Literal::Byte(b)) => {\n            lits.cross_add(&[b]);\n        }\n        HirKind::Class(hir::Class::Unicode(ref cls)) => {\n            if !lits.add_char_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Class(hir::Class::Bytes(ref cls)) => {\n            if !lits.add_byte_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Group(hir::Group { ref hir, .. }) => {\n            prefixes(&**hir, lits);\n        }\n        HirKind::Repetition(ref x) => match x.kind {\n            hir::RepetitionKind::ZeroOrOne => {\n                repeat_zero_or_one_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::ZeroOrMore => {\n                repeat_zero_or_more_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::OneOrMore => {\n                repeat_one_or_more_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::Range(ref rng) => {\n                let (min, max) = match *rng {\n                    hir::RepetitionRange::Exactly(m) => (m, Some(m)),\n                    hir::RepetitionRange::AtLeast(m) => (m, None),\n                    hir::RepetitionRange::Bounded(m, n) => (m, Some(n)),\n                };\n                repeat_range_literals(\n                    &x.hir, min, max, x.greedy, lits, prefixes,\n                )\n            }\n        },\n        HirKind::Concat(ref es) if es.is_empty() => {}\n        HirKind::Concat(ref es) if es.len() == 1 => prefixes(&es[0], lits),\n        HirKind::Concat(ref es) => {\n            for e in es {\n                if let HirKind::Anchor(hir::Anchor::StartText) = *e.kind() {\n                    if !lits.is_empty() {\n                        lits.cut();\n                        break;\n                    }\n                    lits.add(Literal::empty());\n                    continue;\n                }\n                let mut lits2 = lits.to_empty();\n                prefixes(e, &mut lits2);\n                if !lits.cross_product(&lits2) || !lits2.any_complete() {\n                    // If this expression couldn't yield any literal that\n                    // could be extended, then we need to quit. Since we're\n                    // short-circuiting, we also need to freeze every member.\n                    lits.cut();\n                    break;\n                }\n            }\n        }\n        HirKind::Alternation(ref es) => {\n            alternate_literals(es, lits, prefixes);\n        }\n        _ => lits.cut(),\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::repeat_one_or_more_literals":["fn repeat_one_or_more_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n){\n    f(e, lits);\n    lits.cut();\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::repeat_range_literals":["fn repeat_range_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    min: u32,\n    max: Option<u32>,\n    greedy: bool,\n    lits: &mut Literals,\n    mut f: F,\n){\n    if min == 0 {\n        // This is a bit conservative. If `max` is set, then we could\n        // treat this as a finite set of alternations. For now, we\n        // just treat it as `e*`.\n        f(\n            &Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: greedy,\n                hir: Box::new(e.clone()),\n            }),\n            lits,\n        );\n    } else {\n        if min > 0 {\n            let n = cmp::min(lits.limit_size, min as usize);\n            let es = iter::repeat(e.clone()).take(n).collect();\n            f(&Hir::concat(es), lits);\n            if n < min as usize || lits.contains_empty() {\n                lits.cut();\n            }\n        }\n        if max.map_or(true, |max| min < max) {\n            lits.cut();\n        }\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::repeat_zero_or_more_literals":["fn repeat_zero_or_more_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n){\n    let (mut lits2, mut lits3) = (lits.clone(), lits.to_empty());\n    lits3.set_limit_size(lits.limit_size() / 2);\n    f(e, &mut lits3);\n\n    if lits3.is_empty() || !lits2.cross_product(&lits3) {\n        lits.cut();\n        return;\n    }\n    lits2.cut();\n    lits2.add(Literal::empty());\n    if !lits.union(lits2) {\n        lits.cut();\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::repeat_zero_or_one_literals":["fn repeat_zero_or_one_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n){\n    let (mut lits2, mut lits3) = (lits.clone(), lits.to_empty());\n    lits3.set_limit_size(lits.limit_size() / 2);\n    f(e, &mut lits3);\n\n    if lits3.is_empty() || !lits2.cross_product(&lits3) {\n        lits.cut();\n        return;\n    }\n    lits2.add(Literal::empty());\n    if !lits.union(lits2) {\n        lits.cut();\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::literal::suffixes":["fn suffixes(expr: &Hir, lits: &mut Literals){\n    match *expr.kind() {\n        HirKind::Literal(hir::Literal::Unicode(c)) => {\n            let mut buf = [0u8; 4];\n            let i = c.encode_utf8(&mut buf).len();\n            let buf = &mut buf[..i];\n            buf.reverse();\n            lits.cross_add(buf);\n        }\n        HirKind::Literal(hir::Literal::Byte(b)) => {\n            lits.cross_add(&[b]);\n        }\n        HirKind::Class(hir::Class::Unicode(ref cls)) => {\n            if !lits.add_char_class_reverse(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Class(hir::Class::Bytes(ref cls)) => {\n            if !lits.add_byte_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Group(hir::Group { ref hir, .. }) => {\n            suffixes(&**hir, lits);\n        }\n        HirKind::Repetition(ref x) => match x.kind {\n            hir::RepetitionKind::ZeroOrOne => {\n                repeat_zero_or_one_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::ZeroOrMore => {\n                repeat_zero_or_more_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::OneOrMore => {\n                repeat_one_or_more_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::Range(ref rng) => {\n                let (min, max) = match *rng {\n                    hir::RepetitionRange::Exactly(m) => (m, Some(m)),\n                    hir::RepetitionRange::AtLeast(m) => (m, None),\n                    hir::RepetitionRange::Bounded(m, n) => (m, Some(n)),\n                };\n                repeat_range_literals(\n                    &x.hir, min, max, x.greedy, lits, suffixes,\n                )\n            }\n        },\n        HirKind::Concat(ref es) if es.is_empty() => {}\n        HirKind::Concat(ref es) if es.len() == 1 => suffixes(&es[0], lits),\n        HirKind::Concat(ref es) => {\n            for e in es.iter().rev() {\n                if let HirKind::Anchor(hir::Anchor::EndText) = *e.kind() {\n                    if !lits.is_empty() {\n                        lits.cut();\n                        break;\n                    }\n                    lits.add(Literal::empty());\n                    continue;\n                }\n                let mut lits2 = lits.to_empty();\n                suffixes(e, &mut lits2);\n                if !lits.cross_product(&lits2) || !lits2.any_complete() {\n                    // If this expression couldn't yield any literal that\n                    // could be extended, then we need to quit. Since we're\n                    // short-circuiting, we also need to freeze every member.\n                    lits.cut();\n                    break;\n                }\n            }\n        }\n        HirKind::Alternation(ref es) => {\n            alternate_literals(es, lits, suffixes);\n        }\n        _ => lits.cut(),\n    }\n}","Real(LocalPath(\"src/hir/literal/mod.rs\"))"],"hir::print::Printer":["/// A printer for a regular expression's high-level intermediate\n/// representation.\n///\n/// A printer converts a high-level intermediate representation (HIR) to a\n/// regular expression pattern string. This particular printer uses constant\n/// stack space and heap space proportional to the size of the HIR.\n///\n/// Since this printer is only using the HIR, the pattern it prints will likely\n/// not resemble the original pattern at all. For example, a pattern like\n/// `\\pL` will have its entire class written out.\n///\n/// The purpose of this printer is to provide a means to mutate an HIR and then\n/// build a regular expression from the result of that mutation. (A regex\n/// library could provide a constructor from this HIR explicitly, but that\n/// creates an unnecessary public coupling between the regex library and this\n/// specific HIR representation.)\npub struct Printer {\n    _priv: (),\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Printer::new":["/// Create a new printer.\npub fn new() -> Printer{\n        PrinterBuilder::new().build()\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Printer::print":["/// Print the given `Ast` to the given writer. The writer must implement\n/// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n/// here are a `fmt::Formatter` (which is available in `fmt::Display`\n/// implementations) or a `&mut String`.\npub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result{\n        visitor::visit(hir, Writer { printer: self, wtr: wtr })\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder":["/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\nstruct PrinterBuilder {\n    _priv: (),\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder::build":["fn build(&self) -> Printer{\n        Printer { _priv: () }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder::new":["fn new() -> PrinterBuilder{\n        PrinterBuilder { _priv: () }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer":["struct Writer<'p, W> {\n    printer: &'p mut Printer,\n    wtr: W,\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<'p, W>::write_literal_byte":["fn write_literal_byte(&mut self, b: u8) -> fmt::Result{\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<'p, W>::write_literal_char":["fn write_literal_char(&mut self, c: char) -> fmt::Result{\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<'p, W>::write_literal_class_byte":["fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result{\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::translate::Flags":["/// A translator's representation of a regular expression's flags at any given\n/// moment in time.\n///\n/// Each flag can be in one of three states: absent, present but disabled or\n/// present but enabled.\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n    // Note that `ignore_whitespace` is omitted here because it is handled\n    // entirely in the parser.\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::case_insensitive":["fn case_insensitive(&self) -> bool{\n        self.case_insensitive.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::dot_matches_new_line":["fn dot_matches_new_line(&self) -> bool{\n        self.dot_matches_new_line.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::from_ast":["fn from_ast(ast: &ast::Flags) -> Flags{\n        let mut flags = Flags::default();\n        let mut enable = true;\n        for item in &ast.items {\n            match item.kind {\n                ast::FlagsItemKind::Negation => {\n                    enable = false;\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {\n                    flags.case_insensitive = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {\n                    flags.multi_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {\n                    flags.dot_matches_new_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {\n                    flags.swap_greed = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => {\n                    flags.unicode = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}\n            }\n        }\n        flags\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::merge":["fn merge(&mut self, previous: &Flags){\n        if self.case_insensitive.is_none() {\n            self.case_insensitive = previous.case_insensitive;\n        }\n        if self.multi_line.is_none() {\n            self.multi_line = previous.multi_line;\n        }\n        if self.dot_matches_new_line.is_none() {\n            self.dot_matches_new_line = previous.dot_matches_new_line;\n        }\n        if self.swap_greed.is_none() {\n            self.swap_greed = previous.swap_greed;\n        }\n        if self.unicode.is_none() {\n            self.unicode = previous.unicode;\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::multi_line":["fn multi_line(&self) -> bool{\n        self.multi_line.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::swap_greed":["fn swap_greed(&self) -> bool{\n        self.swap_greed.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::unicode":["fn unicode(&self) -> bool{\n        self.unicode.unwrap_or(true)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame":["/// An HirFrame is a single stack frame, represented explicitly, which is\n/// created for each item in the Ast that we traverse.\n///\n/// Note that technically, this type doesn't represent our entire stack\n/// frame. In particular, the Ast visitor represents any state associated with\n/// traversing the Ast itself.\nenum HirFrame {\n    /// An arbitrary HIR expression. These get pushed whenever we hit a base\n    /// case in the Ast. They get popped after an inductive (i.e., recursive)\n    /// step is complete.\n    Expr(Hir),\n    /// A Unicode character class. This frame is mutated as we descend into\n    /// the Ast of a character class (which is itself its own mini recursive\n    /// structure).\n    ClassUnicode(hir::ClassUnicode),\n    /// A byte-oriented character class. This frame is mutated as we descend\n    /// into the Ast of a character class (which is itself its own mini\n    /// recursive structure).\n    ///\n    /// Byte character classes are created when Unicode mode (`u`) is disabled.\n    /// If `allow_invalid_utf8` is disabled (the default), then a byte\n    /// character is only permitted to match ASCII text.\n    ClassBytes(hir::ClassBytes),\n    /// This is pushed on to the stack upon first seeing any kind of group,\n    /// indicated by parentheses (including non-capturing groups). It is popped\n    /// upon leaving a group.\n    Group {\n        /// The old active flags when this group was opened.\n        ///\n        /// If this group sets flags, then the new active flags are set to the\n        /// result of merging the old flags with the flags introduced by this\n        /// group. If the group doesn't set any flags, then this is simply\n        /// equivalent to whatever flags were set when the group was opened.\n        ///\n        /// When this group is popped, the active flags should be restored to\n        /// the flags set here.\n        ///\n        /// The \"active\" flags correspond to whatever flags are set in the\n        /// Translator.\n        old_flags: Flags,\n    },\n    /// This is pushed whenever a concatenation is observed. After visiting\n    /// every sub-expression in the concatenation, the translator's stack is\n    /// popped until it sees a Concat frame.\n    Concat,\n    /// This is pushed whenever an alternation is observed. After visiting\n    /// every sub-expression in the alternation, the translator's stack is\n    /// popped until it sees an Alternation frame.\n    Alternation,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_class_bytes":["/// Assert that the current stack frame is a byte class expression and\n/// return it.\nfn unwrap_class_bytes(self) -> hir::ClassBytes{\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_class_unicode":["/// Assert that the current stack frame is a Unicode class expression and\n/// return it.\nfn unwrap_class_unicode(self) -> hir::ClassUnicode{\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_expr":["/// Assert that the current stack frame is an Hir expression and return it.\nfn unwrap_expr(self) -> Hir{\n        match self {\n            HirFrame::Expr(expr) => expr,\n            _ => panic!(\"tried to unwrap expr from HirFrame, got: {:?}\", self),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_group":["/// Assert that the current stack frame is a group indicator and return\n/// its corresponding flags (the flags that were active at the time the\n/// group was entered).\nfn unwrap_group(self) -> Flags{\n        match self {\n            HirFrame::Group { old_flags } => old_flags,\n            _ => {\n                panic!(\"tried to unwrap group from HirFrame, got: {:?}\", self)\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator":["/// A translator maps abstract syntax to a high level intermediate\n/// representation.\n///\n/// A translator may be benefit from reuse. That is, a translator can translate\n/// many abstract syntax trees.\n///\n/// A `Translator` can be configured in more detail via a\n/// [`TranslatorBuilder`](struct.TranslatorBuilder.html).\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    allow_invalid_utf8: bool,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator::new":["/// Create a new translator using the default configuration.\npub fn new() -> Translator{\n        TranslatorBuilder::new().build()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator::translate":["/// Translate the given abstract syntax tree (AST) into a high level\n/// intermediate representation (HIR).\n///\n/// If there was a problem doing the translation, then an HIR-specific\n/// error is returned.\n///\n/// The original pattern string used to produce the `Ast` *must* also be\n/// provided. The translator does not use the pattern string during any\n/// correct translation, but is used for error reporting.\npub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir>{\n        ast::visit(ast, TranslatorI::new(self, pattern))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder":["/// A builder for constructing an AST->HIR translator.\npub struct TranslatorBuilder {\n    allow_invalid_utf8: bool,\n    flags: Flags,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::allow_invalid_utf8":["/// When enabled, translation will permit the construction of a regular\n/// expression that may match invalid UTF-8.\n///\n/// When disabled (the default), the translator is guaranteed to produce\n/// an expression that will only ever match valid UTF-8 (otherwise, the\n/// translator will return an error).\n///\n/// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n/// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n/// the parser to return an error. Namely, a negated ASCII word boundary\n/// can result in matching positions that aren't valid UTF-8 boundaries.\npub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.allow_invalid_utf8 = yes;\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::build":["/// Build a translator using the current configuration.\npub fn build(&self) -> Translator{\n        Translator {\n            stack: RefCell::new(vec![]),\n            flags: Cell::new(self.flags),\n            allow_invalid_utf8: self.allow_invalid_utf8,\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::case_insensitive":["/// Enable or disable the case insensitive flag (`i`) by default.\npub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.case_insensitive = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::dot_matches_new_line":["/// Enable or disable the \"dot matches any character\" flag (`s`) by\n/// default.\npub fn dot_matches_new_line(\n        &mut self,\n        yes: bool,\n    ) -> &mut TranslatorBuilder{\n        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::multi_line":["/// Enable or disable the multi-line matching flag (`m`) by default.\npub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.multi_line = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::new":["/// Create a new translator builder with a default c onfiguration.\npub fn new() -> TranslatorBuilder{\n        TranslatorBuilder {\n            allow_invalid_utf8: false,\n            flags: Flags::default(),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::swap_greed":["/// Enable or disable the \"swap greed\" flag (`U`) by default.\npub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.swap_greed = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::unicode":["/// Enable or disable the Unicode flag (`u`) by default.\npub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.unicode = if yes { None } else { Some(false) };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI":["/// The internal implementation of a translator.\n///\n/// This type is responsible for carrying around the original pattern string,\n/// which is not tied to the internal state of a translator.\n///\n/// A TranslatorI exists for the time it takes to translate a single Ast.\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()>{\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if !self.trans().allow_invalid_utf8 && !class.is_all_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["/// Return a scalar byte value suitable for use as a literal in a byte\n/// character class.\nfn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8>{\n        match self.literal_to_char(ast)? {\n            hir::Literal::Byte(byte) => Ok(byte),\n            hir::Literal::Unicode(ch) => {\n                if ch <= 0x7F as char {\n                    Ok(ch as u8)\n                } else {\n                    // We can't feasibly support Unicode in\n                    // byte oriented classes. Byte classes don't\n                    // do Unicode case folding.\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["/// Converts the given Unicode specific error to an HIR translation error.\n///\n/// The span given should approximate the position at which an error would\n/// occur.\nfn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: unicode::Result<hir::ClassUnicode>,\n    ) -> Result<hir::ClassUnicode>{\n        result.map_err(|err| {\n            let sp = span.clone();\n            match err {\n                unicode::Error::PropertyNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyNotFound)\n                }\n                unicode::Error::PropertyValueNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyValueNotFound)\n                }\n                unicode::Error::PerlClassNotFound => {\n                    self.error(sp, ErrorKind::UnicodePerlClassNotFound)\n                }\n            }\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::error":["/// Create a new error with the given span and error type.\nfn error(&self, span: Span, kind: ErrorKind) -> Error{\n        Error { kind: kind, pattern: self.pattern.to_string(), span: span }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::flags":["/// Return a copy of the active flags.\nfn flags(&self) -> Flags{\n        self.trans().flags.get()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir>{\n        let unicode = self.flags().unicode();\n        let multi_line = self.flags().multi_line();\n        Ok(match asst.kind {\n            ast::AssertionKind::StartLine => Hir::anchor(if multi_line {\n                hir::Anchor::StartLine\n            } else {\n                hir::Anchor::StartText\n            }),\n            ast::AssertionKind::EndLine => Hir::anchor(if multi_line {\n                hir::Anchor::EndLine\n            } else {\n                hir::Anchor::EndText\n            }),\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => Hir::anchor(hir::Anchor::EndText),\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(\n                            self.error(asst.span, ErrorKind::InvalidUtf8)\n                        );\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["fn hir_dot(&self, span: Span) -> Result<Hir>{\n        let unicode = self.flags().unicode();\n        if !unicode && !self.trans().allow_invalid_utf8 {\n            return Err(self.error(span, ErrorKind::InvalidUtf8));\n        }\n        Ok(if self.flags().dot_matches_new_line() {\n            Hir::any(!unicode)\n        } else {\n            Hir::dot(!unicode)\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char":["fn hir_from_char(&self, span: Span, c: char) -> Result<Hir>{\n        if !self.flags().unicode() && c.len_utf8() > 1 {\n            return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n        }\n        Ok(Hir::literal(hir::Literal::Unicode(c)))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive":["fn hir_from_char_case_insensitive(\n        &self,\n        span: Span,\n        c: char,\n    ) -> Result<Hir>{\n        if self.flags().unicode() {\n            // If case folding won't do anything, then don't bother trying.\n            let map =\n                unicode::contains_simple_case_mapping(c, c).map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?;\n            if !map {\n                return self.hir_from_char(span, c);\n            }\n            let mut cls =\n                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(\n                    c, c,\n                )]);\n            cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?;\n            Ok(Hir::class(hir::Class::Unicode(cls)))\n        } else {\n            if c.len_utf8() > 1 {\n                return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n            }\n            // If case folding won't do anything, then don't bother trying.\n            match c {\n                'A'..='Z' | 'a'..='z' => {}\n                _ => return self.hir_from_char(span, c),\n            }\n            let mut cls =\n                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(\n                    c as u8, c as u8,\n                )]);\n            cls.case_fold_simple();\n            Ok(Hir::class(hir::Class::Bytes(cls)))\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_group":["fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir{\n        let kind = match group.kind {\n            ast::GroupKind::CaptureIndex(idx) => {\n                hir::GroupKind::CaptureIndex(idx)\n            }\n            ast::GroupKind::CaptureName(ref capname) => {\n                hir::GroupKind::CaptureName {\n                    name: capname.name.clone(),\n                    index: capname.index,\n                }\n            }\n            ast::GroupKind::NonCapturing(_) => hir::GroupKind::NonCapturing,\n        };\n        Hir::group(hir::Group { kind: kind, hir: Box::new(expr) })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_literal":["fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir>{\n        let ch = match self.literal_to_char(lit)? {\n            byte @ hir::Literal::Byte(_) => return Ok(Hir::literal(byte)),\n            hir::Literal::Unicode(ch) => ch,\n        };\n        if self.flags().case_insensitive() {\n            self.hir_from_char_case_insensitive(lit.span, ch)\n        } else {\n            self.hir_from_char(lit.span, ch)\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> hir::ClassBytes{\n        use ast::ClassPerlKind::*;\n\n        assert!(!self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        // We needn't apply case folding here because the Perl ASCII classes\n        // are already closed (under ASCII case folding).\n        if ast_class.negated {\n            class.negate();\n        }\n        class\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode>{\n        use ast::ClassPerlKind::*;\n\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class =\n            self.convert_unicode_class_error(&ast_class.span, result)?;\n        // We needn't apply case folding here because the Perl Unicode classes\n        // are already closed under Unicode simple case folding.\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir{\n        let kind = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => hir::RepetitionKind::ZeroOrOne,\n            ast::RepetitionKind::ZeroOrMore => hir::RepetitionKind::ZeroOrMore,\n            ast::RepetitionKind::OneOrMore => hir::RepetitionKind::OneOrMore,\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(\n                m,\n                n,\n            )) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(m, n))\n            }\n        };\n        let greedy =\n            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            kind: kind,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode>{\n        use ast::ClassUnicodeKind::*;\n\n        if !self.flags().unicode() {\n            return Err(\n                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)\n            );\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {\n                property_name: name,\n                property_value: value,\n            },\n        };\n        let mut result = self.convert_unicode_class_error(\n            &ast_class.span,\n            unicode::class(query),\n        );\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(\n                &ast_class.span,\n                ast_class.negated,\n                class,\n            )?;\n            if class.ranges().is_empty() {\n                let err = self\n                    .error(ast_class.span, ErrorKind::EmptyClassNotAllowed);\n                return Err(err);\n            }\n        }\n        result\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::literal_to_char":["/// Convert an Ast literal to its scalar representation.\n///\n/// When Unicode mode is enabled, then this always succeeds and returns a\n/// `char` (Unicode scalar value).\n///\n/// When Unicode mode is disabled, then a raw byte is returned. If that\n/// byte is not ASCII and invalid UTF-8 is not allowed, then this returns\n/// an error.\nfn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal>{\n        if self.flags().unicode() {\n            return Ok(hir::Literal::Unicode(lit.c));\n        }\n        let byte = match lit.byte() {\n            None => return Ok(hir::Literal::Unicode(lit.c)),\n            Some(byte) => byte,\n        };\n        if byte <= 0x7F {\n            return Ok(hir::Literal::Unicode(byte as char));\n        }\n        if !self.trans().allow_invalid_utf8 {\n            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(hir::Literal::Byte(byte))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::new":["/// Build a new internal translator.\nfn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p>{\n        TranslatorI { trans: trans, pattern: pattern }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::pop":["/// Pop the top of the call stack. If the call stack is empty, return None.\nfn pop(&self) -> Option<HirFrame>{\n        self.trans().stack.borrow_mut().pop()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::push":["/// Push the given frame on to the call stack.\nfn push(&self, frame: HirFrame){\n        self.trans().stack.borrow_mut().push(frame);\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["/// Set the flags of this translator from the flags set in the given AST.\n/// Then, return the old flags.\nfn set_flags(&self, ast_flags: &ast::Flags) -> Flags{\n        let old_flags = self.flags();\n        let mut new_flags = Flags::from_ast(ast_flags);\n        new_flags.merge(&old_flags);\n        self.trans().flags.set(new_flags);\n        old_flags\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::trans":["/// Return a reference to the underlying translator.\nfn trans(&self) -> &Translator{\n        &self.trans\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()>{\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.try_case_fold_simple().map_err(|_| {\n                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n            })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::ascii_class":["fn ascii_class(kind: &ast::ClassAsciiKind) -> &'static [(char, char)]{\n    use ast::ClassAsciiKind::*;\n    match *kind {\n        Alnum => &[('0', '9'), ('A', 'Z'), ('a', 'z')],\n        Alpha => &[('A', 'Z'), ('a', 'z')],\n        Ascii => &[('\\x00', '\\x7F')],\n        Blank => &[('\\t', '\\t'), (' ', ' ')],\n        Cntrl => &[('\\x00', '\\x1F'), ('\\x7F', '\\x7F')],\n        Digit => &[('0', '9')],\n        Graph => &[('!', '~')],\n        Lower => &[('a', 'z')],\n        Print => &[(' ', '~')],\n        Punct => &[('!', '/'), (':', '@'), ('[', '`'), ('{', '~')],\n        Space => &[\n            ('\\t', '\\t'),\n            ('\\n', '\\n'),\n            ('\\x0B', '\\x0B'),\n            ('\\x0C', '\\x0C'),\n            ('\\r', '\\r'),\n            (' ', ' '),\n        ],\n        Upper => &[('A', 'Z')],\n        Word => &[('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')],\n        Xdigit => &[('0', '9'), ('A', 'F'), ('a', 'f')],\n    }\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::hir_ascii_class_bytes":["fn hir_ascii_class_bytes(kind: &ast::ClassAsciiKind) -> hir::ClassBytes{\n    let ranges: Vec<_> = ascii_class(kind)\n        .iter()\n        .cloned()\n        .map(|(s, e)| hir::ClassBytesRange::new(s as u8, e as u8))\n        .collect();\n    hir::ClassBytes::new(ranges)\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::visitor::Frame":["/// Represents a single stack frame while performing structural induction over\n/// an `Hir`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a hir::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a hir::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Frame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child HIR node to visit.\nfn child(&self) -> &'a Hir{\n        match *self {\n            Frame::Repetition(rep) => &rep.hir,\n            Frame::Group(group) => &group.hir,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor":["/// HeapVisitor visits every item in an `Hir` recursively using constant stack\n/// size and a heap size proportional to the size of the `Hir`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Hir` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Hir, Frame<'a>)>,\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::induct":["/// Build a stack frame for the given HIR if one is needed (which occurs if\n/// and only if there are child nodes in the HIR). Otherwise, return None.\nfn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>>{\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Group(ref x) => Some(Frame::Group(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat { head: &x[0], tail: &x[1..] })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::new":["fn new() -> HeapVisitor<'a>{\n        HeapVisitor { stack: vec![] }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::pop":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>>{\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::visit":["fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err>{\n        self.stack.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(hir)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this HIR, so we can post visit it now.\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor":["/// A trait for visiting the high-level IR (HIR) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on a high-level intermediate representation of a regular\n/// expression without necessarily using recursion. In particular, this permits\n/// callers to do case analysis with constant stack usage, which can be\n/// important since the size of an HIR may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`](fn.visit.html) function.\npub trait Visitor {\n    /// The result of visiting an HIR.\n    type Output;\n    /// An error that visiting an HIR might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the HIR or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the HIR.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Hir` before descending into child `Hir`\n    /// nodes.\n    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Hir` after descending all of its child\n    /// `Hir` nodes.\n    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an alternation.\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::start":["/// This method is called before beginning traversal of the HIR.\nfn start(&mut self){}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_alternation_in":["/// This method is called between child nodes of an alternation.\nfn visit_alternation_in(&mut self) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_post":["/// This method is called on an `Hir` after descending all of its child\n/// `Hir` nodes.\nfn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_pre":["/// This method is called on an `Hir` before descending into child `Hir`\n/// nodes.\nfn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::visit":["/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Hir` while calling\n/// appropriate methods provided by the\n/// [`Visitor`](trait.Visitor.html) trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Hir` without using a stack size proportional to the depth\n/// of the `Hir`. Namely, this method will instead use constant stack space,\n/// but will use heap space proportional to the size of the `Hir`. This may be\n/// desirable in cases where the size of `Hir` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(hir: &Hir, visitor: V) -> Result<V::Output, V::Err>{\n    HeapVisitor::new().visit(hir, visitor)\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"is_meta_character":["/// Returns true if the give character has significance in a regex.\n///\n/// These are the only characters that are allowed to be escaped, with one\n/// exception: an ASCII space character may be escaped when extended mode (with\n/// the `x` flag) is enabled. In particular, `is_meta_character(' ')` returns\n/// `false`.\n///\n/// Note that the set of characters for which this function returns `true` or\n/// `false` is fixed and won't change in a semver compatible release.\npub fn is_meta_character(c: char) -> bool{\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{'\n        | '}' | '^' | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_word_byte":["/// Returns true if and only if the given character is an ASCII word character.\n///\n/// An ASCII word character is defined by the following character class:\n/// `[_0-9a-zA-Z]'.\npub fn is_word_byte(c: u8) -> bool{\n    match c {\n        b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_word_character":["/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](http://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Panics\n///\n/// If the `unicode-perl` feature is not enabled, then this function panics.\n/// For this reason, it is recommended that callers use\n/// [`try_is_word_character`](fn.try_is_word_character.html)\n/// instead.\npub fn is_word_character(c: char) -> bool{\n    try_is_word_character(c).expect(\"unicode-perl feature must be enabled\")\n}","Real(LocalPath(\"src/lib.rs\"))"],"parser::Parser":["/// A convenience parser for regular expressions.\n///\n/// This parser takes as input a regular expression pattern string (the\n/// \"concrete syntax\") and returns a high-level intermediate representation\n/// (the HIR) suitable for most types of analysis. In particular, this parser\n/// hides the intermediate state of producing an AST (the \"abstract syntax\").\n/// The AST is itself far more complex than the HIR, so this parser serves as a\n/// convenience for never having to deal with it at all.\n///\n/// If callers have more fine grained use cases that need an AST, then please\n/// see the [`ast::parse`](ast/parse/index.html) module.\n///\n/// A `Parser` can be configured in more detail via a\n/// [`ParserBuilder`](struct.ParserBuilder.html).\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::new":["/// Create a new parser with a default configuration.\n///\n/// The parser can be run with `parse` method. The parse method returns\n/// a high level intermediate representation of the given regular\n/// expression.\n///\n/// To set configuration options on the parser, use\n/// [`ParserBuilder`](struct.ParserBuilder.html).\npub fn new() -> Parser{\n        ParserBuilder::new().build()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::parse":["/// Parse the regular expression into a high level intermediate\n/// representation.\npub fn parse(&mut self, pattern: &str) -> Result<hir::Hir>{\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder":["/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\n///\n/// This type combines the builder options for both the\n/// [AST `ParserBuilder`](ast/parse/struct.ParserBuilder.html)\n/// and the\n/// [HIR `TranslatorBuilder`](hir/translate/struct.TranslatorBuilder.html).\npub struct ParserBuilder {\n    ast: ast::parse::ParserBuilder,\n    hir: hir::translate::TranslatorBuilder,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::allow_invalid_utf8":["/// When enabled, the parser will permit the construction of a regular\n/// expression that may match invalid UTF-8.\n///\n/// When disabled (the default), the parser is guaranteed to produce\n/// an expression that will only ever match valid UTF-8 (otherwise, the\n/// parser will return an error).\n///\n/// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n/// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n/// the parser to return an error. Namely, a negated ASCII word boundary\n/// can result in matching positions that aren't valid UTF-8 boundaries.\npub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.allow_invalid_utf8(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::build":["/// Build a parser from this configuration with the given pattern.\npub fn build(&self) -> Parser{\n        Parser { ast: self.ast.build(), hir: self.hir.build() }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::case_insensitive":["/// Enable or disable the case insensitive flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `i` flag.\npub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.case_insensitive(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::dot_matches_new_line":["/// Enable or disable the \"dot matches any character\" flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `s` flag.\npub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.dot_matches_new_line(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::ignore_whitespace":["/// Enable verbose mode in the regular expression.\n///\n/// When enabled, verbose mode permits insigificant whitespace in many\n/// places in the regular expression, as well as comments. Comments are\n/// started using `#` and continue until the end of the line.\n///\n/// By default, this is disabled. It may be selectively enabled in the\n/// regular expression by using the `x` flag regardless of this setting.\npub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ast.ignore_whitespace(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::multi_line":["/// Enable or disable the multi-line matching flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `m` flag.\npub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.multi_line(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// lenth of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder{\n        self.ast.nest_limit(limit);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::new":["/// Create a new parser builder with a default configuration.\npub fn new() -> ParserBuilder{\n        ParserBuilder::default()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ast.octal(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::swap_greed":["/// Enable or disable the \"swap greed\" flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `U` flag.\npub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.swap_greed(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::unicode":["/// Enable or disable the Unicode flag (`u`) by default.\n///\n/// By default this is **enabled**. It may alternatively be selectively\n/// disabled in the regular expression itself via the `u` flag.\n///\n/// Note that unless `allow_invalid_utf8` is enabled (it's disabled by\n/// default), a regular expression will fail to parse if Unicode mode is\n/// disabled and a sub-expression could possibly match invalid UTF-8.\npub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.unicode(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"try_is_word_character":["/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](http://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Errors\n///\n/// If the `unicode-perl` feature is not enabled, then this function always\n/// returns an error.\npub fn try_is_word_character(\n    c: char,\n) -> std::result::Result<bool, UnicodeWordError>{\n    unicode::is_word_character(c)\n}","Real(LocalPath(\"src/lib.rs\"))"],"unicode::CanonicalClassQuery":["/// Like ClassQuery, but its parameters have been canonicalized. This also\n/// differentiates binary properties from flattened general categories and\n/// scripts.\nenum CanonicalClassQuery {\n    /// The canonical binary property name.\n    Binary(&'static str),\n    /// The canonical general category name.\n    GeneralCategory(&'static str),\n    /// The canonical script name.\n    Script(&'static str),\n    /// An arbitrary association between property and value, both of which\n    /// have been canonicalized.\n    ///\n    /// Note that by construction, the property name of ByValue will never\n    /// be General_Category or Script. Those two cases are subsumed by the\n    /// eponymous variants.\n    ByValue {\n        /// The canonical property name.\n        property_name: &'static str,\n        /// The canonical property value.\n        property_value: &'static str,\n    },\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::CaseFoldError":["/// An error that occurs when Unicode-aware simple case folding fails.\n///\n/// This error can occur when the case mapping tables necessary for Unicode\n/// aware case folding are unavailable. This only occurs when the\n/// `unicode-case` feature is disabled. (The feature is enabled by default.)\npub struct CaseFoldError(());","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery":["/// A query for finding a character class defined by Unicode. This supports\n/// either use of a property name directly, or lookup by property value. The\n/// former generally refers to Binary properties (see UTS#44, Table 8), but\n/// as a special exception (see UTS#18, Section 1.2) both general categories\n/// (an enumeration) and scripts (a catalog) are supported as if each of their\n/// possible values were a binary property.\n///\n/// In all circumstances, property names and values are normalized and\n/// canonicalized. That is, `GC == gc == GeneralCategory == general_category`.\n///\n/// The lifetime `'a` refers to the shorter of the lifetimes of property name\n/// and property value.\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery::<'a>::canonical_binary":["fn canonical_binary(&self, name: &str) -> Result<CanonicalClassQuery>{\n        let norm = symbolic_name_normalize(name);\n\n        // This is a special case where 'cf' refers to the 'Format' general\n        // category, but where the 'cf' abbreviation is also an abbreviation\n        // for the 'Case_Folding' property. But we want to treat it as\n        // a general category. (Currently, we don't even support the\n        // 'Case_Folding' property. But if we do in the future, users will be\n        // required to spell it out.)\n        if norm != \"cf\" {\n            if let Some(canon) = canonical_prop(&norm)? {\n                return Ok(CanonicalClassQuery::Binary(canon));\n            }\n        }\n        if let Some(canon) = canonical_gencat(&norm)? {\n            return Ok(CanonicalClassQuery::GeneralCategory(canon));\n        }\n        if let Some(canon) = canonical_script(&norm)? {\n            return Ok(CanonicalClassQuery::Script(canon));\n        }\n        Err(Error::PropertyNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery::<'a>::canonicalize":["fn canonicalize(&self) -> Result<CanonicalClassQuery>{\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(match canon_name {\n                    \"General_Category\" => {\n                        let canon = match canonical_gencat(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::GeneralCategory(canon)\n                    }\n                    \"Script\" => {\n                        let canon = match canonical_script(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::Script(canon)\n                    }\n                    _ => {\n                        let vals = match property_values(canon_name)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(vals) => vals,\n                        };\n                        let canon_val =\n                            match canonical_value(vals, &property_value) {\n                                None => {\n                                    return Err(Error::PropertyValueNotFound)\n                                }\n                                Some(canon_val) => canon_val,\n                            };\n                        CanonicalClassQuery::ByValue {\n                            property_name: canon_name,\n                            property_value: canon_val,\n                        }\n                    }\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::Error":["/// An error that occurs when dealing with Unicode.\n///\n/// We don't impl the Error trait here because these always get converted\n/// into other public errors. (This error type isn't exported.)\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    // Not used when unicode-perl is enabled.\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::UnicodeWordError":["/// An error that occurs when the Unicode-aware `\\w` class is unavailable.\n///\n/// This error can occur when the data tables necessary for the Unicode aware\n/// Perl character class `\\w` are unavailable. This only occurs when the\n/// `unicode-perl` feature is disabled. (The feature is enabled by default.)\npub struct UnicodeWordError(());","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ages":["/// Returns an iterator over Unicode Age sets. Each item corresponds to a set\n/// of codepoints that were added in a particular revision of Unicode. The\n/// iterator yields items in chronological order.\n///\n/// If the given age value isn't valid or if the data isn't available, then an\n/// error is returned instead.\nfn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>>{\n    #[cfg(not(feature = \"unicode-age\"))]\n    fn imp(_: &str) -> Result<impl Iterator<Item = Range>> {\n        use std::option::IntoIter;\n        Err::<IntoIter<Range>, _>(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-age\")]\n    fn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>> {\n        use unicode_tables::age;\n\n        const AGES: &'static [(&'static str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..i + 1].iter().map(|&(_, classes)| classes)),\n        }\n    }\n\n    imp(canonical_age)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ages::imp":["#[cfg(feature = \"unicode-age\")]\nfn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>>{\n        use unicode_tables::age;\n\n        const AGES: &'static [(&'static str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..i + 1].iter().map(|&(_, classes)| classes)),\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::bool_property":["/// Returns the Unicode HIR class corresponding to the given Unicode boolean\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given boolean property could not be found, or if the boolean\n/// property data is not available, then an error is returned.\nfn bool_property(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-bool\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyNotFound)\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        \"White_Space\" => perl_space(),\n        name => imp(name),\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::bool_property::imp":["#[cfg(feature = \"unicode-bool\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_gencat":["fn canonical_gencat(normalized_value: &str) -> Result<Option<&'static str>>{\n    Ok(match normalized_value {\n        \"any\" => Some(\"Any\"),\n        \"assigned\" => Some(\"Assigned\"),\n        \"ascii\" => Some(\"ASCII\"),\n        _ => {\n            let gencats = property_values(\"General_Category\")?.unwrap();\n            canonical_value(gencats, normalized_value)\n        }\n    })\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_prop":["/// Find the canonical property name for the given normalized property name.\n///\n/// If no such property exists, then `None` is returned.\n///\n/// The normalized property name must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\n///\n/// If the property names data is not available, then an error is returned.\nfn canonical_prop(normalized_name: &str) -> Result<Option<&'static str>>{\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &str) -> Result<Option<&'static str>> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &str) -> Result<Option<&'static str>> {\n        use unicode_tables::property_names::PROPERTY_NAMES;\n\n        Ok(PROPERTY_NAMES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_NAMES[i].1))\n    }\n\n    imp(normalized_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_prop::imp":["#[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\nfn imp(name: &str) -> Result<Option<&'static str>>{\n        use unicode_tables::property_names::PROPERTY_NAMES;\n\n        Ok(PROPERTY_NAMES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_NAMES[i].1))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_script":["fn canonical_script(normalized_value: &str) -> Result<Option<&'static str>>{\n    let scripts = property_values(\"Script\")?.unwrap();\n    Ok(canonical_value(scripts, normalized_value))\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_value":["/// Find the canonical property value for the given normalized property\n/// value.\n///\n/// The given property values should correspond to the values for the property\n/// under question, which can be found using `property_values`.\n///\n/// If no such property value exists, then `None` is returned.\n///\n/// The normalized property value must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\nfn canonical_value(\n    vals: PropertyValues,\n    normalized_value: &str,\n) -> Option<&'static str>{\n    vals.binary_search_by_key(&normalized_value, |&(n, _)| n)\n        .ok()\n        .map(|i| vals[i].1)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::class":["/// Looks up a Unicode class given a query. If one doesn't exist, then\n/// `None` is returned.\npub fn class(query: ClassQuery) -> Result<hir::ClassUnicode>{\n    use self::CanonicalClassQuery::*;\n\n    match query.canonicalize()? {\n        Binary(name) => bool_property(name),\n        GeneralCategory(name) => gencat(name),\n        Script(name) => script(name),\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            script_extension(property_value)\n        }\n        ByValue {\n            property_name: \"Grapheme_Cluster_Break\",\n            property_value,\n        } => gcb(property_value),\n        ByValue { property_name: \"Sentence_Break\", property_value } => {\n            sb(property_value)\n        }\n        ByValue { property_name: \"Word_Break\", property_value } => {\n            wb(property_value)\n        }\n        _ => {\n            // What else should we support?\n            Err(Error::PropertyNotFound)\n        }\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::contains_simple_case_mapping":["/// Returns true if and only if the given (inclusive) range contains at least\n/// one Unicode scalar value that has a non-empty non-trivial simple case\n/// mapping.\n///\n/// This function panics if `end < start`.\n///\n/// This returns an error if the Unicode case folding tables are not available.\npub fn contains_simple_case_mapping(\n    start: char,\n    end: char,\n) -> FoldResult<bool>{\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn imp(_: char, _: char) -> FoldResult<bool> {\n        Err(CaseFoldError(()))\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn imp(start: char, end: char) -> FoldResult<bool> {\n        use std::cmp::Ordering;\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        assert!(start <= end);\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by(|&(c, _)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if c > end {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }\n\n    imp(start, end)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::contains_simple_case_mapping::imp":["#[cfg(feature = \"unicode-case\")]\nfn imp(start: char, end: char) -> FoldResult<bool>{\n        use std::cmp::Ordering;\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        assert!(start <= end);\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by(|&(c, _)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if c > end {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gcb":["/// Returns the Unicode HIR class corresponding to the given grapheme cluster\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gcb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gencat":["/// Returns the Unicode HIR class corresponding to the given general category.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given general category could not be found, or if the general\n/// category data is not available, then an error is returned.\nfn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-gencat\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => property_set(BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound),\n        }\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        name => imp(name),\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gencat::imp":["#[cfg(feature = \"unicode-gencat\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => property_set(BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound),\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::hir_class":["/// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode{\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::is_word_character":["/// Returns true only if the given codepoint is in the `\\w` character class.\n///\n/// If the `unicode-perl` feature is not enabled, then this returns an error.\npub fn is_word_character(c: char) -> result::Result<bool, UnicodeWordError>{\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp(_: char) -> result::Result<bool, UnicodeWordError> {\n        Err(UnicodeWordError(()))\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp(c: char) -> result::Result<bool, UnicodeWordError> {\n        use is_word_byte;\n        use std::cmp::Ordering;\n        use unicode_tables::perl_word::PERL_WORD;\n\n        if c <= 0x7F as char && is_word_byte(c as u8) {\n            return Ok(true);\n        }\n        Ok(PERL_WORD\n            .binary_search_by(|&(start, end)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if start > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }\n\n    imp(c)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::is_word_character::imp":["#[cfg(feature = \"unicode-perl\")]\nfn imp(c: char) -> result::Result<bool, UnicodeWordError>{\n        use is_word_byte;\n        use std::cmp::Ordering;\n        use unicode_tables::perl_word::PERL_WORD;\n\n        if c <= 0x7F as char && is_word_byte(c as u8) {\n            return Ok(true);\n        }\n        Ok(PERL_WORD\n            .binary_search_by(|&(start, end)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if start > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_digit":["/// Returns a Unicode aware class for \\d.\n///\n/// This returns an error if the data is not available for \\d.\npub fn perl_digit() -> Result<hir::ClassUnicode>{\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_decimal::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::general_category::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_digit::imp":["#[cfg(feature = \"unicode-gencat\")]\nfn imp() -> Result<hir::ClassUnicode>{\n        use unicode_tables::general_category::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_space":["/// Returns a Unicode aware class for \\s.\n///\n/// This returns an error if the data is not available for \\s.\npub fn perl_space() -> Result<hir::ClassUnicode>{\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_space::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::property_bool::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_space::imp":["#[cfg(feature = \"unicode-bool\")]\nfn imp() -> Result<hir::ClassUnicode>{\n        use unicode_tables::property_bool::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_word":["/// Returns a Unicode aware class for \\w.\n///\n/// This returns an error if the data is not available for \\w.\npub fn perl_word() -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_word::PERL_WORD;\n        Ok(hir_class(PERL_WORD))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_word::imp":["#[cfg(feature = \"unicode-perl\")]\nfn imp() -> Result<hir::ClassUnicode>{\n        use unicode_tables::perl_word::PERL_WORD;\n        Ok(hir_class(PERL_WORD))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_set":["#[allow(dead_code)]\nfn property_set(\n    name_map: &'static [(&'static str, Range)],\n    canonical: &'static str,\n) -> Option<Range>{\n    name_map\n        .binary_search_by_key(&canonical, |x| x.0)\n        .ok()\n        .map(|i| name_map[i].1)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_values":["/// Return the table of property values for the given property name.\n///\n/// If the property values data is not available, then an error is returned.\nfn property_values(\n    canonical_property_name: &'static str,\n) -> Result<Option<PropertyValues>>{\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &'static str) -> Result<Option<PropertyValues>> {\n        Err(Error::PropertyValueNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &'static str) -> Result<Option<PropertyValues>> {\n        use unicode_tables::property_values::PROPERTY_VALUES;\n\n        Ok(PROPERTY_VALUES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_VALUES[i].1))\n    }\n\n    imp(canonical_property_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_values::imp":["#[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\nfn imp(name: &'static str) -> Result<Option<PropertyValues>>{\n        use unicode_tables::property_values::PROPERTY_VALUES;\n\n        Ok(PROPERTY_VALUES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_VALUES[i].1))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::sb":["/// Returns the Unicode HIR class corresponding to the given sentence\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::sb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script":["/// Returns the Unicode HIR class corresponding to the given script.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script could not be found, or if the script data is not\n/// available, then an error is returned.\nfn script(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script::imp":["#[cfg(feature = \"unicode-script\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script_extension":["/// Returns the Unicode HIR class corresponding to the given script extension.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script extension could not be found, or if the script data is\n/// not available, then an error is returned.\nfn script_extension(\n    canonical_name: &'static str,\n) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script_extension::imp":["#[cfg(feature = \"unicode-script\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::simple_fold":["/// Return an iterator over the equivalence class of simple case mappings\n/// for the given codepoint. The equivalence class does not include the\n/// given codepoint.\n///\n/// If the equivalence class is empty, then this returns the next scalar\n/// value that has a non-empty equivalence class, if it exists. If no such\n/// scalar value exists, then `None` is returned. The point of this behavior\n/// is to permit callers to avoid calling `simple_fold` more than they need\n/// to, since there is some cost to fetching the equivalence class.\n///\n/// This returns an error if the Unicode case folding tables are not available.\npub fn simple_fold(\n    c: char,\n) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>{\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn imp(\n        _: char,\n    ) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>\n    {\n        use std::option::IntoIter;\n        Err::<result::Result<IntoIter<char>, _>, _>(CaseFoldError(()))\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn imp(\n        c: char,\n    ) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>\n    {\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by_key(&c, |&(c1, _)| c1)\n            .map(|i| CASE_FOLDING_SIMPLE[i].1.iter().map(|&c| c))\n            .map_err(|i| {\n                if i >= CASE_FOLDING_SIMPLE.len() {\n                    None\n                } else {\n                    Some(CASE_FOLDING_SIMPLE[i].0)\n                }\n            }))\n    }\n\n    imp(c)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::simple_fold::imp":["#[cfg(feature = \"unicode-case\")]\nfn imp(\n        c: char,\n    ) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>{\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by_key(&c, |&(c1, _)| c1)\n            .map(|i| CASE_FOLDING_SIMPLE[i].1.iter().map(|&c| c))\n            .map_err(|i| {\n                if i >= CASE_FOLDING_SIMPLE.len() {\n                    None\n                } else {\n                    Some(CASE_FOLDING_SIMPLE[i].0)\n                }\n            }))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::symbolic_name_normalize":["/// Like symbolic_name_normalize_bytes, but operates on a string.\nfn symbolic_name_normalize(x: &str) -> String{\n    let mut tmp = x.as_bytes().to_vec();\n    let len = symbolic_name_normalize_bytes(&mut tmp).len();\n    tmp.truncate(len);\n    // This should always succeed because `symbolic_name_normalize_bytes`\n    // guarantees that `&tmp[..len]` is always valid UTF-8.\n    //\n    // N.B. We could avoid the additional UTF-8 check here, but it's unlikely\n    // to be worth skipping the additional safety check. A benchmark must\n    // justify it first.\n    String::from_utf8(tmp).unwrap()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::symbolic_name_normalize_bytes":["/// Normalize the given symbolic name in place according to UAX44-LM3.\n///\n/// A \"symbolic name\" typically corresponds to property names and property\n/// value aliases. Note, though, that it should not be applied to property\n/// string values.\n///\n/// The slice returned is guaranteed to be valid UTF-8 for all possible values\n/// of `slice`.\n///\n/// See: http://unicode.org/reports/tr44/#UAX44-LM3\nfn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8]{\n    // I couldn't find a place in the standard that specified that property\n    // names/aliases had a particular structure (unlike character names), but\n    // we assume that it's ASCII only and drop anything that isn't ASCII.\n    let mut start = 0;\n    let mut starts_with_is = false;\n    if slice.len() >= 2 {\n        // Ignore any \"is\" prefix.\n        starts_with_is = slice[0..2] == b\"is\"[..]\n            || slice[0..2] == b\"IS\"[..]\n            || slice[0..2] == b\"iS\"[..]\n            || slice[0..2] == b\"Is\"[..];\n        if starts_with_is {\n            start = 2;\n        }\n    }\n    let mut next_write = 0;\n    for i in start..slice.len() {\n        // VALIDITY ARGUMENT: To guarantee that the resulting slice is valid\n        // UTF-8, we ensure that the slice contains only ASCII bytes. In\n        // particular, we drop every non-ASCII byte from the normalized string.\n        let b = slice[i];\n        if b == b' ' || b == b'_' || b == b'-' {\n            continue;\n        } else if b'A' <= b && b <= b'Z' {\n            slice[next_write] = b + (b'a' - b'A');\n            next_write += 1;\n        } else if b <= 0x7F {\n            slice[next_write] = b;\n            next_write += 1;\n        }\n    }\n    // Special case: ISO_Comment has a 'isc' abbreviation. Since we generally\n    // ignore 'is' prefixes, the 'isc' abbreviation gets caught in the cross\n    // fire and ends up creating an alias for 'c' to 'ISO_Comment', but it\n    // is actually an alias for the 'Other' general category.\n    if starts_with_is && next_write == 1 && slice[0] == b'c' {\n        slice[0] = b'i';\n        slice[1] = b's';\n        slice[2] = b'c';\n        next_write = 3;\n    }\n    &mut slice[..next_write]\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::wb":["/// Returns the Unicode HIR class corresponding to the given word break\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::wb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode>{\n        use unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"utf8::ScalarRange":["struct ScalarRange {\n    start: u32,\n    end: u32,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::as_ascii":["/// as_ascii returns this range as a Utf8Range if and only if all scalar\n/// values in this range can be encoded as a single byte.\nfn as_ascii(&self) -> Option<Utf8Range>{\n        if self.is_ascii() {\n            Some(Utf8Range::new(self.start as u8, self.end as u8))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::encode":["/// encode writes the UTF-8 encoding of the start and end of this range\n/// to the corresponding destination slices, and returns the number of\n/// bytes written.\n///\n/// The slices should have room for at least `MAX_UTF8_BYTES`.\nfn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize{\n        let cs = char::from_u32(self.start).unwrap();\n        let ce = char::from_u32(self.end).unwrap();\n        let ss = cs.encode_utf8(start);\n        let se = ce.encode_utf8(end);\n        assert_eq!(ss.len(), se.len());\n        ss.len()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::is_ascii":["/// is_ascii returns true if the range is ASCII only (i.e., takes a single\n/// byte to encode any scalar value).\nfn is_ascii(&self) -> bool{\n        self.is_valid() && self.end <= 0x7f\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::is_valid":["/// is_valid returns true if and only if start <= end.\nfn is_valid(&self) -> bool{\n        self.start <= self.end\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::split":["/// split splits this range if it overlaps with a surrogate codepoint.\n///\n/// Either or both ranges may be invalid.\nfn split(&self) -> Option<(ScalarRange, ScalarRange)>{\n        if self.start < 0xE000 && self.end > 0xD7FF {\n            Some((\n                ScalarRange { start: self.start, end: 0xD7FF },\n                ScalarRange { start: 0xE000, end: self.end },\n            ))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range":["/// A single inclusive range of UTF-8 bytes.\npub struct Utf8Range {\n    /// Start of byte range (inclusive).\n    pub start: u8,\n    /// End of byte range (inclusive).\n    pub end: u8,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range::matches":["/// Returns true if and only if the given byte is in this range.\npub fn matches(&self, b: u8) -> bool{\n        self.start <= b && b <= self.end\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range::new":["fn new(start: u8, end: u8) -> Self{\n        Utf8Range { start, end }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence":["/// Utf8Sequence represents a sequence of byte ranges.\n///\n/// To match a Utf8Sequence, a candidate byte sequence must match each\n/// successive range.\n///\n/// For example, if there are two ranges, `[C2-DF][80-BF]`, then the byte\n/// sequence `\\xDD\\x61` would not match because `0x61 < 0x80`.\npub enum Utf8Sequence {\n    /// One byte range.\n    One(Utf8Range),\n    /// Two successive byte ranges.\n    Two([Utf8Range; 2]),\n    /// Three successive byte ranges.\n    Three([Utf8Range; 3]),\n    /// Four successive byte ranges.\n    Four([Utf8Range; 4]),\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::as_slice":["/// Returns the underlying sequence of byte ranges as a slice.\npub fn as_slice(&self) -> &[Utf8Range]{\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => slice::from_ref(r),\n            Two(ref r) => &r[..],\n            Three(ref r) => &r[..],\n            Four(ref r) => &r[..],\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::from_encoded_range":["/// Creates a new UTF-8 sequence from the encoded bytes of a scalar value\n/// range.\n///\n/// This assumes that `start` and `end` have the same length.\nfn from_encoded_range(start: &[u8], end: &[u8]) -> Self{\n        assert_eq!(start.len(), end.len());\n        match start.len() {\n            2 => Utf8Sequence::Two([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n            ]),\n            3 => Utf8Sequence::Three([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n            ]),\n            4 => Utf8Sequence::Four([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n                Utf8Range::new(start[3], end[3]),\n            ]),\n            n => unreachable!(\"invalid encoded length: {}\", n),\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::len":["/// Returns the number of byte ranges in this sequence.\n///\n/// The length is guaranteed to be in the closed interval `[1, 4]`.\npub fn len(&self) -> usize{\n        self.as_slice().len()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::matches":["/// Returns true if and only if a prefix of `bytes` matches this sequence\n/// of byte ranges.\npub fn matches(&self, bytes: &[u8]) -> bool{\n        if bytes.len() < self.len() {\n            return false;\n        }\n        for (&b, r) in bytes.iter().zip(self) {\n            if !r.matches(b) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::reverse":["/// Reverses the ranges in this sequence.\n///\n/// For example, if this corresponds to the following sequence:\n///\n/// ```ignore\n/// [D0-D3][80-BF]\n/// ```\n///\n/// Then after reversal, it will be\n///\n/// ```ignore\n/// [80-BF][D0-D3]\n/// ```\n///\n/// This is useful when one is constructing a UTF-8 automaton to match\n/// character classes in reverse.\npub fn reverse(&mut self){\n        match *self {\n            Utf8Sequence::One(_) => {}\n            Utf8Sequence::Two(ref mut x) => x.reverse(),\n            Utf8Sequence::Three(ref mut x) => x.reverse(),\n            Utf8Sequence::Four(ref mut x) => x.reverse(),\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences":["/// An iterator over ranges of matching UTF-8 byte sequences.\n///\n/// The iteration represents an alternation of comprehensive byte sequences\n/// that match precisely the set of UTF-8 encoded scalar values.\n///\n/// A byte sequence corresponds to one of the scalar values in the range given\n/// if and only if it completely matches exactly one of the sequences of byte\n/// ranges produced by this iterator.\n///\n/// Each sequence of byte ranges matches a unique set of bytes. That is, no two\n/// sequences will match the same bytes.\n///\n/// # Example\n///\n/// This shows how to match an arbitrary byte sequence against a range of\n/// scalar values.\n///\n/// ```rust\n/// use regex_syntax::utf8::{Utf8Sequences, Utf8Sequence};\n///\n/// fn matches(seqs: &[Utf8Sequence], bytes: &[u8]) -> bool {\n///     for range in seqs {\n///         if range.matches(bytes) {\n///             return true;\n///         }\n///     }\n///     false\n/// }\n///\n/// // Test the basic multilingual plane.\n/// let seqs: Vec<_> = Utf8Sequences::new('\\u{0}', '\\u{FFFF}').collect();\n///\n/// // UTF-8 encoding of 'a'.\n/// assert!(matches(&seqs, &[0x61]));\n/// // UTF-8 encoding of '' (`\\u{2603}`).\n/// assert!(matches(&seqs, &[0xE2, 0x98, 0x83]));\n/// // UTF-8 encoding of `\\u{10348}` (outside the BMP).\n/// assert!(!matches(&seqs, &[0xF0, 0x90, 0x8D, 0x88]));\n/// // Tries to match against a UTF-8 encoding of a surrogate codepoint,\n/// // which is invalid UTF-8, and therefore fails, despite the fact that\n/// // the corresponding codepoint (0xD800) falls in the range given.\n/// assert!(!matches(&seqs, &[0xED, 0xA0, 0x80]));\n/// // And fails against plain old invalid UTF-8.\n/// assert!(!matches(&seqs, &[0xFF, 0xFF]));\n/// ```\n///\n/// If this example seems circuitous, that's because it is! It's meant to be\n/// illustrative. In practice, you could just try to decode your byte sequence\n/// and compare it with the scalar value range directly. However, this is not\n/// always possible (for example, in a byte based automaton).\npub struct Utf8Sequences {\n    range_stack: Vec<ScalarRange>,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::new":["/// Create a new iterator over UTF-8 byte ranges for the scalar value range\n/// given.\npub fn new(start: char, end: char) -> Self{\n        let mut it = Utf8Sequences { range_stack: vec![] };\n        it.push(start as u32, end as u32);\n        it\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::push":["fn push(&mut self, start: u32, end: u32){\n        self.range_stack.push(ScalarRange { start, end });\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::reset":["/// reset resets the scalar value range.\n/// Any existing state is cleared, but resources may be reused.\n///\n/// N.B. Benchmarks say that this method is dubious.\n#[doc(hidden)]\npub fn reset(&mut self, start: char, end: char){\n        self.range_stack.clear();\n        self.push(start as u32, end as u32);\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::max_scalar_value":["fn max_scalar_value(nbytes: usize) -> u32{\n    match nbytes {\n        1 => 0x007F,\n        2 => 0x07FF,\n        3 => 0xFFFF,\n        4 => 0x10FFFF,\n        _ => unreachable!(\"invalid UTF-8 byte sequence size\"),\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"]},"struct_constructor":{"&'a ast::Ast":["child"],"&'a hir::ClassBytesRange":["next"],"&'a hir::ClassUnicodeRange":["next"],"&'a hir::Hir":["child"],"&'static [(&'static str, &'static str)]":["imp","property_values"],"&'static [(char, char)]":["ascii_class","property_set"],"&'static str":["canonical_gencat","canonical_prop","canonical_script","canonical_value","imp"],"&[I]":["intervals"],"&[hir::ClassBytesRange]":["ranges"],"&[hir::ClassUnicodeRange]":["ranges"],"&[hir::literal::Literal]":["literals"],"&[u8]":["as_ref","longest_common_prefix","longest_common_suffix"],"&[utf8::Utf8Range]":["as_slice"],"&ast::ErrorKind":["kind"],"&ast::Flags":["flags"],"&ast::Span":["auxiliary_span","span"],"&ast::parse::Parser":["parser"],"&hir::ErrorKind":["kind"],"&hir::HirKind":["kind"],"&hir::translate::Translator":["trans"],"&str":["description","pattern"],"(ast::ClassBracketed, ast::ClassSetUnion)":["parse_set_class_open"],"(std::option::Option<Self>, std::option::Option<Self>)":["difference","symmetric_difference"],"(utf8::ScalarRange, utf8::ScalarRange)":["split"],"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::IntoIter":["into_iter"],"<Self as ast::visitor::Visitor>::Output":["finish"],"<Self as hir::interval::Interval>::Bound":["lower","upper"],"<Self as hir::visitor::Visitor>::Output":["finish"],"<V as ast::visitor::Visitor>::Output":["visit"],"<V as hir::visitor::Visitor>::Output":["visit"],"<utf8::Utf8Sequences as std::iter::Iterator>::Item":["next"],"ast::Alternation":["clone"],"ast::Assertion":["clone"],"ast::AssertionKind":["clone"],"ast::Ast":["clone","into_ast","parse","pop_group_end"],"ast::CaptureName":["clone","parse_capture_name"],"ast::Class":["clone","parse_set_class"],"ast::ClassAscii":["clone","maybe_parse_ascii_class"],"ast::ClassAsciiKind":["clone","from_name"],"ast::ClassBracketed":["clone"],"ast::ClassPerl":["clone","parse_perl_class"],"ast::ClassPerlKind":["clone"],"ast::ClassSet":["clone","union"],"ast::ClassSetBinaryOp":["clone"],"ast::ClassSetBinaryOpKind":["clone"],"ast::ClassSetItem":["clone","into_class_set_item","into_item","parse_set_class_range"],"ast::ClassSetRange":["clone"],"ast::ClassSetUnion":["clone"],"ast::ClassUnicode":["clone","parse_unicode_class"],"ast::ClassUnicodeKind":["clone"],"ast::ClassUnicodeOpKind":["clone"],"ast::Comment":["clone"],"ast::Concat":["clone"],"ast::Error":["clone","error","unclosed_class_error"],"ast::ErrorKind":["clone"],"ast::Flag":["clone","parse_flag"],"ast::Flags":["clone","parse_flags"],"ast::FlagsItem":["clone"],"ast::FlagsItemKind":["clone"],"ast::Group":["clone"],"ast::GroupKind":["clone"],"ast::HexLiteralKind":["clone"],"ast::Literal":["clone","into_class_literal","parse_hex","parse_hex_brace","parse_hex_digits","parse_octal"],"ast::LiteralKind":["clone"],"ast::Position":["clone","new","pos"],"ast::Repetition":["clone"],"ast::RepetitionKind":["clone"],"ast::RepetitionOp":["clone"],"ast::RepetitionRange":["clone"],"ast::SetFlags":["clone"],"ast::Span":["clone","new","span","span_char","splat"],"ast::SpecialLiteralKind":["clone"],"ast::WithComments":["clone","parse_with_comments"],"ast::parse::ClassState":["clone"],"ast::parse::GroupState":["clone"],"ast::parse::NestLimiter":["new"],"ast::parse::Parser":["build","clone","new"],"ast::parse::ParserBuilder":["clone","default","new"],"ast::parse::ParserI":["clone","new"],"ast::parse::Primitive":["clone","parse_escape","parse_primitive","parse_set_class_item"],"ast::print::Printer":["build","new"],"ast::print::PrinterBuilder":["clone","default","new"],"ast::visitor::ClassFrame":["induct_class"],"ast::visitor::ClassInduct":["child","from_bracketed","from_set"],"ast::visitor::Frame":["induct"],"ast::visitor::HeapVisitor":["new"],"bool":["add","add_byte_class","add_char_class","add_char_class_reverse","all_complete","any_complete","bump","bump_and_bump_space","bump_if","case_insensitive","class_exceeds_limits","contains_empty","contains_simple_case_mapping","cross_add","cross_product","dot_matches_new_line","eq","flag_state","has_subexprs","ignore_whitespace","imp","is_all_ascii","is_all_assertions","is_alternation_literal","is_always_utf8","is_anchored_end","is_anchored_start","is_any_anchored_end","is_any_anchored_start","is_ascii","is_canonical","is_capturing","is_contiguous","is_cut","is_empty","is_eof","is_equal","is_hex","is_intersection_empty","is_line_anchored_end","is_line_anchored_start","is_literal","is_lookaround_prefix","is_match_empty","is_meta_character","is_negated","is_negation","is_one_line","is_subset","is_unicode","is_valid","is_word_byte","is_word_character","matches","multi_line","swap_greed","try_is_word_character","unicode","union","union_prefixes","union_suffixes"],"char":["char","char_at","end","lower","max_value","min_value","peek","peek_space","start","upper"],"either::Either":["clone","parse_group","pop_class"],"error::Error":["clone","from"],"error::Formatter":["from"],"error::Spans":["from_formatter"],"hir::Anchor":["clone"],"hir::Class":["clone"],"hir::ClassBytes":["clone","empty","hir_ascii_class_bytes","hir_perl_byte_class","new","unwrap_class_bytes"],"hir::ClassBytesIter":["iter"],"hir::ClassBytesRange":["clone","default","new"],"hir::ClassUnicode":["bool_property","class","clone","empty","gcb","gencat","hir_class","hir_perl_unicode_class","hir_unicode_class","imp","new","perl_digit","perl_space","perl_word","sb","script","script_extension","unwrap_class_unicode","wb"],"hir::ClassUnicodeIter":["iter"],"hir::ClassUnicodeRange":["clone","default","new"],"hir::Error":["clone","error"],"hir::ErrorKind":["clone"],"hir::Group":["clone"],"hir::GroupKind":["clone"],"hir::Hir":["alternation","anchor","any","class","clone","concat","dot","empty","finish","group","hir_assertion","hir_dot","hir_from_char","hir_from_char_case_insensitive","hir_literal","literal","parse","repetition","translate","unwrap_expr","word_boundary"],"hir::HirInfo":["clone","new"],"hir::HirKind":["clone","into_kind"],"hir::Literal":["clone","literal_to_char"],"hir::Repetition":["clone"],"hir::RepetitionKind":["clone"],"hir::RepetitionRange":["clone"],"hir::WordBoundary":["clone"],"hir::interval::IntervalSet":["clone","new"],"hir::interval::IntervalSetIter":["iter"],"hir::literal::Literal":["clone","empty","new"],"hir::literal::Literals":["clone","empty","prefixes","suffixes","to_empty","trim_suffix","unambiguous_prefixes","unambiguous_suffixes"],"hir::print::Printer":["build","new"],"hir::print::PrinterBuilder":["clone","default","new"],"hir::translate::Flags":["clone","default","flags","from_ast","set_flags","unwrap_group"],"hir::translate::HirFrame":["clone","pop"],"hir::translate::Translator":["build","clone","new"],"hir::translate::TranslatorBuilder":["clone","default","new"],"hir::translate::TranslatorI":["clone","new"],"hir::visitor::Frame":["induct"],"hir::visitor::HeapVisitor":["new"],"impl std::iter::Iterator<Item = &'static [(char, char)]>":["ages","imp"],"impl std::iter::Iterator<Item = char>":["imp","simple_fold"],"parser::Parser":["build","clone","new"],"parser::ParserBuilder":["clone","default","new"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["escape","escape_byte","escape_bytes","escape_unicode","left_pad_line_number","notate","notate_line","repeat_char","symbolic_name_normalize"],"std::vec::Vec":["remove_complete"],"u32":["as_u32","capture_index","digits","max_scalar_value","next_capture_index","parse_decimal"],"u8":["byte","class_literal_byte","end","lower","max_value","min_value","start","upper"],"unicode::CanonicalClassQuery":["canonical_binary","canonicalize"],"usize":["add_item","cls_byte_count","cls_char_count","column","encode","len","limit_class","limit_size","line","line_number_padding","min_len","num_bytes","offset","position"],"utf8::Utf8Range":["as_ascii","clone","new"],"utf8::Utf8Sequence":["clone","from_encoded_range"],"utf8::Utf8Sequences":["new"]},"struct_to_trait":{"ast::Alternation":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Assertion":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::AssertionKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Ast":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"ast::CaptureName":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Class":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassAscii":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassAsciiKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassBracketed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassPerl":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassPerlKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSet":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"ast::ClassSetBinaryOp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetBinaryOpKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetItem":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetUnion":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicode":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicodeKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicodeOpKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Comment":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Concat":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Flag":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Flags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::FlagsItem":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::FlagsItemKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Group":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::GroupKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::HexLiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::LiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Position":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Repetition":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionOp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::SetFlags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Span":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::SpecialLiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::WithComments":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::parse::ClassState":["std::clone::Clone","std::fmt::Debug"],"ast::parse::GroupState":["std::clone::Clone","std::fmt::Debug"],"ast::parse::NestLimiter":["ast::visitor::Visitor","std::fmt::Debug"],"ast::parse::Parser":["std::clone::Clone","std::fmt::Debug"],"ast::parse::ParserBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"ast::parse::ParserI":["std::clone::Clone","std::fmt::Debug"],"ast::parse::Primitive":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::print::Printer":["std::fmt::Debug"],"ast::print::PrinterBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"ast::print::Writer":["ast::visitor::Visitor","std::fmt::Debug"],"ast::visitor::ClassFrame":["std::fmt::Debug"],"ast::visitor::ClassInduct":["std::fmt::Debug"],"either::Either":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Formatter":["std::convert::From","std::fmt::Debug","std::fmt::Display"],"hir::Anchor":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Class":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassBytes":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassBytesIter":["std::fmt::Debug","std::iter::Iterator"],"hir::ClassBytesRange":["hir::interval::Interval","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassUnicode":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassUnicodeIter":["std::fmt::Debug","std::iter::Iterator"],"hir::ClassUnicodeRange":["hir::interval::Interval","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Group":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::GroupKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Hir":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"hir::HirInfo":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::HirKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Repetition":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::RepetitionKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::RepetitionRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::WordBoundary":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::interval::IntervalSet":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::interval::IntervalSetIter":["std::fmt::Debug","std::iter::Iterator"],"hir::literal::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::fmt::Debug","std::marker::StructuralEq","std::ops::Deref","std::ops::DerefMut"],"hir::literal::Literals":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::print::Printer":["std::fmt::Debug"],"hir::print::PrinterBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::print::Writer":["hir::visitor::Visitor","std::fmt::Debug"],"hir::translate::Flags":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"hir::translate::HirFrame":["std::clone::Clone","std::fmt::Debug"],"hir::translate::Translator":["std::clone::Clone","std::fmt::Debug"],"hir::translate::TranslatorBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::translate::TranslatorI":["ast::visitor::Visitor","std::clone::Clone","std::fmt::Debug"],"parser::Parser":["std::clone::Clone","std::fmt::Debug"],"parser::ParserBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"unicode::CanonicalClassQuery":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"unicode::CaseFoldError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"unicode::ClassQuery":["std::fmt::Debug"],"unicode::Error":["std::fmt::Debug"],"unicode::UnicodeWordError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"utf8::ScalarRange":["std::fmt::Debug"],"utf8::Utf8Range":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"utf8::Utf8Sequence":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"utf8::Utf8Sequences":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"]},"targets":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/utf8.rs\"))","std::iter::IntoIterator"],"<ast::Ast as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::Ast as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/ast/mod.rs\"))","std::ops::Drop"],"<ast::ClassSet as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/ast/mod.rs\"))","std::ops::Drop"],"<ast::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/ast/mod.rs\"))","std::error::Error"],"<ast::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::ErrorKind as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::Position as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::Ord"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::PartialOrd"],"<ast::Position as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Debug"],"<ast::Span as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::Ord"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::PartialOrd"],"<ast::Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Debug"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::ParserBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/ast/parse.rs\"))","std::default::Default"],"<ast::print::PrinterBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/ast/print.rs\"))","std::default::Default"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/visitor.rs\"))","std::fmt::Debug"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/visitor.rs\"))","std::fmt::Debug"],"<char as hir::interval::Bound>::as_u32":["as_u32","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::decrement":["decrement","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::increment":["increment","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::max_value":["max_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::min_value":["min_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<error::Error as std::convert::From<ast::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<hir::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/mod.rs\"))","std::iter::Iterator"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["set_lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["set_upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/mod.rs\"))","std::iter::Iterator"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["set_lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["set_upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/hir/mod.rs\"))","std::error::Error"],"<hir::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::ErrorKind as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::Hir as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::Hir as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/hir/mod.rs\"))","std::ops::Drop"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/interval.rs\"))","std::iter::Iterator"],"<hir::literal::Literal as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::cmp::PartialEq"],"<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::cmp::PartialOrd"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::convert::AsRef"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::fmt::Debug"],"<hir::literal::Literal as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::ops::Deref"],"<hir::literal::Literal as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::ops::DerefMut"],"<hir::literal::Literals as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/literal/mod.rs\"))","std::fmt::Debug"],"<hir::print::PrinterBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/print.rs\"))","std::default::Default"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/translate.rs\"))","std::default::Default"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<u8 as hir::interval::Bound>::as_u32":["as_u32","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::decrement":["decrement","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::increment":["increment","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::max_value":["max_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::min_value":["min_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/unicode.rs\"))","std::fmt::Display"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/unicode.rs\"))","std::fmt::Display"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"ast::Alternation::into_ast":["into_ast","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::has_subexprs":["has_subexprs","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Class::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassAsciiKind::from_name":["from_name","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::union":["union","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetItem::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetRange::is_valid":["is_valid","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetUnion::into_item":["into_item","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetUnion::push":["push","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassUnicode::is_negated":["is_negated","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassUnicodeOpKind::is_equal":["is_equal","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Concat::into_ast":["into_ast","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::auxiliary_span":["auxiliary_span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::kind":["kind","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::pattern":["pattern","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Flags::add_item":["add_item","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Flags::flag_state":["flag_state","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::FlagsItemKind::is_negation":["is_negation","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::capture_index":["capture_index","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::flags":["flags","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::is_capturing":["is_capturing","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::HexLiteralKind::digits":["digits","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Literal::byte":["byte","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Position::new":["new","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::RepetitionRange::is_valid":["is_valid","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::is_one_line":["is_one_line","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::new":["new","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::splat":["splat","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::with_end":["with_end","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::with_start":["with_start","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::check":["check","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["decrement_depth","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["increment_depth","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::parse":["parse","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::parse_with_comments":["parse_with_comments","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::reset":["reset","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::build":["build","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::octal":["octal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::add_capture_name":["add_capture_name","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump":["bump","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["bump_and_bump_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_if":["bump_if","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_space":["bump_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::char":["char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::char_at":["char_at","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::column":["column","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::error":["error","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::is_eof":["is_eof","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["is_lookaround_prefix","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::line":["line","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["maybe_parse_ascii_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::next_capture_index":["next_capture_index","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::offset":["offset","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse":["parse","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_capture_name":["parse_capture_name","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["parse_counted_repetition","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_decimal":["parse_decimal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_escape":["parse_escape","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_flag":["parse_flag","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_flags":["parse_flags","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_group":["parse_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex":["parse_hex","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["parse_hex_brace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["parse_hex_digits","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_octal":["parse_octal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_perl_class":["parse_perl_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_primitive":["parse_primitive","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class":["parse_set_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["parse_set_class_item","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["parse_set_class_open","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["parse_set_class_range","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["parse_uncounted_repetition","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["parse_unicode_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_with_comments":["parse_with_comments","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parser":["parser","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pattern":["pattern","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::peek":["peek","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::peek_space":["peek_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_class":["pop_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_class_op":["pop_class_op","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_group":["pop_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_group_end":["pop_group_end","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pos":["pos","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_alternate":["push_alternate","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_class_op":["push_class_op","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_class_open":["push_class_open","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_group":["push_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["push_or_add_alternation","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::span":["span","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::span_char":["span_char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["unclosed_class_error","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_ast":["into_ast","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_class_literal":["into_class_literal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_class_set_item":["into_class_set_item","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::span":["span","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::is_capture_char":["is_capture_char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::is_hex":["is_hex","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::specialize_err":["specialize_err","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::print::Printer::new":["new","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Printer::print":["print","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::PrinterBuilder::build":["build","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::PrinterBuilder::new":["new","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_assertion":["fmt_assertion","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_ascii":["fmt_class_ascii","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":["fmt_class_bracketed_post","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":["fmt_class_bracketed_pre","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_perl":["fmt_class_perl","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":["fmt_class_set_binary_op_kind","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_class_unicode":["fmt_class_unicode","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_flags":["fmt_flags","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_group_post":["fmt_group_post","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_group_pre":["fmt_group_pre","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_literal":["fmt_literal","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_repetition":["fmt_repetition","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_repetition_range":["fmt_repetition_range","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<'p, W>::fmt_set_flags":["fmt_set_flags","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::visitor::ClassFrame::<'a>::child":["child","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::ClassInduct::<'a>::from_bracketed":["from_bracketed","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::ClassInduct::<'a>::from_set":["from_set","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Frame::<'a>::child":["child","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::induct":["induct","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::induct_class":["induct_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::new":["new","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::pop":["pop","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::pop_class":["pop_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit":["visit","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class":["visit_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["visit_class_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["visit_class_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::start":["start","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_post":["visit_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::visit":["visit","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"error::Spans::<'p>::add":["add","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::from_formatter":["from_formatter","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::left_pad_line_number":["left_pad_line_number","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::line_number_padding":["line_number_padding","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::notate":["notate","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::notate_line":["notate_line","Real(LocalPath(\"src/error.rs\"))",""],"error::repeat_char":["repeat_char","Real(LocalPath(\"src/error.rs\"))",""],"escape":["escape","Real(LocalPath(\"src/lib.rs\"))",""],"escape_into":["escape_into","Real(LocalPath(\"src/lib.rs\"))",""],"hir::Class::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::is_always_utf8":["is_always_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::difference":["difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::intersect":["intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::is_all_ascii":["is_all_ascii","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::iter":["iter","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::push":["push","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::ranges":["ranges","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::end":["end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::start":["start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::difference":["difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::intersect":["intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::is_all_ascii":["is_all_ascii","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::iter":["iter","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::push":["push","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::ranges":["ranges","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::try_case_fold_simple":["try_case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::end":["end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::start":["start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::kind":["kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::pattern":["pattern","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::span":["span","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ErrorKind::description":["description","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::alternation":["alternation","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::anchor":["anchor","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::any":["any","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::class":["class","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::concat":["concat","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::dot":["dot","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::group":["group","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::into_kind":["into_kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_all_assertions":["is_all_assertions","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_alternation_literal":["is_alternation_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_always_utf8":["is_always_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_anchored_end":["is_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_anchored_start":["is_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_any_anchored_end":["is_any_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_any_anchored_start":["is_any_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_line_anchored_end":["is_line_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_line_anchored_start":["is_line_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_literal":["is_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::is_match_empty":["is_match_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::kind":["kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::repetition":["repetition","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::word_boundary":["word_boundary","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_all_assertions":["is_all_assertions","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_alternation_literal":["is_alternation_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_always_utf8":["is_always_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_anchored_end":["is_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_anchored_start":["is_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_any_anchored_end":["is_any_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_any_anchored_start":["is_any_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_line_anchored_end":["is_line_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_line_anchored_start":["is_line_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_literal":["is_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::is_match_empty":["is_match_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_all_assertions":["set_all_assertions","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_alternation_literal":["set_alternation_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_always_utf8":["set_always_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_anchored_end":["set_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_anchored_start":["set_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_any_anchored_end":["set_any_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_any_anchored_start":["set_any_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_line_anchored_end":["set_line_anchored_end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_line_anchored_start":["set_line_anchored_start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_literal":["set_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirInfo::set_match_empty":["set_match_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirKind::has_subexprs":["has_subexprs","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirKind::is_empty":["is_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Literal::is_unicode":["is_unicode","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Repetition::is_match_empty":["is_match_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::WordBoundary::is_negated":["is_negated","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::interval::Interval::create":["create","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::difference":["difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::intersect":["intersect","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_contiguous":["is_contiguous","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_intersection_empty":["is_intersection_empty","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_subset":["is_subset","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::union":["union","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::canonicalize":["canonicalize","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::difference":["difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::intersect":["intersect","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::intervals":["intervals","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::is_canonical":["is_canonical","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::iter":["iter","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::negate":["negate","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::new":["new","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::push":["push","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::union":["union","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::literal::Literal::cut":["cut","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literal::empty":["empty","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literal::is_cut":["is_cut","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literal::new":["new","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::_add_char_class":["_add_char_class","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::add":["add","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::add_byte_class":["add_byte_class","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::add_char_class":["add_char_class","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::add_char_class_reverse":["add_char_class_reverse","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::all_complete":["all_complete","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::any_complete":["any_complete","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::class_exceeds_limits":["class_exceeds_limits","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::clear":["clear","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::contains_empty":["contains_empty","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::cross_add":["cross_add","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::cross_product":["cross_product","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::cut":["cut","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::empty":["empty","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::is_empty":["is_empty","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::limit_class":["limit_class","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::limit_size":["limit_size","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::literals":["literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::longest_common_prefix":["longest_common_prefix","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::longest_common_suffix":["longest_common_suffix","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::min_len":["min_len","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::num_bytes":["num_bytes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::prefixes":["prefixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::remove_complete":["remove_complete","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::reverse":["reverse","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::set_limit_class":["set_limit_class","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::set_limit_size":["set_limit_size","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::suffixes":["suffixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::to_empty":["to_empty","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::trim_suffix":["trim_suffix","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::unambiguous_prefixes":["unambiguous_prefixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::unambiguous_suffixes":["unambiguous_suffixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::union":["union","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::union_prefixes":["union_prefixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::Literals::union_suffixes":["union_suffixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::alternate_literals":["alternate_literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::cls_byte_count":["cls_byte_count","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::cls_char_count":["cls_char_count","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::escape_byte":["escape_byte","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::escape_bytes":["escape_bytes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::escape_unicode":["escape_unicode","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::position":["position","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::prefixes":["prefixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::repeat_one_or_more_literals":["repeat_one_or_more_literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::repeat_range_literals":["repeat_range_literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::repeat_zero_or_more_literals":["repeat_zero_or_more_literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::repeat_zero_or_one_literals":["repeat_zero_or_one_literals","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::literal::suffixes":["suffixes","Real(LocalPath(\"src/hir/literal/mod.rs\"))",""],"hir::print::Printer::new":["new","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Printer::print":["print","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::PrinterBuilder::build":["build","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::PrinterBuilder::new":["new","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<'p, W>::write_literal_byte":["write_literal_byte","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<'p, W>::write_literal_char":["write_literal_char","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<'p, W>::write_literal_class_byte":["write_literal_class_byte","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::translate::Flags::case_insensitive":["case_insensitive","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::from_ast":["from_ast","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::merge":["merge","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::multi_line":["multi_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::swap_greed":["swap_greed","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::unicode":["unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_class_bytes":["unwrap_class_bytes","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_class_unicode":["unwrap_class_unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_expr":["unwrap_expr","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_group":["unwrap_group","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Translator::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Translator::translate":["translate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::allow_invalid_utf8":["allow_invalid_utf8","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::build":["build","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::multi_line":["multi_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::unicode":["unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["bytes_fold_and_negate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["class_literal_byte","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["convert_unicode_class_error","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::error":["error","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::flags":["flags","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["hir_assertion","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["hir_dot","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char":["hir_from_char","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive":["hir_from_char_case_insensitive","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_group":["hir_group","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_literal":["hir_literal","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["hir_perl_byte_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["hir_perl_unicode_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["hir_repetition","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["hir_unicode_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::literal_to_char":["literal_to_char","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::pop":["pop","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::push":["push","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["set_flags","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::trans":["trans","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["unicode_fold_and_negate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::ascii_class":["ascii_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::hir_ascii_class_bytes":["hir_ascii_class_bytes","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::visitor::Frame::<'a>::child":["child","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::induct":["induct","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::new":["new","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::pop":["pop","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::visit":["visit","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::start":["start","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_post":["visit_post","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::visit":["visit","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"is_meta_character":["is_meta_character","Real(LocalPath(\"src/lib.rs\"))",""],"is_word_byte":["is_word_byte","Real(LocalPath(\"src/lib.rs\"))",""],"is_word_character":["is_word_character","Real(LocalPath(\"src/lib.rs\"))",""],"parser::Parser::new":["new","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::parse":["parse","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::allow_invalid_utf8":["allow_invalid_utf8","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::build":["build","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::multi_line":["multi_line","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::new":["new","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::octal":["octal","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::unicode":["unicode","Real(LocalPath(\"src/parser.rs\"))",""],"try_is_word_character":["try_is_word_character","Real(LocalPath(\"src/lib.rs\"))",""],"unicode::ClassQuery::<'a>::canonical_binary":["canonical_binary","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ClassQuery::<'a>::canonicalize":["canonicalize","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ages":["ages","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ages::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::bool_property":["bool_property","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::bool_property::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_gencat":["canonical_gencat","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_prop":["canonical_prop","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_prop::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_script":["canonical_script","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_value":["canonical_value","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::class":["class","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::contains_simple_case_mapping":["contains_simple_case_mapping","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::contains_simple_case_mapping::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gcb":["gcb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gcb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gencat":["gencat","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gencat::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::hir_class":["hir_class","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::is_word_character":["is_word_character","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::is_word_character::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_digit":["perl_digit","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_digit::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_space":["perl_space","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_space::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_word":["perl_word","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_word::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_set":["property_set","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_values":["property_values","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_values::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::sb":["sb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::sb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script":["script","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script_extension":["script_extension","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script_extension::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::simple_fold":["simple_fold","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::simple_fold::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::symbolic_name_normalize":["symbolic_name_normalize","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::symbolic_name_normalize_bytes":["symbolic_name_normalize_bytes","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::wb":["wb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::wb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"utf8::ScalarRange::as_ascii":["as_ascii","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::encode":["encode","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::is_ascii":["is_ascii","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::is_valid":["is_valid","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::split":["split","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Range::matches":["matches","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Range::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::as_slice":["as_slice","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::from_encoded_range":["from_encoded_range","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::len":["len","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::matches":["matches","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::reverse":["reverse","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::push":["push","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::reset":["reset","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::max_scalar_value":["max_scalar_value","Real(LocalPath(\"src/utf8.rs\"))",""]},"trait_to_struct":{"ast::visitor::Visitor":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"],"hir::interval::Interval":["hir::ClassBytesRange","hir::ClassUnicodeRange"],"hir::visitor::Visitor":["hir::print::Writer"],"std::clone::Clone":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::ClassState","ast::parse::GroupState","ast::parse::Parser","ast::parse::ParserBuilder","ast::parse::ParserI","ast::parse::Primitive","ast::print::PrinterBuilder","either::Either","error::Error","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Literals","hir::print::PrinterBuilder","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorBuilder","hir::translate::TranslatorI","parser::Parser","parser::ParserBuilder","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::Eq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Literals","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::Ord":["ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::literal::Literal","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::PartialEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Literals","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::PartialOrd":["ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::literal::Literal","utf8::Utf8Range","utf8::Utf8Sequence"],"std::convert::AsRef":["hir::literal::Literal"],"std::convert::From":["error::Error","error::Formatter"],"std::default::Default":["ast::parse::ParserBuilder","ast::print::PrinterBuilder","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::print::PrinterBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder"],"std::error::Error":["ast::Error","error::Error","hir::Error","unicode::CaseFoldError","unicode::UnicodeWordError"],"std::fmt::Debug":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::ClassState","ast::parse::GroupState","ast::parse::NestLimiter","ast::parse::Parser","ast::parse::ParserBuilder","ast::parse::ParserI","ast::parse::Primitive","ast::print::Printer","ast::print::PrinterBuilder","ast::print::Writer","ast::visitor::ClassFrame","ast::visitor::ClassInduct","either::Either","error::Error","error::Formatter","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesIter","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeIter","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::interval::IntervalSetIter","hir::literal::Literal","hir::literal::Literals","hir::print::Printer","hir::print::PrinterBuilder","hir::print::Writer","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorBuilder","hir::translate::TranslatorI","parser::Parser","parser::ParserBuilder","unicode::CanonicalClassQuery","unicode::CaseFoldError","unicode::ClassQuery","unicode::Error","unicode::UnicodeWordError","utf8::ScalarRange","utf8::Utf8Range","utf8::Utf8Sequence","utf8::Utf8Sequences"],"std::fmt::Display":["ast::Ast","ast::Error","ast::ErrorKind","error::Error","error::Formatter","hir::Error","hir::ErrorKind","hir::Hir","unicode::CaseFoldError","unicode::UnicodeWordError"],"std::iter::FusedIterator":["utf8::Utf8Sequences"],"std::iter::Iterator":["hir::ClassBytesIter","hir::ClassUnicodeIter","hir::interval::IntervalSetIter","utf8::Utf8Sequences"],"std::marker::Copy":["ast::ClassSetBinaryOpKind","ast::Flag","ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::translate::Flags","utf8::Utf8Range","utf8::Utf8Sequence"],"std::marker::StructuralEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Literals","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::marker::StructuralPartialEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Anchor","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Error","hir::ErrorKind","hir::Group","hir::GroupKind","hir::Hir","hir::HirInfo","hir::HirKind","hir::Literal","hir::Repetition","hir::RepetitionKind","hir::RepetitionRange","hir::WordBoundary","hir::interval::IntervalSet","hir::literal::Literals","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::ops::Deref":["hir::literal::Literal"],"std::ops::DerefMut":["hir::literal::Literal"],"std::ops::Drop":["ast::Ast","ast::ClassSet","hir::Hir"]},"type_to_def_path":{"ast::Alternation":"ast::Alternation","ast::Assertion":"ast::Assertion","ast::AssertionKind":"ast::AssertionKind","ast::Ast":"ast::Ast","ast::CaptureName":"ast::CaptureName","ast::Class":"ast::Class","ast::ClassAscii":"ast::ClassAscii","ast::ClassAsciiKind":"ast::ClassAsciiKind","ast::ClassBracketed":"ast::ClassBracketed","ast::ClassPerl":"ast::ClassPerl","ast::ClassPerlKind":"ast::ClassPerlKind","ast::ClassSet":"ast::ClassSet","ast::ClassSetBinaryOp":"ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind":"ast::ClassSetBinaryOpKind","ast::ClassSetItem":"ast::ClassSetItem","ast::ClassSetRange":"ast::ClassSetRange","ast::ClassSetUnion":"ast::ClassSetUnion","ast::ClassUnicode":"ast::ClassUnicode","ast::ClassUnicodeKind":"ast::ClassUnicodeKind","ast::ClassUnicodeOpKind":"ast::ClassUnicodeOpKind","ast::Comment":"ast::Comment","ast::Concat":"ast::Concat","ast::Error":"ast::Error","ast::ErrorKind":"ast::ErrorKind","ast::Flag":"ast::Flag","ast::Flags":"ast::Flags","ast::FlagsItem":"ast::FlagsItem","ast::FlagsItemKind":"ast::FlagsItemKind","ast::Group":"ast::Group","ast::GroupKind":"ast::GroupKind","ast::HexLiteralKind":"ast::HexLiteralKind","ast::Literal":"ast::Literal","ast::LiteralKind":"ast::LiteralKind","ast::Position":"ast::Position","ast::Repetition":"ast::Repetition","ast::RepetitionKind":"ast::RepetitionKind","ast::RepetitionOp":"ast::RepetitionOp","ast::RepetitionRange":"ast::RepetitionRange","ast::SetFlags":"ast::SetFlags","ast::Span":"ast::Span","ast::SpecialLiteralKind":"ast::SpecialLiteralKind","ast::WithComments":"ast::WithComments","ast::parse::ClassState":"ast::parse::ClassState","ast::parse::GroupState":"ast::parse::GroupState","ast::parse::NestLimiter<'p, 's, P>":"ast::parse::NestLimiter","ast::parse::Parser":"ast::parse::Parser","ast::parse::ParserBuilder":"ast::parse::ParserBuilder","ast::parse::ParserI<'s, P>":"ast::parse::ParserI","ast::parse::Primitive":"ast::parse::Primitive","ast::print::Printer":"ast::print::Printer","ast::print::PrinterBuilder":"ast::print::PrinterBuilder","ast::print::Writer<'p, W>":"ast::print::Writer","ast::visitor::ClassFrame<'a>":"ast::visitor::ClassFrame","ast::visitor::ClassInduct<'a>":"ast::visitor::ClassInduct","ast::visitor::Frame<'a>":"ast::visitor::Frame","ast::visitor::HeapVisitor<'a>":"ast::visitor::HeapVisitor","either::Either<Left, Right>":"either::Either","error::Error":"error::Error","error::Formatter<'e, E>":"error::Formatter","error::Spans<'p>":"error::Spans","hir::Anchor":"hir::Anchor","hir::Class":"hir::Class","hir::ClassBytes":"hir::ClassBytes","hir::ClassBytesIter<'a>":"hir::ClassBytesIter","hir::ClassBytesRange":"hir::ClassBytesRange","hir::ClassUnicode":"hir::ClassUnicode","hir::ClassUnicodeIter<'a>":"hir::ClassUnicodeIter","hir::ClassUnicodeRange":"hir::ClassUnicodeRange","hir::Error":"hir::Error","hir::ErrorKind":"hir::ErrorKind","hir::Group":"hir::Group","hir::GroupKind":"hir::GroupKind","hir::Hir":"hir::Hir","hir::HirInfo":"hir::HirInfo","hir::HirKind":"hir::HirKind","hir::Literal":"hir::Literal","hir::Repetition":"hir::Repetition","hir::RepetitionKind":"hir::RepetitionKind","hir::RepetitionRange":"hir::RepetitionRange","hir::WordBoundary":"hir::WordBoundary","hir::interval::IntervalSet<I>":"hir::interval::IntervalSet","hir::interval::IntervalSetIter<'a, I>":"hir::interval::IntervalSetIter","hir::literal::Literal":"hir::literal::Literal","hir::literal::Literals":"hir::literal::Literals","hir::print::Printer":"hir::print::Printer","hir::print::PrinterBuilder":"hir::print::PrinterBuilder","hir::print::Writer<'p, W>":"hir::print::Writer","hir::translate::Flags":"hir::translate::Flags","hir::translate::HirFrame":"hir::translate::HirFrame","hir::translate::Translator":"hir::translate::Translator","hir::translate::TranslatorBuilder":"hir::translate::TranslatorBuilder","hir::translate::TranslatorI<'t, 'p>":"hir::translate::TranslatorI","hir::visitor::Frame<'a>":"hir::visitor::Frame","hir::visitor::HeapVisitor<'a>":"hir::visitor::HeapVisitor","parser::Parser":"parser::Parser","parser::ParserBuilder":"parser::ParserBuilder","unicode::CanonicalClassQuery":"unicode::CanonicalClassQuery","unicode::CaseFoldError":"unicode::CaseFoldError","unicode::ClassQuery<'a>":"unicode::ClassQuery","unicode::Error":"unicode::Error","unicode::UnicodeWordError":"unicode::UnicodeWordError","utf8::ScalarRange":"utf8::ScalarRange","utf8::Utf8Range":"utf8::Utf8Range","utf8::Utf8Sequence":"utf8::Utf8Sequence","utf8::Utf8Sequences":"utf8::Utf8Sequences"}}