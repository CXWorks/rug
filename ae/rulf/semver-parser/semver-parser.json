{"dependencies":{"<generated::Rule as std::clone::Clone>::clone":["generated::Rule"],"<generated::Rule as std::cmp::Eq>::assert_receiver_is_total_eq":["generated::Rule"],"<generated::Rule as std::cmp::Ord>::cmp":["generated::Rule","std::cmp::Ordering"],"<generated::Rule as std::cmp::PartialEq>::eq":["generated::Rule"],"<generated::Rule as std::cmp::PartialOrd>::partial_cmp":["generated::Rule","std::marker::Sized","std::option::Option"],"<generated::Rule as std::fmt::Debug>::fmt":["generated::Rule","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<generated::Rule as std::hash::Hash>::hash":["generated::Rule","std::hash::Hasher","std::marker::Sized"],"<lexer::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["lexer::Error"],"<lexer::Error as std::cmp::Ord>::cmp":["lexer::Error","std::cmp::Ordering"],"<lexer::Error as std::cmp::PartialEq>::eq":["lexer::Error"],"<lexer::Error as std::cmp::PartialOrd>::partial_cmp":["lexer::Error","std::marker::Sized","std::option::Option"],"<lexer::Error as std::fmt::Debug>::fmt":["lexer::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<lexer::Lexer<'input> as std::fmt::Debug>::fmt":["lexer::Lexer","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"<lexer::Lexer<'input> as std::iter::Iterator>::next":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"<lexer::Token<'input> as std::cmp::Eq>::assert_receiver_is_total_eq":["lexer::Token"],"<lexer::Token<'input> as std::cmp::Ord>::cmp":["lexer::Token","std::cmp::Ordering"],"<lexer::Token<'input> as std::cmp::PartialEq>::eq":["lexer::Token"],"<lexer::Token<'input> as std::cmp::PartialOrd>::partial_cmp":["lexer::Token","std::marker::Sized","std::option::Option"],"<lexer::Token<'input> as std::fmt::Debug>::fmt":["lexer::Token","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<parser::Error<'input> as std::cmp::Eq>::assert_receiver_is_total_eq":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<parser::Error<'input> as std::cmp::Ord>::cmp":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec"],"<parser::Error<'input> as std::cmp::PartialEq>::eq":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<parser::Error<'input> as std::cmp::PartialOrd>::partial_cmp":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<parser::Error<'input> as std::convert::From<lexer::Error>>::from":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<parser::Error<'input> as std::fmt::Debug>::fmt":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<parser::Error<'input> as std::fmt::Display>::fmt":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<range::Comparator as std::clone::Clone>::clone":["range::Comparator","range::Op","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Comparator as std::cmp::Eq>::assert_receiver_is_total_eq":["range::Comparator","range::Op","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Comparator as std::cmp::Ord>::cmp":["range::Comparator","range::Op","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec"],"<range::Comparator as std::cmp::PartialEq>::eq":["range::Comparator","range::Op","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Comparator as std::cmp::PartialOrd>::partial_cmp":["range::Comparator","range::Op","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Comparator as std::fmt::Debug>::fmt":["range::Comparator","range::Op","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<range::Comparator as std::hash::Hash>::hash":["range::Comparator","range::Op","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<range::Identifier as std::clone::Clone>::clone":["range::Identifier","std::string::String"],"<range::Identifier as std::cmp::Eq>::assert_receiver_is_total_eq":["range::Identifier","std::string::String"],"<range::Identifier as std::cmp::Ord>::cmp":["range::Identifier","std::cmp::Ordering","std::string::String"],"<range::Identifier as std::cmp::PartialEq>::eq":["range::Identifier","std::string::String"],"<range::Identifier as std::cmp::PartialOrd>::partial_cmp":["range::Identifier","std::marker::Sized","std::option::Option","std::string::String"],"<range::Identifier as std::fmt::Debug>::fmt":["range::Identifier","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<range::Identifier as std::hash::Hash>::hash":["range::Identifier","std::hash::Hasher","std::marker::Sized","std::string::String"],"<range::Op as std::clone::Clone>::clone":["range::Op"],"<range::Op as std::cmp::Eq>::assert_receiver_is_total_eq":["range::Op"],"<range::Op as std::cmp::Ord>::cmp":["range::Op","std::cmp::Ordering"],"<range::Op as std::cmp::PartialEq>::eq":["range::Op"],"<range::Op as std::cmp::PartialOrd>::partial_cmp":["range::Op","std::marker::Sized","std::option::Option"],"<range::Op as std::fmt::Debug>::fmt":["range::Op","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<range::Op as std::hash::Hash>::hash":["range::Op","std::hash::Hasher","std::marker::Sized"],"<range::Partial as std::clone::Clone>::clone":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Partial as std::cmp::Eq>::assert_receiver_is_total_eq":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Partial as std::cmp::Ord>::cmp":["range::Partial","range::PartialKind","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Partial as std::cmp::PartialEq>::eq":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Partial as std::cmp::PartialOrd>::partial_cmp":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Partial as std::fmt::Debug>::fmt":["range::Partial","range::PartialKind","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<range::Partial as std::hash::Hash>::hash":["range::Partial","range::PartialKind","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::PartialKind as std::clone::Clone>::clone":["range::PartialKind"],"<range::PartialKind as std::cmp::Eq>::assert_receiver_is_total_eq":["range::PartialKind"],"<range::PartialKind as std::cmp::Ord>::cmp":["range::PartialKind","std::cmp::Ordering"],"<range::PartialKind as std::cmp::PartialEq>::eq":["range::PartialKind"],"<range::PartialKind as std::cmp::PartialOrd>::partial_cmp":["range::PartialKind","std::marker::Sized","std::option::Option"],"<range::PartialKind as std::fmt::Debug>::fmt":["range::PartialKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<range::PartialKind as std::hash::Hash>::hash":["range::PartialKind","std::hash::Hasher","std::marker::Sized"],"<range::Range as std::clone::Clone>::clone":["range::Range","range_set::Compat","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Range as std::cmp::Eq>::assert_receiver_is_total_eq":["range::Range","range_set::Compat","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Range as std::cmp::Ord>::cmp":["range::Range","range_set::Compat","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec"],"<range::Range as std::cmp::PartialEq>::eq":["range::Range","range_set::Compat","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range::Range as std::cmp::PartialOrd>::partial_cmp":["range::Range","range_set::Compat","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range::Range as std::fmt::Debug>::fmt":["range::Range","range_set::Compat","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<range::Range as std::hash::Hash>::hash":["range::Range","range_set::Compat","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<range_set::Compat as std::clone::Clone>::clone":["range_set::Compat"],"<range_set::Compat as std::cmp::Eq>::assert_receiver_is_total_eq":["range_set::Compat"],"<range_set::Compat as std::cmp::Ord>::cmp":["range_set::Compat","std::cmp::Ordering"],"<range_set::Compat as std::cmp::PartialEq>::eq":["range_set::Compat"],"<range_set::Compat as std::cmp::PartialOrd>::partial_cmp":["range_set::Compat","std::marker::Sized","std::option::Option"],"<range_set::Compat as std::fmt::Debug>::fmt":["range_set::Compat","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<range_set::Compat as std::hash::Hash>::hash":["range_set::Compat","std::hash::Hasher","std::marker::Sized"],"<range_set::RangeSet as std::clone::Clone>::clone":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range_set::RangeSet as std::cmp::Eq>::assert_receiver_is_total_eq":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range_set::RangeSet as std::cmp::Ord>::cmp":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec"],"<range_set::RangeSet as std::cmp::PartialEq>::eq":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<range_set::RangeSet as std::cmp::PartialOrd>::partial_cmp":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<range_set::RangeSet as std::fmt::Debug>::fmt":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<range_set::RangeSet as std::hash::Hash>::hash":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<range_set::RangeSet as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<version::Identifier as std::clone::Clone>::clone":["std::string::String","version::Identifier"],"<version::Identifier as std::cmp::Eq>::assert_receiver_is_total_eq":["std::string::String","version::Identifier"],"<version::Identifier as std::cmp::Ord>::cmp":["std::cmp::Ordering","std::string::String","version::Identifier"],"<version::Identifier as std::cmp::PartialEq>::eq":["std::string::String","version::Identifier"],"<version::Identifier as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","std::string::String","version::Identifier"],"<version::Identifier as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","version::Identifier"],"<version::Identifier as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","version::Identifier"],"<version::Identifier as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","std::string::String","version::Identifier"],"<version::Version as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","version::Version"],"<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","version::Version"],"<version::Version as std::cmp::Ord>::cmp":["std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec","version::Version"],"<version::Version as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","version::Version"],"<version::Version as std::cmp::PartialOrd>::partial_cmp":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","version::Version"],"<version::Version as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","version::Version"],"<version::Version as std::fmt::Display>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","version::Version"],"<version::Version as std::hash::Hash>::hash":["std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec","version::Version"],"SemverParser":["SemverParser"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse":["generated::Rule","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::hidden::skip":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::EOI":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::SOI":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::caret":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::empty":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::hyphen":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::logical_or":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::nr":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::part":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::partial":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::parts":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive_op":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::qualifier":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range_set":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::simple":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::space":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::tilde":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr_op":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"generated::Rule":["generated::Rule"],"lexer::Error":["lexer::Error"],"lexer::Lexer":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::component":["lexer::Lexer","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"lexer::Lexer::<'input>::new":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::one":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::step":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::step_n":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::two":["lexer::Lexer","std::marker::Sized","std::option::Option","std::str::CharIndices"],"lexer::Lexer::<'input>::whitespace":["lexer::Lexer","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"lexer::Token":["lexer::Token"],"lexer::Token::<'input>::is_whitespace":["lexer::Token"],"lexer::Token::<'input>::is_wildcard":["lexer::Token"],"parser::<impl std::convert::From<parser::Error<'input>> for std::string::String>::from":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"parser::Error":["lexer::Error","lexer::Token","parser::Error","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"parser::Parser":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::str::CharIndices"],"parser::Parser::<'input>::component":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::dot_component":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::dot_numeric":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::identifier":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::is_eof":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::str::CharIndices"],"parser::Parser::<'input>::new":["std::marker::Sized","std::result::Result"],"parser::Parser::<'input>::numeric":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::parts":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::peek":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::str::CharIndices"],"parser::Parser::<'input>::plus_build_metadata":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::pop":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::pre":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::skip_whitespace":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::tail":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"parser::Parser::<'input>::version":["lexer::Lexer","parser::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::CharIndices"],"range::Comparator":["range::Comparator","range::Op","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"range::Identifier":["range::Identifier","std::string::String"],"range::Op":["range::Op"],"range::Partial":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::as_comparator":["range::Comparator","range::Op","range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::inc_major":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::inc_minor":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::inc_patch":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::new":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::no_pre":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::zero_minor":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::zero_missing":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::Partial::zero_patch":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::PartialKind":["range::PartialKind"],"range::Range":["range::Range","range_set::Compat","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"range::from_pair_iterator":["pest::iterators::Pair","range_set::Compat","std::marker::Sized","std::result::Result"],"range::simple::from_hyphen_range":["pest::iterators::Pair","std::marker::Sized","std::result::Result"],"range::simple::from_pair_iterator":["pest::iterators::Pair","range_set::Compat","std::marker::Sized","std::result::Result"],"range::simple::handle_caret_range":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range::simple::parse_partial":["range::Partial","range::PartialKind","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"range_set::Compat":["range_set::Compat"],"range_set::RangeSet":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"range_set::RangeSet::new":["range_set::Compat","range_set::RangeSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"range_set::RangeSet::parse":["range_set::Compat","std::marker::Sized","std::result::Result"],"range_set::from_pair_iterator":["pest::iterators::Pair","range_set::Compat","std::marker::Sized","std::result::Result"],"version::Identifier":["std::string::String","version::Identifier"],"version::Identifier::concat":["std::string::String","version::Identifier"],"version::Version":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","version::Version"],"version::parse":["std::marker::Sized","std::result::Result"]},"glob_path_import":{"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible":"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::"},"self_to_fn":{"SemverParser":["impl ::pest::Parser<Rule> for SemverParser {\n  fn parse<'i>(\n    rule: Rule,\n    input: &'i str,\n  ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n    mod rules {\n      pub mod hidden {\n        use super::super::Rule;\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn skip(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          Ok(state)\n        }\n      }\n      pub mod visible {\n        use super::super::Rule;\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn range_set(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::range_set, |state| {\n            state.sequence(|state| {\n              self::SOI(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::range(state))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          self::logical_or(state)\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::range(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  self::logical_or(state)\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::range(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::EOI(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn logical_or(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::logical_or, |state| {\n            state.sequence(|state| {\n              state\n                .sequence(|state| {\n                  state.optional(|state| {\n                    self::space(state).and_then(|state| {\n                      state.repeat(|state| {\n                        state.sequence(|state| {\n                          super::hidden::skip(state).and_then(|state| self::space(state))\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"||\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn range(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::range, |state| {\n            self::hyphen(state)\n              .or_else(|state| {\n                state.sequence(|state| {\n                  self::simple(state)\n                    .and_then(|state| super::hidden::skip(state))\n                    .and_then(|state| {\n                      state.sequence(|state| {\n                        state.optional(|state| {\n                          state\n                            .sequence(|state| {\n                              state\n                                .optional(|state| state.match_string(\",\"))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| {\n                                  state.sequence(|state| {\n                                    self::space(state)\n                                      .and_then(|state| super::hidden::skip(state))\n                                      .and_then(|state| {\n                                        state.sequence(|state| {\n                                          state.optional(|state| {\n                                            self::space(state).and_then(|state| {\n                                              state.repeat(|state| {\n                                                state.sequence(|state| {\n                                                  super::hidden::skip(state)\n                                                    .and_then(|state| self::space(state))\n                                                })\n                                              })\n                                            })\n                                          })\n                                        })\n                                      })\n                                  })\n                                })\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::simple(state))\n                            })\n                            .and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| {\n                                    state.sequence(|state| {\n                                      state\n                                        .optional(|state| state.match_string(\",\"))\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| {\n                                          state.sequence(|state| {\n                                            self::space(state)\n                                              .and_then(|state| super::hidden::skip(state))\n                                              .and_then(|state| {\n                                                state.sequence(|state| {\n                                                  state.optional(|state| {\n                                                    self::space(state).and_then(|state| {\n                                                      state.repeat(|state| {\n                                                        state.sequence(|state| {\n                                                          super::hidden::skip(state)\n                                                            .and_then(|state| self::space(state))\n                                                        })\n                                                      })\n                                                    })\n                                                  })\n                                                })\n                                              })\n                                          })\n                                        })\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| self::simple(state))\n                                    })\n                                  })\n                                })\n                              })\n                            })\n                        })\n                      })\n                    })\n                })\n              })\n              .or_else(|state| self::empty(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn empty(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::empty, |state| state.match_string(\"\"))\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn hyphen(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::hyphen, |state| {\n            state.sequence(|state| {\n              self::partial(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"-\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn simple(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::simple, |state| {\n            self::primitive(state)\n              .or_else(|state| self::partial(state))\n              .or_else(|state| self::tilde(state))\n              .or_else(|state| self::caret(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn primitive(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::primitive, |state| {\n            state.sequence(|state| {\n              self::primitive_op(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn primitive_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::primitive_op, |state| {\n            state\n              .match_string(\"<=\")\n              .or_else(|state| state.match_string(\">=\"))\n              .or_else(|state| state.match_string(\">\"))\n              .or_else(|state| state.match_string(\"<\"))\n              .or_else(|state| state.match_string(\"=\"))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn partial(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::partial, |state| {\n            state.sequence(|state| {\n              self::xr(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.optional(|state| {\n                    state.sequence(|state| {\n                      state\n                        .match_string(\".\")\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| self::xr(state))\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| {\n                          state.optional(|state| {\n                            state.sequence(|state| {\n                              state\n                                .match_string(\".\")\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::xr(state))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn xr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::xr, |state| {\n            self::xr_op(state).or_else(|state| self::nr(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn xr_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::xr_op, |state| {\n            state\n              .match_string(\"x\")\n              .or_else(|state| state.match_string(\"X\"))\n              .or_else(|state| state.match_string(\"*\"))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn nr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::nr, |state| {\n            state.match_string(\"0\").or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_range('1'..'9')\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state.match_range('0'..'9').and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state)\n                                .and_then(|state| state.match_range('0'..'9'))\n                            })\n                          })\n                        })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn tilde(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::tilde, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"~>\")\n                .or_else(|state| state.match_string(\"~\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn caret(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::caret, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"^\")\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn qualifier(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::qualifier, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"-\")\n                .or_else(|state| state.match_string(\"+\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::parts(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn parts(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::parts, |state| {\n            state.sequence(|state| {\n              self::part(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          state\n                            .match_string(\".\")\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::part(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  state\n                                    .match_string(\".\")\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::part(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn part(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::part, |state| {\n            self::nr(state).or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_string(\"-\")\n                  .or_else(|state| state.match_range('0'..'9'))\n                  .or_else(|state| state.match_range('A'..'Z'))\n                  .or_else(|state| state.match_range('a'..'z'))\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state\n                          .match_string(\"-\")\n                          .or_else(|state| state.match_range('0'..'9'))\n                          .or_else(|state| state.match_range('A'..'Z'))\n                          .or_else(|state| state.match_range('a'..'z'))\n                          .and_then(|state| {\n                            state.repeat(|state| {\n                              state.sequence(|state| {\n                                super::hidden::skip(state).and_then(|state| {\n                                  state\n                                    .match_string(\"-\")\n                                    .or_else(|state| state.match_range('0'..'9'))\n                                    .or_else(|state| state.match_range('A'..'Z'))\n                                    .or_else(|state| state.match_range('a'..'z'))\n                                })\n                              })\n                            })\n                          })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn space(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state\n            .match_string(\" \")\n            .or_else(|state| state.match_string(\"\\t\"))\n        }\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn EOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::EOI, |state| state.end_of_input())\n        }\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn SOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.start_of_input()\n        }\n      }\n      pub use self::visible::*;\n    }\n    ::pest::state(input, |state| match rule {\n      Rule::range_set => rules::range_set(state),\n      Rule::logical_or => rules::logical_or(state),\n      Rule::range => rules::range(state),\n      Rule::empty => rules::empty(state),\n      Rule::hyphen => rules::hyphen(state),\n      Rule::simple => rules::simple(state),\n      Rule::primitive => rules::primitive(state),\n      Rule::primitive_op => rules::primitive_op(state),\n      Rule::partial => rules::partial(state),\n      Rule::xr => rules::xr(state),\n      Rule::xr_op => rules::xr_op(state),\n      Rule::nr => rules::nr(state),\n      Rule::tilde => rules::tilde(state),\n      Rule::caret => rules::caret(state),\n      Rule::qualifier => rules::qualifier(state),\n      Rule::parts => rules::parts(state),\n      Rule::part => rules::part(state),\n      Rule::space => rules::space(state),\n      Rule::EOI => rules::EOI(state),\n    })\n  }\n}"],"generated::Rule":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"lexer::Error":["Debug","Eq","Ord","PartialEq","PartialOrd"],"lexer::Lexer":["Debug","impl<'input> Iterator for Lexer<'input> {\n    type Item = Result<Token<'input>, Error>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        #[allow(clippy::never_loop)]\n        loop {\n            // two subsequent char tokens.\n            if let Some((_, a, b)) = self.two() {\n                let two = match (a, b) {\n                    ('<', '=') => Some(LtEq),\n                    ('>', '=') => Some(GtEq),\n                    ('|', '|') => Some(Or),\n                    _ => None,\n                };\n\n                if let Some(two) = two {\n                    self.step_n(2);\n                    return Some(Ok(two));\n                }\n            }\n\n            // single char and start of numeric tokens.\n            if let Some((start, c)) = self.one() {\n                let tok = match c {\n                    ' ' | '\\t' | '\\n' | '\\r' => {\n                        self.step();\n                        return Some(self.whitespace(start));\n                    }\n                    '=' => Eq,\n                    '>' => Gt,\n                    '<' => Lt,\n                    '^' => Caret,\n                    '~' => Tilde,\n                    '*' => Star,\n                    '.' => Dot,\n                    ',' => Comma,\n                    '-' => Hyphen,\n                    '+' => Plus,\n                    '0'..='9' | 'a'..='z' | 'A'..='Z' => {\n                        self.step();\n                        return Some(self.component(start));\n                    }\n                    c => return Some(Err(UnexpectedChar(c))),\n                };\n\n                self.step();\n                return Some(Ok(tok));\n            };\n\n            return None;\n        }\n    }\n}","impl<'input> Lexer<'input> {\n    /// Construct a new lexer for the given input.\n    pub fn new(input: &str) -> Lexer {\n        let mut chars = input.char_indices();\n        let c1 = chars.next();\n        let c2 = chars.next();\n\n        Lexer {\n            input,\n            chars,\n            c1,\n            c2,\n        }\n    }\n\n    /// Shift all lookahead storage by one.\n    fn step(&mut self) {\n        self.c1 = self.c2;\n        self.c2 = self.chars.next();\n    }\n\n    fn step_n(&mut self, n: usize) {\n        for _ in 0..n {\n            self.step();\n        }\n    }\n\n    /// Access the one character, or set it if it is not set.\n    fn one(&mut self) -> Option<(usize, char)> {\n        self.c1\n    }\n\n    /// Access two characters.\n    fn two(&mut self) -> Option<(usize, char, char)> {\n        self.c1\n            .and_then(|(start, c1)| self.c2.map(|(_, c2)| (start, c1, c2)))\n    }\n\n    /// Consume a component.\n    ///\n    /// A component can either be an alphanumeric or numeric.\n    /// Does not permit leading zeroes if numeric.\n    fn component(&mut self, start: usize) -> Result<Token<'input>, Error> {\n        let end = scan_while!(self, start, '0'..='9' | 'A'..='Z' | 'a'..='z');\n        let input = &self.input[start..end];\n\n        let mut it = input.chars();\n        let (a, b) = (it.next(), it.next());\n\n        // exactly zero\n        if a == Some('0') && b.is_none() {\n            return Ok(Numeric(0));\n        }\n\n        if a != Some('0') {\n            if let Ok(numeric) = input.parse::<u64>() {\n                return Ok(Numeric(numeric));\n            }\n        }\n\n        Ok(AlphaNumeric(input))\n    }\n\n    /// Consume whitespace.\n    fn whitespace(&mut self, start: usize) -> Result<Token<'input>, Error> {\n        let end = scan_while!(self, start, ' ' | '\\t' | '\\n' | '\\r');\n        Ok(Whitespace(start, end))\n    }\n}"],"lexer::Token":["Debug","Eq","Ord","PartialEq","PartialOrd","impl<'input> Token<'input> {\n    /// Check if the current token is a whitespace token.\n    pub fn is_whitespace(&self) -> bool {\n        match *self {\n            Whitespace(..) => true,\n            _ => false,\n        }\n    }\n\n    /// Check if the current token is a wildcard token.\n    pub fn is_wildcard(&self) -> bool {\n        match *self {\n            Star | AlphaNumeric(\"X\") | AlphaNumeric(\"x\") => true,\n            _ => false,\n        }\n    }\n}"],"parser::Error":["Debug","Eq","Ord","PartialEq","PartialOrd","impl<'input> From<lexer::Error> for Error<'input> {\n    fn from(value: lexer::Error) -> Self {\n        Error::Lexer(value)\n    }\n}","impl<'input> fmt::Display for Error<'input> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        use self::Error::*;\n\n        match *self {\n            UnexpectedEnd => write!(fmt, \"expected more input\"),\n            UnexpectedToken(ref token) => write!(fmt, \"encountered unexpected token: {:?}\", token),\n            Lexer(ref error) => write!(fmt, \"lexer error: {:?}\", error),\n            MoreInput(ref tokens) => write!(fmt, \"expected end of input, but got: {:?}\", tokens),\n            EmptyPredicate => write!(fmt, \"encountered empty predicate\"),\n            EmptyRange => write!(fmt, \"encountered empty range\"),\n        }\n    }\n}"],"parser::Parser":["impl<'input> Parser<'input> {\n    /// Construct a new parser for the given input.\n    pub fn new(input: &'input str) -> Result<Parser<'input>, Error<'input>> {\n        let mut lexer = Lexer::new(input);\n\n        let c1 = if let Some(c1) = lexer.next() {\n            Some(c1?)\n        } else {\n            None\n        };\n\n        Ok(Parser { lexer, c1 })\n    }\n\n    /// Pop one token.\n    #[inline(always)]\n    fn pop(&mut self) -> Result<Token<'input>, Error<'input>> {\n        let c1 = if let Some(c1) = self.lexer.next() {\n            Some(c1?)\n        } else {\n            None\n        };\n\n        mem::replace(&mut self.c1, c1).ok_or_else(|| UnexpectedEnd)\n    }\n\n    /// Peek one token.\n    #[inline(always)]\n    fn peek(&mut self) -> Option<&Token<'input>> {\n        self.c1.as_ref()\n    }\n\n    /// Skip whitespace if present.\n    fn skip_whitespace(&mut self) -> Result<(), Error<'input>> {\n        match self.peek() {\n            Some(&Token::Whitespace(_, _)) => self.pop().map(|_| ()),\n            _ => Ok(()),\n        }\n    }\n\n    /// Parse a single component.\n    ///\n    /// Returns `None` if the component is a wildcard.\n    pub fn component(&mut self) -> Result<Option<u64>, Error<'input>> {\n        match self.pop()? {\n            Token::Numeric(number) => Ok(Some(number)),\n            ref t if t.is_wildcard() => Ok(None),\n            tok => Err(UnexpectedToken(tok)),\n        }\n    }\n\n    /// Parse a single numeric.\n    pub fn numeric(&mut self) -> Result<u64, Error<'input>> {\n        match self.pop()? {\n            Token::Numeric(number) => Ok(number),\n            tok => Err(UnexpectedToken(tok)),\n        }\n    }\n\n    /// Optionally parse a dot, then a component.\n    ///\n    /// The second component of the tuple indicates if a wildcard has been encountered, and is\n    /// always `false` if the first component is `Some`.\n    ///\n    /// If a dot is not encountered, `(None, false)` is returned.\n    ///\n    /// If a wildcard is encountered, `(None, true)` is returned.\n    pub fn dot_component(&mut self) -> Result<(Option<u64>, bool), Error<'input>> {\n        match self.peek() {\n            Some(&Token::Dot) => {}\n            _ => return Ok((None, false)),\n        }\n\n        // pop the peeked dot.\n        self.pop()?;\n        self.component().map(|n| (n, n.is_none()))\n    }\n\n    /// Parse a dot, then a numeric.\n    pub fn dot_numeric(&mut self) -> Result<u64, Error<'input>> {\n        match self.pop()? {\n            Token::Dot => {}\n            tok => return Err(UnexpectedToken(tok)),\n        }\n\n        self.numeric()\n    }\n\n    /// Parse an string identifier.\n    ///\n    /// Like, `foo`, or `bar`, or `beta-1`.\n    pub fn identifier(&mut self) -> Result<Identifier, Error<'input>> {\n        let identifier = match self.pop()? {\n            Token::AlphaNumeric(identifier) => {\n                // TODO: Borrow?\n                Identifier::AlphaNumeric(identifier.to_string())\n            }\n            Token::Numeric(n) => Identifier::Numeric(n),\n            tok => return Err(UnexpectedToken(tok)),\n        };\n\n        if let Some(&Token::Hyphen) = self.peek() {\n            // pop the peeked hyphen\n            self.pop()?;\n            // concat with any following identifiers\n            Ok(identifier\n                .concat(\"-\")\n                .concat(&self.identifier()?.to_string()))\n        } else {\n            Ok(identifier)\n        }\n    }\n\n    /// Parse all pre-release identifiers, separated by dots.\n    ///\n    /// Like, `abcdef.1234`.\n    fn pre(&mut self) -> Result<Vec<Identifier>, Error<'input>> {\n        match self.peek() {\n            Some(&Token::Hyphen) => {}\n            _ => return Ok(vec![]),\n        }\n\n        // pop the peeked hyphen.\n        self.pop()?;\n        self.parts()\n    }\n\n    /// Parse a dot-separated set of identifiers.\n    fn parts(&mut self) -> Result<Vec<Identifier>, Error<'input>> {\n        let mut parts = Vec::new();\n\n        parts.push(self.identifier()?);\n\n        while let Some(&Token::Dot) = self.peek() {\n            self.pop()?;\n\n            parts.push(self.identifier()?);\n        }\n\n        Ok(parts)\n    }\n\n    /// Parse optional build metadata.\n    ///\n    /// Like, `` (empty), or `+abcdef`.\n    fn plus_build_metadata(&mut self) -> Result<Vec<Identifier>, Error<'input>> {\n        match self.peek() {\n            Some(&Token::Plus) => {}\n            _ => return Ok(vec![]),\n        }\n\n        // pop the plus.\n        self.pop()?;\n        self.parts()\n    }\n\n    /// Parse a version.\n    ///\n    /// Like, `1.0.0` or `3.0.0-beta.1`.\n    pub fn version(&mut self) -> Result<Version, Error<'input>> {\n        self.skip_whitespace()?;\n\n        let major = self.numeric()?;\n        let minor = self.dot_numeric()?;\n        let patch = self.dot_numeric()?;\n        let pre = self.pre()?;\n        let build = self.plus_build_metadata()?;\n\n        self.skip_whitespace()?;\n\n        Ok(Version {\n            major,\n            minor,\n            patch,\n            pre,\n            build,\n        })\n    }\n\n    /// Check if we have reached the end of input.\n    pub fn is_eof(&mut self) -> bool {\n        self.c1.is_none()\n    }\n\n    /// Get the rest of the tokens in the parser.\n    ///\n    /// Useful for debugging.\n    pub fn tail(&mut self) -> Result<Vec<Token<'input>>, Error<'input>> {\n        let mut out = Vec::new();\n\n        if let Some(t) = self.c1.take() {\n            out.push(t);\n        }\n\n        while let Some(t) = self.lexer.next() {\n            out.push(t?);\n        }\n\n        Ok(out)\n    }\n}"],"range::Comparator":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range::Identifier":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range::Op":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range::Partial":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Partial {\n    pub fn new() -> Self {\n        Self {\n            major: None,\n            minor: None,\n            patch: None,\n            pre: Vec::new(),\n            kind: PartialKind::XRangeOnly,\n        }\n    }\n\n    pub fn as_comparator(&self, op: Op) -> Comparator {\n        Comparator {\n            op,\n            major: self.major.unwrap_or(0),\n            minor: self.minor.unwrap_or(0),\n            patch: self.patch.unwrap_or(0),\n            pre: self.pre.clone(),\n        }\n    }\n\n    pub fn inc_major(&mut self) -> &mut Self {\n        self.major = Some(self.major.unwrap_or(0) + 1);\n        self\n    }\n\n    pub fn inc_minor(&mut self) -> &mut Self {\n        self.minor = Some(self.minor.unwrap_or(0) + 1);\n        self\n    }\n\n    pub fn inc_patch(&mut self) -> &mut Self {\n        self.patch = Some(self.patch.unwrap_or(0) + 1);\n        self\n    }\n\n    pub fn zero_missing(&mut self) -> &mut Self {\n        self.major = Some(self.major.unwrap_or(0));\n        self.minor = Some(self.minor.unwrap_or(0));\n        self.patch = Some(self.patch.unwrap_or(0));\n        self\n    }\n\n    pub fn zero_minor(&mut self) -> &mut Self {\n        self.minor = Some(0);\n        self\n    }\n\n    pub fn zero_patch(&mut self) -> &mut Self {\n        self.patch = Some(0);\n        self\n    }\n\n    pub fn no_pre(&mut self) -> &mut Self {\n        self.pre = Vec::new();\n        self\n    }\n}"],"range::PartialKind":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range::Range":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range_set::Compat":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"range_set::RangeSet":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl FromStr for RangeSet {\n    type Err = String;\n\n    fn from_str(input: &str) -> Result<Self, Self::Err> {\n        // default to cargo-compatible mode\n        RangeSet::parse(input, Compat::Cargo)\n    }\n}","impl RangeSet {\n    fn new() -> RangeSet {\n        RangeSet {\n            ranges: Vec::new(),\n            compat: Compat::Cargo, // default\n        }\n    }\n\n    pub fn parse(input: &str, compat: Compat) -> Result<Self, String> {\n        let range_set = match SemverParser::parse(Rule::range_set, input) {\n            Ok(mut parsed) => match parsed.next() {\n                Some(parsed) => parsed,\n                None => return Err(String::from(\"Could not parse a range set\")),\n            },\n            Err(e) => return Err(e.to_string()),\n        };\n\n        from_pair_iterator(range_set, compat)\n    }\n}"],"std::string::String":["impl<'input> From<Error<'input>> for String {\n    fn from(value: Error<'input>) -> Self {\n        value.to_string()\n    }\n}"],"version::Identifier":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Identifier {\n    pub fn concat(self, add_str: &str) -> Identifier {\n        match self {\n            Identifier::Numeric(n) => Identifier::AlphaNumeric(format!(\"{}{}\", n, add_str)),\n            Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(format!(\"{}{}\", s, add_str)),\n        }\n    }\n}","impl fmt::Display for Identifier {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Identifier::Numeric(ref id) => id.fmt(f),\n            Identifier::AlphaNumeric(ref id) => id.fmt(f),\n        }\n    }\n}"],"version::Version":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl fmt::Display for Version {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch).expect(\"write failed\");\n        if !self.pre.is_empty() {\n            let strs: Vec<_> = self.pre.iter().map(ToString::to_string).collect();\n            write!(f, \"-{}\", strs.join(\".\")).expect(\"write failed\");\n        }\n        if !self.build.is_empty() {\n            let strs: Vec<_> = self.build.iter().map(ToString::to_string).collect();\n            write!(f, \"+{}\", strs.join(\".\")).expect(\"write failed\");\n        }\n        Ok(())\n    }\n}"]},"single_path_import":{"range::Comparator":"Comparator","range::Identifier":"Identifier","range::Op":"Op","range::Range":"Range","range_set::Compat":"Compat","range_set::RangeSet":"RangeSet"},"srcs":{"<lexer::Lexer<'input> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        #[allow(clippy::never_loop)]\n        loop {\n            // two subsequent char tokens.\n            if let Some((_, a, b)) = self.two() {\n                let two = match (a, b) {\n                    ('<', '=') => Some(LtEq),\n                    ('>', '=') => Some(GtEq),\n                    ('|', '|') => Some(Or),\n                    _ => None,\n                };\n\n                if let Some(two) = two {\n                    self.step_n(2);\n                    return Some(Ok(two));\n                }\n            }\n\n            // single char and start of numeric tokens.\n            if let Some((start, c)) = self.one() {\n                let tok = match c {\n                    ' ' | '\\t' | '\\n' | '\\r' => {\n                        self.step();\n                        return Some(self.whitespace(start));\n                    }\n                    '=' => Eq,\n                    '>' => Gt,\n                    '<' => Lt,\n                    '^' => Caret,\n                    '~' => Tilde,\n                    '*' => Star,\n                    '.' => Dot,\n                    ',' => Comma,\n                    '-' => Hyphen,\n                    '+' => Plus,\n                    '0'..='9' | 'a'..='z' | 'A'..='Z' => {\n                        self.step();\n                        return Some(self.component(start));\n                    }\n                    c => return Some(Err(UnexpectedChar(c))),\n                };\n\n                self.step();\n                return Some(Ok(tok));\n            };\n\n            return None;\n        }\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"<parser::Error<'input> as std::convert::From<lexer::Error>>::from":["fn from(value: lexer::Error) -> Self{\n        Error::Lexer(value)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"<parser::Error<'input> as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        use self::Error::*;\n\n        match *self {\n            UnexpectedEnd => write!(fmt, \"expected more input\"),\n            UnexpectedToken(ref token) => write!(fmt, \"encountered unexpected token: {:?}\", token),\n            Lexer(ref error) => write!(fmt, \"lexer error: {:?}\", error),\n            MoreInput(ref tokens) => write!(fmt, \"expected end of input, but got: {:?}\", tokens),\n            EmptyPredicate => write!(fmt, \"encountered empty predicate\"),\n            EmptyRange => write!(fmt, \"encountered empty range\"),\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"<range_set::RangeSet as std::str::FromStr>::from_str":["fn from_str(input: &str) -> Result<Self, Self::Err>{\n        // default to cargo-compatible mode\n        RangeSet::parse(input, Compat::Cargo)\n    }","Real(LocalPath(\"src/range_set.rs\"))"],"<version::Identifier as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Identifier::Numeric(ref id) => id.fmt(f),\n            Identifier::AlphaNumeric(ref id) => id.fmt(f),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch).expect(\"write failed\");\n        if !self.pre.is_empty() {\n            let strs: Vec<_> = self.pre.iter().map(ToString::to_string).collect();\n            write!(f, \"-{}\", strs.join(\".\")).expect(\"write failed\");\n        }\n        if !self.build.is_empty() {\n            let strs: Vec<_> = self.build.iter().map(ToString::to_string).collect();\n            write!(f, \"+{}\", strs.join(\".\")).expect(\"write failed\");\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/version.rs\"))"],"SemverParser":["struct SemverParser;","Real(LocalPath(\"src/lib.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse":["fn parse<'i>(\n    rule: Rule,\n    input: &'i str,\n  ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>>{\n    mod rules {\n      pub mod hidden {\n        use super::super::Rule;\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn skip(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          Ok(state)\n        }\n      }\n      pub mod visible {\n        use super::super::Rule;\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn range_set(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::range_set, |state| {\n            state.sequence(|state| {\n              self::SOI(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::range(state))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          self::logical_or(state)\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::range(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  self::logical_or(state)\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::range(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::EOI(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn logical_or(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::logical_or, |state| {\n            state.sequence(|state| {\n              state\n                .sequence(|state| {\n                  state.optional(|state| {\n                    self::space(state).and_then(|state| {\n                      state.repeat(|state| {\n                        state.sequence(|state| {\n                          super::hidden::skip(state).and_then(|state| self::space(state))\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"||\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn range(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::range, |state| {\n            self::hyphen(state)\n              .or_else(|state| {\n                state.sequence(|state| {\n                  self::simple(state)\n                    .and_then(|state| super::hidden::skip(state))\n                    .and_then(|state| {\n                      state.sequence(|state| {\n                        state.optional(|state| {\n                          state\n                            .sequence(|state| {\n                              state\n                                .optional(|state| state.match_string(\",\"))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| {\n                                  state.sequence(|state| {\n                                    self::space(state)\n                                      .and_then(|state| super::hidden::skip(state))\n                                      .and_then(|state| {\n                                        state.sequence(|state| {\n                                          state.optional(|state| {\n                                            self::space(state).and_then(|state| {\n                                              state.repeat(|state| {\n                                                state.sequence(|state| {\n                                                  super::hidden::skip(state)\n                                                    .and_then(|state| self::space(state))\n                                                })\n                                              })\n                                            })\n                                          })\n                                        })\n                                      })\n                                  })\n                                })\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::simple(state))\n                            })\n                            .and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| {\n                                    state.sequence(|state| {\n                                      state\n                                        .optional(|state| state.match_string(\",\"))\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| {\n                                          state.sequence(|state| {\n                                            self::space(state)\n                                              .and_then(|state| super::hidden::skip(state))\n                                              .and_then(|state| {\n                                                state.sequence(|state| {\n                                                  state.optional(|state| {\n                                                    self::space(state).and_then(|state| {\n                                                      state.repeat(|state| {\n                                                        state.sequence(|state| {\n                                                          super::hidden::skip(state)\n                                                            .and_then(|state| self::space(state))\n                                                        })\n                                                      })\n                                                    })\n                                                  })\n                                                })\n                                              })\n                                          })\n                                        })\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| self::simple(state))\n                                    })\n                                  })\n                                })\n                              })\n                            })\n                        })\n                      })\n                    })\n                })\n              })\n              .or_else(|state| self::empty(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn empty(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::empty, |state| state.match_string(\"\"))\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn hyphen(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::hyphen, |state| {\n            state.sequence(|state| {\n              self::partial(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"-\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn simple(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::simple, |state| {\n            self::primitive(state)\n              .or_else(|state| self::partial(state))\n              .or_else(|state| self::tilde(state))\n              .or_else(|state| self::caret(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn primitive(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::primitive, |state| {\n            state.sequence(|state| {\n              self::primitive_op(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn primitive_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::primitive_op, |state| {\n            state\n              .match_string(\"<=\")\n              .or_else(|state| state.match_string(\">=\"))\n              .or_else(|state| state.match_string(\">\"))\n              .or_else(|state| state.match_string(\"<\"))\n              .or_else(|state| state.match_string(\"=\"))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn partial(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::partial, |state| {\n            state.sequence(|state| {\n              self::xr(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.optional(|state| {\n                    state.sequence(|state| {\n                      state\n                        .match_string(\".\")\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| self::xr(state))\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| {\n                          state.optional(|state| {\n                            state.sequence(|state| {\n                              state\n                                .match_string(\".\")\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::xr(state))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn xr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::xr, |state| {\n            self::xr_op(state).or_else(|state| self::nr(state))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn xr_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::xr_op, |state| {\n            state\n              .match_string(\"x\")\n              .or_else(|state| state.match_string(\"X\"))\n              .or_else(|state| state.match_string(\"*\"))\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn nr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::nr, |state| {\n            state.match_string(\"0\").or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_range('1'..'9')\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state.match_range('0'..'9').and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state)\n                                .and_then(|state| state.match_range('0'..'9'))\n                            })\n                          })\n                        })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn tilde(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::tilde, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"~>\")\n                .or_else(|state| state.match_string(\"~\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn caret(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::caret, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"^\")\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn qualifier(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::qualifier, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"-\")\n                .or_else(|state| state.match_string(\"+\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::parts(state))\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn parts(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::parts, |state| {\n            state.sequence(|state| {\n              self::part(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          state\n                            .match_string(\".\")\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::part(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  state\n                                    .match_string(\".\")\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::part(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn part(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::part, |state| {\n            self::nr(state).or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_string(\"-\")\n                  .or_else(|state| state.match_range('0'..'9'))\n                  .or_else(|state| state.match_range('A'..'Z'))\n                  .or_else(|state| state.match_range('a'..'z'))\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state\n                          .match_string(\"-\")\n                          .or_else(|state| state.match_range('0'..'9'))\n                          .or_else(|state| state.match_range('A'..'Z'))\n                          .or_else(|state| state.match_range('a'..'z'))\n                          .and_then(|state| {\n                            state.repeat(|state| {\n                              state.sequence(|state| {\n                                super::hidden::skip(state).and_then(|state| {\n                                  state\n                                    .match_string(\"-\")\n                                    .or_else(|state| state.match_range('0'..'9'))\n                                    .or_else(|state| state.match_range('A'..'Z'))\n                                    .or_else(|state| state.match_range('a'..'z'))\n                                })\n                              })\n                            })\n                          })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }\n        #[inline]\n        #[allow(non_snake_case, unused_variables)]\n        pub fn space(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state\n            .match_string(\" \")\n            .or_else(|state| state.match_string(\"\\t\"))\n        }\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn EOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.rule(Rule::EOI, |state| state.end_of_input())\n        }\n        #[inline]\n        #[allow(dead_code, non_snake_case, unused_variables)]\n        pub fn SOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n          state.start_of_input()\n        }\n      }\n      pub use self::visible::*;\n    }\n    ::pest::state(input, |state| match rule {\n      Rule::range_set => rules::range_set(state),\n      Rule::logical_or => rules::logical_or(state),\n      Rule::range => rules::range(state),\n      Rule::empty => rules::empty(state),\n      Rule::hyphen => rules::hyphen(state),\n      Rule::simple => rules::simple(state),\n      Rule::primitive => rules::primitive(state),\n      Rule::primitive_op => rules::primitive_op(state),\n      Rule::partial => rules::partial(state),\n      Rule::xr => rules::xr(state),\n      Rule::xr_op => rules::xr_op(state),\n      Rule::nr => rules::nr(state),\n      Rule::tilde => rules::tilde(state),\n      Rule::caret => rules::caret(state),\n      Rule::qualifier => rules::qualifier(state),\n      Rule::parts => rules::parts(state),\n      Rule::part => rules::part(state),\n      Rule::space => rules::space(state),\n      Rule::EOI => rules::EOI(state),\n    })\n  }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::hidden::skip":["#[inline]\n#[allow(dead_code, non_snake_case, unused_variables)]\npub fn skip(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          Ok(state)\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::EOI":["#[inline]\n#[allow(dead_code, non_snake_case, unused_variables)]\npub fn EOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::EOI, |state| state.end_of_input())\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::SOI":["#[inline]\n#[allow(dead_code, non_snake_case, unused_variables)]\npub fn SOI(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.start_of_input()\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::caret":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn caret(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::caret, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"^\")\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::empty":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn empty(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::empty, |state| state.match_string(\"\"))\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::hyphen":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn hyphen(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::hyphen, |state| {\n            state.sequence(|state| {\n              self::partial(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"-\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    self::space(state)\n                      .and_then(|state| super::hidden::skip(state))\n                      .and_then(|state| {\n                        state.sequence(|state| {\n                          state.optional(|state| {\n                            self::space(state).and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| self::space(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                      })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::logical_or":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn logical_or(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::logical_or, |state| {\n            state.sequence(|state| {\n              state\n                .sequence(|state| {\n                  state.optional(|state| {\n                    self::space(state).and_then(|state| {\n                      state.repeat(|state| {\n                        state.sequence(|state| {\n                          super::hidden::skip(state).and_then(|state| self::space(state))\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| state.match_string(\"||\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::nr":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn nr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::nr, |state| {\n            state.match_string(\"0\").or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_range('1'..'9')\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state.match_range('0'..'9').and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state)\n                                .and_then(|state| state.match_range('0'..'9'))\n                            })\n                          })\n                        })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::part":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn part(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::part, |state| {\n            self::nr(state).or_else(|state| {\n              state.sequence(|state| {\n                state\n                  .match_string(\"-\")\n                  .or_else(|state| state.match_range('0'..'9'))\n                  .or_else(|state| state.match_range('A'..'Z'))\n                  .or_else(|state| state.match_range('a'..'z'))\n                  .and_then(|state| super::hidden::skip(state))\n                  .and_then(|state| {\n                    state.sequence(|state| {\n                      state.optional(|state| {\n                        state\n                          .match_string(\"-\")\n                          .or_else(|state| state.match_range('0'..'9'))\n                          .or_else(|state| state.match_range('A'..'Z'))\n                          .or_else(|state| state.match_range('a'..'z'))\n                          .and_then(|state| {\n                            state.repeat(|state| {\n                              state.sequence(|state| {\n                                super::hidden::skip(state).and_then(|state| {\n                                  state\n                                    .match_string(\"-\")\n                                    .or_else(|state| state.match_range('0'..'9'))\n                                    .or_else(|state| state.match_range('A'..'Z'))\n                                    .or_else(|state| state.match_range('a'..'z'))\n                                })\n                              })\n                            })\n                          })\n                      })\n                    })\n                  })\n              })\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::partial":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn partial(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::partial, |state| {\n            state.sequence(|state| {\n              self::xr(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.optional(|state| {\n                    state.sequence(|state| {\n                      state\n                        .match_string(\".\")\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| self::xr(state))\n                        .and_then(|state| super::hidden::skip(state))\n                        .and_then(|state| {\n                          state.optional(|state| {\n                            state.sequence(|state| {\n                              state\n                                .match_string(\".\")\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::xr(state))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::parts":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn parts(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::parts, |state| {\n            state.sequence(|state| {\n              self::part(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          state\n                            .match_string(\".\")\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::part(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  state\n                                    .match_string(\".\")\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::part(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn primitive(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::primitive, |state| {\n            state.sequence(|state| {\n              self::primitive_op(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive_op":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn primitive_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::primitive_op, |state| {\n            state\n              .match_string(\"<=\")\n              .or_else(|state| state.match_string(\">=\"))\n              .or_else(|state| state.match_string(\">\"))\n              .or_else(|state| state.match_string(\"<\"))\n              .or_else(|state| state.match_string(\"=\"))\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::qualifier":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn qualifier(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::qualifier, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"-\")\n                .or_else(|state| state.match_string(\"+\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::parts(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn range(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::range, |state| {\n            self::hyphen(state)\n              .or_else(|state| {\n                state.sequence(|state| {\n                  self::simple(state)\n                    .and_then(|state| super::hidden::skip(state))\n                    .and_then(|state| {\n                      state.sequence(|state| {\n                        state.optional(|state| {\n                          state\n                            .sequence(|state| {\n                              state\n                                .optional(|state| state.match_string(\",\"))\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| {\n                                  state.sequence(|state| {\n                                    self::space(state)\n                                      .and_then(|state| super::hidden::skip(state))\n                                      .and_then(|state| {\n                                        state.sequence(|state| {\n                                          state.optional(|state| {\n                                            self::space(state).and_then(|state| {\n                                              state.repeat(|state| {\n                                                state.sequence(|state| {\n                                                  super::hidden::skip(state)\n                                                    .and_then(|state| self::space(state))\n                                                })\n                                              })\n                                            })\n                                          })\n                                        })\n                                      })\n                                  })\n                                })\n                                .and_then(|state| super::hidden::skip(state))\n                                .and_then(|state| self::simple(state))\n                            })\n                            .and_then(|state| {\n                              state.repeat(|state| {\n                                state.sequence(|state| {\n                                  super::hidden::skip(state).and_then(|state| {\n                                    state.sequence(|state| {\n                                      state\n                                        .optional(|state| state.match_string(\",\"))\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| {\n                                          state.sequence(|state| {\n                                            self::space(state)\n                                              .and_then(|state| super::hidden::skip(state))\n                                              .and_then(|state| {\n                                                state.sequence(|state| {\n                                                  state.optional(|state| {\n                                                    self::space(state).and_then(|state| {\n                                                      state.repeat(|state| {\n                                                        state.sequence(|state| {\n                                                          super::hidden::skip(state)\n                                                            .and_then(|state| self::space(state))\n                                                        })\n                                                      })\n                                                    })\n                                                  })\n                                                })\n                                              })\n                                          })\n                                        })\n                                        .and_then(|state| super::hidden::skip(state))\n                                        .and_then(|state| self::simple(state))\n                                    })\n                                  })\n                                })\n                              })\n                            })\n                        })\n                      })\n                    })\n                })\n              })\n              .or_else(|state| self::empty(state))\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range_set":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn range_set(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::range_set, |state| {\n            state.sequence(|state| {\n              self::SOI(state)\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::range(state))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      state\n                        .sequence(|state| {\n                          self::logical_or(state)\n                            .and_then(|state| super::hidden::skip(state))\n                            .and_then(|state| self::range(state))\n                        })\n                        .and_then(|state| {\n                          state.repeat(|state| {\n                            state.sequence(|state| {\n                              super::hidden::skip(state).and_then(|state| {\n                                state.sequence(|state| {\n                                  self::logical_or(state)\n                                    .and_then(|state| super::hidden::skip(state))\n                                    .and_then(|state| self::range(state))\n                                })\n                              })\n                            })\n                          })\n                        })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::EOI(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::simple":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn simple(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::simple, |state| {\n            self::primitive(state)\n              .or_else(|state| self::partial(state))\n              .or_else(|state| self::tilde(state))\n              .or_else(|state| self::caret(state))\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::space":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn space(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state\n            .match_string(\" \")\n            .or_else(|state| state.match_string(\"\\t\"))\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::tilde":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn tilde(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::tilde, |state| {\n            state.sequence(|state| {\n              state\n                .match_string(\"~>\")\n                .or_else(|state| state.match_string(\"~\"))\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| {\n                  state.sequence(|state| {\n                    state.optional(|state| {\n                      self::space(state).and_then(|state| {\n                        state.repeat(|state| {\n                          state.sequence(|state| {\n                            super::hidden::skip(state).and_then(|state| self::space(state))\n                          })\n                        })\n                      })\n                    })\n                  })\n                })\n                .and_then(|state| super::hidden::skip(state))\n                .and_then(|state| self::partial(state))\n            })\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn xr(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::xr, |state| {\n            self::xr_op(state).or_else(|state| self::nr(state))\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr_op":["#[inline]\n#[allow(non_snake_case, unused_variables)]\npub fn xr_op(\n          state: Box<::pest::ParserState<Rule>>,\n        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>>{\n          state.rule(Rule::xr_op, |state| {\n            state\n              .match_string(\"x\")\n              .or_else(|state| state.match_string(\"X\"))\n              .or_else(|state| state.match_string(\"*\"))\n          })\n        }","Real(LocalPath(\"src/generated.rs\"))"],"generated::Rule":["#[allow(dead_code, non_camel_case_types)]\npub enum Rule {\n  EOI,\n  range_set,\n  logical_or,\n  range,\n  empty,\n  hyphen,\n  simple,\n  primitive,\n  primitive_op,\n  partial,\n  xr,\n  xr_op,\n  nr,\n  tilde,\n  caret,\n  qualifier,\n  parts,\n  part,\n  space,\n}","Real(LocalPath(\"src/generated.rs\"))"],"lexer::Error":["pub enum Error {\n    /// Unexpected character.\n    UnexpectedChar(char),\n}","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer":["/// Lexer for semver tokens belonging to a range.\npub struct Lexer<'input> {\n    input: &'input str,\n    chars: str::CharIndices<'input>,\n    // lookahead\n    c1: Option<(usize, char)>,\n    c2: Option<(usize, char)>,\n}","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::component":["/// Consume a component.\n///\n/// A component can either be an alphanumeric or numeric.\n/// Does not permit leading zeroes if numeric.\nfn component(&mut self, start: usize) -> Result<Token<'input>, Error>{\n        let end = scan_while!(self, start, '0'..='9' | 'A'..='Z' | 'a'..='z');\n        let input = &self.input[start..end];\n\n        let mut it = input.chars();\n        let (a, b) = (it.next(), it.next());\n\n        // exactly zero\n        if a == Some('0') && b.is_none() {\n            return Ok(Numeric(0));\n        }\n\n        if a != Some('0') {\n            if let Ok(numeric) = input.parse::<u64>() {\n                return Ok(Numeric(numeric));\n            }\n        }\n\n        Ok(AlphaNumeric(input))\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::new":["/// Construct a new lexer for the given input.\npub fn new(input: &str) -> Lexer{\n        let mut chars = input.char_indices();\n        let c1 = chars.next();\n        let c2 = chars.next();\n\n        Lexer {\n            input,\n            chars,\n            c1,\n            c2,\n        }\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::one":["/// Access the one character, or set it if it is not set.\nfn one(&mut self) -> Option<(usize, char)>{\n        self.c1\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::step":["/// Shift all lookahead storage by one.\nfn step(&mut self){\n        self.c1 = self.c2;\n        self.c2 = self.chars.next();\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::step_n":["fn step_n(&mut self, n: usize){\n        for _ in 0..n {\n            self.step();\n        }\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::two":["/// Access two characters.\nfn two(&mut self) -> Option<(usize, char, char)>{\n        self.c1\n            .and_then(|(start, c1)| self.c2.map(|(_, c2)| (start, c1, c2)))\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Lexer::<'input>::whitespace":["/// Consume whitespace.\nfn whitespace(&mut self, start: usize) -> Result<Token<'input>, Error>{\n        let end = scan_while!(self, start, ' ' | '\\t' | '\\n' | '\\r');\n        Ok(Whitespace(start, end))\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Token":["/// Semver tokens.\npub enum Token<'input> {\n    /// `=`\n    Eq,\n    /// `>`\n    Gt,\n    /// `<`\n    Lt,\n    /// `<=`\n    LtEq,\n    /// `>=`\n    GtEq,\n    /// '^`\n    Caret,\n    /// '~`\n    Tilde,\n    /// '*`\n    Star,\n    /// `.`\n    Dot,\n    /// `,`\n    Comma,\n    /// `-`\n    Hyphen,\n    /// `+`\n    Plus,\n    /// '||'\n    Or,\n    /// any number of whitespace (`\\t\\r\\n `) and its span.\n    Whitespace(usize, usize),\n    /// Numeric component, like `0` or `42`.\n    Numeric(u64),\n    /// Alphanumeric component, like `alpha1` or `79deadbe`.\n    AlphaNumeric(&'input str),\n}","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Token::<'input>::is_whitespace":["/// Check if the current token is a whitespace token.\npub fn is_whitespace(&self) -> bool{\n        match *self {\n            Whitespace(..) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"lexer::Token::<'input>::is_wildcard":["/// Check if the current token is a wildcard token.\npub fn is_wildcard(&self) -> bool{\n        match *self {\n            Star | AlphaNumeric(\"X\") | AlphaNumeric(\"x\") => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/lexer.rs\"))"],"parser::<impl std::convert::From<parser::Error<'input>> for std::string::String>::from":["fn from(value: Error<'input>) -> Self{\n        value.to_string()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Error":["pub enum Error<'input> {\n    /// Needed more tokens for parsing, but none are available.\n    UnexpectedEnd,\n    /// Unexpected token.\n    UnexpectedToken(Token<'input>),\n    /// An error occurred in the lexer.\n    Lexer(lexer::Error),\n    /// More input available.\n    MoreInput(Vec<Token<'input>>),\n    /// Encountered empty predicate in a set of predicates.\n    EmptyPredicate,\n    /// Encountered an empty range.\n    EmptyRange,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser":["/// A recursive-descent parser for parsing version requirements.\npub struct Parser<'input> {\n    /// Source of token.\n    lexer: Lexer<'input>,\n    /// Lookaehead.\n    c1: Option<Token<'input>>,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::component":["/// Parse a single component.\n///\n/// Returns `None` if the component is a wildcard.\npub fn component(&mut self) -> Result<Option<u64>, Error<'input>>{\n        match self.pop()? {\n            Token::Numeric(number) => Ok(Some(number)),\n            ref t if t.is_wildcard() => Ok(None),\n            tok => Err(UnexpectedToken(tok)),\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::dot_component":["/// Optionally parse a dot, then a component.\n///\n/// The second component of the tuple indicates if a wildcard has been encountered, and is\n/// always `false` if the first component is `Some`.\n///\n/// If a dot is not encountered, `(None, false)` is returned.\n///\n/// If a wildcard is encountered, `(None, true)` is returned.\npub fn dot_component(&mut self) -> Result<(Option<u64>, bool), Error<'input>>{\n        match self.peek() {\n            Some(&Token::Dot) => {}\n            _ => return Ok((None, false)),\n        }\n\n        // pop the peeked dot.\n        self.pop()?;\n        self.component().map(|n| (n, n.is_none()))\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::dot_numeric":["/// Parse a dot, then a numeric.\npub fn dot_numeric(&mut self) -> Result<u64, Error<'input>>{\n        match self.pop()? {\n            Token::Dot => {}\n            tok => return Err(UnexpectedToken(tok)),\n        }\n\n        self.numeric()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::identifier":["/// Parse an string identifier.\n///\n/// Like, `foo`, or `bar`, or `beta-1`.\npub fn identifier(&mut self) -> Result<Identifier, Error<'input>>{\n        let identifier = match self.pop()? {\n            Token::AlphaNumeric(identifier) => {\n                // TODO: Borrow?\n                Identifier::AlphaNumeric(identifier.to_string())\n            }\n            Token::Numeric(n) => Identifier::Numeric(n),\n            tok => return Err(UnexpectedToken(tok)),\n        };\n\n        if let Some(&Token::Hyphen) = self.peek() {\n            // pop the peeked hyphen\n            self.pop()?;\n            // concat with any following identifiers\n            Ok(identifier\n                .concat(\"-\")\n                .concat(&self.identifier()?.to_string()))\n        } else {\n            Ok(identifier)\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::is_eof":["/// Check if we have reached the end of input.\npub fn is_eof(&mut self) -> bool{\n        self.c1.is_none()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::new":["/// Construct a new parser for the given input.\npub fn new(input: &'input str) -> Result<Parser<'input>, Error<'input>>{\n        let mut lexer = Lexer::new(input);\n\n        let c1 = if let Some(c1) = lexer.next() {\n            Some(c1?)\n        } else {\n            None\n        };\n\n        Ok(Parser { lexer, c1 })\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::numeric":["/// Parse a single numeric.\npub fn numeric(&mut self) -> Result<u64, Error<'input>>{\n        match self.pop()? {\n            Token::Numeric(number) => Ok(number),\n            tok => Err(UnexpectedToken(tok)),\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::parts":["/// Parse a dot-separated set of identifiers.\nfn parts(&mut self) -> Result<Vec<Identifier>, Error<'input>>{\n        let mut parts = Vec::new();\n\n        parts.push(self.identifier()?);\n\n        while let Some(&Token::Dot) = self.peek() {\n            self.pop()?;\n\n            parts.push(self.identifier()?);\n        }\n\n        Ok(parts)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::peek":["/// Peek one token.\n#[inline(always)]\nfn peek(&mut self) -> Option<&Token<'input>>{\n        self.c1.as_ref()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::plus_build_metadata":["/// Parse optional build metadata.\n///\n/// Like, `` (empty), or `+abcdef`.\nfn plus_build_metadata(&mut self) -> Result<Vec<Identifier>, Error<'input>>{\n        match self.peek() {\n            Some(&Token::Plus) => {}\n            _ => return Ok(vec![]),\n        }\n\n        // pop the plus.\n        self.pop()?;\n        self.parts()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::pop":["/// Pop one token.\n#[inline(always)]\nfn pop(&mut self) -> Result<Token<'input>, Error<'input>>{\n        let c1 = if let Some(c1) = self.lexer.next() {\n            Some(c1?)\n        } else {\n            None\n        };\n\n        mem::replace(&mut self.c1, c1).ok_or_else(|| UnexpectedEnd)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::pre":["/// Parse all pre-release identifiers, separated by dots.\n///\n/// Like, `abcdef.1234`.\nfn pre(&mut self) -> Result<Vec<Identifier>, Error<'input>>{\n        match self.peek() {\n            Some(&Token::Hyphen) => {}\n            _ => return Ok(vec![]),\n        }\n\n        // pop the peeked hyphen.\n        self.pop()?;\n        self.parts()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::skip_whitespace":["/// Skip whitespace if present.\nfn skip_whitespace(&mut self) -> Result<(), Error<'input>>{\n        match self.peek() {\n            Some(&Token::Whitespace(_, _)) => self.pop().map(|_| ()),\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::tail":["/// Get the rest of the tokens in the parser.\n///\n/// Useful for debugging.\npub fn tail(&mut self) -> Result<Vec<Token<'input>>, Error<'input>>{\n        let mut out = Vec::new();\n\n        if let Some(t) = self.c1.take() {\n            out.push(t);\n        }\n\n        while let Some(t) = self.lexer.next() {\n            out.push(t?);\n        }\n\n        Ok(out)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::<'input>::version":["/// Parse a version.\n///\n/// Like, `1.0.0` or `3.0.0-beta.1`.\npub fn version(&mut self) -> Result<Version, Error<'input>>{\n        self.skip_whitespace()?;\n\n        let major = self.numeric()?;\n        let minor = self.dot_numeric()?;\n        let patch = self.dot_numeric()?;\n        let pre = self.pre()?;\n        let build = self.plus_build_metadata()?;\n\n        self.skip_whitespace()?;\n\n        Ok(Version {\n            major,\n            minor,\n            patch,\n            pre,\n            build,\n        })\n    }","Real(LocalPath(\"src/parser.rs\"))"],"range::Comparator":["pub struct Comparator {\n    pub op: Op,\n    pub major: u64,\n    pub minor: u64,\n    pub patch: u64,\n    pub pre: Vec<Identifier>,\n}","Real(LocalPath(\"src/range.rs\"))"],"range::Identifier":["pub enum Identifier {\n    Numeric(u64),\n    AlphaNumeric(String),\n}","Real(LocalPath(\"src/range.rs\"))"],"range::Op":["pub enum Op {\n    Lt,\n    Lte,\n    Gt,\n    Gte,\n    Eq,\n}","Real(LocalPath(\"src/range.rs\"))"],"range::Partial":["pub struct Partial {\n    major: Option<u64>,\n    minor: Option<u64>,\n    patch: Option<u64>,\n    pre: Vec<Identifier>,\n    kind: PartialKind,\n}","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::as_comparator":["pub fn as_comparator(&self, op: Op) -> Comparator{\n        Comparator {\n            op,\n            major: self.major.unwrap_or(0),\n            minor: self.minor.unwrap_or(0),\n            patch: self.patch.unwrap_or(0),\n            pre: self.pre.clone(),\n        }\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::inc_major":["pub fn inc_major(&mut self) -> &mut Self{\n        self.major = Some(self.major.unwrap_or(0) + 1);\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::inc_minor":["pub fn inc_minor(&mut self) -> &mut Self{\n        self.minor = Some(self.minor.unwrap_or(0) + 1);\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::inc_patch":["pub fn inc_patch(&mut self) -> &mut Self{\n        self.patch = Some(self.patch.unwrap_or(0) + 1);\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::new":["pub fn new() -> Self{\n        Self {\n            major: None,\n            minor: None,\n            patch: None,\n            pre: Vec::new(),\n            kind: PartialKind::XRangeOnly,\n        }\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::no_pre":["pub fn no_pre(&mut self) -> &mut Self{\n        self.pre = Vec::new();\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::zero_minor":["pub fn zero_minor(&mut self) -> &mut Self{\n        self.minor = Some(0);\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::zero_missing":["pub fn zero_missing(&mut self) -> &mut Self{\n        self.major = Some(self.major.unwrap_or(0));\n        self.minor = Some(self.minor.unwrap_or(0));\n        self.patch = Some(self.patch.unwrap_or(0));\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::Partial::zero_patch":["pub fn zero_patch(&mut self) -> &mut Self{\n        self.patch = Some(0);\n        self\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::PartialKind":["pub enum PartialKind {\n    XRangeOnly,\n    MajorOnly,\n    MajorMinor,\n    MajorMinorPatch,\n}","Real(LocalPath(\"src/range.rs\"))"],"range::Range":["pub struct Range {\n    pub comparator_set: Vec<Comparator>,\n    pub compat: range_set::Compat,\n}","Real(LocalPath(\"src/range.rs\"))"],"range::from_pair_iterator":["pub fn from_pair_iterator(\n    parsed_range: pest::iterators::Pair<'_, Rule>,\n    compat: range_set::Compat,\n) -> Result<Range, String>{\n    // First of all, do we have the correct iterator?\n    if parsed_range.as_rule() != Rule::range {\n        return Err(String::from(\"Error parsing range\"));\n    }\n\n    let mut comparator_set = Vec::new();\n\n    // Now we need to parse each comparator set out of the range\n    for record in parsed_range.into_inner() {\n        match record.as_rule() {\n            Rule::hyphen => {\n                let mut hyphen_set = simple::from_hyphen_range(record)?;\n                comparator_set.append(&mut hyphen_set);\n            }\n            Rule::simple => {\n                let mut comparators = simple::from_pair_iterator(record, compat)?;\n                comparator_set.append(&mut comparators);\n            }\n            Rule::empty => {\n                comparator_set.push(Partial::new().zero_missing().as_comparator(Op::Gte));\n            }\n            _ => unreachable!(),\n        }\n    }\n\n    Ok(Range {\n        comparator_set,\n        compat,\n    })\n}","Real(LocalPath(\"src/range.rs\"))"],"range::simple::from_hyphen_range":["pub fn from_hyphen_range(\n        parsed_simple: pest::iterators::Pair<'_, Rule>,\n    ) -> Result<Vec<Comparator>, String>{\n        // First of all, do we have the correct iterator?\n        if parsed_simple.as_rule() != Rule::hyphen {\n            return Err(String::from(\"Error parsing comparator set\"));\n        }\n\n        let mut comparators = Vec::new();\n\n        // At this point, we have 2 partial records\n        let mut records = parsed_simple.into_inner();\n\n        let components1: Vec<_> = records.next().unwrap().into_inner().collect();\n        let mut partial1 = parse_partial(components1);\n        match partial1.kind {\n            PartialKind::XRangeOnly => {\n                // don't need to include this - the range will be limited by the 2nd part of hyphen\n                // range\n            }\n            _ => comparators.push(partial1.zero_missing().as_comparator(Op::Gte)),\n        }\n\n        let components2: Vec<_> = records.next().unwrap().into_inner().collect();\n        let mut partial2 = parse_partial(components2);\n\n        match partial2.kind {\n            PartialKind::XRangeOnly => {\n                // only include this if the first part of the hyphen range was also '*'\n                if partial1.kind == PartialKind::XRangeOnly {\n                    comparators.push(partial2.zero_missing().as_comparator(Op::Gte));\n                }\n            }\n            PartialKind::MajorOnly => {\n                // \"1.2.3 - 2\" --> \">=1.2.3 <3.0.0\"\n                comparators.push(\n                    partial2\n                        .inc_major()\n                        .zero_minor()\n                        .zero_patch()\n                        .as_comparator(Op::Lt),\n                );\n            }\n            PartialKind::MajorMinor => {\n                // \"1.2.3 - 2.3.x\" --> \">=1.2.3 <2.4.0\"\n                comparators.push(partial2.inc_minor().zero_patch().as_comparator(Op::Lt));\n            }\n            PartialKind::MajorMinorPatch => {\n                // \"1.2.3 - 2.3.4\" --> \">=1.2.3 <=2.3.4\"\n                comparators.push(partial2.as_comparator(Op::Lte));\n            }\n        }\n\n        Ok(comparators)\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::simple::from_pair_iterator":["pub fn from_pair_iterator(\n        parsed_simple: pest::iterators::Pair<'_, Rule>,\n        compat: range_set::Compat,\n    ) -> Result<Vec<Comparator>, String>{\n        // First of all, do we have the correct iterator?\n        if parsed_simple.as_rule() != Rule::simple {\n            return Err(String::from(\"Error parsing comparator set\"));\n        }\n\n        let mut comparators = Vec::new();\n\n        // Now we need to parse each comparator set out of the range\n        for record in parsed_simple.into_inner() {\n            match record.as_rule() {\n                Rule::partial => {\n                    let components: Vec<_> = record.into_inner().collect();\n\n                    let mut partial = parse_partial(components);\n\n                    match partial.kind {\n                        PartialKind::XRangeOnly => {\n                            // '*', 'x', 'X' --> \">=0.0.0\"\n                            comparators.push(partial.zero_missing().as_comparator(Op::Gte));\n                        }\n                        PartialKind::MajorOnly => {\n                            // \"1\", \"1.*\", or \"1.*.*\" --> \">=1.0.0 <2.0.0\"\n                            // \"1.*.3\" == \"1.*\"\n                            comparators.push(partial.clone().zero_missing().as_comparator(Op::Gte));\n                            comparators\n                                .push(partial.inc_major().zero_missing().as_comparator(Op::Lt));\n                        }\n                        PartialKind::MajorMinor => {\n                            // \"1.2\" or \"1.2.*\" --> \">=1.2.0 <1.3.0\"\n                            comparators.push(partial.clone().zero_patch().as_comparator(Op::Gte));\n                            comparators\n                                .push(partial.inc_minor().zero_patch().as_comparator(Op::Lt));\n                        }\n                        PartialKind::MajorMinorPatch => {\n                            match compat {\n                                range_set::Compat::Npm => {\n                                    // for node, \"1.2.3\" is \"=1.2.3\"\n                                    comparators.push(partial.as_comparator(Op::Eq));\n                                }\n                                range_set::Compat::Cargo => {\n                                    // for cargo, \"1.2.3\" is parsed as \"^1.2.3\"\n                                    handle_caret_range(partial, &mut comparators);\n                                }\n                            }\n                        }\n                    }\n                }\n                Rule::primitive => {\n                    let mut components: Vec<_> = record.into_inner().collect();\n                    let op_component = components.remove(0);\n\n                    let op = match op_component.as_str() {\n                        \"=\" => Op::Eq,\n                        \"<\" => Op::Lt,\n                        \"<=\" => Op::Lte,\n                        \">\" => Op::Gt,\n                        \">=\" => Op::Gte,\n                        _ => unreachable!(),\n                    };\n\n                    let partial_component = components.remove(0);\n                    let components: Vec<_> = partial_component.into_inner().collect();\n                    let mut partial = parse_partial(components);\n\n                    // equal is different because it can be a range with 2 comparators\n                    if op == Op::Eq {\n                        match partial.kind {\n                            PartialKind::XRangeOnly => {\n                                // '=*' --> \">=0.0.0\"\n                                comparators.push(partial.zero_missing().as_comparator(Op::Gte));\n                            }\n                            PartialKind::MajorOnly => {\n                                // \"=1\", \"=1.*\", or \"=1.*.*\" --> \">=1.0.0 <2.0.0\"\n                                comparators\n                                    .push(partial.clone().zero_missing().as_comparator(Op::Gte));\n                                comparators\n                                    .push(partial.inc_major().zero_missing().as_comparator(Op::Lt));\n                            }\n                            PartialKind::MajorMinor => {\n                                // \"=1.2\" or \"=1.2.*\" --> \">=1.2.0 <1.3.0\"\n                                comparators\n                                    .push(partial.clone().zero_patch().as_comparator(Op::Gte));\n                                comparators\n                                    .push(partial.inc_minor().zero_patch().as_comparator(Op::Lt));\n                            }\n                            PartialKind::MajorMinorPatch => {\n                                comparators.push(partial.as_comparator(Op::Eq));\n                            }\n                        }\n                    } else {\n                        match partial.kind {\n                            PartialKind::XRangeOnly => {\n                                match op {\n                                    Op::Eq => comparators\n                                        .push(partial.zero_missing().as_comparator(Op::Gte)),\n                                    Op::Lt => comparators\n                                        .push(partial.zero_missing().as_comparator(Op::Lt)),\n                                    Op::Lte => comparators\n                                        .push(partial.zero_missing().as_comparator(Op::Gte)),\n                                    Op::Gt => comparators\n                                        .push(partial.zero_missing().as_comparator(Op::Lt)),\n                                    Op::Gte => comparators\n                                        .push(partial.zero_missing().as_comparator(Op::Gte)),\n                                }\n                            }\n                            PartialKind::MajorOnly => {\n                                // \">1\", \"=1\", etc.\n                                // \">1.*.3\" == \">1.*\"\n                                match op {\n                                    Op::Lte => comparators.push(\n                                        partial\n                                            .inc_major()\n                                            .zero_minor()\n                                            .zero_patch()\n                                            .as_comparator(Op::Lt),\n                                    ),\n                                    _ => comparators.push(partial.zero_missing().as_comparator(op)),\n                                }\n                            }\n                            PartialKind::MajorMinor => {\n                                // \">1.2\", \"<1.2.*\", etc.\n                                match op {\n                                    Op::Lte => comparators.push(\n                                        partial.inc_minor().zero_patch().as_comparator(Op::Lt),\n                                    ),\n                                    _ => comparators.push(partial.zero_patch().as_comparator(op)),\n                                }\n                            }\n                            PartialKind::MajorMinorPatch => {\n                                comparators.push(partial.as_comparator(op));\n                            }\n                        }\n                    }\n                }\n                Rule::caret => {\n                    let mut components: Vec<_> = record.into_inner().collect();\n\n                    let partial_component = components.remove(0);\n                    let components: Vec<_> = partial_component.into_inner().collect();\n                    let partial = parse_partial(components);\n\n                    handle_caret_range(partial, &mut comparators);\n                }\n                Rule::tilde => {\n                    let mut components: Vec<_> = record.into_inner().collect();\n\n                    let partial_component = components.remove(0);\n                    let components: Vec<_> = partial_component.into_inner().collect();\n                    let mut partial = parse_partial(components);\n\n                    comparators.push(partial.clone().zero_missing().as_comparator(Op::Gte));\n\n                    match partial.kind {\n                        PartialKind::XRangeOnly => {\n                            // \"~*\" --> \">=0.0.0\"\n                            // which has already been added, so nothing to do here\n                        }\n                        PartialKind::MajorOnly => {\n                            // \"~0\" --> \">=0.0.0 <1.0.0\"\n                            comparators.push(\n                                partial\n                                    .inc_major()\n                                    .zero_missing()\n                                    .no_pre()\n                                    .as_comparator(Op::Lt),\n                            );\n                        }\n                        PartialKind::MajorMinor | PartialKind::MajorMinorPatch => {\n                            // \"~1.2\" --> \">=1.2.0 <1.3.0\"\n                            // \"~1.2.3\" --> \">=1.2.3 <1.3.0\"\n                            comparators.push(\n                                partial\n                                    .inc_minor()\n                                    .zero_patch()\n                                    .no_pre()\n                                    .as_comparator(Op::Lt),\n                            );\n                        }\n                    }\n                }\n                _ => unreachable!(),\n            }\n        }\n\n        Ok(comparators)\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::simple::handle_caret_range":["fn handle_caret_range(mut partial: Partial, comparators: &mut Vec<Comparator>){\n        // major version 0 is a special case for caret\n        if partial.major == Some(0) {\n            match partial.kind {\n                PartialKind::XRangeOnly => unreachable!(),\n                PartialKind::MajorOnly => {\n                    // \"^0\", \"^0.*\" --> \">=0.0.0 <1.0.0\"\n                    comparators.push(partial.clone().zero_missing().as_comparator(Op::Gte));\n                    comparators.push(\n                        partial\n                            .inc_major()\n                            .zero_missing()\n                            .no_pre()\n                            .as_comparator(Op::Lt),\n                    );\n                }\n                PartialKind::MajorMinor => {\n                    // \"^0.2\", \"^0.2.*\" --> \">=0.2.0 <0.3.0\"\n                    comparators.push(partial.clone().zero_missing().as_comparator(Op::Gte));\n                    comparators.push(\n                        partial\n                            .inc_minor()\n                            .zero_patch()\n                            .no_pre()\n                            .as_comparator(Op::Lt),\n                    );\n                }\n                PartialKind::MajorMinorPatch => {\n                    if partial.minor == Some(0) {\n                        // \"^0.0.1\" --> \">=0.0.1 <0.0.2\"\n                        comparators.push(partial.as_comparator(Op::Gte));\n                        comparators.push(partial.inc_patch().no_pre().as_comparator(Op::Lt));\n                    } else {\n                        // \"^0.2.3\" --> \">=0.2.3 <0.3.0\"\n                        comparators.push(partial.as_comparator(Op::Gte));\n                        comparators.push(\n                            partial\n                                .inc_minor()\n                                .zero_patch()\n                                .no_pre()\n                                .as_comparator(Op::Lt),\n                        );\n                    }\n                }\n            }\n        } else {\n            match partial.kind {\n                PartialKind::XRangeOnly => {\n                    // \"^*\" --> \">=0.0.0\"\n                    comparators.push(partial.zero_missing().as_comparator(Op::Gte));\n                }\n                _ => {\n                    // \"^1\", \"^1.*\" --> \">=1.0.0 <2.0.0\"\n                    // \"^1.2\", \"^1.2.*\" --> \">=1.2.0 <2.0.0\"\n                    // \"^1.2.3\" --> \">=1.2.3 <2.0.0\"\n                    comparators.push(partial.clone().zero_missing().as_comparator(Op::Gte));\n                    comparators.push(\n                        partial\n                            .inc_major()\n                            .zero_minor()\n                            .zero_patch()\n                            .no_pre()\n                            .as_comparator(Op::Lt),\n                    );\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/range.rs\"))"],"range::simple::parse_partial":["fn parse_partial(mut components: Vec<pest::iterators::Pair<'_, Rule>>) -> Partial{\n        let mut partial = Partial::new();\n\n        // there will be at least one component\n        let one = components.remove(0);\n\n        match one.as_rule() {\n            Rule::xr => {\n                let inner = one.into_inner().next().unwrap();\n                match inner.as_rule() {\n                    Rule::xr_op => {\n                        // for \"*\", \">=*\", etc.\n                        partial.major = None;\n                        partial.kind = PartialKind::XRangeOnly;\n                        // end the pattern here\n                        return partial;\n                    }\n                    Rule::nr => {\n                        partial.major = Some(inner.as_str().parse::<u64>().unwrap());\n                    }\n                    _ => unreachable!(),\n                }\n            }\n            _ => unreachable!(),\n        }\n\n        if components.is_empty() {\n            // only the major has been given\n            partial.kind = PartialKind::MajorOnly;\n            return partial;\n        } else {\n            let two = components.remove(0);\n\n            match two.as_rule() {\n                Rule::xr => {\n                    let inner = two.into_inner().next().unwrap();\n                    match inner.as_rule() {\n                        Rule::xr_op => {\n                            partial.minor = None;\n                            // only the major has been given, minor is xrange (ignore anything after)\n                            partial.kind = PartialKind::MajorOnly;\n                            return partial;\n                        }\n                        Rule::nr => {\n                            partial.minor = Some(inner.as_str().parse::<u64>().unwrap());\n                        }\n                        _ => unreachable!(),\n                    }\n                }\n                _ => unreachable!(),\n            }\n        }\n\n        if components.is_empty() {\n            // only major and minor have been given\n            partial.kind = PartialKind::MajorMinor;\n            return partial;\n        } else {\n            let three = components.remove(0);\n\n            match three.as_rule() {\n                Rule::xr => {\n                    let inner = three.into_inner().next().unwrap();\n                    match inner.as_rule() {\n                        Rule::xr_op => {\n                            partial.patch = None;\n                            // only major and minor have been given, patch is xrange\n                            partial.kind = PartialKind::MajorMinor;\n                            return partial;\n                        }\n                        Rule::nr => {\n                            partial.patch = Some(inner.as_str().parse::<u64>().unwrap());\n                        }\n                        _ => unreachable!(),\n                    }\n                }\n                _ => unreachable!(),\n            }\n        }\n\n        // at this point we at least have all three fields\n        partial.kind = PartialKind::MajorMinorPatch;\n\n        if !components.is_empty() {\n            // there's only going to be one, let's move it out\n            let pre = components.remove(0);\n            // now we want to look at the inner bit, so that we don't have the leading -\n            let mut pre: Vec<_> = pre.into_inner().collect();\n            let pre = pre.remove(0);\n            let pre = pre.as_str();\n\n            // now we have all of the stuff in pre, so we split by . to get each bit\n            for bit in pre.split('.') {\n                let identifier = match bit.parse::<u64>() {\n                    Ok(num) => Identifier::Numeric(num),\n                    Err(_) => Identifier::AlphaNumeric(bit.to_string()),\n                };\n\n                partial.pre.push(identifier);\n            }\n        }\n\n        partial\n    }","Real(LocalPath(\"src/range.rs\"))"],"range_set::Compat":["pub enum Compat {\n    Cargo, // default\n    Npm,\n}","Real(LocalPath(\"src/range_set.rs\"))"],"range_set::RangeSet":["pub struct RangeSet {\n    pub ranges: Vec<Range>,\n    pub compat: Compat,\n}","Real(LocalPath(\"src/range_set.rs\"))"],"range_set::RangeSet::new":["fn new() -> RangeSet{\n        RangeSet {\n            ranges: Vec::new(),\n            compat: Compat::Cargo, // default\n        }\n    }","Real(LocalPath(\"src/range_set.rs\"))"],"range_set::RangeSet::parse":["pub fn parse(input: &str, compat: Compat) -> Result<Self, String>{\n        let range_set = match SemverParser::parse(Rule::range_set, input) {\n            Ok(mut parsed) => match parsed.next() {\n                Some(parsed) => parsed,\n                None => return Err(String::from(\"Could not parse a range set\")),\n            },\n            Err(e) => return Err(e.to_string()),\n        };\n\n        from_pair_iterator(range_set, compat)\n    }","Real(LocalPath(\"src/range_set.rs\"))"],"range_set::from_pair_iterator":["/// Converts an iterator of Pairs into a RangeSet\nfn from_pair_iterator(\n    parsed_range_set: pest::iterators::Pair<'_, Rule>,\n    compat: Compat,\n) -> Result<RangeSet, String>{\n    // First of all, do we have the correct iterator?\n    if parsed_range_set.as_rule() != Rule::range_set {\n        return Err(String::from(\"Error parsing range set\"));\n    }\n\n    // Next, we make a new, empty range\n    let mut range_set = RangeSet::new();\n    range_set.compat = compat;\n\n    // Now we need to parse each range out of the set\n    for record in parsed_range_set.into_inner() {\n        match record.as_rule() {\n            // if we have a range...\n            Rule::range => {\n                // ... let's parse it and push it onto our list of ranges\n                range_set\n                    .ranges\n                    .push(range::from_pair_iterator(record, compat)?);\n            }\n\n            // we don't need to do anything with the logical ors between ranges\n            Rule::logical_or => (),\n\n            // don't need to do anything with end-of-input\n            Rule::EOI => (),\n\n            // those are the only rules we can have, according to the grammar\n            _ => unreachable!(),\n        }\n    }\n\n    // and that's it!\n    Ok(range_set)\n}","Real(LocalPath(\"src/range_set.rs\"))"],"version::Identifier":["/// Helper enum for holding data of alphanumeric or numeric suffix identifiers.\n///\n/// This enum is used to hold suffix parts of `pre` and `build` fields of\n/// [`Version`] struct. Theses suffixes may be either numeric or alphanumeric.\n///\n/// # Examples\n///\n/// Parsing [`Version`] with pre-release part composed of two `Identifier`s:\n///\n/// ```\n/// use semver_parser::version;\n///\n/// # fn try_main() -> Result<(), String> {\n/// let version = version::parse(\"0.1.2-alpha1.0\")?;\n///\n/// let expected_pre = vec![\n///     version::Identifier::AlphaNumeric(String::from(\"alpha1\")),\n///     version::Identifier::Numeric(0),\n/// ];\n///\n/// assert_eq!(expected_pre, version.pre);\n/// # Ok(())\n/// # }\n/// #\n/// # try_main().unwrap();\n/// ```\n/// [`Version`]: ./struct.Version.html\npub enum Identifier {\n    /// An identifier that's solely numbers.\n    Numeric(u64),\n    /// An identifier with letters and numbers.\n    AlphaNumeric(String),\n}","Real(LocalPath(\"src/version.rs\"))"],"version::Identifier::concat":["pub fn concat(self, add_str: &str) -> Identifier{\n        match self {\n            Identifier::Numeric(n) => Identifier::AlphaNumeric(format!(\"{}{}\", n, add_str)),\n            Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(format!(\"{}{}\", s, add_str)),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version":["/// Structure representing version data.\n///\n/// `Version` struct has some public fields representing version data, like major/minor version\n/// string, patch number and vectors of prefix and build identifiers.\n///\n/// # Examples\n///\n/// Parsing `Version` from string and checking its fields:\n///\n/// ```\n/// use semver_parser::version;\n///\n/// # fn try_main() -> Result<(), String> {\n/// let version = version::parse(\"0.1.2-alpha1\")?;\n/// assert_eq!(version.major, 0);\n/// assert_eq!(version.minor, 1);\n/// assert_eq!(version.patch, 2);\n/// let expected_pre = vec![version::Identifier::AlphaNumeric(String::from(\"alpha1\"))];\n/// assert_eq!(expected_pre, version.pre);\n/// # Ok(())\n/// # }\n/// #\n/// # try_main().unwrap();\n/// ```\npub struct Version {\n    /// Major version as number (`0` in `\"0.1.2\"`).\n    pub major: u64,\n    /// Minor version as number (`1` in `\"0.1.2\"`).\n    pub minor: u64,\n    /// Patch version as number (`2` in `\"0.1.2\"`).\n    pub patch: u64,\n    /// Pre-release metadata as a vector of `Identifier` (`\"alpha1\"` in `\"0.1.2-alpha1\"`\n    /// or `7` (numeric) in `\"0.1.2-7\"`, `\"pre\"` and `0` (numeric) in `\"0.1.2-pre.0\"`).\n    pub pre: Vec<Identifier>,\n    /// Build metadata as a vector of `Identifier` (`\"build1\"` in `\"0.1.2+build1\"`\n    /// or `7` (numeric) in `\"0.1.2+7\"`, `\"build\"` and `0` (numeric) in `\"0.1.2+pre.0\"`).\n    pub build: Vec<Identifier>,\n}","Real(LocalPath(\"src/version.rs\"))"],"version::parse":["/// Function for parsing version string to [`Version`].\n///\n/// Returns `Result<`[`Version`]`, String>`, where `String` represents an error while parsing.\n///\n/// # Examples\n///\n/// Parsing [`Version`] from string and checking its fields:\n///\n/// ```\n/// use semver_parser::version;\n///\n/// # fn try_main() -> Result<(), String> {\n/// let version = version::parse(\"0.1.2-alpha1\")?;\n/// assert_eq!(version.major, 0);\n/// assert_eq!(version.minor, 1);\n/// assert_eq!(version.patch, 2);\n/// let expected_pre = vec![version::Identifier::AlphaNumeric(String::from(\"alpha1\"))];\n/// assert_eq!(expected_pre, version.pre);\n/// # Ok(())\n/// # }\n/// #\n/// # try_main().unwrap();\n/// ```\n/// [`Version`]: ./struct.Version.html\npub fn parse(input: &str) -> Result<Version, parser::Error>{\n    let mut parser = Parser::new(input)?;\n    let version = parser.version()?;\n\n    if !parser.is_eof() {\n        return Err(parser::Error::MoreInput(parser.tail()?));\n    }\n\n    Ok(version)\n}","Real(LocalPath(\"src/version.rs\"))"]},"struct_constructor":{"(std::option::Option<u64>, bool)":["dot_component"],"(usize, char)":["one"],"(usize, char, char)":["two"],"<lexer::Lexer<'input> as std::iter::Iterator>::Item":["next"],"bool":["eq","is_eof","is_whitespace","is_wildcard"],"generated::Rule":["clone"],"lexer::Lexer":["new"],"lexer::Token":["component","pop","whitespace"],"parser::Error":["from"],"parser::Parser":["new"],"pest::iterators::Pairs":["parse"],"range::Comparator":["as_comparator","clone"],"range::Identifier":["clone"],"range::Op":["clone"],"range::Partial":["clone","new","parse_partial"],"range::PartialKind":["clone"],"range::Range":["clone","from_pair_iterator"],"range_set::Compat":["clone"],"range_set::RangeSet":["clone","from_pair_iterator","from_str","new","parse"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["from"],"std::vec::Vec":["from_hyphen_range","from_pair_iterator","parts","plus_build_metadata","pre","tail"],"u64":["component","dot_numeric","numeric"],"version::Identifier":["clone","identifier"],"version::Version":["clone","parse","version"]},"struct_to_trait":{"SemverParser":["pest::Parser"],"generated::Rule":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"lexer::Error":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"lexer::Lexer":["std::fmt::Debug","std::iter::Iterator"],"lexer::Token":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"parser::Error":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::Comparator":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::Identifier":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::Op":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::Partial":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::PartialKind":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range::Range":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range_set::Compat":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"range_set::RangeSet":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"std::string::String":["std::convert::From"],"version::Identifier":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version::Version":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<lexer::Lexer<'input> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lexer.rs\"))","std::iter::Iterator"],"<parser::Error<'input> as std::convert::From<lexer::Error>>::from":["from","Real(LocalPath(\"src/parser.rs\"))","std::convert::From"],"<parser::Error<'input> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/parser.rs\"))","std::fmt::Display"],"<range_set::RangeSet as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/range_set.rs\"))","std::str::FromStr"],"<version::Identifier as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Display"],"<version::Version as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Display"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse":["parse","Real(LocalPath(\"src/generated.rs\"))","pest::Parser"],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::hidden::skip":["skip","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::EOI":["EOI","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::SOI":["SOI","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::caret":["caret","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::empty":["empty","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::hyphen":["hyphen","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::logical_or":["logical_or","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::nr":["nr","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::part":["part","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::partial":["partial","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::parts":["parts","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive":["primitive","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::primitive_op":["primitive_op","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::qualifier":["qualifier","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range":["range","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::range_set":["range_set","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::simple":["simple","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::space":["space","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::tilde":["tilde","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr":["xr","Real(LocalPath(\"src/generated.rs\"))",""],"generated::<impl pest::Parser<generated::Rule> for SemverParser>::parse::rules::visible::xr_op":["xr_op","Real(LocalPath(\"src/generated.rs\"))",""],"lexer::Lexer::<'input>::component":["component","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::new":["new","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::one":["one","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::step":["step","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::step_n":["step_n","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::two":["two","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Lexer::<'input>::whitespace":["whitespace","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Token::<'input>::is_whitespace":["is_whitespace","Real(LocalPath(\"src/lexer.rs\"))",""],"lexer::Token::<'input>::is_wildcard":["is_wildcard","Real(LocalPath(\"src/lexer.rs\"))",""],"parser::<impl std::convert::From<parser::Error<'input>> for std::string::String>::from":["from","Real(LocalPath(\"src/parser.rs\"))","std::convert::From"],"parser::Parser::<'input>::component":["component","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::dot_component":["dot_component","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::dot_numeric":["dot_numeric","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::identifier":["identifier","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::is_eof":["is_eof","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::new":["new","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::numeric":["numeric","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::parts":["parts","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::peek":["peek","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::plus_build_metadata":["plus_build_metadata","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::pop":["pop","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::pre":["pre","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::skip_whitespace":["skip_whitespace","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::tail":["tail","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::<'input>::version":["version","Real(LocalPath(\"src/parser.rs\"))",""],"range::Partial::as_comparator":["as_comparator","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::inc_major":["inc_major","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::inc_minor":["inc_minor","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::inc_patch":["inc_patch","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::new":["new","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::no_pre":["no_pre","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::zero_minor":["zero_minor","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::zero_missing":["zero_missing","Real(LocalPath(\"src/range.rs\"))",""],"range::Partial::zero_patch":["zero_patch","Real(LocalPath(\"src/range.rs\"))",""],"range::from_pair_iterator":["from_pair_iterator","Real(LocalPath(\"src/range.rs\"))",""],"range::simple::from_hyphen_range":["from_hyphen_range","Real(LocalPath(\"src/range.rs\"))",""],"range::simple::from_pair_iterator":["from_pair_iterator","Real(LocalPath(\"src/range.rs\"))",""],"range::simple::handle_caret_range":["handle_caret_range","Real(LocalPath(\"src/range.rs\"))",""],"range::simple::parse_partial":["parse_partial","Real(LocalPath(\"src/range.rs\"))",""],"range_set::RangeSet::new":["new","Real(LocalPath(\"src/range_set.rs\"))",""],"range_set::RangeSet::parse":["parse","Real(LocalPath(\"src/range_set.rs\"))",""],"range_set::from_pair_iterator":["from_pair_iterator","Real(LocalPath(\"src/range_set.rs\"))",""],"version::Identifier::concat":["concat","Real(LocalPath(\"src/version.rs\"))",""],"version::parse":["parse","Real(LocalPath(\"src/version.rs\"))",""]},"trait_to_struct":{"pest::Parser":["SemverParser"],"std::clone::Clone":["generated::Rule","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::cmp::Eq":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::cmp::Ord":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::cmp::PartialEq":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::cmp::PartialOrd":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::convert::From":["parser::Error","std::string::String"],"std::fmt::Debug":["generated::Rule","lexer::Error","lexer::Lexer","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::fmt::Display":["parser::Error","version::Identifier","version::Version"],"std::hash::Hash":["generated::Rule","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::iter::Iterator":["lexer::Lexer"],"std::marker::Copy":["generated::Rule","range_set::Compat"],"std::marker::StructuralEq":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::marker::StructuralPartialEq":["generated::Rule","lexer::Error","lexer::Token","parser::Error","range::Comparator","range::Identifier","range::Op","range::Partial","range::PartialKind","range::Range","range_set::Compat","range_set::RangeSet","version::Identifier","version::Version"],"std::str::FromStr":["range_set::RangeSet"]},"type_to_def_path":{"SemverParser":"SemverParser","generated::Rule":"generated::Rule","lexer::Error":"lexer::Error","lexer::Lexer<'input>":"lexer::Lexer","lexer::Token<'input>":"lexer::Token","parser::Error<'input>":"parser::Error","parser::Parser<'input>":"parser::Parser","range::Comparator":"range::Comparator","range::Identifier":"range::Identifier","range::Op":"range::Op","range::Partial":"range::Partial","range::PartialKind":"range::PartialKind","range::Range":"range::Range","range_set::Compat":"range_set::Compat","range_set::RangeSet":"range_set::RangeSet","version::Identifier":"version::Identifier","version::Version":"version::Version"}}