{"dependencies":{"<backend::termion::Bg as std::fmt::Display>::fmt":["backend::termion::Bg","std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color"],"<backend::termion::Fg as std::fmt::Display>::fmt":["backend::termion::Fg","std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color"],"<backend::termion::ModifierDiff as std::fmt::Display>::fmt":["backend::termion::ModifierDiff","std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<backend::termion::TermionBackend<W> as backend::Backend>::clear":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::draw":["backend::termion::TermionBackend","std::io::Write","std::iter::Iterator","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::flush":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::get_cursor":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::hide_cursor":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::set_cursor":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::show_cursor":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as backend::Backend>::size":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as std::io::Write>::flush":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::termion::TermionBackend<W> as std::io::Write>::write":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized","std::result::Result"],"<backend::test::TestBackend as backend::Backend>::clear":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::draw":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::iter::Iterator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::flush":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::get_cursor":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::hide_cursor":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::set_cursor":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::show_cursor":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as backend::Backend>::size":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backend::test::TestBackend as std::fmt::Debug>::fmt":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<buffer::Buffer as std::clone::Clone>::clone":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<buffer::Buffer as std::cmp::PartialEq>::eq":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<buffer::Buffer as std::default::Default>::default":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<buffer::Buffer as std::fmt::Debug>::fmt":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<buffer::Cell as std::clone::Clone>::clone":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"<buffer::Cell as std::cmp::PartialEq>::eq":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"<buffer::Cell as std::default::Default>::default":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"<buffer::Cell as std::fmt::Debug>::fmt":["buffer::Cell","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","style::Color","style::Modifier"],"<layout::Alignment as std::clone::Clone>::clone":["layout::Alignment"],"<layout::Alignment as std::cmp::PartialEq>::eq":["layout::Alignment"],"<layout::Alignment as std::fmt::Debug>::fmt":["layout::Alignment","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Constraint as std::clone::Clone>::clone":["layout::Constraint"],"<layout::Constraint as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Constraint"],"<layout::Constraint as std::cmp::PartialEq>::eq":["layout::Constraint"],"<layout::Constraint as std::fmt::Debug>::fmt":["layout::Constraint","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Constraint as std::hash::Hash>::hash":["layout::Constraint","std::hash::Hasher","std::marker::Sized"],"<layout::Corner as std::clone::Clone>::clone":["layout::Corner"],"<layout::Corner as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Corner"],"<layout::Corner as std::cmp::PartialEq>::eq":["layout::Corner"],"<layout::Corner as std::fmt::Debug>::fmt":["layout::Corner","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Corner as std::hash::Hash>::hash":["layout::Corner","std::hash::Hasher","std::marker::Sized"],"<layout::Direction as std::clone::Clone>::clone":["layout::Direction"],"<layout::Direction as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Direction"],"<layout::Direction as std::cmp::PartialEq>::eq":["layout::Direction"],"<layout::Direction as std::fmt::Debug>::fmt":["layout::Direction","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Direction as std::hash::Hash>::hash":["layout::Direction","std::hash::Hasher","std::marker::Sized"],"<layout::Layout as std::clone::Clone>::clone":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<layout::Layout as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<layout::Layout as std::cmp::PartialEq>::eq":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<layout::Layout as std::default::Default>::default":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<layout::Layout as std::fmt::Debug>::fmt":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<layout::Layout as std::hash::Hash>::hash":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<layout::Margin as std::clone::Clone>::clone":["layout::Margin"],"<layout::Margin as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Margin"],"<layout::Margin as std::cmp::PartialEq>::eq":["layout::Margin"],"<layout::Margin as std::fmt::Debug>::fmt":["layout::Margin","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Margin as std::hash::Hash>::hash":["layout::Margin","std::hash::Hasher","std::marker::Sized"],"<layout::Rect as std::clone::Clone>::clone":["layout::Rect"],"<layout::Rect as std::cmp::Eq>::assert_receiver_is_total_eq":["layout::Rect"],"<layout::Rect as std::cmp::PartialEq>::eq":["layout::Rect"],"<layout::Rect as std::default::Default>::default":["layout::Rect"],"<layout::Rect as std::fmt::Debug>::fmt":["layout::Rect","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<layout::Rect as std::hash::Hash>::hash":["layout::Rect","std::hash::Hasher","std::marker::Sized"],"<style::Color as std::clone::Clone>::clone":["style::Color"],"<style::Color as std::cmp::PartialEq>::eq":["style::Color"],"<style::Color as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::BOLD":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::CROSSED_OUT":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::DIM":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::ITALIC":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::RAPID_BLINK":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::REVERSED":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::SLOW_BLINK":["style::Modifier"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::UNDERLINED":["style::Modifier"],"<style::Modifier as std::clone::Clone>::clone":["style::Modifier"],"<style::Modifier as std::cmp::Eq>::assert_receiver_is_total_eq":["style::Modifier"],"<style::Modifier as std::cmp::Ord>::cmp":["std::cmp::Ordering","style::Modifier"],"<style::Modifier as std::cmp::PartialEq>::eq":["style::Modifier"],"<style::Modifier as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","style::Modifier"],"<style::Modifier as std::fmt::Binary>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<style::Modifier as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::BOLD":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::CROSSED_OUT":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::DIM":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::ITALIC":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::RAPID_BLINK":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::REVERSED":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::SLOW_BLINK":[],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::UNDERLINED":[],"<style::Modifier as std::fmt::LowerHex>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<style::Modifier as std::fmt::Octal>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<style::Modifier as std::fmt::UpperHex>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Modifier"],"<style::Modifier as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","style::Modifier"],"<style::Modifier as std::iter::Extend<style::Modifier>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","style::Modifier","text::Text"],"<style::Modifier as std::iter::FromIterator<style::Modifier>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","style::Modifier","text::Text"],"<style::Modifier as std::ops::BitAnd>::bitand":["style::Modifier"],"<style::Modifier as std::ops::BitAndAssign>::bitand_assign":["style::Modifier"],"<style::Modifier as std::ops::BitOr>::bitor":["style::Modifier"],"<style::Modifier as std::ops::BitOrAssign>::bitor_assign":["style::Modifier"],"<style::Modifier as std::ops::BitXor>::bitxor":["style::Modifier"],"<style::Modifier as std::ops::BitXorAssign>::bitxor_assign":["style::Modifier"],"<style::Modifier as std::ops::Not>::not":["style::Modifier"],"<style::Modifier as std::ops::Sub>::sub":["style::Modifier"],"<style::Modifier as std::ops::SubAssign>::sub_assign":["style::Modifier"],"<style::Style as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"<style::Style as std::cmp::PartialEq>::eq":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"<style::Style as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"<style::Style as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style"],"<symbols::Marker as std::clone::Clone>::clone":["symbols::Marker"],"<symbols::Marker as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","symbols::Marker"],"<symbols::bar::Set as std::clone::Clone>::clone":["symbols::bar::Set"],"<symbols::bar::Set as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","symbols::bar::Set"],"<symbols::block::Set as std::clone::Clone>::clone":["symbols::block::Set"],"<symbols::block::Set as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","symbols::block::Set"],"<symbols::line::Set as std::clone::Clone>::clone":["symbols::line::Set"],"<symbols::line::Set as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","symbols::line::Set"],"<terminal::ResizeBehavior as std::clone::Clone>::clone":["terminal::ResizeBehavior"],"<terminal::ResizeBehavior as std::cmp::PartialEq>::eq":["terminal::ResizeBehavior"],"<terminal::ResizeBehavior as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","terminal::ResizeBehavior"],"<terminal::Terminal<B> as std::fmt::Debug>::fmt":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"<terminal::Terminal<B> as std::ops::Drop>::drop":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"<terminal::TerminalOptions as std::clone::Clone>::clone":["layout::Rect","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport"],"<terminal::TerminalOptions as std::cmp::PartialEq>::eq":["layout::Rect","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport"],"<terminal::TerminalOptions as std::fmt::Debug>::fmt":["layout::Rect","std::fmt::Formatter","std::marker::Sized","std::result::Result","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport"],"<terminal::Viewport as std::clone::Clone>::clone":["layout::Rect","terminal::ResizeBehavior","terminal::Viewport"],"<terminal::Viewport as std::cmp::PartialEq>::eq":["layout::Rect","terminal::ResizeBehavior","terminal::Viewport"],"<terminal::Viewport as std::fmt::Debug>::fmt":["layout::Rect","std::fmt::Formatter","std::marker::Sized","std::result::Result","terminal::ResizeBehavior","terminal::Viewport"],"<text::Span<'a> as std::clone::Clone>::clone":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"<text::Span<'a> as std::cmp::PartialEq>::eq":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"<text::Span<'a> as std::convert::From<&'a str>>::from":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"<text::Span<'a> as std::convert::From<std::string::String>>::from":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::string::String","style::Modifier","style::Style","text::Span"],"<text::Span<'a> as std::fmt::Debug>::fmt":["std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","text::Span"],"<text::Spans<'a> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::convert::From<&'a str>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::convert::From<std::string::String>>::from":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::convert::From<std::vec::Vec<text::Span<'a>>>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::convert::From<text::Span<'a>>>::from":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","text::Spans"],"<text::Spans<'a> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"<text::Spans<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","text::Spans"],"<text::StyledGrapheme<'a> as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::StyledGrapheme"],"<text::StyledGrapheme<'a> as std::cmp::PartialEq>::eq":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::StyledGrapheme"],"<text::StyledGrapheme<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","text::StyledGrapheme"],"<text::Text<'a> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::convert::From<&'a str>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::convert::From<std::string::String>>::from":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","text::Text"],"<text::Text<'a> as std::convert::From<std::vec::Vec<text::Spans<'a>>>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::convert::From<text::Span<'a>>>::from":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","text::Text"],"<text::Text<'a> as std::convert::From<text::Spans<'a>>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans","text::Text"],"<text::Text<'a> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","text::Text"],"<text::Text<'a> as std::iter::Extend<text::Spans<'a>>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","text::Text"],"<text::Text<'a> as std::iter::IntoIterator>::into_iter":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::ALL":["widgets::Borders"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::BOTTOM":["widgets::Borders"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::LEFT":["widgets::Borders"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::NONE":["widgets::Borders"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::RIGHT":["widgets::Borders"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::TOP":["widgets::Borders"],"<widgets::Borders as std::clone::Clone>::clone":["widgets::Borders"],"<widgets::Borders as std::cmp::Eq>::assert_receiver_is_total_eq":["widgets::Borders"],"<widgets::Borders as std::cmp::Ord>::cmp":["std::cmp::Ordering","widgets::Borders"],"<widgets::Borders as std::cmp::PartialEq>::eq":["widgets::Borders"],"<widgets::Borders as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","widgets::Borders"],"<widgets::Borders as std::fmt::Binary>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::Borders"],"<widgets::Borders as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::Borders"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::ALL":[],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::BOTTOM":[],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::LEFT":[],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::NONE":[],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::RIGHT":[],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::TOP":[],"<widgets::Borders as std::fmt::LowerHex>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::Borders"],"<widgets::Borders as std::fmt::Octal>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::Borders"],"<widgets::Borders as std::fmt::UpperHex>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::Borders"],"<widgets::Borders as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","widgets::Borders"],"<widgets::Borders as std::iter::Extend<widgets::Borders>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","text::Text","widgets::Borders"],"<widgets::Borders as std::iter::FromIterator<widgets::Borders>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","text::Text","widgets::Borders"],"<widgets::Borders as std::ops::BitAnd>::bitand":["widgets::Borders"],"<widgets::Borders as std::ops::BitAndAssign>::bitand_assign":["widgets::Borders"],"<widgets::Borders as std::ops::BitOr>::bitor":["widgets::Borders"],"<widgets::Borders as std::ops::BitOrAssign>::bitor_assign":["widgets::Borders"],"<widgets::Borders as std::ops::BitXor>::bitxor":["widgets::Borders"],"<widgets::Borders as std::ops::BitXorAssign>::bitxor_assign":["widgets::Borders"],"<widgets::Borders as std::ops::Not>::not":["widgets::Borders"],"<widgets::Borders as std::ops::Sub>::sub":["widgets::Borders"],"<widgets::Borders as std::ops::SubAssign>::sub_assign":["widgets::Borders"],"<widgets::barchart::BarChart<'a> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"<widgets::barchart::BarChart<'a> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"<widgets::barchart::BarChart<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"<widgets::barchart::BarChart<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"<widgets::block::Block<'a> as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"<widgets::block::Block<'a> as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"<widgets::block::Block<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"<widgets::block::Block<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"<widgets::block::BorderType as std::clone::Clone>::clone":["widgets::block::BorderType"],"<widgets::block::BorderType as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::block::BorderType"],"<widgets::canvas::BrailleGrid as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::height":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::paint":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::reset":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::resolution":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::save":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","widgets::canvas::BrailleGrid","widgets::canvas::Layer"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::width":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"<widgets::canvas::Canvas<'a, F> as std::default::Default>::default":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"<widgets::canvas::Canvas<'a, F> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::ops::Fn","std::option::Option","std::vec::Vec","style::Color","symbols::Marker","widgets::canvas::Canvas"],"<widgets::canvas::CharGrid as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::height":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::paint":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::reset":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::resolution":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::save":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","widgets::canvas::CharGrid","widgets::canvas::Layer"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::width":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"<widgets::canvas::Context<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","widgets::canvas::Context"],"<widgets::canvas::Label<'a> as std::clone::Clone>::clone":["style::Color","widgets::canvas::Label"],"<widgets::canvas::Label<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color","widgets::canvas::Label"],"<widgets::canvas::Layer as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","widgets::canvas::Layer"],"<widgets::canvas::Layer as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","widgets::canvas::Layer"],"<widgets::canvas::Painter<'a, 'b> as std::convert::From<&'a mut widgets::canvas::Context<'b>>>::from":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context","widgets::canvas::Painter"],"<widgets::canvas::Painter<'a, 'b> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","widgets::canvas::Context","widgets::canvas::Painter"],"<widgets::canvas::line::Line as std::clone::Clone>::clone":["style::Color","widgets::canvas::line::Line"],"<widgets::canvas::line::Line as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color","widgets::canvas::line::Line"],"<widgets::canvas::line::Line as widgets::canvas::Shape>::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter","widgets::canvas::line::Line"],"<widgets::canvas::map::Map as std::clone::Clone>::clone":["style::Color","widgets::canvas::map::Map","widgets::canvas::map::MapResolution"],"<widgets::canvas::map::Map as std::default::Default>::default":["style::Color","widgets::canvas::map::Map","widgets::canvas::map::MapResolution"],"<widgets::canvas::map::Map as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color","widgets::canvas::map::Map","widgets::canvas::map::MapResolution"],"<widgets::canvas::map::Map as widgets::canvas::Shape>::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter","widgets::canvas::map::Map","widgets::canvas::map::MapResolution"],"<widgets::canvas::map::MapResolution as std::clone::Clone>::clone":["widgets::canvas::map::MapResolution"],"<widgets::canvas::map::MapResolution as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::canvas::map::MapResolution"],"<widgets::canvas::points::Points<'a> as std::clone::Clone>::clone":["style::Color","widgets::canvas::points::Points"],"<widgets::canvas::points::Points<'a> as std::default::Default>::default":["style::Color","widgets::canvas::points::Points"],"<widgets::canvas::points::Points<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color","widgets::canvas::points::Points"],"<widgets::canvas::points::Points<'a> as widgets::canvas::Shape>::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter","widgets::canvas::points::Points"],"<widgets::canvas::rectangle::Rectangle as std::clone::Clone>::clone":["style::Color","widgets::canvas::rectangle::Rectangle"],"<widgets::canvas::rectangle::Rectangle as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","style::Color","widgets::canvas::rectangle::Rectangle"],"<widgets::canvas::rectangle::Rectangle as widgets::canvas::Shape>::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter","widgets::canvas::rectangle::Rectangle"],"<widgets::chart::Axis<'a> as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"<widgets::chart::Axis<'a> as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"<widgets::chart::Axis<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","widgets::chart::Axis"],"<widgets::chart::Chart<'a> as std::clone::Clone>::clone":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"<widgets::chart::Chart<'a> as std::fmt::Debug>::fmt":["layout::Constraint","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"<widgets::chart::Chart<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Constraint","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"<widgets::chart::ChartLayout as std::clone::Clone>::clone":["layout::Rect","std::marker::Sized","std::option::Option","widgets::chart::ChartLayout"],"<widgets::chart::ChartLayout as std::cmp::PartialEq>::eq":["layout::Rect","std::marker::Sized","std::option::Option","widgets::chart::ChartLayout"],"<widgets::chart::ChartLayout as std::default::Default>::default":["layout::Rect","std::marker::Sized","std::option::Option","widgets::chart::ChartLayout"],"<widgets::chart::ChartLayout as std::fmt::Debug>::fmt":["layout::Rect","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","widgets::chart::ChartLayout"],"<widgets::chart::Dataset<'a> as std::clone::Clone>::clone":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"<widgets::chart::Dataset<'a> as std::default::Default>::default":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"<widgets::chart::Dataset<'a> as std::fmt::Debug>::fmt":["std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"<widgets::chart::GraphType as std::clone::Clone>::clone":["widgets::chart::GraphType"],"<widgets::chart::GraphType as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::chart::GraphType"],"<widgets::clear::Clear as std::clone::Clone>::clone":["widgets::clear::Clear"],"<widgets::clear::Clear as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::clear::Clear"],"<widgets::clear::Clear as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::clear::Clear"],"<widgets::gauge::Gauge<'a> as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"<widgets::gauge::Gauge<'a> as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"<widgets::gauge::Gauge<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","widgets::gauge::Gauge"],"<widgets::gauge::Gauge<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::gauge::Gauge"],"<widgets::gauge::LineGauge<'a> as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"<widgets::gauge::LineGauge<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"<widgets::list::List<'a> as std::clone::Clone>::clone":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"<widgets::list::List<'a> as std::fmt::Debug>::fmt":["layout::Corner","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"<widgets::list::List<'a> as widgets::StatefulWidget>::render":["buffer::Buffer","layout::Corner","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"<widgets::list::List<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Corner","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"<widgets::list::ListItem<'a> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"<widgets::list::ListItem<'a> as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"<widgets::list::ListItem<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"<widgets::list::ListState as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","widgets::list::ListState"],"<widgets::list::ListState as std::default::Default>::default":["std::marker::Sized","std::option::Option","widgets::list::ListState"],"<widgets::list::ListState as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","widgets::list::ListState"],"<widgets::paragraph::Paragraph<'a> as std::clone::Clone>::clone":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"<widgets::paragraph::Paragraph<'a> as std::fmt::Debug>::fmt":["layout::Alignment","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"<widgets::paragraph::Paragraph<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Alignment","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"<widgets::paragraph::Wrap as std::clone::Clone>::clone":["widgets::paragraph::Wrap"],"<widgets::paragraph::Wrap as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","widgets::paragraph::Wrap"],"<widgets::reflow::LineTruncator<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","widgets::reflow::LineTruncator"],"<widgets::reflow::WordWrapper<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","widgets::reflow::WordWrapper"],"<widgets::sparkline::Sparkline<'a> as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"<widgets::sparkline::Sparkline<'a> as std::default::Default>::default":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"<widgets::sparkline::Sparkline<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"<widgets::sparkline::Sparkline<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"<widgets::table::Row<D> as std::clone::Clone>::clone":["backend::termion::Bg","std::fmt::Display","std::iter::Iterator","std::marker::Sized","std::option::Option","style::Color","style::Modifier","style::Style","widgets::table::Row"],"<widgets::table::Row<D> as std::fmt::Debug>::fmt":["backend::termion::Bg","std::fmt::Display","std::fmt::Formatter","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result","style::Color","style::Modifier","style::Style","widgets::table::Row"],"<widgets::table::Table<'a, H, R> as std::clone::Clone>::clone":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"<widgets::table::Table<'a, H, R> as std::default::Default>::default":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"<widgets::table::Table<'a, H, R> as std::fmt::Debug>::fmt":["layout::Constraint","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","style::Modifier","style::Style","widgets::table::Table"],"<widgets::table::Table<'a, H, R> as widgets::StatefulWidget>::render":["buffer::Buffer","layout::Constraint","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::table::Table"],"<widgets::table::Table<'a, H, R> as widgets::Widget>::render":["buffer::Buffer","layout::Constraint","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::table::Table"],"<widgets::table::TableState as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","widgets::table::TableState"],"<widgets::table::TableState as std::default::Default>::default":["std::marker::Sized","std::option::Option","widgets::table::TableState"],"<widgets::table::TableState as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","widgets::table::TableState"],"<widgets::tabs::Tabs<'a> as std::clone::Clone>::clone":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"<widgets::tabs::Tabs<'a> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"<widgets::tabs::Tabs<'a> as widgets::Widget>::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"backend::Backend::clear":["std::marker::Sized","std::result::Result"],"backend::Backend::draw":["std::iter::Iterator","std::marker::Sized","std::result::Result"],"backend::Backend::flush":["std::marker::Sized","std::result::Result"],"backend::Backend::get_cursor":["std::marker::Sized","std::result::Result"],"backend::Backend::hide_cursor":["std::marker::Sized","std::result::Result"],"backend::Backend::set_cursor":["std::marker::Sized","std::result::Result"],"backend::Backend::show_cursor":["std::marker::Sized","std::result::Result"],"backend::Backend::size":["std::marker::Sized","std::result::Result"],"backend::termion::Bg":["backend::termion::Bg","style::Color"],"backend::termion::Fg":["backend::termion::Fg","style::Color"],"backend::termion::ModifierDiff":["backend::termion::ModifierDiff","style::Modifier"],"backend::termion::TermionBackend":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized"],"backend::termion::TermionBackend::<W>::new":["backend::termion::TermionBackend","std::io::Write","std::marker::Sized"],"backend::test::TestBackend":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"backend::test::TestBackend::assert_buffer":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"backend::test::TestBackend::buffer":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"backend::test::TestBackend::new":["backend::test::TestBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"backend::test::buffer_view":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"buffer::Buffer":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::area":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::content":["buffer::Buffer","buffer::Cell","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","style::Color","style::Modifier"],"buffer::Buffer::diff":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::empty":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::filled":["buffer::Buffer","buffer::Cell","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","style::Color","style::Modifier"],"buffer::Buffer::get":["buffer::Buffer","buffer::Cell","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","style::Color","style::Modifier"],"buffer::Buffer::get_mut":["buffer::Buffer","buffer::Cell","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","style::Color","style::Modifier"],"buffer::Buffer::index_of":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::merge":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::pos_of":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::reset":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::resize":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"buffer::Buffer::set_background":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","style::Color"],"buffer::Buffer::set_span":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span"],"buffer::Buffer::set_spans":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"buffer::Buffer::set_string":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style"],"buffer::Buffer::set_stringn":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style"],"buffer::Buffer::set_style":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style"],"buffer::Buffer::with_lines":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"buffer::Cell":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::reset":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::set_bg":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::set_char":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::set_fg":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::set_style":["buffer::Cell","std::marker::Sized","std::option::Option","std::string::String","style::Color","style::Modifier","style::Style"],"buffer::Cell::set_symbol":["buffer::Cell","std::string::String","style::Color","style::Modifier"],"buffer::Cell::style":["buffer::Cell","std::marker::Sized","std::option::Option","std::string::String","style::Color","style::Modifier","style::Style"],"layout::Alignment":["layout::Alignment"],"layout::Constraint":["layout::Constraint"],"layout::Constraint::apply":["layout::Constraint"],"layout::Corner":["layout::Corner"],"layout::Direction":["layout::Direction"],"layout::Element":["cassowary::Variable","layout::Element"],"layout::Element::bottom":["cassowary::Expression","cassowary::Variable","layout::Element"],"layout::Element::left":["cassowary::Variable","layout::Element"],"layout::Element::new":["cassowary::Variable","layout::Element"],"layout::Element::right":["cassowary::Expression","cassowary::Variable","layout::Element"],"layout::Element::top":["cassowary::Variable","layout::Element"],"layout::LAYOUT_CACHE::__getit":["std::marker::Sized","std::option::Option"],"layout::LAYOUT_CACHE::__init":["std::cell::RefCell"],"layout::Layout":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Layout::constraints":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::vec::Vec"],"layout::Layout::direction":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Layout::horizontal_margin":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Layout::margin":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Layout::split":["layout::Direction","layout::Layout","layout::Margin","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Layout::vertical_margin":["layout::Direction","layout::Layout","layout::Margin","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"layout::Margin":["layout::Margin"],"layout::Rect":["layout::Rect"],"layout::Rect::area":["layout::Rect"],"layout::Rect::bottom":["layout::Rect"],"layout::Rect::inner":["layout::Margin","layout::Rect"],"layout::Rect::intersection":["layout::Rect"],"layout::Rect::intersects":["layout::Rect"],"layout::Rect::left":["layout::Rect"],"layout::Rect::new":["layout::Rect"],"layout::Rect::right":["layout::Rect"],"layout::Rect::top":["layout::Rect"],"layout::Rect::union":["layout::Rect"],"layout::split":["layout::Direction","layout::Layout","layout::Margin","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"style::Color":["style::Color"],"style::Modifier":["style::Modifier"],"style::Modifier::all":["style::Modifier"],"style::Modifier::bits":["style::Modifier"],"style::Modifier::complement":["style::Modifier"],"style::Modifier::contains":["style::Modifier"],"style::Modifier::difference":["style::Modifier"],"style::Modifier::empty":["style::Modifier"],"style::Modifier::from_bits":["std::marker::Sized","std::option::Option"],"style::Modifier::from_bits_truncate":["style::Modifier"],"style::Modifier::from_bits_unchecked":["style::Modifier"],"style::Modifier::insert":["style::Modifier"],"style::Modifier::intersection":["style::Modifier"],"style::Modifier::intersects":["style::Modifier"],"style::Modifier::is_all":["style::Modifier"],"style::Modifier::is_empty":["style::Modifier"],"style::Modifier::remove":["style::Modifier"],"style::Modifier::set":["style::Modifier"],"style::Modifier::symmetric_difference":["style::Modifier"],"style::Modifier::toggle":["style::Modifier"],"style::Modifier::union":["style::Modifier"],"style::Style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"style::Style::add_modifier":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"style::Style::bg":["std::marker::Sized","std::option::Option","style::Color","style::Modifier","style::Style"],"style::Style::fg":["std::marker::Sized","std::option::Option","style::Color","style::Modifier","style::Style"],"style::Style::patch":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"style::Style::remove_modifier":["std::marker::Sized","std::option::Option","style::Modifier","style::Style"],"symbols::Marker":["symbols::Marker"],"symbols::bar::Set":["symbols::bar::Set"],"symbols::block::Set":["symbols::block::Set"],"symbols::line::Set":["symbols::line::Set"],"terminal::Frame":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Frame::<'a, B>::render_stateful_widget":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Corner","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport","widgets::StatefulWidget","widgets::list::List"],"terminal::Frame::<'a, B>::render_widget":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport","widgets::Widget","widgets::barchart::BarChart"],"terminal::Frame::<'a, B>::set_cursor":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Frame::<'a, B>::size":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::ResizeBehavior":["terminal::ResizeBehavior"],"terminal::Terminal":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::autoresize":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::backend":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::backend_mut":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::clear":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::current_buffer_mut":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::draw":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::ops::FnOnce","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::flush":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::get_cursor":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::get_frame":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","terminal::Frame","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::hide_cursor":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::new":["std::marker::Sized","std::result::Result"],"terminal::Terminal::<B>::resize":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::set_cursor":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::show_cursor":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::size":["backend::Backend","backend::termion::TermionBackend","buffer::Buffer","layout::Rect","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec","terminal::ResizeBehavior","terminal::Terminal","terminal::Viewport"],"terminal::Terminal::<B>::with_options":["layout::Rect","std::marker::Sized","std::result::Result","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport"],"terminal::TerminalOptions":["layout::Rect","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport"],"terminal::Viewport":["layout::Rect","terminal::ResizeBehavior","terminal::Viewport"],"terminal::Viewport::fixed":["layout::Rect","terminal::ResizeBehavior","terminal::Viewport"],"text::<impl std::convert::From<text::Spans<'a>> for std::string::String>::from":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","text::Spans"],"text::Span":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"text::Span::<'a>::raw":["std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"text::Span::<'a>::styled":["std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"text::Span::<'a>::styled_graphemes":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"text::Span::<'a>::width":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::Span"],"text::Spans":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"text::Spans::<'a>::width":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Spans"],"text::StyledGrapheme":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","text::StyledGrapheme"],"text::Text":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"text::Text::<'a>::height":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"text::Text::<'a>::patch_style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text"],"text::Text::<'a>::raw":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::vec::Vec","text::Text"],"text::Text::<'a>::styled":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text"],"text::Text::<'a>::width":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","text::Text"],"widgets::Borders":["widgets::Borders"],"widgets::Borders::all":["widgets::Borders"],"widgets::Borders::bits":["widgets::Borders"],"widgets::Borders::complement":["widgets::Borders"],"widgets::Borders::contains":["widgets::Borders"],"widgets::Borders::difference":["widgets::Borders"],"widgets::Borders::empty":["widgets::Borders"],"widgets::Borders::from_bits":["std::marker::Sized","std::option::Option"],"widgets::Borders::from_bits_truncate":["widgets::Borders"],"widgets::Borders::from_bits_unchecked":["widgets::Borders"],"widgets::Borders::insert":["widgets::Borders"],"widgets::Borders::intersection":["widgets::Borders"],"widgets::Borders::intersects":["widgets::Borders"],"widgets::Borders::is_all":["widgets::Borders"],"widgets::Borders::is_empty":["widgets::Borders"],"widgets::Borders::remove":["widgets::Borders"],"widgets::Borders::set":["widgets::Borders"],"widgets::Borders::symmetric_difference":["widgets::Borders"],"widgets::Borders::toggle":["widgets::Borders"],"widgets::Borders::union":["widgets::Borders"],"widgets::StatefulWidget::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"widgets::Widget::render":["buffer::Buffer","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"widgets::barchart::BarChart":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::bar_gap":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::bar_set":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::bar_style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::bar_width":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::block":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::Borders","widgets::barchart::BarChart","widgets::block::Block","widgets::block::BorderType"],"widgets::barchart::BarChart::<'a>::data":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::label_style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::max":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::barchart::BarChart::<'a>::value_style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","symbols::bar::Set","widgets::barchart::BarChart"],"widgets::block::Block":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::border_style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::border_type":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::borders":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::inner":["layout::Rect","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::title":["std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::Block::<'a>::title_style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType"],"widgets::block::BorderType":["widgets::block::BorderType"],"widgets::block::BorderType::line_symbols":["symbols::line::Set","widgets::block::BorderType"],"widgets::canvas::BrailleGrid":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"widgets::canvas::BrailleGrid::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::BrailleGrid"],"widgets::canvas::Canvas":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::background_color":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::block":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","style::Modifier","style::Style","symbols::Marker","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::marker":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::paint":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::x_bounds":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::Canvas::<'a, F>::y_bounds":["std::marker::Sized","std::ops::Fn","std::option::Option","style::Color","symbols::Marker","widgets::canvas::Canvas"],"widgets::canvas::CharGrid":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"widgets::canvas::CharGrid::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::canvas::CharGrid"],"widgets::canvas::Context":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context"],"widgets::canvas::Context::<'a>::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Shape","widgets::canvas::line::Line"],"widgets::canvas::Context::<'a>::finish":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context"],"widgets::canvas::Context::<'a>::layer":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context"],"widgets::canvas::Context::<'a>::new":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","symbols::Marker","widgets::canvas::Context"],"widgets::canvas::Context::<'a>::print":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context"],"widgets::canvas::Grid::height":[],"widgets::canvas::Grid::paint":["style::Color"],"widgets::canvas::Grid::reset":[],"widgets::canvas::Grid::resolution":[],"widgets::canvas::Grid::save":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","widgets::canvas::Layer"],"widgets::canvas::Grid::width":[],"widgets::canvas::Label":["style::Color","widgets::canvas::Label"],"widgets::canvas::Layer":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","widgets::canvas::Layer"],"widgets::canvas::Painter":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::Painter::<'a, 'b>::get_point":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::Painter::<'a, 'b>::paint":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::Shape::draw":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::line::Line":["style::Color","widgets::canvas::line::Line"],"widgets::canvas::line::draw_line_high":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::line::draw_line_low":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","style::Color","widgets::canvas::Context","widgets::canvas::Painter"],"widgets::canvas::map::Map":["style::Color","widgets::canvas::map::Map","widgets::canvas::map::MapResolution"],"widgets::canvas::map::MapResolution":["widgets::canvas::map::MapResolution"],"widgets::canvas::map::MapResolution::data":["widgets::canvas::map::MapResolution"],"widgets::canvas::points::Points":["style::Color","widgets::canvas::points::Points"],"widgets::canvas::rectangle::Rectangle":["style::Color","widgets::canvas::rectangle::Rectangle"],"widgets::chart::Axis":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Axis::<'a>::bounds":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Axis::<'a>::labels":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Axis::<'a>::style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Axis::<'a>::title":["std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Axis::<'a>::title_style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::chart::Axis"],"widgets::chart::Chart":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::block":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::hidden_legend_constraints":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::layout":["layout::Constraint","layout::Rect","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart","widgets::chart::ChartLayout"],"widgets::chart::Chart::<'a>::new":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::style":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::x_axis":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::Chart::<'a>::y_axis":["layout::Constraint","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::chart::Axis","widgets::chart::Chart"],"widgets::chart::ChartLayout":["layout::Rect","std::marker::Sized","std::option::Option","widgets::chart::ChartLayout"],"widgets::chart::Dataset":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::Dataset::<'a>::data":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::Dataset::<'a>::graph_type":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::Dataset::<'a>::marker":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::Dataset::<'a>::name":["std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::Dataset::<'a>::style":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::Marker","widgets::chart::Dataset","widgets::chart::GraphType"],"widgets::chart::GraphType":["widgets::chart::GraphType"],"widgets::clear::Clear":["widgets::clear::Clear"],"widgets::gauge::Gauge":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::block":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::gauge_style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::label":["std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::percent":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::ratio":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::Gauge::<'a>::style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::gauge::Gauge"],"widgets::gauge::LineGauge":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::block":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::gauge_style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::label":["std::convert::Into","std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::line_set":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::ratio":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::gauge::LineGauge::<'a>::style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::line::Set","widgets::gauge::LineGauge"],"widgets::list::List":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::List::<'a>::block":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::list::List"],"widgets::list::List::<'a>::highlight_style":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::List::<'a>::highlight_symbol":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::List::<'a>::new":["layout::Corner","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::List::<'a>::start_corner":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::List::<'a>::style":["layout::Corner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","widgets::list::List"],"widgets::list::ListItem":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"widgets::list::ListItem::<'a>::height":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"widgets::list::ListItem::<'a>::new":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"widgets::list::ListItem::<'a>::style":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::list::ListItem"],"widgets::list::ListState":["std::marker::Sized","std::option::Option","widgets::list::ListState"],"widgets::list::ListState::select":["std::marker::Sized","std::option::Option","widgets::list::ListState"],"widgets::list::ListState::selected":["std::marker::Sized","std::option::Option","widgets::list::ListState"],"widgets::paragraph::Paragraph":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::alignment":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::block":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::new":["layout::Alignment","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::scroll":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::style":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph"],"widgets::paragraph::Paragraph::<'a>::wrap":["layout::Alignment","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::paragraph::Paragraph","widgets::paragraph::Wrap"],"widgets::paragraph::Wrap":["widgets::paragraph::Wrap"],"widgets::paragraph::get_line_offset":["layout::Alignment"],"widgets::reflow::LineComposer::next_line":["std::marker::Sized","std::option::Option"],"widgets::reflow::LineTruncator":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::reflow::LineTruncator"],"widgets::reflow::LineTruncator::<'a, 'b>::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::reflow::LineTruncator"],"widgets::reflow::LineTruncator::<'a, 'b>::set_horizontal_offset":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::reflow::LineTruncator"],"widgets::reflow::WordWrapper":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::reflow::WordWrapper"],"widgets::reflow::WordWrapper::<'a, 'b>::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","widgets::reflow::WordWrapper"],"widgets::reflow::trim_offset":[],"widgets::sparkline::Sparkline":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"widgets::sparkline::Sparkline::<'a>::bar_set":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"widgets::sparkline::Sparkline::<'a>::block":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::sparkline::Sparkline"],"widgets::sparkline::Sparkline::<'a>::data":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"widgets::sparkline::Sparkline::<'a>::max":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"widgets::sparkline::Sparkline::<'a>::style":["std::marker::Sized","std::option::Option","style::Modifier","style::Style","symbols::bar::Set","widgets::sparkline::Sparkline"],"widgets::table::Row":["backend::termion::Bg","std::fmt::Display","std::iter::Iterator","std::marker::Sized","std::option::Option","style::Color","style::Modifier","style::Style","widgets::table::Row"],"widgets::table::Table":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::block":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::column_spacing":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::header":["layout::Constraint","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::header_gap":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::header_style":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::highlight_style":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::highlight_symbol":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::new":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::rows":["layout::Constraint","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Text","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::style":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::Table::<'a, H, R>::widths":["layout::Constraint","std::marker::Sized","std::option::Option","style::Modifier","style::Style","widgets::table::Table"],"widgets::table::TableState":["std::marker::Sized","std::option::Option","widgets::table::TableState"],"widgets::table::TableState::select":["std::marker::Sized","std::option::Option","widgets::table::TableState"],"widgets::table::TableState::selected":["std::marker::Sized","std::option::Option","widgets::table::TableState"],"widgets::tabs::Tabs":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::block":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::Borders","widgets::block::Block","widgets::block::BorderType","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::divider":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::highlight_style":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::new":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::select":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"],"widgets::tabs::Tabs::<'a>::style":["std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::vec::Vec","style::Modifier","style::Style","text::Span","widgets::tabs::Tabs"]},"glob_path_import":{},"self_to_fn":{"backend::termion::Bg":["impl fmt::Display for Bg {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use termion::color::Color as TermionColor;\n        match self.0 {\n            Color::Reset => termion::color::Reset.write_bg(f),\n            Color::Black => termion::color::Black.write_bg(f),\n            Color::Red => termion::color::Red.write_bg(f),\n            Color::Green => termion::color::Green.write_bg(f),\n            Color::Yellow => termion::color::Yellow.write_bg(f),\n            Color::Blue => termion::color::Blue.write_bg(f),\n            Color::Magenta => termion::color::Magenta.write_bg(f),\n            Color::Cyan => termion::color::Cyan.write_bg(f),\n            Color::Gray => termion::color::White.write_bg(f),\n            Color::DarkGray => termion::color::LightBlack.write_bg(f),\n            Color::LightRed => termion::color::LightRed.write_bg(f),\n            Color::LightGreen => termion::color::LightGreen.write_bg(f),\n            Color::LightBlue => termion::color::LightBlue.write_bg(f),\n            Color::LightYellow => termion::color::LightYellow.write_bg(f),\n            Color::LightMagenta => termion::color::LightMagenta.write_bg(f),\n            Color::LightCyan => termion::color::LightCyan.write_bg(f),\n            Color::White => termion::color::LightWhite.write_bg(f),\n            Color::Indexed(i) => termion::color::AnsiValue(i).write_bg(f),\n            Color::Rgb(r, g, b) => termion::color::Rgb(r, g, b).write_bg(f),\n        }\n    }\n}"],"backend::termion::Fg":["impl fmt::Display for Fg {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use termion::color::Color as TermionColor;\n        match self.0 {\n            Color::Reset => termion::color::Reset.write_fg(f),\n            Color::Black => termion::color::Black.write_fg(f),\n            Color::Red => termion::color::Red.write_fg(f),\n            Color::Green => termion::color::Green.write_fg(f),\n            Color::Yellow => termion::color::Yellow.write_fg(f),\n            Color::Blue => termion::color::Blue.write_fg(f),\n            Color::Magenta => termion::color::Magenta.write_fg(f),\n            Color::Cyan => termion::color::Cyan.write_fg(f),\n            Color::Gray => termion::color::White.write_fg(f),\n            Color::DarkGray => termion::color::LightBlack.write_fg(f),\n            Color::LightRed => termion::color::LightRed.write_fg(f),\n            Color::LightGreen => termion::color::LightGreen.write_fg(f),\n            Color::LightBlue => termion::color::LightBlue.write_fg(f),\n            Color::LightYellow => termion::color::LightYellow.write_fg(f),\n            Color::LightMagenta => termion::color::LightMagenta.write_fg(f),\n            Color::LightCyan => termion::color::LightCyan.write_fg(f),\n            Color::White => termion::color::LightWhite.write_fg(f),\n            Color::Indexed(i) => termion::color::AnsiValue(i).write_fg(f),\n            Color::Rgb(r, g, b) => termion::color::Rgb(r, g, b).write_fg(f),\n        }\n    }\n}"],"backend::termion::ModifierDiff":["impl fmt::Display for ModifierDiff {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let remove = self.from - self.to;\n        if remove.contains(Modifier::REVERSED) {\n            write!(f, \"{}\", termion::style::NoInvert)?;\n        }\n        if remove.contains(Modifier::BOLD) {\n            // XXX: the termion NoBold flag actually enables double-underline on ECMA-48 compliant\n            // terminals, and NoFaint additionally disables bold... so we use this trick to get\n            // the right semantics.\n            write!(f, \"{}\", termion::style::NoFaint)?;\n\n            if self.to.contains(Modifier::DIM) {\n                write!(f, \"{}\", termion::style::Faint)?;\n            }\n        }\n        if remove.contains(Modifier::ITALIC) {\n            write!(f, \"{}\", termion::style::NoItalic)?;\n        }\n        if remove.contains(Modifier::UNDERLINED) {\n            write!(f, \"{}\", termion::style::NoUnderline)?;\n        }\n        if remove.contains(Modifier::DIM) {\n            write!(f, \"{}\", termion::style::NoFaint)?;\n\n            // XXX: the NoFaint flag additionally disables bold as well, so we need to re-enable it\n            // here if we want it.\n            if self.to.contains(Modifier::BOLD) {\n                write!(f, \"{}\", termion::style::Bold)?;\n            }\n        }\n        if remove.contains(Modifier::CROSSED_OUT) {\n            write!(f, \"{}\", termion::style::NoCrossedOut)?;\n        }\n        if remove.contains(Modifier::SLOW_BLINK) || remove.contains(Modifier::RAPID_BLINK) {\n            write!(f, \"{}\", termion::style::NoBlink)?;\n        }\n\n        let add = self.to - self.from;\n        if add.contains(Modifier::REVERSED) {\n            write!(f, \"{}\", termion::style::Invert)?;\n        }\n        if add.contains(Modifier::BOLD) {\n            write!(f, \"{}\", termion::style::Bold)?;\n        }\n        if add.contains(Modifier::ITALIC) {\n            write!(f, \"{}\", termion::style::Italic)?;\n        }\n        if add.contains(Modifier::UNDERLINED) {\n            write!(f, \"{}\", termion::style::Underline)?;\n        }\n        if add.contains(Modifier::DIM) {\n            write!(f, \"{}\", termion::style::Faint)?;\n        }\n        if add.contains(Modifier::CROSSED_OUT) {\n            write!(f, \"{}\", termion::style::CrossedOut)?;\n        }\n        if add.contains(Modifier::SLOW_BLINK) || add.contains(Modifier::RAPID_BLINK) {\n            write!(f, \"{}\", termion::style::Blink)?;\n        }\n\n        Ok(())\n    }\n}"],"backend::termion::TermionBackend":["impl<W> Backend for TermionBackend<W>\nwhere\n    W: Write,\n{\n    /// Clears the entire screen and move the cursor to the top left of the screen\n    fn clear(&mut self) -> io::Result<()> {\n        write!(self.stdout, \"{}\", termion::clear::All)?;\n        write!(self.stdout, \"{}\", termion::cursor::Goto(1, 1))?;\n        self.stdout.flush()\n    }\n\n    /// Hides cursor\n    fn hide_cursor(&mut self) -> io::Result<()> {\n        write!(self.stdout, \"{}\", termion::cursor::Hide)?;\n        self.stdout.flush()\n    }\n\n    /// Shows cursor\n    fn show_cursor(&mut self) -> io::Result<()> {\n        write!(self.stdout, \"{}\", termion::cursor::Show)?;\n        self.stdout.flush()\n    }\n\n    /// Gets cursor position (0-based index)\n    fn get_cursor(&mut self) -> io::Result<(u16, u16)> {\n        termion::cursor::DetectCursorPos::cursor_pos(&mut self.stdout).map(|(x, y)| (x - 1, y - 1))\n    }\n\n    /// Sets cursor position (0-based index)\n    fn set_cursor(&mut self, x: u16, y: u16) -> io::Result<()> {\n        write!(self.stdout, \"{}\", termion::cursor::Goto(x + 1, y + 1))?;\n        self.stdout.flush()\n    }\n\n    fn draw<'a, I>(&mut self, content: I) -> io::Result<()>\n    where\n        I: Iterator<Item = (u16, u16, &'a Cell)>,\n    {\n        use std::fmt::Write;\n\n        let mut string = String::with_capacity(content.size_hint().0 * 3);\n        let mut fg = Color::Reset;\n        let mut bg = Color::Reset;\n        let mut modifier = Modifier::empty();\n        let mut last_pos: Option<(u16, u16)> = None;\n        for (x, y, cell) in content {\n            // Move the cursor if the previous location was not (x - 1, y)\n            if !matches!(last_pos, Some(p) if x == p.0 + 1 && y == p.1) {\n                write!(string, \"{}\", termion::cursor::Goto(x + 1, y + 1)).unwrap();\n            }\n            last_pos = Some((x, y));\n            if cell.modifier != modifier {\n                write!(\n                    string,\n                    \"{}\",\n                    ModifierDiff {\n                        from: modifier,\n                        to: cell.modifier\n                    }\n                )\n                .unwrap();\n                modifier = cell.modifier;\n            }\n            if cell.fg != fg {\n                write!(string, \"{}\", Fg(cell.fg)).unwrap();\n                fg = cell.fg;\n            }\n            if cell.bg != bg {\n                write!(string, \"{}\", Bg(cell.bg)).unwrap();\n                bg = cell.bg;\n            }\n            string.push_str(&cell.symbol);\n        }\n        write!(\n            self.stdout,\n            \"{}{}{}{}\",\n            string,\n            Fg(Color::Reset),\n            Bg(Color::Reset),\n            termion::style::Reset,\n        )\n    }\n\n    /// Return the size of the terminal\n    fn size(&self) -> io::Result<Rect> {\n        let terminal = termion::terminal_size()?;\n        Ok(Rect::new(0, 0, terminal.0, terminal.1))\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.stdout.flush()\n    }\n}","impl<W> TermionBackend<W>\nwhere\n    W: Write,\n{\n    pub fn new(stdout: W) -> TermionBackend<W> {\n        TermionBackend { stdout }\n    }\n}","impl<W> Write for TermionBackend<W>\nwhere\n    W: Write,\n{\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.stdout.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.stdout.flush()\n    }\n}"],"backend::test::TestBackend":["Debug","impl Backend for TestBackend {\n    fn draw<'a, I>(&mut self, content: I) -> Result<(), io::Error>\n    where\n        I: Iterator<Item = (u16, u16, &'a Cell)>,\n    {\n        for (x, y, c) in content {\n            let cell = self.buffer.get_mut(x, y);\n            *cell = c.clone();\n        }\n        Ok(())\n    }\n\n    fn hide_cursor(&mut self) -> Result<(), io::Error> {\n        self.cursor = false;\n        Ok(())\n    }\n\n    fn show_cursor(&mut self) -> Result<(), io::Error> {\n        self.cursor = true;\n        Ok(())\n    }\n\n    fn get_cursor(&mut self) -> Result<(u16, u16), io::Error> {\n        Ok(self.pos)\n    }\n\n    fn set_cursor(&mut self, x: u16, y: u16) -> Result<(), io::Error> {\n        self.pos = (x, y);\n        Ok(())\n    }\n\n    fn clear(&mut self) -> Result<(), io::Error> {\n        Ok(())\n    }\n\n    fn size(&self) -> Result<Rect, io::Error> {\n        Ok(Rect::new(0, 0, self.width, self.height))\n    }\n\n    fn flush(&mut self) -> Result<(), io::Error> {\n        Ok(())\n    }\n}","impl TestBackend {\n    pub fn new(width: u16, height: u16) -> TestBackend {\n        TestBackend {\n            width,\n            height,\n            buffer: Buffer::empty(Rect::new(0, 0, width, height)),\n            cursor: false,\n            pos: (0, 0),\n        }\n    }\n\n    pub fn buffer(&self) -> &Buffer {\n        &self.buffer\n    }\n\n    pub fn assert_buffer(&self, expected: &Buffer) {\n        assert_eq!(expected.area, self.buffer.area);\n        let diff = expected.diff(&self.buffer);\n        if diff.is_empty() {\n            return;\n        }\n\n        let mut debug_info = String::from(\"Buffers are not equal\");\n        debug_info.push('\\n');\n        debug_info.push_str(\"Expected:\");\n        debug_info.push('\\n');\n        let expected_view = buffer_view(expected);\n        debug_info.push_str(&expected_view);\n        debug_info.push('\\n');\n        debug_info.push_str(\"Got:\");\n        debug_info.push('\\n');\n        let view = buffer_view(&self.buffer);\n        debug_info.push_str(&view);\n        debug_info.push('\\n');\n\n        debug_info.push_str(\"Diff:\");\n        debug_info.push('\\n');\n        let nice_diff = diff\n            .iter()\n            .enumerate()\n            .map(|(i, (x, y, cell))| {\n                let expected_cell = expected.get(*x, *y);\n                format!(\n                    \"{}: at ({}, {}) expected {:?} got {:?}\",\n                    i, x, y, expected_cell, cell\n                )\n            })\n            .collect::<Vec<String>>()\n            .join(\"\\n\");\n        debug_info.push_str(&nice_diff);\n        panic!(debug_info);\n    }\n}"],"buffer::Buffer":["Clone","Debug","PartialEq","impl Buffer {\n    /// Returns a Buffer with all cells set to the default one\n    pub fn empty(area: Rect) -> Buffer {\n        let cell: Cell = Default::default();\n        Buffer::filled(area, &cell)\n    }\n\n    /// Returns a Buffer with all cells initialized with the attributes of the given Cell\n    pub fn filled(area: Rect, cell: &Cell) -> Buffer {\n        let size = area.area() as usize;\n        let mut content = Vec::with_capacity(size);\n        for _ in 0..size {\n            content.push(cell.clone());\n        }\n        Buffer { area, content }\n    }\n\n    /// Returns a Buffer containing the given lines\n    pub fn with_lines<S>(lines: Vec<S>) -> Buffer\n    where\n        S: AsRef<str>,\n    {\n        let height = lines.len() as u16;\n        let width = lines\n            .iter()\n            .map(|i| i.as_ref().width() as u16)\n            .max()\n            .unwrap_or_default();\n        let mut buffer = Buffer::empty(Rect {\n            x: 0,\n            y: 0,\n            width,\n            height,\n        });\n        for (y, line) in lines.iter().enumerate() {\n            buffer.set_string(0, y as u16, line, Style::default());\n        }\n        buffer\n    }\n\n    /// Returns the content of the buffer as a slice\n    pub fn content(&self) -> &[Cell] {\n        &self.content\n    }\n\n    /// Returns the area covered by this buffer\n    pub fn area(&self) -> &Rect {\n        &self.area\n    }\n\n    /// Returns a reference to Cell at the given coordinates\n    pub fn get(&self, x: u16, y: u16) -> &Cell {\n        let i = self.index_of(x, y);\n        &self.content[i]\n    }\n\n    /// Returns a mutable reference to Cell at the given coordinates\n    pub fn get_mut(&mut self, x: u16, y: u16) -> &mut Cell {\n        let i = self.index_of(x, y);\n        &mut self.content[i]\n    }\n\n    /// Returns the index in the Vec<Cell> for the given global (x, y) coordinates.\n    ///\n    /// Global coordinates are offset by the Buffer's area offset (`x`/`y`).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use tui::buffer::Buffer;\n    /// # use tui::layout::Rect;\n    /// let rect = Rect::new(200, 100, 10, 10);\n    /// let buffer = Buffer::empty(rect);\n    /// // Global coordinates to the top corner of this buffer's area\n    /// assert_eq!(buffer.index_of(200, 100), 0);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics when given an coordinate that is outside of this Buffer's area.\n    ///\n    /// ```should_panic\n    /// # use tui::buffer::Buffer;\n    /// # use tui::layout::Rect;\n    /// let rect = Rect::new(200, 100, 10, 10);\n    /// let buffer = Buffer::empty(rect);\n    /// // Top coordinate is outside of the buffer in global coordinate space, as the Buffer's area\n    /// // starts at (200, 100).\n    /// buffer.index_of(0, 0); // Panics\n    /// ```\n    pub fn index_of(&self, x: u16, y: u16) -> usize {\n        debug_assert!(\n            x >= self.area.left()\n                && x < self.area.right()\n                && y >= self.area.top()\n                && y < self.area.bottom(),\n            \"Trying to access position outside the buffer: x={}, y={}, area={:?}\",\n            x,\n            y,\n            self.area\n        );\n        ((y - self.area.y) * self.area.width + (x - self.area.x)) as usize\n    }\n\n    /// Returns the (global) coordinates of a cell given its index\n    ///\n    /// Global coordinates are offset by the Buffer's area offset (`x`/`y`).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use tui::buffer::Buffer;\n    /// # use tui::layout::Rect;\n    /// let rect = Rect::new(200, 100, 10, 10);\n    /// let buffer = Buffer::empty(rect);\n    /// assert_eq!(buffer.pos_of(0), (200, 100));\n    /// assert_eq!(buffer.pos_of(14), (204, 101));\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics when given an index that is outside the Buffer's content.\n    ///\n    /// ```should_panic\n    /// # use tui::buffer::Buffer;\n    /// # use tui::layout::Rect;\n    /// let rect = Rect::new(0, 0, 10, 10); // 100 cells in total\n    /// let buffer = Buffer::empty(rect);\n    /// // Index 100 is the 101th cell, which lies outside of the area of this Buffer.\n    /// buffer.pos_of(100); // Panics\n    /// ```\n    pub fn pos_of(&self, i: usize) -> (u16, u16) {\n        debug_assert!(\n            i < self.content.len(),\n            \"Trying to get the coords of a cell outside the buffer: i={} len={}\",\n            i,\n            self.content.len()\n        );\n        (\n            self.area.x + i as u16 % self.area.width,\n            self.area.y + i as u16 / self.area.width,\n        )\n    }\n\n    /// Print a string, starting at the position (x, y)\n    pub fn set_string<S>(&mut self, x: u16, y: u16, string: S, style: Style)\n    where\n        S: AsRef<str>,\n    {\n        self.set_stringn(x, y, string, usize::MAX, style);\n    }\n\n    /// Print at most the first n characters of a string if enough space is available\n    /// until the end of the line\n    pub fn set_stringn<S>(\n        &mut self,\n        x: u16,\n        y: u16,\n        string: S,\n        width: usize,\n        style: Style,\n    ) -> (u16, u16)\n    where\n        S: AsRef<str>,\n    {\n        let mut index = self.index_of(x, y);\n        let mut x_offset = x as usize;\n        let graphemes = UnicodeSegmentation::graphemes(string.as_ref(), true);\n        let max_offset = min(self.area.right() as usize, width.saturating_add(x as usize));\n        for s in graphemes {\n            let width = s.width();\n            if width == 0 {\n                continue;\n            }\n            // `x_offset + width > max_offset` could be integer overflow on 32-bit machines if we\n            // change dimenstions to usize or u32 and someone resizes the terminal to 1x2^32.\n            if width > max_offset.saturating_sub(x_offset) {\n                break;\n            }\n\n            self.content[index].set_symbol(s);\n            self.content[index].set_style(style);\n            // Reset following cells if multi-width (they would be hidden by the grapheme),\n            for i in index + 1..index + width {\n                self.content[i].reset();\n            }\n            index += width;\n            x_offset += width;\n        }\n        (x_offset as u16, y)\n    }\n\n    pub fn set_spans<'a>(&mut self, x: u16, y: u16, spans: &Spans<'a>, width: u16) -> (u16, u16) {\n        let mut remaining_width = width;\n        let mut x = x;\n        for span in &spans.0 {\n            if remaining_width == 0 {\n                break;\n            }\n            let pos = self.set_stringn(\n                x,\n                y,\n                span.content.as_ref(),\n                remaining_width as usize,\n                span.style,\n            );\n            let w = pos.0.saturating_sub(x);\n            x = pos.0;\n            remaining_width = remaining_width.saturating_sub(w);\n        }\n        (x, y)\n    }\n\n    pub fn set_span<'a>(&mut self, x: u16, y: u16, span: &Span<'a>, width: u16) -> (u16, u16) {\n        self.set_stringn(x, y, span.content.as_ref(), width as usize, span.style)\n    }\n\n    #[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `Buffer::set_style`\"\n    )]\n    pub fn set_background(&mut self, area: Rect, color: Color) {\n        for y in area.top()..area.bottom() {\n            for x in area.left()..area.right() {\n                self.get_mut(x, y).set_bg(color);\n            }\n        }\n    }\n\n    pub fn set_style(&mut self, area: Rect, style: Style) {\n        for y in area.top()..area.bottom() {\n            for x in area.left()..area.right() {\n                self.get_mut(x, y).set_style(style);\n            }\n        }\n    }\n\n    /// Resize the buffer so that the mapped area matches the given area and that the buffer\n    /// length is equal to area.width * area.height\n    pub fn resize(&mut self, area: Rect) {\n        let length = area.area() as usize;\n        if self.content.len() > length {\n            self.content.truncate(length);\n        } else {\n            self.content.resize(length, Default::default());\n        }\n        self.area = area;\n    }\n\n    /// Reset all cells in the buffer\n    pub fn reset(&mut self) {\n        for c in &mut self.content {\n            c.reset();\n        }\n    }\n\n    /// Merge an other buffer into this one\n    pub fn merge(&mut self, other: &Buffer) {\n        let area = self.area.union(other.area);\n        let cell: Cell = Default::default();\n        self.content.resize(area.area() as usize, cell.clone());\n\n        // Move original content to the appropriate space\n        let size = self.area.area() as usize;\n        for i in (0..size).rev() {\n            let (x, y) = self.pos_of(i);\n            // New index in content\n            let k = ((y - area.y) * area.width + x - area.x) as usize;\n            if i != k {\n                self.content[k] = self.content[i].clone();\n                self.content[i] = cell.clone();\n            }\n        }\n\n        // Push content of the other buffer into this one (may erase previous\n        // data)\n        let size = other.area.area() as usize;\n        for i in 0..size {\n            let (x, y) = other.pos_of(i);\n            // New index in content\n            let k = ((y - area.y) * area.width + x - area.x) as usize;\n            self.content[k] = other.content[i].clone();\n        }\n        self.area = area;\n    }\n\n    /// Builds a minimal sequence of coordinates and Cells necessary to update the UI from\n    /// self to other.\n    ///\n    /// We're assuming that buffers are well-formed, that is no double-width cell is followed by\n    /// a non-blank cell.\n    ///\n    /// # Multi-width characters handling:\n    ///\n    /// ```text\n    /// (Index:) `01`\n    /// Prev:    ``\n    /// Next:    `aa`\n    /// Updates: `0: a, 1: a'\n    /// ```\n    ///\n    /// ```text\n    /// (Index:) `01`\n    /// Prev:    `a `\n    /// Next:    ``\n    /// Updates: `0: ` (double width symbol at index 0 - skip index 1)\n    /// ```\n    ///\n    /// ```text\n    /// (Index:) `012`\n    /// Prev:    `aaa`\n    /// Next:    `a`\n    /// Updates: `0: a, 1: ` (double width symbol at index 1 - skip index 2)\n    /// ```\n    pub fn diff<'a>(&self, other: &'a Buffer) -> Vec<(u16, u16, &'a Cell)> {\n        let previous_buffer = &self.content;\n        let next_buffer = &other.content;\n        let width = self.area.width;\n\n        let mut updates: Vec<(u16, u16, &Cell)> = vec![];\n        // Cells invalidated by drawing/replacing preceeding multi-width characters:\n        let mut invalidated: usize = 0;\n        // Cells from the current buffer to skip due to preceeding multi-width characters taking their\n        // place (the skipped cells should be blank anyway):\n        let mut to_skip: usize = 0;\n        for (i, (current, previous)) in next_buffer.iter().zip(previous_buffer.iter()).enumerate() {\n            if (current != previous || invalidated > 0) && to_skip == 0 {\n                let x = i as u16 % width;\n                let y = i as u16 / width;\n                updates.push((x, y, &next_buffer[i]));\n            }\n\n            to_skip = current.symbol.width().saturating_sub(1);\n\n            let affected_width = std::cmp::max(current.symbol.width(), previous.symbol.width());\n            invalidated = std::cmp::max(affected_width, invalidated).saturating_sub(1);\n        }\n        updates\n    }\n}","impl Default for Buffer {\n    fn default() -> Buffer {\n        Buffer {\n            area: Default::default(),\n            content: Vec::new(),\n        }\n    }\n}"],"buffer::Cell":["Clone","Debug","PartialEq","impl Cell {\n    pub fn set_symbol(&mut self, symbol: &str) -> &mut Cell {\n        self.symbol.clear();\n        self.symbol.push_str(symbol);\n        self\n    }\n\n    pub fn set_char(&mut self, ch: char) -> &mut Cell {\n        self.symbol.clear();\n        self.symbol.push(ch);\n        self\n    }\n\n    pub fn set_fg(&mut self, color: Color) -> &mut Cell {\n        self.fg = color;\n        self\n    }\n\n    pub fn set_bg(&mut self, color: Color) -> &mut Cell {\n        self.bg = color;\n        self\n    }\n\n    pub fn set_style(&mut self, style: Style) -> &mut Cell {\n        if let Some(c) = style.fg {\n            self.fg = c;\n        }\n        if let Some(c) = style.bg {\n            self.bg = c;\n        }\n        self.modifier.insert(style.add_modifier);\n        self.modifier.remove(style.sub_modifier);\n        self\n    }\n\n    pub fn style(&self) -> Style {\n        Style::default()\n            .fg(self.fg)\n            .bg(self.bg)\n            .add_modifier(self.modifier)\n    }\n\n    pub fn reset(&mut self) {\n        self.symbol.clear();\n        self.symbol.push(' ');\n        self.fg = Color::Reset;\n        self.bg = Color::Reset;\n        self.modifier = Modifier::empty();\n    }\n}","impl Default for Cell {\n    fn default() -> Cell {\n        Cell {\n            symbol: \" \".into(),\n            fg: Color::Reset,\n            bg: Color::Reset,\n            modifier: Modifier::empty(),\n        }\n    }\n}"],"layout::Alignment":["Clone","Copy","Debug","PartialEq"],"layout::Constraint":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Constraint {\n    pub fn apply(&self, length: u16) -> u16 {\n        match *self {\n            Constraint::Percentage(p) => length * p / 100,\n            Constraint::Ratio(num, den) => {\n                let r = num * u32::from(length) / den;\n                r as u16\n            }\n            Constraint::Length(l) => length.min(l),\n            Constraint::Max(m) => length.min(m),\n            Constraint::Min(m) => length.max(m),\n        }\n    }\n}"],"layout::Corner":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"layout::Direction":["Clone","Debug","Eq","Hash","PartialEq"],"layout::Element":["impl Element {\n    fn new() -> Element {\n        Element {\n            x: Variable::new(),\n            y: Variable::new(),\n            width: Variable::new(),\n            height: Variable::new(),\n        }\n    }\n\n    fn left(&self) -> Variable {\n        self.x\n    }\n\n    fn top(&self) -> Variable {\n        self.y\n    }\n\n    fn right(&self) -> Expression {\n        self.x + self.width\n    }\n\n    fn bottom(&self) -> Expression {\n        self.y + self.height\n    }\n}"],"layout::Layout":["Clone","Debug","Eq","Hash","PartialEq","impl Default for Layout {\n    fn default() -> Layout {\n        Layout {\n            direction: Direction::Vertical,\n            margin: Margin {\n                horizontal: 0,\n                vertical: 0,\n            },\n            constraints: Vec::new(),\n        }\n    }\n}","impl Layout {\n    pub fn constraints<C>(mut self, constraints: C) -> Layout\n    where\n        C: Into<Vec<Constraint>>,\n    {\n        self.constraints = constraints.into();\n        self\n    }\n\n    pub fn margin(mut self, margin: u16) -> Layout {\n        self.margin = Margin {\n            horizontal: margin,\n            vertical: margin,\n        };\n        self\n    }\n\n    pub fn horizontal_margin(mut self, horizontal: u16) -> Layout {\n        self.margin.horizontal = horizontal;\n        self\n    }\n\n    pub fn vertical_margin(mut self, vertical: u16) -> Layout {\n        self.margin.vertical = vertical;\n        self\n    }\n\n    pub fn direction(mut self, direction: Direction) -> Layout {\n        self.direction = direction;\n        self\n    }\n\n    /// Wrapper function around the cassowary-rs solver to be able to split a given\n    /// area into smaller ones based on the preferred widths or heights and the direction.\n    ///\n    /// # Examples\n    /// ```\n    /// # use tui::layout::{Rect, Constraint, Direction, Layout};\n    /// let chunks = Layout::default()\n    ///     .direction(Direction::Vertical)\n    ///     .constraints([Constraint::Length(5), Constraint::Min(0)].as_ref())\n    ///     .split(Rect {\n    ///         x: 2,\n    ///         y: 2,\n    ///         width: 10,\n    ///         height: 10,\n    ///     });\n    /// assert_eq!(\n    ///     chunks,\n    ///     vec![\n    ///         Rect {\n    ///             x: 2,\n    ///             y: 2,\n    ///             width: 10,\n    ///             height: 5\n    ///         },\n    ///         Rect {\n    ///             x: 2,\n    ///             y: 7,\n    ///             width: 10,\n    ///             height: 5\n    ///         }\n    ///     ]\n    /// );\n    ///\n    /// let chunks = Layout::default()\n    ///     .direction(Direction::Horizontal)\n    ///     .constraints([Constraint::Ratio(1, 3), Constraint::Ratio(2, 3)].as_ref())\n    ///     .split(Rect {\n    ///         x: 0,\n    ///         y: 0,\n    ///         width: 9,\n    ///         height: 2,\n    ///     });\n    /// assert_eq!(\n    ///     chunks,\n    ///     vec![\n    ///         Rect {\n    ///             x: 0,\n    ///             y: 0,\n    ///             width: 3,\n    ///             height: 2\n    ///         },\n    ///         Rect {\n    ///             x: 3,\n    ///             y: 0,\n    ///             width: 6,\n    ///             height: 2\n    ///         }\n    ///     ]\n    /// );\n    /// ```\n    pub fn split(&self, area: Rect) -> Vec<Rect> {\n        // TODO: Maybe use a fixed size cache ?\n        LAYOUT_CACHE.with(|c| {\n            c.borrow_mut()\n                .entry((area, self.clone()))\n                .or_insert_with(|| split(area, self))\n                .clone()\n        })\n    }\n}"],"layout::Margin":["Clone","Debug","Eq","Hash","PartialEq"],"layout::Rect":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Default for Rect {\n    fn default() -> Rect {\n        Rect {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        }\n    }\n}","impl Rect {\n    /// Creates a new rect, with width and height limited to keep the area under max u16.\n    /// If clipped, aspect ratio will be preserved.\n    pub fn new(x: u16, y: u16, width: u16, height: u16) -> Rect {\n        let max_area = u16::max_value();\n        let (clipped_width, clipped_height) =\n            if u32::from(width) * u32::from(height) > u32::from(max_area) {\n                let aspect_ratio = f64::from(width) / f64::from(height);\n                let max_area_f = f64::from(max_area);\n                let height_f = (max_area_f / aspect_ratio).sqrt();\n                let width_f = height_f * aspect_ratio;\n                (width_f as u16, height_f as u16)\n            } else {\n                (width, height)\n            };\n        Rect {\n            x,\n            y,\n            width: clipped_width,\n            height: clipped_height,\n        }\n    }\n\n    pub fn area(self) -> u16 {\n        self.width * self.height\n    }\n\n    pub fn left(self) -> u16 {\n        self.x\n    }\n\n    pub fn right(self) -> u16 {\n        self.x + self.width\n    }\n\n    pub fn top(self) -> u16 {\n        self.y\n    }\n\n    pub fn bottom(self) -> u16 {\n        self.y + self.height\n    }\n\n    pub fn inner(self, margin: &Margin) -> Rect {\n        if self.width < 2 * margin.horizontal || self.height < 2 * margin.vertical {\n            Rect::default()\n        } else {\n            Rect {\n                x: self.x + margin.horizontal,\n                y: self.y + margin.vertical,\n                width: self.width - 2 * margin.horizontal,\n                height: self.height - 2 * margin.vertical,\n            }\n        }\n    }\n\n    pub fn union(self, other: Rect) -> Rect {\n        let x1 = min(self.x, other.x);\n        let y1 = min(self.y, other.y);\n        let x2 = max(self.x + self.width, other.x + other.width);\n        let y2 = max(self.y + self.height, other.y + other.height);\n        Rect {\n            x: x1,\n            y: y1,\n            width: x2 - x1,\n            height: y2 - y1,\n        }\n    }\n\n    pub fn intersection(self, other: Rect) -> Rect {\n        let x1 = max(self.x, other.x);\n        let y1 = max(self.y, other.y);\n        let x2 = min(self.x + self.width, other.x + other.width);\n        let y2 = min(self.y + self.height, other.y + other.height);\n        Rect {\n            x: x1,\n            y: y1,\n            width: x2 - x1,\n            height: y2 - y1,\n        }\n    }\n\n    pub fn intersects(self, other: Rect) -> bool {\n        self.x < other.x + other.width\n            && self.x + self.width > other.x\n            && self.y < other.y + other.height\n            && self.y + self.height > other.y\n    }\n}"],"std::string::String":["impl<'a> From<Spans<'a>> for String {\n    fn from(line: Spans<'a>) -> String {\n        line.0.iter().fold(String::new(), |mut acc, s| {\n            acc.push_str(s.content.as_ref());\n            acc\n        })\n    }\n}"],"style::Color":["Clone","Copy","Debug","PartialEq"],"style::Modifier":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }","impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Debug for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }","impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }","impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }","impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }","impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }","impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }","impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }","impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }","impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }","impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }","impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }","impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }","impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }","impl __BitFlags for $BitFlags {\n            $(\n                __impl_bitflags! {\n                    #[allow(deprecated)]\n                    $(? #[$attr $($args)*])*\n                    const $Flag: $T = Self::$Flag.bits;\n                }\n            )+\n        }"],"style::Style":["Clone","Copy","Debug","PartialEq","impl Default for Style {\n    fn default() -> Style {\n        Style {\n            fg: None,\n            bg: None,\n            add_modifier: Modifier::empty(),\n            sub_modifier: Modifier::empty(),\n        }\n    }\n}","impl Style {\n    /// Changes the foreground color.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::style::{Color, Style};\n    /// let style = Style::default().fg(Color::Blue);\n    /// let diff = Style::default().fg(Color::Red);\n    /// assert_eq!(style.patch(diff), Style::default().fg(Color::Red));\n    /// ```\n    pub fn fg(mut self, color: Color) -> Style {\n        self.fg = Some(color);\n        self\n    }\n\n    /// Changes the background color.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::style::{Color, Style};\n    /// let style = Style::default().bg(Color::Blue);\n    /// let diff = Style::default().bg(Color::Red);\n    /// assert_eq!(style.patch(diff), Style::default().bg(Color::Red));\n    /// ```\n    pub fn bg(mut self, color: Color) -> Style {\n        self.bg = Some(color);\n        self\n    }\n\n    /// Changes the text emphasis.\n    ///\n    /// When applied, it adds the given modifier to the `Style` modifiers.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style = Style::default().add_modifier(Modifier::BOLD);\n    /// let diff = Style::default().add_modifier(Modifier::ITALIC);\n    /// let patched = style.patch(diff);\n    /// assert_eq!(patched.add_modifier, Modifier::BOLD | Modifier::ITALIC);\n    /// assert_eq!(patched.sub_modifier, Modifier::empty());\n    /// ```\n    pub fn add_modifier(mut self, modifier: Modifier) -> Style {\n        self.sub_modifier.remove(modifier);\n        self.add_modifier.insert(modifier);\n        self\n    }\n\n    /// Changes the text emphasis.\n    ///\n    /// When applied, it removes the given modifier from the `Style` modifiers.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style = Style::default().add_modifier(Modifier::BOLD | Modifier::ITALIC);\n    /// let diff = Style::default().remove_modifier(Modifier::ITALIC);\n    /// let patched = style.patch(diff);\n    /// assert_eq!(patched.add_modifier, Modifier::BOLD);\n    /// assert_eq!(patched.sub_modifier, Modifier::ITALIC);\n    /// ```\n    pub fn remove_modifier(mut self, modifier: Modifier) -> Style {\n        self.add_modifier.remove(modifier);\n        self.sub_modifier.insert(modifier);\n        self\n    }\n\n    /// Results in a combined style that is equivalent to applying the two individual styles to\n    /// a style one after the other.\n    ///\n    /// ## Examples\n    /// ```\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style_1 = Style::default().fg(Color::Yellow);\n    /// let style_2 = Style::default().bg(Color::Red);\n    /// let combined = style_1.patch(style_2);\n    /// assert_eq!(\n    ///     Style::default().patch(style_1).patch(style_2),\n    ///     Style::default().patch(combined));\n    /// ```\n    pub fn patch(mut self, other: Style) -> Style {\n        self.fg = other.fg.or(self.fg);\n        self.bg = other.bg.or(self.bg);\n\n        self.add_modifier.remove(other.sub_modifier);\n        self.add_modifier.insert(other.add_modifier);\n        self.sub_modifier.remove(other.add_modifier);\n        self.sub_modifier.insert(other.sub_modifier);\n\n        self\n    }\n}"],"symbols::Marker":["Clone","Copy","Debug"],"symbols::bar::Set":["Clone","Debug"],"symbols::block::Set":["Clone","Debug"],"symbols::line::Set":["Clone","Debug"],"terminal::Frame":["impl<'a, B> Frame<'a, B>\nwhere\n    B: Backend,\n{\n    /// Terminal size, guaranteed not to change when rendering.\n    pub fn size(&self) -> Rect {\n        self.terminal.viewport.area\n    }\n\n    /// Render a [`Widget`] to the current buffer using [`Widget::render`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use std::io;\n    /// # use tui::Terminal;\n    /// # use tui::backend::TermionBackend;\n    /// # use tui::layout::Rect;\n    /// # use tui::widgets::Block;\n    /// # let stdout = io::stdout();\n    /// # let backend = TermionBackend::new(stdout);\n    /// # let mut terminal = Terminal::new(backend).unwrap();\n    /// let block = Block::default();\n    /// let area = Rect::new(0, 0, 5, 5);\n    /// let mut frame = terminal.get_frame();\n    /// frame.render_widget(block, area);\n    /// ```\n    pub fn render_widget<W>(&mut self, widget: W, area: Rect)\n    where\n        W: Widget,\n    {\n        widget.render(area, self.terminal.current_buffer_mut());\n    }\n\n    /// Render a [`StatefulWidget`] to the current buffer using [`StatefulWidget::render`].\n    ///\n    /// The last argument should be an instance of the [`StatefulWidget::State`] associated to the\n    /// given [`StatefulWidget`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use std::io;\n    /// # use tui::Terminal;\n    /// # use tui::backend::TermionBackend;\n    /// # use tui::layout::Rect;\n    /// # use tui::widgets::{List, ListItem, ListState};\n    /// # let stdout = io::stdout();\n    /// # let backend = TermionBackend::new(stdout);\n    /// # let mut terminal = Terminal::new(backend).unwrap();\n    /// let mut state = ListState::default();\n    /// state.select(Some(1));\n    /// let items = vec![\n    ///     ListItem::new(\"Item 1\"),\n    ///     ListItem::new(\"Item 2\"),\n    /// ];\n    /// let list = List::new(items);\n    /// let area = Rect::new(0, 0, 5, 5);\n    /// let mut frame = terminal.get_frame();\n    /// frame.render_stateful_widget(list, area, &mut state);\n    /// ```\n    pub fn render_stateful_widget<W>(&mut self, widget: W, area: Rect, state: &mut W::State)\n    where\n        W: StatefulWidget,\n    {\n        widget.render(area, self.terminal.current_buffer_mut(), state);\n    }\n\n    /// After drawing this frame, make the cursor visible and put it at the specified (x, y)\n    /// coordinates. If this method is not called, the cursor will be hidden.\n    ///\n    /// Note that this will interfere with calls to `Terminal::hide_cursor()`,\n    /// `Terminal::show_cursor()`, and `Terminal::set_cursor()`. Pick one of the APIs and stick\n    /// with it.\n    pub fn set_cursor(&mut self, x: u16, y: u16) {\n        self.cursor_position = Some((x, y));\n    }\n}"],"terminal::ResizeBehavior":["Clone","Debug","PartialEq"],"terminal::Terminal":["Debug","impl<B> Drop for Terminal<B>\nwhere\n    B: Backend,\n{\n    fn drop(&mut self) {\n        // Attempt to restore the cursor state\n        if self.hidden_cursor {\n            if let Err(err) = self.show_cursor() {\n                eprintln!(\"Failed to show the cursor: {}\", err);\n            }\n        }\n    }\n}","impl<B> Terminal<B>\nwhere\n    B: Backend,\n{\n    /// Wrapper around Terminal initialization. Each buffer is initialized with a blank string and\n    /// default colors for the foreground and the background\n    pub fn new(backend: B) -> io::Result<Terminal<B>> {\n        let size = backend.size()?;\n        Terminal::with_options(\n            backend,\n            TerminalOptions {\n                viewport: Viewport {\n                    area: size,\n                    resize_behavior: ResizeBehavior::Auto,\n                },\n            },\n        )\n    }\n\n    /// UNSTABLE\n    pub fn with_options(backend: B, options: TerminalOptions) -> io::Result<Terminal<B>> {\n        Ok(Terminal {\n            backend,\n            buffers: [\n                Buffer::empty(options.viewport.area),\n                Buffer::empty(options.viewport.area),\n            ],\n            current: 0,\n            hidden_cursor: false,\n            viewport: options.viewport,\n        })\n    }\n\n    /// Get a Frame object which provides a consistent view into the terminal state for rendering.\n    pub fn get_frame(&mut self) -> Frame<B> {\n        Frame {\n            terminal: self,\n            cursor_position: None,\n        }\n    }\n\n    pub fn current_buffer_mut(&mut self) -> &mut Buffer {\n        &mut self.buffers[self.current]\n    }\n\n    pub fn backend(&self) -> &B {\n        &self.backend\n    }\n\n    pub fn backend_mut(&mut self) -> &mut B {\n        &mut self.backend\n    }\n\n    /// Obtains a difference between the previous and the current buffer and passes it to the\n    /// current backend for drawing.\n    pub fn flush(&mut self) -> io::Result<()> {\n        let previous_buffer = &self.buffers[1 - self.current];\n        let current_buffer = &self.buffers[self.current];\n        let updates = previous_buffer.diff(current_buffer);\n        self.backend.draw(updates.into_iter())\n    }\n\n    /// Updates the Terminal so that internal buffers match the requested size. Requested size will\n    /// be saved so the size can remain consistent when rendering.\n    /// This leads to a full clear of the screen.\n    pub fn resize(&mut self, area: Rect) -> io::Result<()> {\n        self.buffers[self.current].resize(area);\n        self.buffers[1 - self.current].resize(area);\n        self.viewport.area = area;\n        self.clear()\n    }\n\n    /// Queries the backend for size and resizes if it doesn't match the previous size.\n    pub fn autoresize(&mut self) -> io::Result<()> {\n        if self.viewport.resize_behavior == ResizeBehavior::Auto {\n            let size = self.size()?;\n            if size != self.viewport.area {\n                self.resize(size)?;\n            }\n        };\n        Ok(())\n    }\n\n    /// Synchronizes terminal size, calls the rendering closure, flushes the current internal state\n    /// and prepares for the next draw call.\n    pub fn draw<F>(&mut self, f: F) -> io::Result<()>\n    where\n        F: FnOnce(&mut Frame<B>),\n    {\n        // Autoresize - otherwise we get glitches if shrinking or potential desync between widgets\n        // and the terminal (if growing), which may OOB.\n        self.autoresize()?;\n\n        let mut frame = self.get_frame();\n        f(&mut frame);\n        // We can't change the cursor position right away because we have to flush the frame to\n        // stdout first. But we also can't keep the frame around, since it holds a &mut to\n        // Terminal. Thus, we're taking the important data out of the Frame and dropping it.\n        let cursor_position = frame.cursor_position;\n\n        // Draw to stdout\n        self.flush()?;\n\n        match cursor_position {\n            None => self.hide_cursor()?,\n            Some((x, y)) => {\n                self.show_cursor()?;\n                self.set_cursor(x, y)?;\n            }\n        }\n\n        // Swap buffers\n        self.buffers[1 - self.current].reset();\n        self.current = 1 - self.current;\n\n        // Flush\n        self.backend.flush()?;\n        Ok(())\n    }\n\n    pub fn hide_cursor(&mut self) -> io::Result<()> {\n        self.backend.hide_cursor()?;\n        self.hidden_cursor = true;\n        Ok(())\n    }\n\n    pub fn show_cursor(&mut self) -> io::Result<()> {\n        self.backend.show_cursor()?;\n        self.hidden_cursor = false;\n        Ok(())\n    }\n\n    pub fn get_cursor(&mut self) -> io::Result<(u16, u16)> {\n        self.backend.get_cursor()\n    }\n\n    pub fn set_cursor(&mut self, x: u16, y: u16) -> io::Result<()> {\n        self.backend.set_cursor(x, y)\n    }\n\n    /// Clear the terminal and force a full redraw on the next draw call.\n    pub fn clear(&mut self) -> io::Result<()> {\n        self.backend.clear()?;\n        // Reset the back buffer to make sure the next update will redraw everything.\n        self.buffers[1 - self.current].reset();\n        Ok(())\n    }\n\n    /// Queries the real size of the backend.\n    pub fn size(&self) -> io::Result<Rect> {\n        self.backend.size()\n    }\n}"],"terminal::TerminalOptions":["Clone","Debug","PartialEq"],"terminal::Viewport":["Clone","Debug","PartialEq","impl Viewport {\n    /// UNSTABLE\n    pub fn fixed(area: Rect) -> Viewport {\n        Viewport {\n            area,\n            resize_behavior: ResizeBehavior::Fixed,\n        }\n    }\n}"],"text::Span":["Clone","Debug","PartialEq","impl<'a> From<&'a str> for Span<'a> {\n    fn from(s: &'a str) -> Span<'a> {\n        Span::raw(s)\n    }\n}","impl<'a> From<String> for Span<'a> {\n    fn from(s: String) -> Span<'a> {\n        Span::raw(s)\n    }\n}","impl<'a> Span<'a> {\n    /// Create a span with no style.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::text::Span;\n    /// Span::raw(\"My text\");\n    /// Span::raw(String::from(\"My text\"));\n    /// ```\n    pub fn raw<T>(content: T) -> Span<'a>\n    where\n        T: Into<Cow<'a, str>>,\n    {\n        Span {\n            content: content.into(),\n            style: Style::default(),\n        }\n    }\n\n    /// Create a span with a style.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use tui::text::Span;\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n    /// Span::styled(\"My text\", style);\n    /// Span::styled(String::from(\"My text\"), style);\n    /// ```\n    pub fn styled<T>(content: T, style: Style) -> Span<'a>\n    where\n        T: Into<Cow<'a, str>>,\n    {\n        Span {\n            content: content.into(),\n            style,\n        }\n    }\n\n    /// Returns the width of the content held by this span.\n    pub fn width(&self) -> usize {\n        self.content.width()\n    }\n\n    /// Returns an iterator over the graphemes held by this span.\n    ///\n    /// `base_style` is the [`Style`] that will be patched with each grapheme [`Style`] to get\n    /// the resulting [`Style`].\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::text::{Span, StyledGrapheme};\n    /// # use tui::style::{Color, Modifier, Style};\n    /// # use std::iter::Iterator;\n    /// let style = Style::default().fg(Color::Yellow);\n    /// let span = Span::styled(\"Text\", style);\n    /// let style = Style::default().fg(Color::Green).bg(Color::Black);\n    /// let styled_graphemes = span.styled_graphemes(style);\n    /// assert_eq!(\n    ///     vec![\n    ///         StyledGrapheme {\n    ///             symbol: \"T\",\n    ///             style: Style {\n    ///                 fg: Some(Color::Yellow),\n    ///                 bg: Some(Color::Black),\n    ///                 add_modifier: Modifier::empty(),\n    ///                 sub_modifier: Modifier::empty(),\n    ///             },\n    ///         },\n    ///         StyledGrapheme {\n    ///             symbol: \"e\",\n    ///             style: Style {\n    ///                 fg: Some(Color::Yellow),\n    ///                 bg: Some(Color::Black),\n    ///                 add_modifier: Modifier::empty(),\n    ///                 sub_modifier: Modifier::empty(),\n    ///             },\n    ///         },\n    ///         StyledGrapheme {\n    ///             symbol: \"x\",\n    ///             style: Style {\n    ///                 fg: Some(Color::Yellow),\n    ///                 bg: Some(Color::Black),\n    ///                 add_modifier: Modifier::empty(),\n    ///                 sub_modifier: Modifier::empty(),\n    ///             },\n    ///         },\n    ///         StyledGrapheme {\n    ///             symbol: \"t\",\n    ///             style: Style {\n    ///                 fg: Some(Color::Yellow),\n    ///                 bg: Some(Color::Black),\n    ///                 add_modifier: Modifier::empty(),\n    ///                 sub_modifier: Modifier::empty(),\n    ///             },\n    ///         },\n    ///     ],\n    ///     styled_graphemes.collect::<Vec<StyledGrapheme>>()\n    /// );\n    /// ```\n    pub fn styled_graphemes(\n        &'a self,\n        base_style: Style,\n    ) -> impl Iterator<Item = StyledGrapheme<'a>> {\n        UnicodeSegmentation::graphemes(self.content.as_ref(), true)\n            .map(move |g| StyledGrapheme {\n                symbol: g,\n                style: base_style.patch(self.style),\n            })\n            .filter(|s| s.symbol != \"\\n\")\n    }\n}"],"text::Spans":["Clone","Debug","PartialEq","impl<'a> Default for Spans<'a> {\n    fn default() -> Spans<'a> {\n        Spans(Vec::new())\n    }\n}","impl<'a> From<&'a str> for Spans<'a> {\n    fn from(s: &'a str) -> Spans<'a> {\n        Spans(vec![Span::from(s)])\n    }\n}","impl<'a> From<Span<'a>> for Spans<'a> {\n    fn from(span: Span<'a>) -> Spans<'a> {\n        Spans(vec![span])\n    }\n}","impl<'a> From<String> for Spans<'a> {\n    fn from(s: String) -> Spans<'a> {\n        Spans(vec![Span::from(s)])\n    }\n}","impl<'a> From<Vec<Span<'a>>> for Spans<'a> {\n    fn from(spans: Vec<Span<'a>>) -> Spans<'a> {\n        Spans(spans)\n    }\n}","impl<'a> Spans<'a> {\n    /// Returns the width of the underlying string.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::text::{Span, Spans};\n    /// # use tui::style::{Color, Style};\n    /// let spans = Spans::from(vec![\n    ///     Span::styled(\"My\", Style::default().fg(Color::Yellow)),\n    ///     Span::raw(\" text\"),\n    /// ]);\n    /// assert_eq!(7, spans.width());\n    /// ```\n    pub fn width(&self) -> usize {\n        self.0.iter().map(Span::width).sum()\n    }\n}"],"text::StyledGrapheme":["Clone","Debug","PartialEq"],"text::Text":["Clone","Debug","PartialEq","impl<'a> Default for Text<'a> {\n    fn default() -> Text<'a> {\n        Text { lines: Vec::new() }\n    }\n}","impl<'a> Extend<Spans<'a>> for Text<'a> {\n    fn extend<T: IntoIterator<Item = Spans<'a>>>(&mut self, iter: T) {\n        self.lines.extend(iter);\n    }\n}","impl<'a> From<&'a str> for Text<'a> {\n    fn from(s: &'a str) -> Text<'a> {\n        Text::raw(s)\n    }\n}","impl<'a> From<Span<'a>> for Text<'a> {\n    fn from(span: Span<'a>) -> Text<'a> {\n        Text {\n            lines: vec![Spans::from(span)],\n        }\n    }\n}","impl<'a> From<Spans<'a>> for Text<'a> {\n    fn from(spans: Spans<'a>) -> Text<'a> {\n        Text { lines: vec![spans] }\n    }\n}","impl<'a> From<String> for Text<'a> {\n    fn from(s: String) -> Text<'a> {\n        Text::raw(s)\n    }\n}","impl<'a> From<Vec<Spans<'a>>> for Text<'a> {\n    fn from(lines: Vec<Spans<'a>>) -> Text<'a> {\n        Text { lines }\n    }\n}","impl<'a> IntoIterator for Text<'a> {\n    type Item = Spans<'a>;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.lines.into_iter()\n    }\n}","impl<'a> Text<'a> {\n    /// Create some text (potentially multiple lines) with no style.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # use tui::text::Text;\n    /// Text::raw(\"The first line\\nThe second line\");\n    /// Text::raw(String::from(\"The first line\\nThe second line\"));\n    /// ```\n    pub fn raw<T>(content: T) -> Text<'a>\n    where\n        T: Into<Cow<'a, str>>,\n    {\n        Text {\n            lines: match content.into() {\n                Cow::Borrowed(s) => s.lines().map(Spans::from).collect(),\n                Cow::Owned(s) => s.lines().map(|l| Spans::from(l.to_owned())).collect(),\n            },\n        }\n    }\n\n    /// Create some text (potentially multiple lines) with a style.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use tui::text::Text;\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n    /// Text::styled(\"The first line\\nThe second line\", style);\n    /// Text::styled(String::from(\"The first line\\nThe second line\"), style);\n    /// ```\n    pub fn styled<T>(content: T, style: Style) -> Text<'a>\n    where\n        T: Into<Cow<'a, str>>,\n    {\n        let mut text = Text::raw(content);\n        text.patch_style(style);\n        text\n    }\n\n    /// Returns the max width of all the lines.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// use tui::text::Text;\n    /// let text = Text::from(\"The first line\\nThe second line\");\n    /// assert_eq!(15, text.width());\n    /// ```\n    pub fn width(&self) -> usize {\n        self.lines\n            .iter()\n            .map(Spans::width)\n            .max()\n            .unwrap_or_default()\n    }\n\n    /// Returns the height.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// use tui::text::Text;\n    /// let text = Text::from(\"The first line\\nThe second line\");\n    /// assert_eq!(2, text.height());\n    /// ```\n    pub fn height(&self) -> usize {\n        self.lines.len()\n    }\n\n    /// Apply a new style to existing text.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use tui::text::Text;\n    /// # use tui::style::{Color, Modifier, Style};\n    /// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n    /// let mut raw_text = Text::raw(\"The first line\\nThe second line\");\n    /// let styled_text = Text::styled(String::from(\"The first line\\nThe second line\"), style);\n    /// assert_ne!(raw_text, styled_text);\n    ///\n    /// raw_text.patch_style(style);\n    /// assert_eq!(raw_text, styled_text);\n    /// ```\n    pub fn patch_style(&mut self, style: Style) {\n        for line in &mut self.lines {\n            for span in &mut line.0 {\n                span.style = span.style.patch(style);\n            }\n        }\n    }\n}"],"widgets::Borders":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }","impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Debug for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }","impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }","impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }","impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }","impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }","impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }","impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }","impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }","impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }","impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }","impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }","impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }","impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }","impl __BitFlags for $BitFlags {\n            $(\n                __impl_bitflags! {\n                    #[allow(deprecated)]\n                    $(? #[$attr $($args)*])*\n                    const $Flag: $T = Self::$Flag.bits;\n                }\n            )+\n        }"],"widgets::barchart::BarChart":["Clone","Debug","impl<'a> BarChart<'a> {\n    pub fn data(mut self, data: &'a [(&'a str, u64)]) -> BarChart<'a> {\n        self.data = data;\n        self.values = Vec::with_capacity(self.data.len());\n        for &(_, v) in self.data {\n            self.values.push(format!(\"{}\", v));\n        }\n        self\n    }\n\n    pub fn block(mut self, block: Block<'a>) -> BarChart<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn max(mut self, max: u64) -> BarChart<'a> {\n        self.max = Some(max);\n        self\n    }\n\n    pub fn bar_style(mut self, style: Style) -> BarChart<'a> {\n        self.bar_style = style;\n        self\n    }\n\n    pub fn bar_width(mut self, width: u16) -> BarChart<'a> {\n        self.bar_width = width;\n        self\n    }\n\n    pub fn bar_gap(mut self, gap: u16) -> BarChart<'a> {\n        self.bar_gap = gap;\n        self\n    }\n\n    pub fn bar_set(mut self, bar_set: symbols::bar::Set) -> BarChart<'a> {\n        self.bar_set = bar_set;\n        self\n    }\n\n    pub fn value_style(mut self, style: Style) -> BarChart<'a> {\n        self.value_style = style;\n        self\n    }\n\n    pub fn label_style(mut self, style: Style) -> BarChart<'a> {\n        self.label_style = style;\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> BarChart<'a> {\n        self.style = style;\n        self\n    }\n}","impl<'a> Default for BarChart<'a> {\n    fn default() -> BarChart<'a> {\n        BarChart {\n            block: None,\n            max: None,\n            data: &[],\n            values: Vec::new(),\n            bar_style: Style::default(),\n            bar_width: 1,\n            bar_gap: 1,\n            bar_set: symbols::bar::NINE_LEVELS,\n            value_style: Default::default(),\n            label_style: Default::default(),\n            style: Default::default(),\n        }\n    }\n}","impl<'a> Widget for BarChart<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n\n        let chart_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if chart_area.height < 2 {\n            return;\n        }\n\n        let max = self\n            .max\n            .unwrap_or_else(|| self.data.iter().map(|t| t.1).max().unwrap_or_default());\n        let max_index = min(\n            (chart_area.width / (self.bar_width + self.bar_gap)) as usize,\n            self.data.len(),\n        );\n        let mut data = self\n            .data\n            .iter()\n            .take(max_index)\n            .map(|&(l, v)| {\n                (\n                    l,\n                    v * u64::from(chart_area.height - 1) * 8 / std::cmp::max(max, 1),\n                )\n            })\n            .collect::<Vec<(&str, u64)>>();\n        for j in (0..chart_area.height - 1).rev() {\n            for (i, d) in data.iter_mut().enumerate() {\n                let symbol = match d.1 {\n                    0 => self.bar_set.empty,\n                    1 => self.bar_set.one_eighth,\n                    2 => self.bar_set.one_quarter,\n                    3 => self.bar_set.three_eighths,\n                    4 => self.bar_set.half,\n                    5 => self.bar_set.five_eighths,\n                    6 => self.bar_set.three_quarters,\n                    7 => self.bar_set.seven_eighths,\n                    _ => self.bar_set.full,\n                };\n\n                for x in 0..self.bar_width {\n                    buf.get_mut(\n                        chart_area.left() + i as u16 * (self.bar_width + self.bar_gap) + x,\n                        chart_area.top() + j,\n                    )\n                    .set_symbol(symbol)\n                    .set_style(self.bar_style);\n                }\n\n                if d.1 > 8 {\n                    d.1 -= 8;\n                } else {\n                    d.1 = 0;\n                }\n            }\n        }\n\n        for (i, &(label, value)) in self.data.iter().take(max_index).enumerate() {\n            if value != 0 {\n                let value_label = &self.values[i];\n                let width = value_label.width() as u16;\n                if width < self.bar_width {\n                    buf.set_string(\n                        chart_area.left()\n                            + i as u16 * (self.bar_width + self.bar_gap)\n                            + (self.bar_width - width) / 2,\n                        chart_area.bottom() - 2,\n                        value_label,\n                        self.value_style,\n                    );\n                }\n            }\n            buf.set_stringn(\n                chart_area.left() + i as u16 * (self.bar_width + self.bar_gap),\n                chart_area.bottom() - 1,\n                label,\n                self.bar_width as usize,\n                self.label_style,\n            );\n        }\n    }\n}"],"widgets::block::Block":["Clone","Debug","impl<'a> Block<'a> {\n    pub fn title<T>(mut self, title: T) -> Block<'a>\n    where\n        T: Into<Spans<'a>>,\n    {\n        self.title = Some(title.into());\n        self\n    }\n\n    #[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `text::Spans` given as argument of the `title` method to apply styling to the title.\"\n    )]\n    pub fn title_style(mut self, style: Style) -> Block<'a> {\n        if let Some(t) = self.title {\n            let title = String::from(t);\n            self.title = Some(Spans::from(Span::styled(title, style)));\n        }\n        self\n    }\n\n    pub fn border_style(mut self, style: Style) -> Block<'a> {\n        self.border_style = style;\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Block<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn borders(mut self, flag: Borders) -> Block<'a> {\n        self.borders = flag;\n        self\n    }\n\n    pub fn border_type(mut self, border_type: BorderType) -> Block<'a> {\n        self.border_type = border_type;\n        self\n    }\n\n    /// Compute the inner area of a block based on its border visibility rules.\n    pub fn inner(&self, area: Rect) -> Rect {\n        if area.width < 2 || area.height < 2 {\n            return Rect::default();\n        }\n        let mut inner = area;\n        if self.borders.intersects(Borders::LEFT) {\n            inner.x += 1;\n            inner.width -= 1;\n        }\n        if self.borders.intersects(Borders::TOP) || self.title.is_some() {\n            inner.y += 1;\n            inner.height -= 1;\n        }\n        if self.borders.intersects(Borders::RIGHT) {\n            inner.width -= 1;\n        }\n        if self.borders.intersects(Borders::BOTTOM) {\n            inner.height -= 1;\n        }\n        inner\n    }\n}","impl<'a> Default for Block<'a> {\n    fn default() -> Block<'a> {\n        Block {\n            title: None,\n            borders: Borders::NONE,\n            border_style: Default::default(),\n            border_type: BorderType::Plain,\n            style: Default::default(),\n        }\n    }\n}","impl<'a> Widget for Block<'a> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n\n        if area.width < 2 || area.height < 2 {\n            return;\n        }\n\n        let symbols = BorderType::line_symbols(self.border_type);\n        // Sides\n        if self.borders.intersects(Borders::LEFT) {\n            for y in area.top()..area.bottom() {\n                buf.get_mut(area.left(), y)\n                    .set_symbol(symbols.vertical)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::TOP) {\n            for x in area.left()..area.right() {\n                buf.get_mut(x, area.top())\n                    .set_symbol(symbols.horizontal)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::RIGHT) {\n            let x = area.right() - 1;\n            for y in area.top()..area.bottom() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols.vertical)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::BOTTOM) {\n            let y = area.bottom() - 1;\n            for x in area.left()..area.right() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols.horizontal)\n                    .set_style(self.border_style);\n            }\n        }\n\n        // Corners\n        if self.borders.contains(Borders::LEFT | Borders::TOP) {\n            buf.get_mut(area.left(), area.top())\n                .set_symbol(symbols.top_left)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::RIGHT | Borders::TOP) {\n            buf.get_mut(area.right() - 1, area.top())\n                .set_symbol(symbols.top_right)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::LEFT | Borders::BOTTOM) {\n            buf.get_mut(area.left(), area.bottom() - 1)\n                .set_symbol(symbols.bottom_left)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::RIGHT | Borders::BOTTOM) {\n            buf.get_mut(area.right() - 1, area.bottom() - 1)\n                .set_symbol(symbols.bottom_right)\n                .set_style(self.border_style);\n        }\n\n        if let Some(title) = self.title {\n            let lx = if self.borders.intersects(Borders::LEFT) {\n                1\n            } else {\n                0\n            };\n            let rx = if self.borders.intersects(Borders::RIGHT) {\n                1\n            } else {\n                0\n            };\n            let width = area.width - lx - rx;\n            buf.set_spans(area.left() + lx, area.top(), &title, width);\n        }\n    }\n}"],"widgets::block::BorderType":["Clone","Copy","Debug","impl BorderType {\n    pub fn line_symbols(border_type: BorderType) -> line::Set {\n        match border_type {\n            BorderType::Plain => line::NORMAL,\n            BorderType::Rounded => line::ROUNDED,\n            BorderType::Double => line::DOUBLE,\n            BorderType::Thick => line::THICK,\n        }\n    }\n}"],"widgets::canvas::BrailleGrid":["Clone","Debug","impl BrailleGrid {\n    fn new(width: u16, height: u16) -> BrailleGrid {\n        let length = usize::from(width * height);\n        BrailleGrid {\n            width,\n            height,\n            cells: vec![symbols::braille::BLANK; length],\n            colors: vec![Color::Reset; length],\n        }\n    }\n}","impl Grid for BrailleGrid {\n    fn width(&self) -> u16 {\n        self.width\n    }\n\n    fn height(&self) -> u16 {\n        self.height\n    }\n\n    fn resolution(&self) -> (f64, f64) {\n        (\n            f64::from(self.width) * 2.0 - 1.0,\n            f64::from(self.height) * 4.0 - 1.0,\n        )\n    }\n\n    fn save(&self) -> Layer {\n        Layer {\n            string: String::from_utf16(&self.cells).unwrap(),\n            colors: self.colors.clone(),\n        }\n    }\n\n    fn reset(&mut self) {\n        for c in &mut self.cells {\n            *c = symbols::braille::BLANK;\n        }\n        for c in &mut self.colors {\n            *c = Color::Reset;\n        }\n    }\n\n    fn paint(&mut self, x: usize, y: usize, color: Color) {\n        let index = y / 4 * self.width as usize + x / 2;\n        if let Some(c) = self.cells.get_mut(index) {\n            *c |= symbols::braille::DOTS[y % 4][x % 2];\n        }\n        if let Some(c) = self.colors.get_mut(index) {\n            *c = color;\n        }\n    }\n}"],"widgets::canvas::Canvas":["impl<'a, F> Canvas<'a, F>\nwhere\n    F: Fn(&mut Context),\n{\n    pub fn block(mut self, block: Block<'a>) -> Canvas<'a, F> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn x_bounds(mut self, bounds: [f64; 2]) -> Canvas<'a, F> {\n        self.x_bounds = bounds;\n        self\n    }\n\n    pub fn y_bounds(mut self, bounds: [f64; 2]) -> Canvas<'a, F> {\n        self.y_bounds = bounds;\n        self\n    }\n\n    /// Store the closure that will be used to draw to the Canvas\n    pub fn paint(mut self, f: F) -> Canvas<'a, F> {\n        self.painter = Some(f);\n        self\n    }\n\n    pub fn background_color(mut self, color: Color) -> Canvas<'a, F> {\n        self.background_color = color;\n        self\n    }\n\n    /// Change the type of points used to draw the shapes. By default the braille patterns are used\n    /// as they provide a more fine grained result but you might want to use the simple dot or\n    /// block instead if the targeted terminal does not support those symbols.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use tui::widgets::canvas::Canvas;\n    /// # use tui::symbols;\n    /// Canvas::default().marker(symbols::Marker::Braille).paint(|ctx| {});\n    ///\n    /// Canvas::default().marker(symbols::Marker::Dot).paint(|ctx| {});\n    ///\n    /// Canvas::default().marker(symbols::Marker::Block).paint(|ctx| {});\n    /// ```\n    pub fn marker(mut self, marker: symbols::Marker) -> Canvas<'a, F> {\n        self.marker = marker;\n        self\n    }\n}","impl<'a, F> Default for Canvas<'a, F>\nwhere\n    F: Fn(&mut Context),\n{\n    fn default() -> Canvas<'a, F> {\n        Canvas {\n            block: None,\n            x_bounds: [0.0, 0.0],\n            y_bounds: [0.0, 0.0],\n            painter: None,\n            background_color: Color::Reset,\n            marker: symbols::Marker::Braille,\n        }\n    }\n}","impl<'a, F> Widget for Canvas<'a, F>\nwhere\n    F: Fn(&mut Context),\n{\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        let canvas_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let width = canvas_area.width as usize;\n\n        let painter = match self.painter {\n            Some(ref p) => p,\n            None => return,\n        };\n\n        // Create a blank context that match the size of the canvas\n        let mut ctx = Context::new(\n            canvas_area.width,\n            canvas_area.height,\n            self.x_bounds,\n            self.y_bounds,\n            self.marker,\n        );\n        // Paint to this context\n        painter(&mut ctx);\n        ctx.finish();\n\n        // Retreive painted points for each layer\n        for layer in ctx.layers {\n            for (i, (ch, color)) in layer\n                .string\n                .chars()\n                .zip(layer.colors.into_iter())\n                .enumerate()\n            {\n                if ch != ' ' && ch != '\\u{2800}' {\n                    let (x, y) = (i % width, i / width);\n                    buf.get_mut(x as u16 + canvas_area.left(), y as u16 + canvas_area.top())\n                        .set_char(ch)\n                        .set_fg(color)\n                        .set_bg(self.background_color);\n                }\n            }\n        }\n\n        // Finally draw the labels\n        let style = Style::default().bg(self.background_color);\n        let left = self.x_bounds[0];\n        let right = self.x_bounds[1];\n        let top = self.y_bounds[1];\n        let bottom = self.y_bounds[0];\n        let width = (self.x_bounds[1] - self.x_bounds[0]).abs();\n        let height = (self.y_bounds[1] - self.y_bounds[0]).abs();\n        let resolution = {\n            let width = f64::from(canvas_area.width - 1);\n            let height = f64::from(canvas_area.height - 1);\n            (width, height)\n        };\n        for label in ctx\n            .labels\n            .iter()\n            .filter(|l| l.x >= left && l.x <= right && l.y <= top && l.y >= bottom)\n        {\n            let x = ((label.x - left) * resolution.0 / width) as u16 + canvas_area.left();\n            let y = ((top - label.y) * resolution.1 / height) as u16 + canvas_area.top();\n            buf.set_stringn(\n                x,\n                y,\n                label.text,\n                (canvas_area.right() - x) as usize,\n                style.fg(label.color),\n            );\n        }\n    }\n}"],"widgets::canvas::CharGrid":["Clone","Debug","impl CharGrid {\n    fn new(width: u16, height: u16, cell_char: char) -> CharGrid {\n        let length = usize::from(width * height);\n        CharGrid {\n            width,\n            height,\n            cells: vec![' '; length],\n            colors: vec![Color::Reset; length],\n            cell_char,\n        }\n    }\n}","impl Grid for CharGrid {\n    fn width(&self) -> u16 {\n        self.width\n    }\n\n    fn height(&self) -> u16 {\n        self.height\n    }\n\n    fn resolution(&self) -> (f64, f64) {\n        (f64::from(self.width) - 1.0, f64::from(self.height) - 1.0)\n    }\n\n    fn save(&self) -> Layer {\n        Layer {\n            string: self.cells.iter().collect(),\n            colors: self.colors.clone(),\n        }\n    }\n\n    fn reset(&mut self) {\n        for c in &mut self.cells {\n            *c = ' ';\n        }\n        for c in &mut self.colors {\n            *c = Color::Reset;\n        }\n    }\n\n    fn paint(&mut self, x: usize, y: usize, color: Color) {\n        let index = y * self.width as usize + x;\n        if let Some(c) = self.cells.get_mut(index) {\n            *c = self.cell_char;\n        }\n        if let Some(c) = self.colors.get_mut(index) {\n            *c = color;\n        }\n    }\n}"],"widgets::canvas::Context":["Debug","impl<'a> Context<'a> {\n    pub fn new(\n        width: u16,\n        height: u16,\n        x_bounds: [f64; 2],\n        y_bounds: [f64; 2],\n        marker: symbols::Marker,\n    ) -> Context<'a> {\n        let grid: Box<dyn Grid> = match marker {\n            symbols::Marker::Dot => Box::new(CharGrid::new(width, height, '')),\n            symbols::Marker::Block => Box::new(CharGrid::new(width, height, '')),\n            symbols::Marker::Braille => Box::new(BrailleGrid::new(width, height)),\n        };\n        Context {\n            x_bounds,\n            y_bounds,\n            grid,\n            dirty: false,\n            layers: Vec::new(),\n            labels: Vec::new(),\n        }\n    }\n\n    /// Draw any object that may implement the Shape trait\n    pub fn draw<S>(&mut self, shape: &S)\n    where\n        S: Shape,\n    {\n        self.dirty = true;\n        let mut painter = Painter::from(self);\n        shape.draw(&mut painter);\n    }\n\n    /// Go one layer above in the canvas.\n    pub fn layer(&mut self) {\n        self.layers.push(self.grid.save());\n        self.grid.reset();\n        self.dirty = false;\n    }\n\n    /// Print a string on the canvas at the given position\n    pub fn print(&mut self, x: f64, y: f64, text: &'a str, color: Color) {\n        self.labels.push(Label { x, y, text, color });\n    }\n\n    /// Push the last layer if necessary\n    fn finish(&mut self) {\n        if self.dirty {\n            self.layer()\n        }\n    }\n}"],"widgets::canvas::Label":["Clone","Debug"],"widgets::canvas::Layer":["Clone","Debug"],"widgets::canvas::Painter":["Debug","impl<'a, 'b> From<&'a mut Context<'b>> for Painter<'a, 'b> {\n    fn from(context: &'a mut Context<'b>) -> Painter<'a, 'b> {\n        let resolution = context.grid.resolution();\n        Painter {\n            context,\n            resolution,\n        }\n    }\n}","impl<'a, 'b> Painter<'a, 'b> {\n    /// Convert the (x, y) coordinates to location of a point on the grid\n    ///\n    /// # Examples:\n    /// ```\n    /// use tui::{symbols, widgets::canvas::{Painter, Context}};\n    ///\n    /// let mut ctx = Context::new(2, 2, [1.0, 2.0], [0.0, 2.0], symbols::Marker::Braille);\n    /// let mut painter = Painter::from(&mut ctx);\n    /// let point = painter.get_point(1.0, 0.0);\n    /// assert_eq!(point, Some((0, 7)));\n    /// let point = painter.get_point(1.5, 1.0);\n    /// assert_eq!(point, Some((1, 3)));\n    /// let point = painter.get_point(0.0, 0.0);\n    /// assert_eq!(point, None);\n    /// let point = painter.get_point(2.0, 2.0);\n    /// assert_eq!(point, Some((3, 0)));\n    /// let point = painter.get_point(1.0, 2.0);\n    /// assert_eq!(point, Some((0, 0)));\n    /// ```\n    pub fn get_point(&self, x: f64, y: f64) -> Option<(usize, usize)> {\n        let left = self.context.x_bounds[0];\n        let right = self.context.x_bounds[1];\n        let top = self.context.y_bounds[1];\n        let bottom = self.context.y_bounds[0];\n        if x < left || x > right || y < bottom || y > top {\n            return None;\n        }\n        let width = (self.context.x_bounds[1] - self.context.x_bounds[0]).abs();\n        let height = (self.context.y_bounds[1] - self.context.y_bounds[0]).abs();\n        if width == 0.0 || height == 0.0 {\n            return None;\n        }\n        let x = ((x - left) * self.resolution.0 / width) as usize;\n        let y = ((top - y) * self.resolution.1 / height) as usize;\n        Some((x, y))\n    }\n\n    /// Paint a point of the grid\n    ///\n    /// # Examples:\n    /// ```\n    /// use tui::{style::Color, symbols, widgets::canvas::{Painter, Context}};\n    ///\n    /// let mut ctx = Context::new(1, 1, [0.0, 2.0], [0.0, 2.0], symbols::Marker::Braille);\n    /// let mut painter = Painter::from(&mut ctx);\n    /// let cell = painter.paint(1, 3, Color::Red);\n    /// ```\n    pub fn paint(&mut self, x: usize, y: usize, color: Color) {\n        self.context.grid.paint(x, y, color);\n    }\n}"],"widgets::canvas::line::Line":["Clone","Debug","impl Shape for Line {\n    fn draw(&self, painter: &mut Painter) {\n        let (x1, y1) = match painter.get_point(self.x1, self.y1) {\n            Some(c) => c,\n            None => return,\n        };\n        let (x2, y2) = match painter.get_point(self.x2, self.y2) {\n            Some(c) => c,\n            None => return,\n        };\n        let (dx, x_range) = if x2 >= x1 {\n            (x2 - x1, x1..=x2)\n        } else {\n            (x1 - x2, x2..=x1)\n        };\n        let (dy, y_range) = if y2 >= y1 {\n            (y2 - y1, y1..=y2)\n        } else {\n            (y1 - y2, y2..=y1)\n        };\n\n        if dx == 0 {\n            for y in y_range {\n                painter.paint(x1, y, self.color);\n            }\n        } else if dy == 0 {\n            for x in x_range {\n                painter.paint(x, y1, self.color);\n            }\n        } else if dy < dx {\n            if x1 > x2 {\n                draw_line_low(painter, x2, y2, x1, y1, self.color);\n            } else {\n                draw_line_low(painter, x1, y1, x2, y2, self.color);\n            }\n        } else if y1 > y2 {\n            draw_line_high(painter, x2, y2, x1, y1, self.color);\n        } else {\n            draw_line_high(painter, x1, y1, x2, y2, self.color);\n        }\n    }\n}"],"widgets::canvas::map::Map":["Clone","Debug","impl Default for Map {\n    fn default() -> Map {\n        Map {\n            resolution: MapResolution::Low,\n            color: Color::Reset,\n        }\n    }\n}","impl Shape for Map {\n    fn draw(&self, painter: &mut Painter) {\n        for (x, y) in self.resolution.data() {\n            if let Some((x, y)) = painter.get_point(*x, *y) {\n                painter.paint(x, y, self.color);\n            }\n        }\n    }\n}"],"widgets::canvas::map::MapResolution":["Clone","Copy","Debug","impl MapResolution {\n    fn data(self) -> &'static [(f64, f64)] {\n        match self {\n            MapResolution::Low => &WORLD_LOW_RESOLUTION,\n            MapResolution::High => &WORLD_HIGH_RESOLUTION,\n        }\n    }\n}"],"widgets::canvas::points::Points":["Clone","Debug","impl<'a> Default for Points<'a> {\n    fn default() -> Points<'a> {\n        Points {\n            coords: &[],\n            color: Color::Reset,\n        }\n    }\n}","impl<'a> Shape for Points<'a> {\n    fn draw(&self, painter: &mut Painter) {\n        for (x, y) in self.coords {\n            if let Some((x, y)) = painter.get_point(*x, *y) {\n                painter.paint(x, y, self.color);\n            }\n        }\n    }\n}"],"widgets::canvas::rectangle::Rectangle":["Clone","Debug","impl Shape for Rectangle {\n    fn draw(&self, painter: &mut Painter) {\n        let lines: [Line; 4] = [\n            Line {\n                x1: self.x,\n                y1: self.y,\n                x2: self.x,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x,\n                y1: self.y + self.height,\n                x2: self.x + self.width,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x + self.width,\n                y1: self.y,\n                x2: self.x + self.width,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x,\n                y1: self.y,\n                x2: self.x + self.width,\n                y2: self.y,\n                color: self.color,\n            },\n        ];\n        for line in &lines {\n            line.draw(painter);\n        }\n    }\n}"],"widgets::chart::Axis":["Clone","Debug","impl<'a> Axis<'a> {\n    pub fn title<T>(mut self, title: T) -> Axis<'a>\n    where\n        T: Into<Spans<'a>>,\n    {\n        self.title = Some(title.into());\n        self\n    }\n\n    #[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `text::Spans` given as argument of the `title` method to apply styling to the title.\"\n    )]\n    pub fn title_style(mut self, style: Style) -> Axis<'a> {\n        if let Some(t) = self.title {\n            let title = String::from(t);\n            self.title = Some(Spans::from(Span::styled(title, style)));\n        }\n        self\n    }\n\n    pub fn bounds(mut self, bounds: [f64; 2]) -> Axis<'a> {\n        self.bounds = bounds;\n        self\n    }\n\n    pub fn labels(mut self, labels: Vec<Span<'a>>) -> Axis<'a> {\n        self.labels = Some(labels);\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Axis<'a> {\n        self.style = style;\n        self\n    }\n}","impl<'a> Default for Axis<'a> {\n    fn default() -> Axis<'a> {\n        Axis {\n            title: None,\n            bounds: [0.0, 0.0],\n            labels: None,\n            style: Default::default(),\n        }\n    }\n}"],"widgets::chart::Chart":["Clone","Debug","impl<'a> Chart<'a> {\n    pub fn new(datasets: Vec<Dataset<'a>>) -> Chart<'a> {\n        Chart {\n            block: None,\n            x_axis: Axis::default(),\n            y_axis: Axis::default(),\n            style: Default::default(),\n            datasets,\n            hidden_legend_constraints: (Constraint::Ratio(1, 4), Constraint::Ratio(1, 4)),\n        }\n    }\n\n    pub fn block(mut self, block: Block<'a>) -> Chart<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Chart<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn x_axis(mut self, axis: Axis<'a>) -> Chart<'a> {\n        self.x_axis = axis;\n        self\n    }\n\n    pub fn y_axis(mut self, axis: Axis<'a>) -> Chart<'a> {\n        self.y_axis = axis;\n        self\n    }\n\n    /// Set the constraints used to determine whether the legend should be shown or not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use tui::widgets::Chart;\n    /// # use tui::layout::Constraint;\n    /// let constraints = (\n    ///     Constraint::Ratio(1, 3),\n    ///     Constraint::Ratio(1, 4)\n    /// );\n    /// // Hide the legend when either its width is greater than 33% of the total widget width\n    /// // or if its height is greater than 25% of the total widget height.\n    /// let _chart: Chart = Chart::new(vec![])\n    ///     .hidden_legend_constraints(constraints);\n    /// ```\n    pub fn hidden_legend_constraints(mut self, constraints: (Constraint, Constraint)) -> Chart<'a> {\n        self.hidden_legend_constraints = constraints;\n        self\n    }\n\n    /// Compute the internal layout of the chart given the area. If the area is too small some\n    /// elements may be automatically hidden\n    fn layout(&self, area: Rect) -> ChartLayout {\n        let mut layout = ChartLayout::default();\n        if area.height == 0 || area.width == 0 {\n            return layout;\n        }\n        let mut x = area.left();\n        let mut y = area.bottom() - 1;\n\n        if self.x_axis.labels.is_some() && y > area.top() {\n            layout.label_x = Some(y);\n            y -= 1;\n        }\n\n        if let Some(ref y_labels) = self.y_axis.labels {\n            let mut max_width = y_labels.iter().map(Span::width).max().unwrap_or_default() as u16;\n            if let Some(ref x_labels) = self.x_axis.labels {\n                if !x_labels.is_empty() {\n                    max_width = max(max_width, x_labels[0].content.width() as u16);\n                }\n            }\n            if x + max_width < area.right() {\n                layout.label_y = Some(x);\n                x += max_width;\n            }\n        }\n\n        if self.x_axis.labels.is_some() && y > area.top() {\n            layout.axis_x = Some(y);\n            y -= 1;\n        }\n\n        if self.y_axis.labels.is_some() && x + 1 < area.right() {\n            layout.axis_y = Some(x);\n            x += 1;\n        }\n\n        if x < area.right() && y > 1 {\n            layout.graph_area = Rect::new(x, area.top(), area.right() - x, y - area.top() + 1);\n        }\n\n        if let Some(ref title) = self.x_axis.title {\n            let w = title.width() as u16;\n            if w < layout.graph_area.width && layout.graph_area.height > 2 {\n                layout.title_x = Some((x + layout.graph_area.width - w, y));\n            }\n        }\n\n        if let Some(ref title) = self.y_axis.title {\n            let w = title.width() as u16;\n            if w + 1 < layout.graph_area.width && layout.graph_area.height > 2 {\n                layout.title_y = Some((x, area.top()));\n            }\n        }\n\n        if let Some(inner_width) = self.datasets.iter().map(|d| d.name.width() as u16).max() {\n            let legend_width = inner_width + 2;\n            let legend_height = self.datasets.len() as u16 + 2;\n            let max_legend_width = self\n                .hidden_legend_constraints\n                .0\n                .apply(layout.graph_area.width);\n            let max_legend_height = self\n                .hidden_legend_constraints\n                .1\n                .apply(layout.graph_area.height);\n            if inner_width > 0\n                && legend_width < max_legend_width\n                && legend_height < max_legend_height\n            {\n                layout.legend_area = Some(Rect::new(\n                    layout.graph_area.right() - legend_width,\n                    layout.graph_area.top(),\n                    legend_width,\n                    legend_height,\n                ));\n            }\n        }\n        layout\n    }\n}","impl<'a> Widget for Chart<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n        // Sample the style of the entire widget. This sample will be used to reset the style of\n        // the cells that are part of the components put on top of the grah area (i.e legend and\n        // axis names).\n        let original_style = buf.get(area.left(), area.top()).style();\n\n        let chart_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let layout = self.layout(chart_area);\n        let graph_area = layout.graph_area;\n        if graph_area.width < 1 || graph_area.height < 1 {\n            return;\n        }\n\n        if let Some(y) = layout.label_x {\n            let labels = self.x_axis.labels.unwrap();\n            let total_width = labels.iter().map(Span::width).sum::<usize>() as u16;\n            let labels_len = labels.len() as u16;\n            if total_width < graph_area.width && labels_len > 1 {\n                for (i, label) in labels.iter().enumerate() {\n                    buf.set_span(\n                        graph_area.left() + i as u16 * (graph_area.width - 1) / (labels_len - 1)\n                            - label.content.width() as u16,\n                        y,\n                        label,\n                        label.width() as u16,\n                    );\n                }\n            }\n        }\n\n        if let Some(x) = layout.label_y {\n            let labels = self.y_axis.labels.unwrap();\n            let labels_len = labels.len() as u16;\n            for (i, label) in labels.iter().enumerate() {\n                let dy = i as u16 * (graph_area.height - 1) / (labels_len - 1);\n                if dy < graph_area.bottom() {\n                    buf.set_span(x, graph_area.bottom() - 1 - dy, label, label.width() as u16);\n                }\n            }\n        }\n\n        if let Some(y) = layout.axis_x {\n            for x in graph_area.left()..graph_area.right() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::HORIZONTAL)\n                    .set_style(self.x_axis.style);\n            }\n        }\n\n        if let Some(x) = layout.axis_y {\n            for y in graph_area.top()..graph_area.bottom() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::VERTICAL)\n                    .set_style(self.y_axis.style);\n            }\n        }\n\n        if let Some(y) = layout.axis_x {\n            if let Some(x) = layout.axis_y {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::BOTTOM_LEFT)\n                    .set_style(self.x_axis.style);\n            }\n        }\n\n        for dataset in &self.datasets {\n            Canvas::default()\n                .background_color(self.style.bg.unwrap_or(Color::Reset))\n                .x_bounds(self.x_axis.bounds)\n                .y_bounds(self.y_axis.bounds)\n                .marker(dataset.marker)\n                .paint(|ctx| {\n                    ctx.draw(&Points {\n                        coords: dataset.data,\n                        color: dataset.style.fg.unwrap_or(Color::Reset),\n                    });\n                    if let GraphType::Line = dataset.graph_type {\n                        for data in dataset.data.windows(2) {\n                            ctx.draw(&Line {\n                                x1: data[0].0,\n                                y1: data[0].1,\n                                x2: data[1].0,\n                                y2: data[1].1,\n                                color: dataset.style.fg.unwrap_or(Color::Reset),\n                            })\n                        }\n                    }\n                })\n                .render(graph_area, buf);\n        }\n\n        if let Some(legend_area) = layout.legend_area {\n            buf.set_style(legend_area, original_style);\n            Block::default()\n                .borders(Borders::ALL)\n                .render(legend_area, buf);\n            for (i, dataset) in self.datasets.iter().enumerate() {\n                buf.set_string(\n                    legend_area.x + 1,\n                    legend_area.y + 1 + i as u16,\n                    &dataset.name,\n                    dataset.style,\n                );\n            }\n        }\n\n        if let Some((x, y)) = layout.title_x {\n            let title = self.x_axis.title.unwrap();\n            let width = graph_area.right().saturating_sub(x);\n            buf.set_style(\n                Rect {\n                    x,\n                    y,\n                    width,\n                    height: 1,\n                },\n                original_style,\n            );\n            buf.set_spans(x, y, &title, width);\n        }\n\n        if let Some((x, y)) = layout.title_y {\n            let title = self.y_axis.title.unwrap();\n            let width = graph_area.right().saturating_sub(x);\n            buf.set_style(\n                Rect {\n                    x,\n                    y,\n                    width,\n                    height: 1,\n                },\n                original_style,\n            );\n            buf.set_spans(x, y, &title, width);\n        }\n    }\n}"],"widgets::chart::ChartLayout":["Clone","Debug","PartialEq","impl Default for ChartLayout {\n    fn default() -> ChartLayout {\n        ChartLayout {\n            title_x: None,\n            title_y: None,\n            label_x: None,\n            label_y: None,\n            axis_x: None,\n            axis_y: None,\n            legend_area: None,\n            graph_area: Rect::default(),\n        }\n    }\n}"],"widgets::chart::Dataset":["Clone","Debug","impl<'a> Dataset<'a> {\n    pub fn name<S>(mut self, name: S) -> Dataset<'a>\n    where\n        S: Into<Cow<'a, str>>,\n    {\n        self.name = name.into();\n        self\n    }\n\n    pub fn data(mut self, data: &'a [(f64, f64)]) -> Dataset<'a> {\n        self.data = data;\n        self\n    }\n\n    pub fn marker(mut self, marker: symbols::Marker) -> Dataset<'a> {\n        self.marker = marker;\n        self\n    }\n\n    pub fn graph_type(mut self, graph_type: GraphType) -> Dataset<'a> {\n        self.graph_type = graph_type;\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Dataset<'a> {\n        self.style = style;\n        self\n    }\n}","impl<'a> Default for Dataset<'a> {\n    fn default() -> Dataset<'a> {\n        Dataset {\n            name: Cow::from(\"\"),\n            data: &[],\n            marker: symbols::Marker::Dot,\n            graph_type: GraphType::Scatter,\n            style: Style::default(),\n        }\n    }\n}"],"widgets::chart::GraphType":["Clone","Copy","Debug"],"widgets::clear::Clear":["Clone","Debug","impl Widget for Clear {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        for x in area.left()..area.right() {\n            for y in area.top()..area.bottom() {\n                buf.get_mut(x, y).reset();\n            }\n        }\n    }\n}"],"widgets::gauge::Gauge":["Clone","Debug","impl<'a> Default for Gauge<'a> {\n    fn default() -> Gauge<'a> {\n        Gauge {\n            block: None,\n            ratio: 0.0,\n            label: None,\n            style: Style::default(),\n            gauge_style: Style::default(),\n        }\n    }\n}","impl<'a> Gauge<'a> {\n    pub fn block(mut self, block: Block<'a>) -> Gauge<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn percent(mut self, percent: u16) -> Gauge<'a> {\n        assert!(\n            percent <= 100,\n            \"Percentage should be between 0 and 100 inclusively.\"\n        );\n        self.ratio = f64::from(percent) / 100.0;\n        self\n    }\n\n    /// Sets ratio ([0.0, 1.0]) directly.\n    pub fn ratio(mut self, ratio: f64) -> Gauge<'a> {\n        assert!(\n            ratio <= 1.0 && ratio >= 0.0,\n            \"Ratio should be between 0 and 1 inclusively.\"\n        );\n        self.ratio = ratio;\n        self\n    }\n\n    pub fn label<T>(mut self, label: T) -> Gauge<'a>\n    where\n        T: Into<Span<'a>>,\n    {\n        self.label = Some(label.into());\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Gauge<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn gauge_style(mut self, style: Style) -> Gauge<'a> {\n        self.gauge_style = style;\n        self\n    }\n}","impl<'a> Widget for Gauge<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n        let gauge_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n        buf.set_style(gauge_area, self.gauge_style);\n        if gauge_area.height < 1 {\n            return;\n        }\n\n        let center = gauge_area.height / 2 + gauge_area.top();\n        let width = (f64::from(gauge_area.width) * self.ratio).round() as u16;\n        let end = gauge_area.left() + width;\n        // Label\n        let ratio = self.ratio;\n        let label = self\n            .label\n            .unwrap_or_else(|| Span::from(format!(\"{}%\", (ratio * 100.0).round())));\n        for y in gauge_area.top()..gauge_area.bottom() {\n            // Gauge\n            for x in gauge_area.left()..end {\n                buf.get_mut(x, y).set_symbol(\" \");\n            }\n\n            if y == center {\n                let label_width = label.width() as u16;\n                let middle = (gauge_area.width - label_width) / 2 + gauge_area.left();\n                buf.set_span(middle, y, &label, gauge_area.right() - middle);\n            }\n\n            // Fix colors\n            for x in gauge_area.left()..end {\n                buf.get_mut(x, y)\n                    .set_fg(self.gauge_style.bg.unwrap_or(Color::Reset))\n                    .set_bg(self.gauge_style.fg.unwrap_or(Color::Reset));\n            }\n        }\n    }\n}"],"widgets::gauge::LineGauge":["impl<'a> Default for LineGauge<'a> {\n    fn default() -> Self {\n        Self {\n            block: None,\n            ratio: 0.0,\n            label: None,\n            style: Style::default(),\n            line_set: symbols::line::NORMAL,\n            gauge_style: Style::default(),\n        }\n    }\n}","impl<'a> LineGauge<'a> {\n    pub fn block(mut self, block: Block<'a>) -> Self {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn ratio(mut self, ratio: f64) -> Self {\n        assert!(\n            ratio <= 1.0 && ratio >= 0.0,\n            \"Ratio should be between 0 and 1 inclusively.\"\n        );\n        self.ratio = ratio;\n        self\n    }\n\n    pub fn line_set(mut self, set: symbols::line::Set) -> Self {\n        self.line_set = set;\n        self\n    }\n\n    pub fn label<T>(mut self, label: T) -> Self\n    where\n        T: Into<Spans<'a>>,\n    {\n        self.label = Some(label.into());\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Self {\n        self.style = style;\n        self\n    }\n\n    pub fn gauge_style(mut self, style: Style) -> Self {\n        self.gauge_style = style;\n        self\n    }\n}","impl<'a> Widget for LineGauge<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n        let gauge_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if gauge_area.height < 1 {\n            return;\n        }\n\n        let ratio = self.ratio;\n        let label = self\n            .label\n            .unwrap_or_else(move || Spans::from(format!(\"{:.0}%\", ratio * 100.0)));\n        let (col, row) = buf.set_spans(\n            gauge_area.left(),\n            gauge_area.top(),\n            &label,\n            gauge_area.width,\n        );\n        let start = col + 1;\n        if start >= gauge_area.right() {\n            return;\n        }\n\n        let end = start\n            + (f64::from(gauge_area.right().saturating_sub(start)) * self.ratio).floor() as u16;\n        for col in start..end {\n            buf.get_mut(col, row)\n                .set_symbol(self.line_set.horizontal)\n                .set_style(Style {\n                    fg: self.gauge_style.fg,\n                    bg: None,\n                    add_modifier: self.gauge_style.add_modifier,\n                    sub_modifier: self.gauge_style.sub_modifier,\n                });\n        }\n        for col in end..gauge_area.right() {\n            buf.get_mut(col, row)\n                .set_symbol(self.line_set.horizontal)\n                .set_style(Style {\n                    fg: self.gauge_style.bg,\n                    bg: None,\n                    add_modifier: self.gauge_style.add_modifier,\n                    sub_modifier: self.gauge_style.sub_modifier,\n                });\n        }\n    }\n}"],"widgets::list::List":["Clone","Debug","impl<'a> List<'a> {\n    pub fn new<T>(items: T) -> List<'a>\n    where\n        T: Into<Vec<ListItem<'a>>>,\n    {\n        List {\n            block: None,\n            style: Style::default(),\n            items: items.into(),\n            start_corner: Corner::TopLeft,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n        }\n    }\n\n    pub fn block(mut self, block: Block<'a>) -> List<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> List<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn highlight_symbol(mut self, highlight_symbol: &'a str) -> List<'a> {\n        self.highlight_symbol = Some(highlight_symbol);\n        self\n    }\n\n    pub fn highlight_style(mut self, style: Style) -> List<'a> {\n        self.highlight_style = style;\n        self\n    }\n\n    pub fn start_corner(mut self, corner: Corner) -> List<'a> {\n        self.start_corner = corner;\n        self\n    }\n}","impl<'a> StatefulWidget for List<'a> {\n    type State = ListState;\n\n    fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        buf.set_style(area, self.style);\n        let list_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if list_area.width < 1 || list_area.height < 1 {\n            return;\n        }\n\n        if self.items.is_empty() {\n            return;\n        }\n        let list_height = list_area.height as usize;\n\n        let mut start = state.offset;\n        let mut end = state.offset;\n        let mut height = 0;\n        for item in self.items.iter().skip(state.offset) {\n            if height + item.height() > list_height {\n                break;\n            }\n            height += item.height();\n            end += 1;\n        }\n\n        let selected = state.selected.unwrap_or(0).min(self.items.len() - 1);\n        while selected >= end {\n            height = height.saturating_add(self.items[end].height());\n            end += 1;\n            while height > list_height {\n                height = height.saturating_sub(self.items[start].height());\n                start += 1;\n            }\n        }\n        while selected < start {\n            start -= 1;\n            height = height.saturating_add(self.items[start].height());\n            while height > list_height {\n                end -= 1;\n                height = height.saturating_sub(self.items[end].height());\n            }\n        }\n        state.offset = start;\n\n        let highlight_symbol = self.highlight_symbol.unwrap_or(\"\");\n        let blank_symbol = iter::repeat(\" \")\n            .take(highlight_symbol.width())\n            .collect::<String>();\n\n        let mut current_height = 0;\n        let has_selection = state.selected.is_some();\n        for (i, item) in self\n            .items\n            .iter_mut()\n            .enumerate()\n            .skip(state.offset)\n            .take(end - start)\n        {\n            let (x, y) = match self.start_corner {\n                Corner::BottomLeft => {\n                    current_height += item.height() as u16;\n                    (list_area.left(), list_area.bottom() - current_height)\n                }\n                _ => {\n                    let pos = (list_area.left(), list_area.top() + current_height);\n                    current_height += item.height() as u16;\n                    pos\n                }\n            };\n            let area = Rect {\n                x,\n                y,\n                width: list_area.width,\n                height: item.height() as u16,\n            };\n            let item_style = self.style.patch(item.style);\n            buf.set_style(area, item_style);\n\n            let is_selected = state.selected.map(|s| s == i).unwrap_or(false);\n            let elem_x = if has_selection {\n                let symbol = if is_selected {\n                    highlight_symbol\n                } else {\n                    &blank_symbol\n                };\n                let (x, _) = buf.set_stringn(x, y, symbol, list_area.width as usize, item_style);\n                x\n            } else {\n                x\n            };\n            let max_element_width = (list_area.width - (elem_x - x)) as usize;\n            for (j, line) in item.content.lines.iter().enumerate() {\n                buf.set_spans(elem_x, y + j as u16, line, max_element_width as u16);\n            }\n            if is_selected {\n                buf.set_style(area, self.highlight_style);\n            }\n        }\n    }\n}","impl<'a> Widget for List<'a> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        let mut state = ListState::default();\n        StatefulWidget::render(self, area, buf, &mut state);\n    }\n}"],"widgets::list::ListItem":["Clone","Debug","PartialEq","impl<'a> ListItem<'a> {\n    pub fn new<T>(content: T) -> ListItem<'a>\n    where\n        T: Into<Text<'a>>,\n    {\n        ListItem {\n            content: content.into(),\n            style: Style::default(),\n        }\n    }\n\n    pub fn style(mut self, style: Style) -> ListItem<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn height(&self) -> usize {\n        self.content.height()\n    }\n}"],"widgets::list::ListState":["Clone","Debug","impl Default for ListState {\n    fn default() -> ListState {\n        ListState {\n            offset: 0,\n            selected: None,\n        }\n    }\n}","impl ListState {\n    pub fn selected(&self) -> Option<usize> {\n        self.selected\n    }\n\n    pub fn select(&mut self, index: Option<usize>) {\n        self.selected = index;\n        if index.is_none() {\n            self.offset = 0;\n        }\n    }\n}"],"widgets::paragraph::Paragraph":["Clone","Debug","impl<'a> Paragraph<'a> {\n    pub fn new<T>(text: T) -> Paragraph<'a>\n    where\n        T: Into<Text<'a>>,\n    {\n        Paragraph {\n            block: None,\n            style: Default::default(),\n            wrap: None,\n            text: text.into(),\n            scroll: (0, 0),\n            alignment: Alignment::Left,\n        }\n    }\n\n    pub fn block(mut self, block: Block<'a>) -> Paragraph<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Paragraph<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn wrap(mut self, wrap: Wrap) -> Paragraph<'a> {\n        self.wrap = Some(wrap);\n        self\n    }\n\n    pub fn scroll(mut self, offset: (u16, u16)) -> Paragraph<'a> {\n        self.scroll = offset;\n        self\n    }\n\n    pub fn alignment(mut self, alignment: Alignment) -> Paragraph<'a> {\n        self.alignment = alignment;\n        self\n    }\n}","impl<'a> Widget for Paragraph<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n        let text_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if text_area.height < 1 {\n            return;\n        }\n\n        let style = self.style;\n        let mut styled = self.text.lines.iter().flat_map(|spans| {\n            spans\n                .0\n                .iter()\n                .flat_map(|span| span.styled_graphemes(style))\n                // Required given the way composers work but might be refactored out if we change\n                // composers to operate on lines instead of a stream of graphemes.\n                .chain(iter::once(StyledGrapheme {\n                    symbol: \"\\n\",\n                    style: self.style,\n                }))\n        });\n\n        let mut line_composer: Box<dyn LineComposer> = if let Some(Wrap { trim }) = self.wrap {\n            Box::new(WordWrapper::new(&mut styled, text_area.width, trim))\n        } else {\n            let mut line_composer = Box::new(LineTruncator::new(&mut styled, text_area.width));\n            if let Alignment::Left = self.alignment {\n                line_composer.set_horizontal_offset(self.scroll.1);\n            }\n            line_composer\n        };\n        let mut y = 0;\n        while let Some((current_line, current_line_width)) = line_composer.next_line() {\n            if y >= self.scroll.0 {\n                let mut x = get_line_offset(current_line_width, text_area.width, self.alignment);\n                for StyledGrapheme { symbol, style } in current_line {\n                    buf.get_mut(text_area.left() + x, text_area.top() + y - self.scroll.0)\n                        .set_symbol(if symbol.is_empty() {\n                            // If the symbol is empty, the last char which rendered last time will\n                            // leave on the line. It's a quick fix.\n                            \" \"\n                        } else {\n                            symbol\n                        })\n                        .set_style(*style);\n                    x += symbol.width() as u16;\n                }\n            }\n            y += 1;\n            if y >= text_area.height + self.scroll.0 {\n                break;\n            }\n        }\n    }\n}"],"widgets::paragraph::Wrap":["Clone","Copy","Debug"],"widgets::reflow::LineTruncator":["impl<'a, 'b> LineComposer<'a> for LineTruncator<'a, 'b> {\n    fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)> {\n        if self.max_line_width == 0 {\n            return None;\n        }\n\n        self.current_line.truncate(0);\n        let mut current_line_width = 0;\n\n        let mut skip_rest = false;\n        let mut symbols_exhausted = true;\n        let mut horizontal_offset = self.horizontal_offset as usize;\n        for StyledGrapheme { symbol, style } in &mut self.symbols {\n            symbols_exhausted = false;\n\n            // Ignore characters wider that the total max width.\n            if symbol.width() as u16 > self.max_line_width {\n                continue;\n            }\n\n            // Break on newline and discard it.\n            if symbol == \"\\n\" {\n                break;\n            }\n\n            if current_line_width + symbol.width() as u16 > self.max_line_width {\n                // Exhaust the remainder of the line.\n                skip_rest = true;\n                break;\n            }\n\n            let symbol = if horizontal_offset == 0 {\n                symbol\n            } else {\n                let w = symbol.width();\n                if w > horizontal_offset {\n                    let t = trim_offset(symbol, horizontal_offset);\n                    horizontal_offset = 0;\n                    t\n                } else {\n                    horizontal_offset -= w;\n                    \"\"\n                }\n            };\n            current_line_width += symbol.width() as u16;\n            self.current_line.push(StyledGrapheme { symbol, style });\n        }\n\n        if skip_rest {\n            for StyledGrapheme { symbol, .. } in &mut self.symbols {\n                if symbol == \"\\n\" {\n                    break;\n                }\n            }\n        }\n\n        if symbols_exhausted && self.current_line.is_empty() {\n            None\n        } else {\n            Some((&self.current_line[..], current_line_width))\n        }\n    }\n}","impl<'a, 'b> LineTruncator<'a, 'b> {\n    pub fn new(\n        symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n        max_line_width: u16,\n    ) -> LineTruncator<'a, 'b> {\n        LineTruncator {\n            symbols,\n            max_line_width,\n            horizontal_offset: 0,\n            current_line: vec![],\n        }\n    }\n\n    pub fn set_horizontal_offset(&mut self, horizontal_offset: u16) {\n        self.horizontal_offset = horizontal_offset;\n    }\n}"],"widgets::reflow::WordWrapper":["impl<'a, 'b> LineComposer<'a> for WordWrapper<'a, 'b> {\n    fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)> {\n        if self.max_line_width == 0 {\n            return None;\n        }\n        std::mem::swap(&mut self.current_line, &mut self.next_line);\n        self.next_line.truncate(0);\n\n        let mut current_line_width = self\n            .current_line\n            .iter()\n            .map(|StyledGrapheme { symbol, .. }| symbol.width() as u16)\n            .sum();\n\n        let mut symbols_to_last_word_end: usize = 0;\n        let mut width_to_last_word_end: u16 = 0;\n        let mut prev_whitespace = false;\n        let mut symbols_exhausted = true;\n        for StyledGrapheme { symbol, style } in &mut self.symbols {\n            symbols_exhausted = false;\n            let symbol_whitespace = symbol.chars().all(&char::is_whitespace);\n\n            // Ignore characters wider that the total max width.\n            if symbol.width() as u16 > self.max_line_width\n                // Skip leading whitespace when trim is enabled.\n                || self.trim && symbol_whitespace && symbol != \"\\n\" && current_line_width == 0\n            {\n                continue;\n            }\n\n            // Break on newline and discard it.\n            if symbol == \"\\n\" {\n                if prev_whitespace {\n                    current_line_width = width_to_last_word_end;\n                    self.current_line.truncate(symbols_to_last_word_end);\n                }\n                break;\n            }\n\n            // Mark the previous symbol as word end.\n            if symbol_whitespace && !prev_whitespace && symbol != NBSP {\n                symbols_to_last_word_end = self.current_line.len();\n                width_to_last_word_end = current_line_width;\n            }\n\n            self.current_line.push(StyledGrapheme { symbol, style });\n            current_line_width += symbol.width() as u16;\n\n            if current_line_width > self.max_line_width {\n                // If there was no word break in the text, wrap at the end of the line.\n                let (truncate_at, truncated_width) = if symbols_to_last_word_end != 0 {\n                    (symbols_to_last_word_end, width_to_last_word_end)\n                } else {\n                    (self.current_line.len() - 1, self.max_line_width)\n                };\n\n                // Push the remainder to the next line but strip leading whitespace:\n                {\n                    let remainder = &self.current_line[truncate_at..];\n                    if let Some(remainder_nonwhite) =\n                        remainder.iter().position(|StyledGrapheme { symbol, .. }| {\n                            !symbol.chars().all(&char::is_whitespace)\n                        })\n                    {\n                        self.next_line\n                            .extend_from_slice(&remainder[remainder_nonwhite..]);\n                    }\n                }\n                self.current_line.truncate(truncate_at);\n                current_line_width = truncated_width;\n                break;\n            }\n\n            prev_whitespace = symbol_whitespace;\n        }\n\n        // Even if the iterator is exhausted, pass the previous remainder.\n        if symbols_exhausted && self.current_line.is_empty() {\n            None\n        } else {\n            Some((&self.current_line[..], current_line_width))\n        }\n    }\n}","impl<'a, 'b> WordWrapper<'a, 'b> {\n    pub fn new(\n        symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n        max_line_width: u16,\n        trim: bool,\n    ) -> WordWrapper<'a, 'b> {\n        WordWrapper {\n            symbols,\n            max_line_width,\n            current_line: vec![],\n            next_line: vec![],\n            trim,\n        }\n    }\n}"],"widgets::sparkline::Sparkline":["Clone","Debug","impl<'a> Default for Sparkline<'a> {\n    fn default() -> Sparkline<'a> {\n        Sparkline {\n            block: None,\n            style: Default::default(),\n            data: &[],\n            max: None,\n            bar_set: symbols::bar::NINE_LEVELS,\n        }\n    }\n}","impl<'a> Sparkline<'a> {\n    pub fn block(mut self, block: Block<'a>) -> Sparkline<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Sparkline<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn data(mut self, data: &'a [u64]) -> Sparkline<'a> {\n        self.data = data;\n        self\n    }\n\n    pub fn max(mut self, max: u64) -> Sparkline<'a> {\n        self.max = Some(max);\n        self\n    }\n\n    pub fn bar_set(mut self, bar_set: symbols::bar::Set) -> Sparkline<'a> {\n        self.bar_set = bar_set;\n        self\n    }\n}","impl<'a> Widget for Sparkline<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        let spark_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if spark_area.height < 1 {\n            return;\n        }\n\n        let max = match self.max {\n            Some(v) => v,\n            None => *self.data.iter().max().unwrap_or(&1u64),\n        };\n        let max_index = min(spark_area.width as usize, self.data.len());\n        let mut data = self\n            .data\n            .iter()\n            .take(max_index)\n            .map(|e| {\n                if max != 0 {\n                    e * u64::from(spark_area.height) * 8 / max\n                } else {\n                    0\n                }\n            })\n            .collect::<Vec<u64>>();\n        for j in (0..spark_area.height).rev() {\n            for (i, d) in data.iter_mut().enumerate() {\n                let symbol = match *d {\n                    0 => self.bar_set.empty,\n                    1 => self.bar_set.one_eighth,\n                    2 => self.bar_set.one_quarter,\n                    3 => self.bar_set.three_eighths,\n                    4 => self.bar_set.half,\n                    5 => self.bar_set.five_eighths,\n                    6 => self.bar_set.three_quarters,\n                    7 => self.bar_set.seven_eighths,\n                    _ => self.bar_set.full,\n                };\n                buf.get_mut(spark_area.left() + i as u16, spark_area.top() + j)\n                    .set_symbol(symbol)\n                    .set_style(self.style);\n\n                if *d > 8 {\n                    *d -= 8;\n                } else {\n                    *d = 0;\n                }\n            }\n        }\n    }\n}"],"widgets::table::Row":["Clone","Debug"],"widgets::table::Table":["Clone","Debug","impl<'a, H, D, R> StatefulWidget for Table<'a, H, R>\nwhere\n    H: Iterator,\n    H::Item: Display,\n    D: Iterator,\n    D::Item: Display,\n    R: Iterator<Item = Row<D>>,\n{\n    type State = TableState;\n\n    fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        buf.set_style(area, self.style);\n\n        // Render block if necessary and get the drawing area\n        let table_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let mut solver = Solver::new();\n        let mut var_indices = HashMap::new();\n        let mut ccs = Vec::new();\n        let mut variables = Vec::new();\n        for i in 0..self.widths.len() {\n            let var = cassowary::Variable::new();\n            variables.push(var);\n            var_indices.insert(var, i);\n        }\n        for (i, constraint) in self.widths.iter().enumerate() {\n            ccs.push(variables[i] | GE(WEAK) | 0.);\n            ccs.push(match *constraint {\n                Constraint::Length(v) => variables[i] | EQ(MEDIUM) | f64::from(v),\n                Constraint::Percentage(v) => {\n                    variables[i] | EQ(WEAK) | (f64::from(v * table_area.width) / 100.0)\n                }\n                Constraint::Ratio(n, d) => {\n                    variables[i]\n                        | EQ(WEAK)\n                        | (f64::from(table_area.width) * f64::from(n) / f64::from(d))\n                }\n                Constraint::Min(v) => variables[i] | GE(WEAK) | f64::from(v),\n                Constraint::Max(v) => variables[i] | LE(WEAK) | f64::from(v),\n            })\n        }\n        solver\n            .add_constraint(\n                variables\n                    .iter()\n                    .fold(Expression::from_constant(0.), |acc, v| acc + *v)\n                    | LE(REQUIRED)\n                    | f64::from(\n                        area.width - 2 - (self.column_spacing * (variables.len() as u16 - 1)),\n                    ),\n            )\n            .unwrap();\n        solver.add_constraints(&ccs).unwrap();\n        let mut solved_widths = vec![0; variables.len()];\n        for &(var, value) in solver.fetch_changes() {\n            let index = var_indices[&var];\n            let value = if value.is_sign_negative() {\n                0\n            } else {\n                value.round() as u16\n            };\n            solved_widths[index] = value\n        }\n\n        let mut y = table_area.top();\n        let mut x = table_area.left();\n\n        // Draw header\n        if y < table_area.bottom() {\n            for (w, t) in solved_widths.iter().zip(self.header.by_ref()) {\n                buf.set_stringn(x, y, format!(\"{}\", t), *w as usize, self.header_style);\n                x += *w + self.column_spacing;\n            }\n        }\n        y += 1 + self.header_gap;\n\n        // Use highlight_style only if something is selected\n        let (selected, highlight_style) = match state.selected {\n            Some(i) => (Some(i), self.highlight_style),\n            None => (None, self.style),\n        };\n        let highlight_symbol = self.highlight_symbol.unwrap_or(\"\");\n        let blank_symbol = iter::repeat(\" \")\n            .take(highlight_symbol.width())\n            .collect::<String>();\n\n        // Draw rows\n        let default_style = Style::default();\n        if y < table_area.bottom() {\n            let remaining = (table_area.bottom() - y) as usize;\n\n            // Make sure the table shows the selected item\n            state.offset = if let Some(selected) = selected {\n                if selected >= remaining + state.offset - 1 {\n                    selected + 1 - remaining\n                } else if selected < state.offset {\n                    selected\n                } else {\n                    state.offset\n                }\n            } else {\n                0\n            };\n            for (i, row) in self.rows.skip(state.offset).take(remaining).enumerate() {\n                let (data, style, symbol) = match row {\n                    Row::Data(d) | Row::StyledData(d, _)\n                        if Some(i) == state.selected.map(|s| s - state.offset) =>\n                    {\n                        (d, highlight_style, highlight_symbol)\n                    }\n                    Row::Data(d) => (d, default_style, blank_symbol.as_ref()),\n                    Row::StyledData(d, s) => (d, s, blank_symbol.as_ref()),\n                };\n                x = table_area.left();\n                for (c, (w, elt)) in solved_widths.iter().zip(data).enumerate() {\n                    let s = if c == 0 {\n                        format!(\"{}{}\", symbol, elt)\n                    } else {\n                        format!(\"{}\", elt)\n                    };\n                    buf.set_stringn(x, y + i as u16, s, *w as usize, style);\n                    x += *w + self.column_spacing;\n                }\n            }\n        }\n    }\n}","impl<'a, H, D, R> Table<'a, H, R>\nwhere\n    H: Iterator,\n    D: Iterator,\n    D::Item: Display,\n    R: Iterator<Item = Row<D>>,\n{\n    pub fn new(header: H, rows: R) -> Table<'a, H, R> {\n        Table {\n            block: None,\n            style: Style::default(),\n            header,\n            header_style: Style::default(),\n            widths: &[],\n            column_spacing: 1,\n            header_gap: 1,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n            rows,\n        }\n    }\n    pub fn block(mut self, block: Block<'a>) -> Table<'a, H, R> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn header<II>(mut self, header: II) -> Table<'a, H, R>\n    where\n        II: IntoIterator<Item = H::Item, IntoIter = H>,\n    {\n        self.header = header.into_iter();\n        self\n    }\n\n    pub fn header_style(mut self, style: Style) -> Table<'a, H, R> {\n        self.header_style = style;\n        self\n    }\n\n    pub fn widths(mut self, widths: &'a [Constraint]) -> Table<'a, H, R> {\n        let between_0_and_100 = |&w| match w {\n            Constraint::Percentage(p) => p <= 100,\n            _ => true,\n        };\n        assert!(\n            widths.iter().all(between_0_and_100),\n            \"Percentages should be between 0 and 100 inclusively.\"\n        );\n        self.widths = widths;\n        self\n    }\n\n    pub fn rows<II>(mut self, rows: II) -> Table<'a, H, R>\n    where\n        II: IntoIterator<Item = Row<D>, IntoIter = R>,\n    {\n        self.rows = rows.into_iter();\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Table<'a, H, R> {\n        self.style = style;\n        self\n    }\n\n    pub fn highlight_symbol(mut self, highlight_symbol: &'a str) -> Table<'a, H, R> {\n        self.highlight_symbol = Some(highlight_symbol);\n        self\n    }\n\n    pub fn highlight_style(mut self, highlight_style: Style) -> Table<'a, H, R> {\n        self.highlight_style = highlight_style;\n        self\n    }\n\n    pub fn column_spacing(mut self, spacing: u16) -> Table<'a, H, R> {\n        self.column_spacing = spacing;\n        self\n    }\n\n    pub fn header_gap(mut self, gap: u16) -> Table<'a, H, R> {\n        self.header_gap = gap;\n        self\n    }\n}","impl<'a, H, D, R> Widget for Table<'a, H, R>\nwhere\n    H: Iterator,\n    H::Item: Display,\n    D: Iterator,\n    D::Item: Display,\n    R: Iterator<Item = Row<D>>,\n{\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        let mut state = TableState::default();\n        StatefulWidget::render(self, area, buf, &mut state);\n    }\n}","impl<'a, H, R> Default for Table<'a, H, R>\nwhere\n    H: Iterator + Default,\n    R: Iterator + Default,\n{\n    fn default() -> Table<'a, H, R> {\n        Table {\n            block: None,\n            style: Style::default(),\n            header: H::default(),\n            header_style: Style::default(),\n            widths: &[],\n            column_spacing: 1,\n            header_gap: 1,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n            rows: R::default(),\n        }\n    }\n}"],"widgets::table::TableState":["Clone","Debug","impl Default for TableState {\n    fn default() -> TableState {\n        TableState {\n            offset: 0,\n            selected: None,\n        }\n    }\n}","impl TableState {\n    pub fn selected(&self) -> Option<usize> {\n        self.selected\n    }\n\n    pub fn select(&mut self, index: Option<usize>) {\n        self.selected = index;\n        if index.is_none() {\n            self.offset = 0;\n        }\n    }\n}"],"widgets::tabs::Tabs":["Clone","Debug","impl<'a> Tabs<'a> {\n    pub fn new(titles: Vec<Spans<'a>>) -> Tabs<'a> {\n        Tabs {\n            block: None,\n            titles,\n            selected: 0,\n            style: Default::default(),\n            highlight_style: Default::default(),\n            divider: Span::raw(symbols::line::VERTICAL),\n        }\n    }\n\n    pub fn block(mut self, block: Block<'a>) -> Tabs<'a> {\n        self.block = Some(block);\n        self\n    }\n\n    pub fn select(mut self, selected: usize) -> Tabs<'a> {\n        self.selected = selected;\n        self\n    }\n\n    pub fn style(mut self, style: Style) -> Tabs<'a> {\n        self.style = style;\n        self\n    }\n\n    pub fn highlight_style(mut self, style: Style) -> Tabs<'a> {\n        self.highlight_style = style;\n        self\n    }\n\n    pub fn divider<T>(mut self, divider: T) -> Tabs<'a>\n    where\n        T: Into<Span<'a>>,\n    {\n        self.divider = divider.into();\n        self\n    }\n}","impl<'a> Widget for Tabs<'a> {\n    fn render(mut self, area: Rect, buf: &mut Buffer) {\n        buf.set_style(area, self.style);\n        let tabs_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if tabs_area.height < 1 {\n            return;\n        }\n\n        let mut x = tabs_area.left();\n        let titles_length = self.titles.len();\n        for (i, title) in self.titles.into_iter().enumerate() {\n            let last_title = titles_length - 1 == i;\n            x = x.saturating_add(1);\n            let remaining_width = tabs_area.right().saturating_sub(x);\n            if remaining_width == 0 {\n                break;\n            }\n            let pos = buf.set_spans(x, tabs_area.top(), &title, remaining_width);\n            if i == self.selected {\n                buf.set_style(\n                    Rect {\n                        x,\n                        y: tabs_area.top(),\n                        width: pos.0.saturating_sub(x),\n                        height: 1,\n                    },\n                    self.highlight_style,\n                );\n            }\n            x = pos.0.saturating_add(1);\n            let remaining_width = tabs_area.right().saturating_sub(x);\n            if remaining_width == 0 || last_title {\n                break;\n            }\n            let pos = buf.set_span(x, tabs_area.top(), &self.divider, remaining_width);\n            x = pos.0;\n        }\n    }\n}"]},"single_path_import":{"backend::termion::TermionBackend":"backend::TermionBackend","backend::test::TestBackend":"backend::TestBackend","terminal::Frame":"Frame","terminal::Terminal":"Terminal","terminal::TerminalOptions":"TerminalOptions","terminal::Viewport":"Viewport","widgets::barchart::BarChart":"widgets::BarChart","widgets::block::Block":"widgets::Block","widgets::block::BorderType":"widgets::BorderType","widgets::canvas::line::Line":"widgets::canvas::Line","widgets::canvas::map::Map":"widgets::canvas::Map","widgets::canvas::map::MapResolution":"widgets::canvas::MapResolution","widgets::canvas::points::Points":"widgets::canvas::Points","widgets::canvas::rectangle::Rectangle":"widgets::canvas::Rectangle","widgets::chart::Axis":"widgets::Axis","widgets::chart::Chart":"widgets::Chart","widgets::chart::Dataset":"widgets::Dataset","widgets::chart::GraphType":"widgets::GraphType","widgets::clear::Clear":"widgets::Clear","widgets::gauge::Gauge":"widgets::Gauge","widgets::gauge::LineGauge":"widgets::LineGauge","widgets::list::List":"widgets::List","widgets::list::ListItem":"widgets::ListItem","widgets::list::ListState":"widgets::ListState","widgets::paragraph::Paragraph":"widgets::Paragraph","widgets::paragraph::Wrap":"widgets::Wrap","widgets::sparkline::Sparkline":"widgets::Sparkline","widgets::table::Row":"widgets::Row","widgets::table::Table":"widgets::Table","widgets::table::TableState":"widgets::TableState","widgets::tabs::Tabs":"widgets::Tabs"},"srcs":{"<backend::termion::Bg as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use termion::color::Color as TermionColor;\n        match self.0 {\n            Color::Reset => termion::color::Reset.write_bg(f),\n            Color::Black => termion::color::Black.write_bg(f),\n            Color::Red => termion::color::Red.write_bg(f),\n            Color::Green => termion::color::Green.write_bg(f),\n            Color::Yellow => termion::color::Yellow.write_bg(f),\n            Color::Blue => termion::color::Blue.write_bg(f),\n            Color::Magenta => termion::color::Magenta.write_bg(f),\n            Color::Cyan => termion::color::Cyan.write_bg(f),\n            Color::Gray => termion::color::White.write_bg(f),\n            Color::DarkGray => termion::color::LightBlack.write_bg(f),\n            Color::LightRed => termion::color::LightRed.write_bg(f),\n            Color::LightGreen => termion::color::LightGreen.write_bg(f),\n            Color::LightBlue => termion::color::LightBlue.write_bg(f),\n            Color::LightYellow => termion::color::LightYellow.write_bg(f),\n            Color::LightMagenta => termion::color::LightMagenta.write_bg(f),\n            Color::LightCyan => termion::color::LightCyan.write_bg(f),\n            Color::White => termion::color::LightWhite.write_bg(f),\n            Color::Indexed(i) => termion::color::AnsiValue(i).write_bg(f),\n            Color::Rgb(r, g, b) => termion::color::Rgb(r, g, b).write_bg(f),\n        }\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::Fg as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use termion::color::Color as TermionColor;\n        match self.0 {\n            Color::Reset => termion::color::Reset.write_fg(f),\n            Color::Black => termion::color::Black.write_fg(f),\n            Color::Red => termion::color::Red.write_fg(f),\n            Color::Green => termion::color::Green.write_fg(f),\n            Color::Yellow => termion::color::Yellow.write_fg(f),\n            Color::Blue => termion::color::Blue.write_fg(f),\n            Color::Magenta => termion::color::Magenta.write_fg(f),\n            Color::Cyan => termion::color::Cyan.write_fg(f),\n            Color::Gray => termion::color::White.write_fg(f),\n            Color::DarkGray => termion::color::LightBlack.write_fg(f),\n            Color::LightRed => termion::color::LightRed.write_fg(f),\n            Color::LightGreen => termion::color::LightGreen.write_fg(f),\n            Color::LightBlue => termion::color::LightBlue.write_fg(f),\n            Color::LightYellow => termion::color::LightYellow.write_fg(f),\n            Color::LightMagenta => termion::color::LightMagenta.write_fg(f),\n            Color::LightCyan => termion::color::LightCyan.write_fg(f),\n            Color::White => termion::color::LightWhite.write_fg(f),\n            Color::Indexed(i) => termion::color::AnsiValue(i).write_fg(f),\n            Color::Rgb(r, g, b) => termion::color::Rgb(r, g, b).write_fg(f),\n        }\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::ModifierDiff as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let remove = self.from - self.to;\n        if remove.contains(Modifier::REVERSED) {\n            write!(f, \"{}\", termion::style::NoInvert)?;\n        }\n        if remove.contains(Modifier::BOLD) {\n            // XXX: the termion NoBold flag actually enables double-underline on ECMA-48 compliant\n            // terminals, and NoFaint additionally disables bold... so we use this trick to get\n            // the right semantics.\n            write!(f, \"{}\", termion::style::NoFaint)?;\n\n            if self.to.contains(Modifier::DIM) {\n                write!(f, \"{}\", termion::style::Faint)?;\n            }\n        }\n        if remove.contains(Modifier::ITALIC) {\n            write!(f, \"{}\", termion::style::NoItalic)?;\n        }\n        if remove.contains(Modifier::UNDERLINED) {\n            write!(f, \"{}\", termion::style::NoUnderline)?;\n        }\n        if remove.contains(Modifier::DIM) {\n            write!(f, \"{}\", termion::style::NoFaint)?;\n\n            // XXX: the NoFaint flag additionally disables bold as well, so we need to re-enable it\n            // here if we want it.\n            if self.to.contains(Modifier::BOLD) {\n                write!(f, \"{}\", termion::style::Bold)?;\n            }\n        }\n        if remove.contains(Modifier::CROSSED_OUT) {\n            write!(f, \"{}\", termion::style::NoCrossedOut)?;\n        }\n        if remove.contains(Modifier::SLOW_BLINK) || remove.contains(Modifier::RAPID_BLINK) {\n            write!(f, \"{}\", termion::style::NoBlink)?;\n        }\n\n        let add = self.to - self.from;\n        if add.contains(Modifier::REVERSED) {\n            write!(f, \"{}\", termion::style::Invert)?;\n        }\n        if add.contains(Modifier::BOLD) {\n            write!(f, \"{}\", termion::style::Bold)?;\n        }\n        if add.contains(Modifier::ITALIC) {\n            write!(f, \"{}\", termion::style::Italic)?;\n        }\n        if add.contains(Modifier::UNDERLINED) {\n            write!(f, \"{}\", termion::style::Underline)?;\n        }\n        if add.contains(Modifier::DIM) {\n            write!(f, \"{}\", termion::style::Faint)?;\n        }\n        if add.contains(Modifier::CROSSED_OUT) {\n            write!(f, \"{}\", termion::style::CrossedOut)?;\n        }\n        if add.contains(Modifier::SLOW_BLINK) || add.contains(Modifier::RAPID_BLINK) {\n            write!(f, \"{}\", termion::style::Blink)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::clear":["/// Clears the entire screen and move the cursor to the top left of the screen\nfn clear(&mut self) -> io::Result<()>{\n        write!(self.stdout, \"{}\", termion::clear::All)?;\n        write!(self.stdout, \"{}\", termion::cursor::Goto(1, 1))?;\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::draw":["fn draw<'a, I>(&mut self, content: I) -> io::Result<()>\n    where\n        I: Iterator<Item = (u16, u16, &'a Cell)>,{\n        use std::fmt::Write;\n\n        let mut string = String::with_capacity(content.size_hint().0 * 3);\n        let mut fg = Color::Reset;\n        let mut bg = Color::Reset;\n        let mut modifier = Modifier::empty();\n        let mut last_pos: Option<(u16, u16)> = None;\n        for (x, y, cell) in content {\n            // Move the cursor if the previous location was not (x - 1, y)\n            if !matches!(last_pos, Some(p) if x == p.0 + 1 && y == p.1) {\n                write!(string, \"{}\", termion::cursor::Goto(x + 1, y + 1)).unwrap();\n            }\n            last_pos = Some((x, y));\n            if cell.modifier != modifier {\n                write!(\n                    string,\n                    \"{}\",\n                    ModifierDiff {\n                        from: modifier,\n                        to: cell.modifier\n                    }\n                )\n                .unwrap();\n                modifier = cell.modifier;\n            }\n            if cell.fg != fg {\n                write!(string, \"{}\", Fg(cell.fg)).unwrap();\n                fg = cell.fg;\n            }\n            if cell.bg != bg {\n                write!(string, \"{}\", Bg(cell.bg)).unwrap();\n                bg = cell.bg;\n            }\n            string.push_str(&cell.symbol);\n        }\n        write!(\n            self.stdout,\n            \"{}{}{}{}\",\n            string,\n            Fg(Color::Reset),\n            Bg(Color::Reset),\n            termion::style::Reset,\n        )\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::get_cursor":["/// Gets cursor position (0-based index)\nfn get_cursor(&mut self) -> io::Result<(u16, u16)>{\n        termion::cursor::DetectCursorPos::cursor_pos(&mut self.stdout).map(|(x, y)| (x - 1, y - 1))\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::hide_cursor":["/// Hides cursor\nfn hide_cursor(&mut self) -> io::Result<()>{\n        write!(self.stdout, \"{}\", termion::cursor::Hide)?;\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::set_cursor":["/// Sets cursor position (0-based index)\nfn set_cursor(&mut self, x: u16, y: u16) -> io::Result<()>{\n        write!(self.stdout, \"{}\", termion::cursor::Goto(x + 1, y + 1))?;\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::show_cursor":["/// Shows cursor\nfn show_cursor(&mut self) -> io::Result<()>{\n        write!(self.stdout, \"{}\", termion::cursor::Show)?;\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as backend::Backend>::size":["/// Return the size of the terminal\nfn size(&self) -> io::Result<Rect>{\n        let terminal = termion::terminal_size()?;\n        Ok(Rect::new(0, 0, terminal.0, terminal.1))\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.stdout.flush()\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::termion::TermionBackend<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.stdout.write(buf)\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"<backend::test::TestBackend as backend::Backend>::clear":["fn clear(&mut self) -> Result<(), io::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::draw":["fn draw<'a, I>(&mut self, content: I) -> Result<(), io::Error>\n    where\n        I: Iterator<Item = (u16, u16, &'a Cell)>,{\n        for (x, y, c) in content {\n            let cell = self.buffer.get_mut(x, y);\n            *cell = c.clone();\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::flush":["fn flush(&mut self) -> Result<(), io::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::get_cursor":["fn get_cursor(&mut self) -> Result<(u16, u16), io::Error>{\n        Ok(self.pos)\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::hide_cursor":["fn hide_cursor(&mut self) -> Result<(), io::Error>{\n        self.cursor = false;\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::set_cursor":["fn set_cursor(&mut self, x: u16, y: u16) -> Result<(), io::Error>{\n        self.pos = (x, y);\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::show_cursor":["fn show_cursor(&mut self) -> Result<(), io::Error>{\n        self.cursor = true;\n        Ok(())\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<backend::test::TestBackend as backend::Backend>::size":["fn size(&self) -> Result<Rect, io::Error>{\n        Ok(Rect::new(0, 0, self.width, self.height))\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"<buffer::Buffer as std::default::Default>::default":["fn default() -> Buffer{\n        Buffer {\n            area: Default::default(),\n            content: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"<buffer::Cell as std::default::Default>::default":["fn default() -> Cell{\n        Cell {\n            symbol: \" \".into(),\n            fg: Color::Reset,\n            bg: Color::Reset,\n            modifier: Modifier::empty(),\n        }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"<layout::Layout as std::default::Default>::default":["fn default() -> Layout{\n        Layout {\n            direction: Direction::Vertical,\n            margin: Margin {\n                horizontal: 0,\n                vertical: 0,\n            },\n            constraints: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"<layout::Rect as std::default::Default>::default":["fn default() -> Rect{\n        Rect {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::BOLD":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::CROSSED_OUT":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::DIM":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::ITALIC":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::RAPID_BLINK":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::REVERSED":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::SLOW_BLINK":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::UNDERLINED":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Binary>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::BOLD":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::CROSSED_OUT":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::DIM":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::ITALIC":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::RAPID_BLINK":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::REVERSED":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::SLOW_BLINK":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::UNDERLINED":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::Octal>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::iter::Extend<style::Modifier>>::extend":["fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T){\n                for item in iterator {\n                    self.insert(item)\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::iter::FromIterator<style::Modifier>>::from_iter":["fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self{\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitAnd>::bitand":["/// Returns the intersection between the two sets of flags.\n#[inline]\nfn bitand(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitAndAssign>::bitand_assign":["/// Disables all flags disabled in the set.\n#[inline]\nfn bitand_assign(&mut self, other: Self){\n                self.bits &= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitOr>::bitor":["/// Returns the union of the two sets of flags.\n#[inline]\nfn bitor(self, other: $BitFlags) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitOrAssign>::bitor_assign":["/// Adds the set of flags.\n#[inline]\nfn bitor_assign(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitXor>::bitxor":["/// Returns the left flags, but with all the right flags toggled.\n#[inline]\nfn bitxor(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::BitXorAssign>::bitxor_assign":["/// Toggles the set of flags.\n#[inline]\nfn bitxor_assign(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::Not>::not":["/// Returns the complement of this set of flags.\n#[inline]\nfn not(self) -> Self{\n                Self { bits: !self.bits } & Self::all()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::Sub>::sub":["/// Returns the set difference of the two sets of flags.\n#[inline]\nfn sub(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Modifier as std::ops::SubAssign>::sub_assign":["/// Disables all flags enabled in the set.\n#[inline]\nfn sub_assign(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<style::Style as std::default::Default>::default":["fn default() -> Style{\n        Style {\n            fg: None,\n            bg: None,\n            add_modifier: Modifier::empty(),\n            sub_modifier: Modifier::empty(),\n        }\n    }","Real(LocalPath(\"src/style.rs\"))"],"<terminal::Terminal<B> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Attempt to restore the cursor state\n        if self.hidden_cursor {\n            if let Err(err) = self.show_cursor() {\n                eprintln!(\"Failed to show the cursor: {}\", err);\n            }\n        }\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"<text::Span<'a> as std::convert::From<&'a str>>::from":["fn from(s: &'a str) -> Span<'a>{\n        Span::raw(s)\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Span<'a> as std::convert::From<std::string::String>>::from":["fn from(s: String) -> Span<'a>{\n        Span::raw(s)\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Spans<'a> as std::convert::From<&'a str>>::from":["fn from(s: &'a str) -> Spans<'a>{\n        Spans(vec![Span::from(s)])\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Spans<'a> as std::convert::From<std::string::String>>::from":["fn from(s: String) -> Spans<'a>{\n        Spans(vec![Span::from(s)])\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Spans<'a> as std::convert::From<std::vec::Vec<text::Span<'a>>>>::from":["fn from(spans: Vec<Span<'a>>) -> Spans<'a>{\n        Spans(spans)\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Spans<'a> as std::convert::From<text::Span<'a>>>::from":["fn from(span: Span<'a>) -> Spans<'a>{\n        Spans(vec![span])\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Spans<'a> as std::default::Default>::default":["fn default() -> Spans<'a>{\n        Spans(Vec::new())\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::convert::From<&'a str>>::from":["fn from(s: &'a str) -> Text<'a>{\n        Text::raw(s)\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::convert::From<std::string::String>>::from":["fn from(s: String) -> Text<'a>{\n        Text::raw(s)\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::convert::From<std::vec::Vec<text::Spans<'a>>>>::from":["fn from(lines: Vec<Spans<'a>>) -> Text<'a>{\n        Text { lines }\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::convert::From<text::Span<'a>>>::from":["fn from(span: Span<'a>) -> Text<'a>{\n        Text {\n            lines: vec![Spans::from(span)],\n        }\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::convert::From<text::Spans<'a>>>::from":["fn from(spans: Spans<'a>) -> Text<'a>{\n        Text { lines: vec![spans] }\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::default::Default>::default":["fn default() -> Text<'a>{\n        Text { lines: Vec::new() }\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::iter::Extend<text::Spans<'a>>>::extend":["fn extend<T: IntoIterator<Item = Spans<'a>>>(&mut self, iter: T){\n        self.lines.extend(iter);\n    }","Real(LocalPath(\"src/text.rs\"))"],"<text::Text<'a> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.lines.into_iter()\n    }","Real(LocalPath(\"src/text.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::ALL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::BOTTOM":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::LEFT":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::NONE":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::RIGHT":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::TOP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Binary>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::ALL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::BOTTOM":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::LEFT":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::NONE":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::RIGHT":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::TOP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::Octal>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::iter::Extend<widgets::Borders>>::extend":["fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T){\n                for item in iterator {\n                    self.insert(item)\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::iter::FromIterator<widgets::Borders>>::from_iter":["fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self{\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitAnd>::bitand":["/// Returns the intersection between the two sets of flags.\n#[inline]\nfn bitand(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitAndAssign>::bitand_assign":["/// Disables all flags disabled in the set.\n#[inline]\nfn bitand_assign(&mut self, other: Self){\n                self.bits &= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitOr>::bitor":["/// Returns the union of the two sets of flags.\n#[inline]\nfn bitor(self, other: $BitFlags) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitOrAssign>::bitor_assign":["/// Adds the set of flags.\n#[inline]\nfn bitor_assign(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitXor>::bitxor":["/// Returns the left flags, but with all the right flags toggled.\n#[inline]\nfn bitxor(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::BitXorAssign>::bitxor_assign":["/// Toggles the set of flags.\n#[inline]\nfn bitxor_assign(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::Not>::not":["/// Returns the complement of this set of flags.\n#[inline]\nfn not(self) -> Self{\n                Self { bits: !self.bits } & Self::all()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::Sub>::sub":["/// Returns the set difference of the two sets of flags.\n#[inline]\nfn sub(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::Borders as std::ops::SubAssign>::sub_assign":["/// Disables all flags enabled in the set.\n#[inline]\nfn sub_assign(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<widgets::barchart::BarChart<'a> as std::default::Default>::default":["fn default() -> BarChart<'a>{\n        BarChart {\n            block: None,\n            max: None,\n            data: &[],\n            values: Vec::new(),\n            bar_style: Style::default(),\n            bar_width: 1,\n            bar_gap: 1,\n            bar_set: symbols::bar::NINE_LEVELS,\n            value_style: Default::default(),\n            label_style: Default::default(),\n            style: Default::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"<widgets::barchart::BarChart<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n\n        let chart_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if chart_area.height < 2 {\n            return;\n        }\n\n        let max = self\n            .max\n            .unwrap_or_else(|| self.data.iter().map(|t| t.1).max().unwrap_or_default());\n        let max_index = min(\n            (chart_area.width / (self.bar_width + self.bar_gap)) as usize,\n            self.data.len(),\n        );\n        let mut data = self\n            .data\n            .iter()\n            .take(max_index)\n            .map(|&(l, v)| {\n                (\n                    l,\n                    v * u64::from(chart_area.height - 1) * 8 / std::cmp::max(max, 1),\n                )\n            })\n            .collect::<Vec<(&str, u64)>>();\n        for j in (0..chart_area.height - 1).rev() {\n            for (i, d) in data.iter_mut().enumerate() {\n                let symbol = match d.1 {\n                    0 => self.bar_set.empty,\n                    1 => self.bar_set.one_eighth,\n                    2 => self.bar_set.one_quarter,\n                    3 => self.bar_set.three_eighths,\n                    4 => self.bar_set.half,\n                    5 => self.bar_set.five_eighths,\n                    6 => self.bar_set.three_quarters,\n                    7 => self.bar_set.seven_eighths,\n                    _ => self.bar_set.full,\n                };\n\n                for x in 0..self.bar_width {\n                    buf.get_mut(\n                        chart_area.left() + i as u16 * (self.bar_width + self.bar_gap) + x,\n                        chart_area.top() + j,\n                    )\n                    .set_symbol(symbol)\n                    .set_style(self.bar_style);\n                }\n\n                if d.1 > 8 {\n                    d.1 -= 8;\n                } else {\n                    d.1 = 0;\n                }\n            }\n        }\n\n        for (i, &(label, value)) in self.data.iter().take(max_index).enumerate() {\n            if value != 0 {\n                let value_label = &self.values[i];\n                let width = value_label.width() as u16;\n                if width < self.bar_width {\n                    buf.set_string(\n                        chart_area.left()\n                            + i as u16 * (self.bar_width + self.bar_gap)\n                            + (self.bar_width - width) / 2,\n                        chart_area.bottom() - 2,\n                        value_label,\n                        self.value_style,\n                    );\n                }\n            }\n            buf.set_stringn(\n                chart_area.left() + i as u16 * (self.bar_width + self.bar_gap),\n                chart_area.bottom() - 1,\n                label,\n                self.bar_width as usize,\n                self.label_style,\n            );\n        }\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"<widgets::block::Block<'a> as std::default::Default>::default":["fn default() -> Block<'a>{\n        Block {\n            title: None,\n            borders: Borders::NONE,\n            border_style: Default::default(),\n            border_type: BorderType::Plain,\n            style: Default::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"<widgets::block::Block<'a> as widgets::Widget>::render":["fn render(self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n\n        if area.width < 2 || area.height < 2 {\n            return;\n        }\n\n        let symbols = BorderType::line_symbols(self.border_type);\n        // Sides\n        if self.borders.intersects(Borders::LEFT) {\n            for y in area.top()..area.bottom() {\n                buf.get_mut(area.left(), y)\n                    .set_symbol(symbols.vertical)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::TOP) {\n            for x in area.left()..area.right() {\n                buf.get_mut(x, area.top())\n                    .set_symbol(symbols.horizontal)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::RIGHT) {\n            let x = area.right() - 1;\n            for y in area.top()..area.bottom() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols.vertical)\n                    .set_style(self.border_style);\n            }\n        }\n        if self.borders.intersects(Borders::BOTTOM) {\n            let y = area.bottom() - 1;\n            for x in area.left()..area.right() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols.horizontal)\n                    .set_style(self.border_style);\n            }\n        }\n\n        // Corners\n        if self.borders.contains(Borders::LEFT | Borders::TOP) {\n            buf.get_mut(area.left(), area.top())\n                .set_symbol(symbols.top_left)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::RIGHT | Borders::TOP) {\n            buf.get_mut(area.right() - 1, area.top())\n                .set_symbol(symbols.top_right)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::LEFT | Borders::BOTTOM) {\n            buf.get_mut(area.left(), area.bottom() - 1)\n                .set_symbol(symbols.bottom_left)\n                .set_style(self.border_style);\n        }\n        if self.borders.contains(Borders::RIGHT | Borders::BOTTOM) {\n            buf.get_mut(area.right() - 1, area.bottom() - 1)\n                .set_symbol(symbols.bottom_right)\n                .set_style(self.border_style);\n        }\n\n        if let Some(title) = self.title {\n            let lx = if self.borders.intersects(Borders::LEFT) {\n                1\n            } else {\n                0\n            };\n            let rx = if self.borders.intersects(Borders::RIGHT) {\n                1\n            } else {\n                0\n            };\n            let width = area.width - lx - rx;\n            buf.set_spans(area.left() + lx, area.top(), &title, width);\n        }\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::height":["fn height(&self) -> u16{\n        self.height\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::paint":["fn paint(&mut self, x: usize, y: usize, color: Color){\n        let index = y / 4 * self.width as usize + x / 2;\n        if let Some(c) = self.cells.get_mut(index) {\n            *c |= symbols::braille::DOTS[y % 4][x % 2];\n        }\n        if let Some(c) = self.colors.get_mut(index) {\n            *c = color;\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::reset":["fn reset(&mut self){\n        for c in &mut self.cells {\n            *c = symbols::braille::BLANK;\n        }\n        for c in &mut self.colors {\n            *c = Color::Reset;\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::resolution":["fn resolution(&self) -> (f64, f64){\n        (\n            f64::from(self.width) * 2.0 - 1.0,\n            f64::from(self.height) * 4.0 - 1.0,\n        )\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::save":["fn save(&self) -> Layer{\n        Layer {\n            string: String::from_utf16(&self.cells).unwrap(),\n            colors: self.colors.clone(),\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::width":["fn width(&self) -> u16{\n        self.width\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::Canvas<'a, F> as std::default::Default>::default":["fn default() -> Canvas<'a, F>{\n        Canvas {\n            block: None,\n            x_bounds: [0.0, 0.0],\n            y_bounds: [0.0, 0.0],\n            painter: None,\n            background_color: Color::Reset,\n            marker: symbols::Marker::Braille,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::Canvas<'a, F> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        let canvas_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let width = canvas_area.width as usize;\n\n        let painter = match self.painter {\n            Some(ref p) => p,\n            None => return,\n        };\n\n        // Create a blank context that match the size of the canvas\n        let mut ctx = Context::new(\n            canvas_area.width,\n            canvas_area.height,\n            self.x_bounds,\n            self.y_bounds,\n            self.marker,\n        );\n        // Paint to this context\n        painter(&mut ctx);\n        ctx.finish();\n\n        // Retreive painted points for each layer\n        for layer in ctx.layers {\n            for (i, (ch, color)) in layer\n                .string\n                .chars()\n                .zip(layer.colors.into_iter())\n                .enumerate()\n            {\n                if ch != ' ' && ch != '\\u{2800}' {\n                    let (x, y) = (i % width, i / width);\n                    buf.get_mut(x as u16 + canvas_area.left(), y as u16 + canvas_area.top())\n                        .set_char(ch)\n                        .set_fg(color)\n                        .set_bg(self.background_color);\n                }\n            }\n        }\n\n        // Finally draw the labels\n        let style = Style::default().bg(self.background_color);\n        let left = self.x_bounds[0];\n        let right = self.x_bounds[1];\n        let top = self.y_bounds[1];\n        let bottom = self.y_bounds[0];\n        let width = (self.x_bounds[1] - self.x_bounds[0]).abs();\n        let height = (self.y_bounds[1] - self.y_bounds[0]).abs();\n        let resolution = {\n            let width = f64::from(canvas_area.width - 1);\n            let height = f64::from(canvas_area.height - 1);\n            (width, height)\n        };\n        for label in ctx\n            .labels\n            .iter()\n            .filter(|l| l.x >= left && l.x <= right && l.y <= top && l.y >= bottom)\n        {\n            let x = ((label.x - left) * resolution.0 / width) as u16 + canvas_area.left();\n            let y = ((top - label.y) * resolution.1 / height) as u16 + canvas_area.top();\n            buf.set_stringn(\n                x,\n                y,\n                label.text,\n                (canvas_area.right() - x) as usize,\n                style.fg(label.color),\n            );\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::height":["fn height(&self) -> u16{\n        self.height\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::paint":["fn paint(&mut self, x: usize, y: usize, color: Color){\n        let index = y * self.width as usize + x;\n        if let Some(c) = self.cells.get_mut(index) {\n            *c = self.cell_char;\n        }\n        if let Some(c) = self.colors.get_mut(index) {\n            *c = color;\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::reset":["fn reset(&mut self){\n        for c in &mut self.cells {\n            *c = ' ';\n        }\n        for c in &mut self.colors {\n            *c = Color::Reset;\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::resolution":["fn resolution(&self) -> (f64, f64){\n        (f64::from(self.width) - 1.0, f64::from(self.height) - 1.0)\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::save":["fn save(&self) -> Layer{\n        Layer {\n            string: self.cells.iter().collect(),\n            colors: self.colors.clone(),\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::width":["fn width(&self) -> u16{\n        self.width\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::Painter<'a, 'b> as std::convert::From<&'a mut widgets::canvas::Context<'b>>>::from":["fn from(context: &'a mut Context<'b>) -> Painter<'a, 'b>{\n        let resolution = context.grid.resolution();\n        Painter {\n            context,\n            resolution,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"<widgets::canvas::line::Line as widgets::canvas::Shape>::draw":["fn draw(&self, painter: &mut Painter){\n        let (x1, y1) = match painter.get_point(self.x1, self.y1) {\n            Some(c) => c,\n            None => return,\n        };\n        let (x2, y2) = match painter.get_point(self.x2, self.y2) {\n            Some(c) => c,\n            None => return,\n        };\n        let (dx, x_range) = if x2 >= x1 {\n            (x2 - x1, x1..=x2)\n        } else {\n            (x1 - x2, x2..=x1)\n        };\n        let (dy, y_range) = if y2 >= y1 {\n            (y2 - y1, y1..=y2)\n        } else {\n            (y1 - y2, y2..=y1)\n        };\n\n        if dx == 0 {\n            for y in y_range {\n                painter.paint(x1, y, self.color);\n            }\n        } else if dy == 0 {\n            for x in x_range {\n                painter.paint(x, y1, self.color);\n            }\n        } else if dy < dx {\n            if x1 > x2 {\n                draw_line_low(painter, x2, y2, x1, y1, self.color);\n            } else {\n                draw_line_low(painter, x1, y1, x2, y2, self.color);\n            }\n        } else if y1 > y2 {\n            draw_line_high(painter, x2, y2, x1, y1, self.color);\n        } else {\n            draw_line_high(painter, x1, y1, x2, y2, self.color);\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/line.rs\"))"],"<widgets::canvas::map::Map as std::default::Default>::default":["fn default() -> Map{\n        Map {\n            resolution: MapResolution::Low,\n            color: Color::Reset,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/map.rs\"))"],"<widgets::canvas::map::Map as widgets::canvas::Shape>::draw":["fn draw(&self, painter: &mut Painter){\n        for (x, y) in self.resolution.data() {\n            if let Some((x, y)) = painter.get_point(*x, *y) {\n                painter.paint(x, y, self.color);\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/map.rs\"))"],"<widgets::canvas::points::Points<'a> as std::default::Default>::default":["fn default() -> Points<'a>{\n        Points {\n            coords: &[],\n            color: Color::Reset,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/points.rs\"))"],"<widgets::canvas::points::Points<'a> as widgets::canvas::Shape>::draw":["fn draw(&self, painter: &mut Painter){\n        for (x, y) in self.coords {\n            if let Some((x, y)) = painter.get_point(*x, *y) {\n                painter.paint(x, y, self.color);\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/points.rs\"))"],"<widgets::canvas::rectangle::Rectangle as widgets::canvas::Shape>::draw":["fn draw(&self, painter: &mut Painter){\n        let lines: [Line; 4] = [\n            Line {\n                x1: self.x,\n                y1: self.y,\n                x2: self.x,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x,\n                y1: self.y + self.height,\n                x2: self.x + self.width,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x + self.width,\n                y1: self.y,\n                x2: self.x + self.width,\n                y2: self.y + self.height,\n                color: self.color,\n            },\n            Line {\n                x1: self.x,\n                y1: self.y,\n                x2: self.x + self.width,\n                y2: self.y,\n                color: self.color,\n            },\n        ];\n        for line in &lines {\n            line.draw(painter);\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/rectangle.rs\"))"],"<widgets::chart::Axis<'a> as std::default::Default>::default":["fn default() -> Axis<'a>{\n        Axis {\n            title: None,\n            bounds: [0.0, 0.0],\n            labels: None,\n            style: Default::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"<widgets::chart::Chart<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n        // Sample the style of the entire widget. This sample will be used to reset the style of\n        // the cells that are part of the components put on top of the grah area (i.e legend and\n        // axis names).\n        let original_style = buf.get(area.left(), area.top()).style();\n\n        let chart_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let layout = self.layout(chart_area);\n        let graph_area = layout.graph_area;\n        if graph_area.width < 1 || graph_area.height < 1 {\n            return;\n        }\n\n        if let Some(y) = layout.label_x {\n            let labels = self.x_axis.labels.unwrap();\n            let total_width = labels.iter().map(Span::width).sum::<usize>() as u16;\n            let labels_len = labels.len() as u16;\n            if total_width < graph_area.width && labels_len > 1 {\n                for (i, label) in labels.iter().enumerate() {\n                    buf.set_span(\n                        graph_area.left() + i as u16 * (graph_area.width - 1) / (labels_len - 1)\n                            - label.content.width() as u16,\n                        y,\n                        label,\n                        label.width() as u16,\n                    );\n                }\n            }\n        }\n\n        if let Some(x) = layout.label_y {\n            let labels = self.y_axis.labels.unwrap();\n            let labels_len = labels.len() as u16;\n            for (i, label) in labels.iter().enumerate() {\n                let dy = i as u16 * (graph_area.height - 1) / (labels_len - 1);\n                if dy < graph_area.bottom() {\n                    buf.set_span(x, graph_area.bottom() - 1 - dy, label, label.width() as u16);\n                }\n            }\n        }\n\n        if let Some(y) = layout.axis_x {\n            for x in graph_area.left()..graph_area.right() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::HORIZONTAL)\n                    .set_style(self.x_axis.style);\n            }\n        }\n\n        if let Some(x) = layout.axis_y {\n            for y in graph_area.top()..graph_area.bottom() {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::VERTICAL)\n                    .set_style(self.y_axis.style);\n            }\n        }\n\n        if let Some(y) = layout.axis_x {\n            if let Some(x) = layout.axis_y {\n                buf.get_mut(x, y)\n                    .set_symbol(symbols::line::BOTTOM_LEFT)\n                    .set_style(self.x_axis.style);\n            }\n        }\n\n        for dataset in &self.datasets {\n            Canvas::default()\n                .background_color(self.style.bg.unwrap_or(Color::Reset))\n                .x_bounds(self.x_axis.bounds)\n                .y_bounds(self.y_axis.bounds)\n                .marker(dataset.marker)\n                .paint(|ctx| {\n                    ctx.draw(&Points {\n                        coords: dataset.data,\n                        color: dataset.style.fg.unwrap_or(Color::Reset),\n                    });\n                    if let GraphType::Line = dataset.graph_type {\n                        for data in dataset.data.windows(2) {\n                            ctx.draw(&Line {\n                                x1: data[0].0,\n                                y1: data[0].1,\n                                x2: data[1].0,\n                                y2: data[1].1,\n                                color: dataset.style.fg.unwrap_or(Color::Reset),\n                            })\n                        }\n                    }\n                })\n                .render(graph_area, buf);\n        }\n\n        if let Some(legend_area) = layout.legend_area {\n            buf.set_style(legend_area, original_style);\n            Block::default()\n                .borders(Borders::ALL)\n                .render(legend_area, buf);\n            for (i, dataset) in self.datasets.iter().enumerate() {\n                buf.set_string(\n                    legend_area.x + 1,\n                    legend_area.y + 1 + i as u16,\n                    &dataset.name,\n                    dataset.style,\n                );\n            }\n        }\n\n        if let Some((x, y)) = layout.title_x {\n            let title = self.x_axis.title.unwrap();\n            let width = graph_area.right().saturating_sub(x);\n            buf.set_style(\n                Rect {\n                    x,\n                    y,\n                    width,\n                    height: 1,\n                },\n                original_style,\n            );\n            buf.set_spans(x, y, &title, width);\n        }\n\n        if let Some((x, y)) = layout.title_y {\n            let title = self.y_axis.title.unwrap();\n            let width = graph_area.right().saturating_sub(x);\n            buf.set_style(\n                Rect {\n                    x,\n                    y,\n                    width,\n                    height: 1,\n                },\n                original_style,\n            );\n            buf.set_spans(x, y, &title, width);\n        }\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"<widgets::chart::ChartLayout as std::default::Default>::default":["fn default() -> ChartLayout{\n        ChartLayout {\n            title_x: None,\n            title_y: None,\n            label_x: None,\n            label_y: None,\n            axis_x: None,\n            axis_y: None,\n            legend_area: None,\n            graph_area: Rect::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"<widgets::chart::Dataset<'a> as std::default::Default>::default":["fn default() -> Dataset<'a>{\n        Dataset {\n            name: Cow::from(\"\"),\n            data: &[],\n            marker: symbols::Marker::Dot,\n            graph_type: GraphType::Scatter,\n            style: Style::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"<widgets::clear::Clear as widgets::Widget>::render":["fn render(self, area: Rect, buf: &mut Buffer){\n        for x in area.left()..area.right() {\n            for y in area.top()..area.bottom() {\n                buf.get_mut(x, y).reset();\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/clear.rs\"))"],"<widgets::gauge::Gauge<'a> as std::default::Default>::default":["fn default() -> Gauge<'a>{\n        Gauge {\n            block: None,\n            ratio: 0.0,\n            label: None,\n            style: Style::default(),\n            gauge_style: Style::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"<widgets::gauge::Gauge<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n        let gauge_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n        buf.set_style(gauge_area, self.gauge_style);\n        if gauge_area.height < 1 {\n            return;\n        }\n\n        let center = gauge_area.height / 2 + gauge_area.top();\n        let width = (f64::from(gauge_area.width) * self.ratio).round() as u16;\n        let end = gauge_area.left() + width;\n        // Label\n        let ratio = self.ratio;\n        let label = self\n            .label\n            .unwrap_or_else(|| Span::from(format!(\"{}%\", (ratio * 100.0).round())));\n        for y in gauge_area.top()..gauge_area.bottom() {\n            // Gauge\n            for x in gauge_area.left()..end {\n                buf.get_mut(x, y).set_symbol(\" \");\n            }\n\n            if y == center {\n                let label_width = label.width() as u16;\n                let middle = (gauge_area.width - label_width) / 2 + gauge_area.left();\n                buf.set_span(middle, y, &label, gauge_area.right() - middle);\n            }\n\n            // Fix colors\n            for x in gauge_area.left()..end {\n                buf.get_mut(x, y)\n                    .set_fg(self.gauge_style.bg.unwrap_or(Color::Reset))\n                    .set_bg(self.gauge_style.fg.unwrap_or(Color::Reset));\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"<widgets::gauge::LineGauge<'a> as std::default::Default>::default":["fn default() -> Self{\n        Self {\n            block: None,\n            ratio: 0.0,\n            label: None,\n            style: Style::default(),\n            line_set: symbols::line::NORMAL,\n            gauge_style: Style::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"<widgets::gauge::LineGauge<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n        let gauge_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if gauge_area.height < 1 {\n            return;\n        }\n\n        let ratio = self.ratio;\n        let label = self\n            .label\n            .unwrap_or_else(move || Spans::from(format!(\"{:.0}%\", ratio * 100.0)));\n        let (col, row) = buf.set_spans(\n            gauge_area.left(),\n            gauge_area.top(),\n            &label,\n            gauge_area.width,\n        );\n        let start = col + 1;\n        if start >= gauge_area.right() {\n            return;\n        }\n\n        let end = start\n            + (f64::from(gauge_area.right().saturating_sub(start)) * self.ratio).floor() as u16;\n        for col in start..end {\n            buf.get_mut(col, row)\n                .set_symbol(self.line_set.horizontal)\n                .set_style(Style {\n                    fg: self.gauge_style.fg,\n                    bg: None,\n                    add_modifier: self.gauge_style.add_modifier,\n                    sub_modifier: self.gauge_style.sub_modifier,\n                });\n        }\n        for col in end..gauge_area.right() {\n            buf.get_mut(col, row)\n                .set_symbol(self.line_set.horizontal)\n                .set_style(Style {\n                    fg: self.gauge_style.bg,\n                    bg: None,\n                    add_modifier: self.gauge_style.add_modifier,\n                    sub_modifier: self.gauge_style.sub_modifier,\n                });\n        }\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"<widgets::list::List<'a> as widgets::StatefulWidget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State){\n        buf.set_style(area, self.style);\n        let list_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if list_area.width < 1 || list_area.height < 1 {\n            return;\n        }\n\n        if self.items.is_empty() {\n            return;\n        }\n        let list_height = list_area.height as usize;\n\n        let mut start = state.offset;\n        let mut end = state.offset;\n        let mut height = 0;\n        for item in self.items.iter().skip(state.offset) {\n            if height + item.height() > list_height {\n                break;\n            }\n            height += item.height();\n            end += 1;\n        }\n\n        let selected = state.selected.unwrap_or(0).min(self.items.len() - 1);\n        while selected >= end {\n            height = height.saturating_add(self.items[end].height());\n            end += 1;\n            while height > list_height {\n                height = height.saturating_sub(self.items[start].height());\n                start += 1;\n            }\n        }\n        while selected < start {\n            start -= 1;\n            height = height.saturating_add(self.items[start].height());\n            while height > list_height {\n                end -= 1;\n                height = height.saturating_sub(self.items[end].height());\n            }\n        }\n        state.offset = start;\n\n        let highlight_symbol = self.highlight_symbol.unwrap_or(\"\");\n        let blank_symbol = iter::repeat(\" \")\n            .take(highlight_symbol.width())\n            .collect::<String>();\n\n        let mut current_height = 0;\n        let has_selection = state.selected.is_some();\n        for (i, item) in self\n            .items\n            .iter_mut()\n            .enumerate()\n            .skip(state.offset)\n            .take(end - start)\n        {\n            let (x, y) = match self.start_corner {\n                Corner::BottomLeft => {\n                    current_height += item.height() as u16;\n                    (list_area.left(), list_area.bottom() - current_height)\n                }\n                _ => {\n                    let pos = (list_area.left(), list_area.top() + current_height);\n                    current_height += item.height() as u16;\n                    pos\n                }\n            };\n            let area = Rect {\n                x,\n                y,\n                width: list_area.width,\n                height: item.height() as u16,\n            };\n            let item_style = self.style.patch(item.style);\n            buf.set_style(area, item_style);\n\n            let is_selected = state.selected.map(|s| s == i).unwrap_or(false);\n            let elem_x = if has_selection {\n                let symbol = if is_selected {\n                    highlight_symbol\n                } else {\n                    &blank_symbol\n                };\n                let (x, _) = buf.set_stringn(x, y, symbol, list_area.width as usize, item_style);\n                x\n            } else {\n                x\n            };\n            let max_element_width = (list_area.width - (elem_x - x)) as usize;\n            for (j, line) in item.content.lines.iter().enumerate() {\n                buf.set_spans(elem_x, y + j as u16, line, max_element_width as u16);\n            }\n            if is_selected {\n                buf.set_style(area, self.highlight_style);\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"<widgets::list::List<'a> as widgets::Widget>::render":["fn render(self, area: Rect, buf: &mut Buffer){\n        let mut state = ListState::default();\n        StatefulWidget::render(self, area, buf, &mut state);\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"<widgets::list::ListState as std::default::Default>::default":["fn default() -> ListState{\n        ListState {\n            offset: 0,\n            selected: None,\n        }\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"<widgets::paragraph::Paragraph<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n        let text_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if text_area.height < 1 {\n            return;\n        }\n\n        let style = self.style;\n        let mut styled = self.text.lines.iter().flat_map(|spans| {\n            spans\n                .0\n                .iter()\n                .flat_map(|span| span.styled_graphemes(style))\n                // Required given the way composers work but might be refactored out if we change\n                // composers to operate on lines instead of a stream of graphemes.\n                .chain(iter::once(StyledGrapheme {\n                    symbol: \"\\n\",\n                    style: self.style,\n                }))\n        });\n\n        let mut line_composer: Box<dyn LineComposer> = if let Some(Wrap { trim }) = self.wrap {\n            Box::new(WordWrapper::new(&mut styled, text_area.width, trim))\n        } else {\n            let mut line_composer = Box::new(LineTruncator::new(&mut styled, text_area.width));\n            if let Alignment::Left = self.alignment {\n                line_composer.set_horizontal_offset(self.scroll.1);\n            }\n            line_composer\n        };\n        let mut y = 0;\n        while let Some((current_line, current_line_width)) = line_composer.next_line() {\n            if y >= self.scroll.0 {\n                let mut x = get_line_offset(current_line_width, text_area.width, self.alignment);\n                for StyledGrapheme { symbol, style } in current_line {\n                    buf.get_mut(text_area.left() + x, text_area.top() + y - self.scroll.0)\n                        .set_symbol(if symbol.is_empty() {\n                            // If the symbol is empty, the last char which rendered last time will\n                            // leave on the line. It's a quick fix.\n                            \" \"\n                        } else {\n                            symbol\n                        })\n                        .set_style(*style);\n                    x += symbol.width() as u16;\n                }\n            }\n            y += 1;\n            if y >= text_area.height + self.scroll.0 {\n                break;\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"<widgets::reflow::LineTruncator<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)>{\n        if self.max_line_width == 0 {\n            return None;\n        }\n\n        self.current_line.truncate(0);\n        let mut current_line_width = 0;\n\n        let mut skip_rest = false;\n        let mut symbols_exhausted = true;\n        let mut horizontal_offset = self.horizontal_offset as usize;\n        for StyledGrapheme { symbol, style } in &mut self.symbols {\n            symbols_exhausted = false;\n\n            // Ignore characters wider that the total max width.\n            if symbol.width() as u16 > self.max_line_width {\n                continue;\n            }\n\n            // Break on newline and discard it.\n            if symbol == \"\\n\" {\n                break;\n            }\n\n            if current_line_width + symbol.width() as u16 > self.max_line_width {\n                // Exhaust the remainder of the line.\n                skip_rest = true;\n                break;\n            }\n\n            let symbol = if horizontal_offset == 0 {\n                symbol\n            } else {\n                let w = symbol.width();\n                if w > horizontal_offset {\n                    let t = trim_offset(symbol, horizontal_offset);\n                    horizontal_offset = 0;\n                    t\n                } else {\n                    horizontal_offset -= w;\n                    \"\"\n                }\n            };\n            current_line_width += symbol.width() as u16;\n            self.current_line.push(StyledGrapheme { symbol, style });\n        }\n\n        if skip_rest {\n            for StyledGrapheme { symbol, .. } in &mut self.symbols {\n                if symbol == \"\\n\" {\n                    break;\n                }\n            }\n        }\n\n        if symbols_exhausted && self.current_line.is_empty() {\n            None\n        } else {\n            Some((&self.current_line[..], current_line_width))\n        }\n    }","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"<widgets::reflow::WordWrapper<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)>{\n        if self.max_line_width == 0 {\n            return None;\n        }\n        std::mem::swap(&mut self.current_line, &mut self.next_line);\n        self.next_line.truncate(0);\n\n        let mut current_line_width = self\n            .current_line\n            .iter()\n            .map(|StyledGrapheme { symbol, .. }| symbol.width() as u16)\n            .sum();\n\n        let mut symbols_to_last_word_end: usize = 0;\n        let mut width_to_last_word_end: u16 = 0;\n        let mut prev_whitespace = false;\n        let mut symbols_exhausted = true;\n        for StyledGrapheme { symbol, style } in &mut self.symbols {\n            symbols_exhausted = false;\n            let symbol_whitespace = symbol.chars().all(&char::is_whitespace);\n\n            // Ignore characters wider that the total max width.\n            if symbol.width() as u16 > self.max_line_width\n                // Skip leading whitespace when trim is enabled.\n                || self.trim && symbol_whitespace && symbol != \"\\n\" && current_line_width == 0\n            {\n                continue;\n            }\n\n            // Break on newline and discard it.\n            if symbol == \"\\n\" {\n                if prev_whitespace {\n                    current_line_width = width_to_last_word_end;\n                    self.current_line.truncate(symbols_to_last_word_end);\n                }\n                break;\n            }\n\n            // Mark the previous symbol as word end.\n            if symbol_whitespace && !prev_whitespace && symbol != NBSP {\n                symbols_to_last_word_end = self.current_line.len();\n                width_to_last_word_end = current_line_width;\n            }\n\n            self.current_line.push(StyledGrapheme { symbol, style });\n            current_line_width += symbol.width() as u16;\n\n            if current_line_width > self.max_line_width {\n                // If there was no word break in the text, wrap at the end of the line.\n                let (truncate_at, truncated_width) = if symbols_to_last_word_end != 0 {\n                    (symbols_to_last_word_end, width_to_last_word_end)\n                } else {\n                    (self.current_line.len() - 1, self.max_line_width)\n                };\n\n                // Push the remainder to the next line but strip leading whitespace:\n                {\n                    let remainder = &self.current_line[truncate_at..];\n                    if let Some(remainder_nonwhite) =\n                        remainder.iter().position(|StyledGrapheme { symbol, .. }| {\n                            !symbol.chars().all(&char::is_whitespace)\n                        })\n                    {\n                        self.next_line\n                            .extend_from_slice(&remainder[remainder_nonwhite..]);\n                    }\n                }\n                self.current_line.truncate(truncate_at);\n                current_line_width = truncated_width;\n                break;\n            }\n\n            prev_whitespace = symbol_whitespace;\n        }\n\n        // Even if the iterator is exhausted, pass the previous remainder.\n        if symbols_exhausted && self.current_line.is_empty() {\n            None\n        } else {\n            Some((&self.current_line[..], current_line_width))\n        }\n    }","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"<widgets::sparkline::Sparkline<'a> as std::default::Default>::default":["fn default() -> Sparkline<'a>{\n        Sparkline {\n            block: None,\n            style: Default::default(),\n            data: &[],\n            max: None,\n            bar_set: symbols::bar::NINE_LEVELS,\n        }\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"<widgets::sparkline::Sparkline<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        let spark_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if spark_area.height < 1 {\n            return;\n        }\n\n        let max = match self.max {\n            Some(v) => v,\n            None => *self.data.iter().max().unwrap_or(&1u64),\n        };\n        let max_index = min(spark_area.width as usize, self.data.len());\n        let mut data = self\n            .data\n            .iter()\n            .take(max_index)\n            .map(|e| {\n                if max != 0 {\n                    e * u64::from(spark_area.height) * 8 / max\n                } else {\n                    0\n                }\n            })\n            .collect::<Vec<u64>>();\n        for j in (0..spark_area.height).rev() {\n            for (i, d) in data.iter_mut().enumerate() {\n                let symbol = match *d {\n                    0 => self.bar_set.empty,\n                    1 => self.bar_set.one_eighth,\n                    2 => self.bar_set.one_quarter,\n                    3 => self.bar_set.three_eighths,\n                    4 => self.bar_set.half,\n                    5 => self.bar_set.five_eighths,\n                    6 => self.bar_set.three_quarters,\n                    7 => self.bar_set.seven_eighths,\n                    _ => self.bar_set.full,\n                };\n                buf.get_mut(spark_area.left() + i as u16, spark_area.top() + j)\n                    .set_symbol(symbol)\n                    .set_style(self.style);\n\n                if *d > 8 {\n                    *d -= 8;\n                } else {\n                    *d = 0;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"<widgets::table::Table<'a, H, R> as std::default::Default>::default":["fn default() -> Table<'a, H, R>{\n        Table {\n            block: None,\n            style: Style::default(),\n            header: H::default(),\n            header_style: Style::default(),\n            widths: &[],\n            column_spacing: 1,\n            header_gap: 1,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n            rows: R::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"<widgets::table::Table<'a, H, R> as widgets::StatefulWidget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State){\n        buf.set_style(area, self.style);\n\n        // Render block if necessary and get the drawing area\n        let table_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        let mut solver = Solver::new();\n        let mut var_indices = HashMap::new();\n        let mut ccs = Vec::new();\n        let mut variables = Vec::new();\n        for i in 0..self.widths.len() {\n            let var = cassowary::Variable::new();\n            variables.push(var);\n            var_indices.insert(var, i);\n        }\n        for (i, constraint) in self.widths.iter().enumerate() {\n            ccs.push(variables[i] | GE(WEAK) | 0.);\n            ccs.push(match *constraint {\n                Constraint::Length(v) => variables[i] | EQ(MEDIUM) | f64::from(v),\n                Constraint::Percentage(v) => {\n                    variables[i] | EQ(WEAK) | (f64::from(v * table_area.width) / 100.0)\n                }\n                Constraint::Ratio(n, d) => {\n                    variables[i]\n                        | EQ(WEAK)\n                        | (f64::from(table_area.width) * f64::from(n) / f64::from(d))\n                }\n                Constraint::Min(v) => variables[i] | GE(WEAK) | f64::from(v),\n                Constraint::Max(v) => variables[i] | LE(WEAK) | f64::from(v),\n            })\n        }\n        solver\n            .add_constraint(\n                variables\n                    .iter()\n                    .fold(Expression::from_constant(0.), |acc, v| acc + *v)\n                    | LE(REQUIRED)\n                    | f64::from(\n                        area.width - 2 - (self.column_spacing * (variables.len() as u16 - 1)),\n                    ),\n            )\n            .unwrap();\n        solver.add_constraints(&ccs).unwrap();\n        let mut solved_widths = vec![0; variables.len()];\n        for &(var, value) in solver.fetch_changes() {\n            let index = var_indices[&var];\n            let value = if value.is_sign_negative() {\n                0\n            } else {\n                value.round() as u16\n            };\n            solved_widths[index] = value\n        }\n\n        let mut y = table_area.top();\n        let mut x = table_area.left();\n\n        // Draw header\n        if y < table_area.bottom() {\n            for (w, t) in solved_widths.iter().zip(self.header.by_ref()) {\n                buf.set_stringn(x, y, format!(\"{}\", t), *w as usize, self.header_style);\n                x += *w + self.column_spacing;\n            }\n        }\n        y += 1 + self.header_gap;\n\n        // Use highlight_style only if something is selected\n        let (selected, highlight_style) = match state.selected {\n            Some(i) => (Some(i), self.highlight_style),\n            None => (None, self.style),\n        };\n        let highlight_symbol = self.highlight_symbol.unwrap_or(\"\");\n        let blank_symbol = iter::repeat(\" \")\n            .take(highlight_symbol.width())\n            .collect::<String>();\n\n        // Draw rows\n        let default_style = Style::default();\n        if y < table_area.bottom() {\n            let remaining = (table_area.bottom() - y) as usize;\n\n            // Make sure the table shows the selected item\n            state.offset = if let Some(selected) = selected {\n                if selected >= remaining + state.offset - 1 {\n                    selected + 1 - remaining\n                } else if selected < state.offset {\n                    selected\n                } else {\n                    state.offset\n                }\n            } else {\n                0\n            };\n            for (i, row) in self.rows.skip(state.offset).take(remaining).enumerate() {\n                let (data, style, symbol) = match row {\n                    Row::Data(d) | Row::StyledData(d, _)\n                        if Some(i) == state.selected.map(|s| s - state.offset) =>\n                    {\n                        (d, highlight_style, highlight_symbol)\n                    }\n                    Row::Data(d) => (d, default_style, blank_symbol.as_ref()),\n                    Row::StyledData(d, s) => (d, s, blank_symbol.as_ref()),\n                };\n                x = table_area.left();\n                for (c, (w, elt)) in solved_widths.iter().zip(data).enumerate() {\n                    let s = if c == 0 {\n                        format!(\"{}{}\", symbol, elt)\n                    } else {\n                        format!(\"{}\", elt)\n                    };\n                    buf.set_stringn(x, y + i as u16, s, *w as usize, style);\n                    x += *w + self.column_spacing;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"<widgets::table::Table<'a, H, R> as widgets::Widget>::render":["fn render(self, area: Rect, buf: &mut Buffer){\n        let mut state = TableState::default();\n        StatefulWidget::render(self, area, buf, &mut state);\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"<widgets::table::TableState as std::default::Default>::default":["fn default() -> TableState{\n        TableState {\n            offset: 0,\n            selected: None,\n        }\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"<widgets::tabs::Tabs<'a> as widgets::Widget>::render":["fn render(mut self, area: Rect, buf: &mut Buffer){\n        buf.set_style(area, self.style);\n        let tabs_area = match self.block.take() {\n            Some(b) => {\n                let inner_area = b.inner(area);\n                b.render(area, buf);\n                inner_area\n            }\n            None => area,\n        };\n\n        if tabs_area.height < 1 {\n            return;\n        }\n\n        let mut x = tabs_area.left();\n        let titles_length = self.titles.len();\n        for (i, title) in self.titles.into_iter().enumerate() {\n            let last_title = titles_length - 1 == i;\n            x = x.saturating_add(1);\n            let remaining_width = tabs_area.right().saturating_sub(x);\n            if remaining_width == 0 {\n                break;\n            }\n            let pos = buf.set_spans(x, tabs_area.top(), &title, remaining_width);\n            if i == self.selected {\n                buf.set_style(\n                    Rect {\n                        x,\n                        y: tabs_area.top(),\n                        width: pos.0.saturating_sub(x),\n                        height: 1,\n                    },\n                    self.highlight_style,\n                );\n            }\n            x = pos.0.saturating_add(1);\n            let remaining_width = tabs_area.right().saturating_sub(x);\n            if remaining_width == 0 || last_title {\n                break;\n            }\n            let pos = buf.set_span(x, tabs_area.top(), &self.divider, remaining_width);\n            x = pos.0;\n        }\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"backend::Backend":["pub trait Backend {\n    fn draw<'a, I>(&mut self, content: I) -> Result<(), io::Error>\n    where\n        I: Iterator<Item = (u16, u16, &'a Cell)>;\n    fn hide_cursor(&mut self) -> Result<(), io::Error>;\n    fn show_cursor(&mut self) -> Result<(), io::Error>;\n    fn get_cursor(&mut self) -> Result<(u16, u16), io::Error>;\n    fn set_cursor(&mut self, x: u16, y: u16) -> Result<(), io::Error>;\n    fn clear(&mut self) -> Result<(), io::Error>;\n    fn size(&self) -> Result<Rect, io::Error>;\n    fn flush(&mut self) -> Result<(), io::Error>;\n}","Real(LocalPath(\"src/backend/mod.rs\"))"],"backend::termion::Bg":["struct Bg(Color);","Real(LocalPath(\"src/backend/termion.rs\"))"],"backend::termion::Fg":["struct Fg(Color);","Real(LocalPath(\"src/backend/termion.rs\"))"],"backend::termion::ModifierDiff":["struct ModifierDiff {\n    from: Modifier,\n    to: Modifier,\n}","Real(LocalPath(\"src/backend/termion.rs\"))"],"backend::termion::TermionBackend":["pub struct TermionBackend<W>\nwhere\n    W: Write,\n{\n    stdout: W,\n}","Real(LocalPath(\"src/backend/termion.rs\"))"],"backend::termion::TermionBackend::<W>::new":["pub fn new(stdout: W) -> TermionBackend<W>{\n        TermionBackend { stdout }\n    }","Real(LocalPath(\"src/backend/termion.rs\"))"],"backend::test::TestBackend":["/// A backend used for the integration tests.\npub struct TestBackend {\n    width: u16,\n    buffer: Buffer,\n    height: u16,\n    cursor: bool,\n    pos: (u16, u16),\n}","Real(LocalPath(\"src/backend/test.rs\"))"],"backend::test::TestBackend::assert_buffer":["pub fn assert_buffer(&self, expected: &Buffer){\n        assert_eq!(expected.area, self.buffer.area);\n        let diff = expected.diff(&self.buffer);\n        if diff.is_empty() {\n            return;\n        }\n\n        let mut debug_info = String::from(\"Buffers are not equal\");\n        debug_info.push('\\n');\n        debug_info.push_str(\"Expected:\");\n        debug_info.push('\\n');\n        let expected_view = buffer_view(expected);\n        debug_info.push_str(&expected_view);\n        debug_info.push('\\n');\n        debug_info.push_str(\"Got:\");\n        debug_info.push('\\n');\n        let view = buffer_view(&self.buffer);\n        debug_info.push_str(&view);\n        debug_info.push('\\n');\n\n        debug_info.push_str(\"Diff:\");\n        debug_info.push('\\n');\n        let nice_diff = diff\n            .iter()\n            .enumerate()\n            .map(|(i, (x, y, cell))| {\n                let expected_cell = expected.get(*x, *y);\n                format!(\n                    \"{}: at ({}, {}) expected {:?} got {:?}\",\n                    i, x, y, expected_cell, cell\n                )\n            })\n            .collect::<Vec<String>>()\n            .join(\"\\n\");\n        debug_info.push_str(&nice_diff);\n        panic!(debug_info);\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"backend::test::TestBackend::buffer":["pub fn buffer(&self) -> &Buffer{\n        &self.buffer\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"backend::test::TestBackend::new":["pub fn new(width: u16, height: u16) -> TestBackend{\n        TestBackend {\n            width,\n            height,\n            buffer: Buffer::empty(Rect::new(0, 0, width, height)),\n            cursor: false,\n            pos: (0, 0),\n        }\n    }","Real(LocalPath(\"src/backend/test.rs\"))"],"backend::test::buffer_view":["/// Returns a string representation of the given buffer for debugging purpose.\nfn buffer_view(buffer: &Buffer) -> String{\n    let mut view = String::with_capacity(buffer.content.len() + buffer.area.height as usize * 3);\n    for cells in buffer.content.chunks(buffer.area.width as usize) {\n        let mut overwritten = vec![];\n        let mut skip: usize = 0;\n        view.push('\"');\n        for (x, c) in cells.iter().enumerate() {\n            if skip == 0 {\n                view.push_str(&c.symbol);\n            } else {\n                overwritten.push((x, &c.symbol))\n            }\n            skip = std::cmp::max(skip, c.symbol.width()).saturating_sub(1);\n        }\n        view.push('\"');\n        if !overwritten.is_empty() {\n            write!(\n                &mut view,\n                \" Hidden by multi-width symbols: {:?}\",\n                overwritten\n            )\n            .unwrap();\n        }\n        view.push('\\n');\n    }\n    view\n}","Real(LocalPath(\"src/backend/test.rs\"))"],"buffer::Buffer":["/// A buffer that maps to the desired content of the terminal after the draw call\n///\n/// No widget in the library interacts directly with the terminal. Instead each of them is required\n/// to draw their state to an intermediate buffer. It is basically a grid where each cell contains\n/// a grapheme, a foreground color and a background color. This grid will then be used to output\n/// the appropriate escape sequences and characters to draw the UI as the user has defined it.\n///\n/// # Examples:\n///\n/// ```\n/// use tui::buffer::{Buffer, Cell};\n/// use tui::layout::Rect;\n/// use tui::style::{Color, Style, Modifier};\n///\n/// let mut buf = Buffer::empty(Rect{x: 0, y: 0, width: 10, height: 5});\n/// buf.get_mut(0, 2).set_symbol(\"x\");\n/// assert_eq!(buf.get(0, 2).symbol, \"x\");\n/// buf.set_string(3, 0, \"string\", Style::default().fg(Color::Red).bg(Color::White));\n/// assert_eq!(buf.get(5, 0), &Cell{\n///     symbol: String::from(\"r\"),\n///     fg: Color::Red,\n///     bg: Color::White,\n///     modifier: Modifier::empty()\n/// });\n/// buf.get_mut(5, 0).set_char('x');\n/// assert_eq!(buf.get(5, 0).symbol, \"x\");\n/// ```\npub struct Buffer {\n    /// The area represented by this buffer\n    pub area: Rect,\n    /// The content of the buffer. The length of this Vec should always be equal to area.width *\n    /// area.height\n    pub content: Vec<Cell>,\n}","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::area":["/// Returns the area covered by this buffer\npub fn area(&self) -> &Rect{\n        &self.area\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::content":["/// Returns the content of the buffer as a slice\npub fn content(&self) -> &[Cell]{\n        &self.content\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::diff":["/// Builds a minimal sequence of coordinates and Cells necessary to update the UI from\n/// self to other.\n///\n/// We're assuming that buffers are well-formed, that is no double-width cell is followed by\n/// a non-blank cell.\n///\n/// # Multi-width characters handling:\n///\n/// ```text\n/// (Index:) `01`\n/// Prev:    ``\n/// Next:    `aa`\n/// Updates: `0: a, 1: a'\n/// ```\n///\n/// ```text\n/// (Index:) `01`\n/// Prev:    `a `\n/// Next:    ``\n/// Updates: `0: ` (double width symbol at index 0 - skip index 1)\n/// ```\n///\n/// ```text\n/// (Index:) `012`\n/// Prev:    `aaa`\n/// Next:    `a`\n/// Updates: `0: a, 1: ` (double width symbol at index 1 - skip index 2)\n/// ```\npub fn diff<'a>(&self, other: &'a Buffer) -> Vec<(u16, u16, &'a Cell)>{\n        let previous_buffer = &self.content;\n        let next_buffer = &other.content;\n        let width = self.area.width;\n\n        let mut updates: Vec<(u16, u16, &Cell)> = vec![];\n        // Cells invalidated by drawing/replacing preceeding multi-width characters:\n        let mut invalidated: usize = 0;\n        // Cells from the current buffer to skip due to preceeding multi-width characters taking their\n        // place (the skipped cells should be blank anyway):\n        let mut to_skip: usize = 0;\n        for (i, (current, previous)) in next_buffer.iter().zip(previous_buffer.iter()).enumerate() {\n            if (current != previous || invalidated > 0) && to_skip == 0 {\n                let x = i as u16 % width;\n                let y = i as u16 / width;\n                updates.push((x, y, &next_buffer[i]));\n            }\n\n            to_skip = current.symbol.width().saturating_sub(1);\n\n            let affected_width = std::cmp::max(current.symbol.width(), previous.symbol.width());\n            invalidated = std::cmp::max(affected_width, invalidated).saturating_sub(1);\n        }\n        updates\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::empty":["/// Returns a Buffer with all cells set to the default one\npub fn empty(area: Rect) -> Buffer{\n        let cell: Cell = Default::default();\n        Buffer::filled(area, &cell)\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::filled":["/// Returns a Buffer with all cells initialized with the attributes of the given Cell\npub fn filled(area: Rect, cell: &Cell) -> Buffer{\n        let size = area.area() as usize;\n        let mut content = Vec::with_capacity(size);\n        for _ in 0..size {\n            content.push(cell.clone());\n        }\n        Buffer { area, content }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::get":["/// Returns a reference to Cell at the given coordinates\npub fn get(&self, x: u16, y: u16) -> &Cell{\n        let i = self.index_of(x, y);\n        &self.content[i]\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::get_mut":["/// Returns a mutable reference to Cell at the given coordinates\npub fn get_mut(&mut self, x: u16, y: u16) -> &mut Cell{\n        let i = self.index_of(x, y);\n        &mut self.content[i]\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::index_of":["/// Returns the index in the Vec<Cell> for the given global (x, y) coordinates.\n///\n/// Global coordinates are offset by the Buffer's area offset (`x`/`y`).\n///\n/// # Examples\n///\n/// ```\n/// # use tui::buffer::Buffer;\n/// # use tui::layout::Rect;\n/// let rect = Rect::new(200, 100, 10, 10);\n/// let buffer = Buffer::empty(rect);\n/// // Global coordinates to the top corner of this buffer's area\n/// assert_eq!(buffer.index_of(200, 100), 0);\n/// ```\n///\n/// # Panics\n///\n/// Panics when given an coordinate that is outside of this Buffer's area.\n///\n/// ```should_panic\n/// # use tui::buffer::Buffer;\n/// # use tui::layout::Rect;\n/// let rect = Rect::new(200, 100, 10, 10);\n/// let buffer = Buffer::empty(rect);\n/// // Top coordinate is outside of the buffer in global coordinate space, as the Buffer's area\n/// // starts at (200, 100).\n/// buffer.index_of(0, 0); // Panics\n/// ```\npub fn index_of(&self, x: u16, y: u16) -> usize{\n        debug_assert!(\n            x >= self.area.left()\n                && x < self.area.right()\n                && y >= self.area.top()\n                && y < self.area.bottom(),\n            \"Trying to access position outside the buffer: x={}, y={}, area={:?}\",\n            x,\n            y,\n            self.area\n        );\n        ((y - self.area.y) * self.area.width + (x - self.area.x)) as usize\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::merge":["/// Merge an other buffer into this one\npub fn merge(&mut self, other: &Buffer){\n        let area = self.area.union(other.area);\n        let cell: Cell = Default::default();\n        self.content.resize(area.area() as usize, cell.clone());\n\n        // Move original content to the appropriate space\n        let size = self.area.area() as usize;\n        for i in (0..size).rev() {\n            let (x, y) = self.pos_of(i);\n            // New index in content\n            let k = ((y - area.y) * area.width + x - area.x) as usize;\n            if i != k {\n                self.content[k] = self.content[i].clone();\n                self.content[i] = cell.clone();\n            }\n        }\n\n        // Push content of the other buffer into this one (may erase previous\n        // data)\n        let size = other.area.area() as usize;\n        for i in 0..size {\n            let (x, y) = other.pos_of(i);\n            // New index in content\n            let k = ((y - area.y) * area.width + x - area.x) as usize;\n            self.content[k] = other.content[i].clone();\n        }\n        self.area = area;\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::pos_of":["/// Returns the (global) coordinates of a cell given its index\n///\n/// Global coordinates are offset by the Buffer's area offset (`x`/`y`).\n///\n/// # Examples\n///\n/// ```\n/// # use tui::buffer::Buffer;\n/// # use tui::layout::Rect;\n/// let rect = Rect::new(200, 100, 10, 10);\n/// let buffer = Buffer::empty(rect);\n/// assert_eq!(buffer.pos_of(0), (200, 100));\n/// assert_eq!(buffer.pos_of(14), (204, 101));\n/// ```\n///\n/// # Panics\n///\n/// Panics when given an index that is outside the Buffer's content.\n///\n/// ```should_panic\n/// # use tui::buffer::Buffer;\n/// # use tui::layout::Rect;\n/// let rect = Rect::new(0, 0, 10, 10); // 100 cells in total\n/// let buffer = Buffer::empty(rect);\n/// // Index 100 is the 101th cell, which lies outside of the area of this Buffer.\n/// buffer.pos_of(100); // Panics\n/// ```\npub fn pos_of(&self, i: usize) -> (u16, u16){\n        debug_assert!(\n            i < self.content.len(),\n            \"Trying to get the coords of a cell outside the buffer: i={} len={}\",\n            i,\n            self.content.len()\n        );\n        (\n            self.area.x + i as u16 % self.area.width,\n            self.area.y + i as u16 / self.area.width,\n        )\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::reset":["/// Reset all cells in the buffer\npub fn reset(&mut self){\n        for c in &mut self.content {\n            c.reset();\n        }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::resize":["/// Resize the buffer so that the mapped area matches the given area and that the buffer\n/// length is equal to area.width * area.height\npub fn resize(&mut self, area: Rect){\n        let length = area.area() as usize;\n        if self.content.len() > length {\n            self.content.truncate(length);\n        } else {\n            self.content.resize(length, Default::default());\n        }\n        self.area = area;\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_background":["#[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `Buffer::set_style`\"\n    )]\npub fn set_background(&mut self, area: Rect, color: Color){\n        for y in area.top()..area.bottom() {\n            for x in area.left()..area.right() {\n                self.get_mut(x, y).set_bg(color);\n            }\n        }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_span":["pub fn set_span<'a>(&mut self, x: u16, y: u16, span: &Span<'a>, width: u16) -> (u16, u16){\n        self.set_stringn(x, y, span.content.as_ref(), width as usize, span.style)\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_spans":["pub fn set_spans<'a>(&mut self, x: u16, y: u16, spans: &Spans<'a>, width: u16) -> (u16, u16){\n        let mut remaining_width = width;\n        let mut x = x;\n        for span in &spans.0 {\n            if remaining_width == 0 {\n                break;\n            }\n            let pos = self.set_stringn(\n                x,\n                y,\n                span.content.as_ref(),\n                remaining_width as usize,\n                span.style,\n            );\n            let w = pos.0.saturating_sub(x);\n            x = pos.0;\n            remaining_width = remaining_width.saturating_sub(w);\n        }\n        (x, y)\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_string":["/// Print a string, starting at the position (x, y)\npub fn set_string<S>(&mut self, x: u16, y: u16, string: S, style: Style)\n    where\n        S: AsRef<str>,{\n        self.set_stringn(x, y, string, usize::MAX, style);\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_stringn":["/// Print at most the first n characters of a string if enough space is available\n/// until the end of the line\npub fn set_stringn<S>(\n        &mut self,\n        x: u16,\n        y: u16,\n        string: S,\n        width: usize,\n        style: Style,\n    ) -> (u16, u16)\n    where\n        S: AsRef<str>,{\n        let mut index = self.index_of(x, y);\n        let mut x_offset = x as usize;\n        let graphemes = UnicodeSegmentation::graphemes(string.as_ref(), true);\n        let max_offset = min(self.area.right() as usize, width.saturating_add(x as usize));\n        for s in graphemes {\n            let width = s.width();\n            if width == 0 {\n                continue;\n            }\n            // `x_offset + width > max_offset` could be integer overflow on 32-bit machines if we\n            // change dimenstions to usize or u32 and someone resizes the terminal to 1x2^32.\n            if width > max_offset.saturating_sub(x_offset) {\n                break;\n            }\n\n            self.content[index].set_symbol(s);\n            self.content[index].set_style(style);\n            // Reset following cells if multi-width (they would be hidden by the grapheme),\n            for i in index + 1..index + width {\n                self.content[i].reset();\n            }\n            index += width;\n            x_offset += width;\n        }\n        (x_offset as u16, y)\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::set_style":["pub fn set_style(&mut self, area: Rect, style: Style){\n        for y in area.top()..area.bottom() {\n            for x in area.left()..area.right() {\n                self.get_mut(x, y).set_style(style);\n            }\n        }\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Buffer::with_lines":["/// Returns a Buffer containing the given lines\npub fn with_lines<S>(lines: Vec<S>) -> Buffer\n    where\n        S: AsRef<str>,{\n        let height = lines.len() as u16;\n        let width = lines\n            .iter()\n            .map(|i| i.as_ref().width() as u16)\n            .max()\n            .unwrap_or_default();\n        let mut buffer = Buffer::empty(Rect {\n            x: 0,\n            y: 0,\n            width,\n            height,\n        });\n        for (y, line) in lines.iter().enumerate() {\n            buffer.set_string(0, y as u16, line, Style::default());\n        }\n        buffer\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell":["/// A buffer cell\npub struct Cell {\n    pub symbol: String,\n    pub fg: Color,\n    pub bg: Color,\n    pub modifier: Modifier,\n}","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::reset":["pub fn reset(&mut self){\n        self.symbol.clear();\n        self.symbol.push(' ');\n        self.fg = Color::Reset;\n        self.bg = Color::Reset;\n        self.modifier = Modifier::empty();\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::set_bg":["pub fn set_bg(&mut self, color: Color) -> &mut Cell{\n        self.bg = color;\n        self\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::set_char":["pub fn set_char(&mut self, ch: char) -> &mut Cell{\n        self.symbol.clear();\n        self.symbol.push(ch);\n        self\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::set_fg":["pub fn set_fg(&mut self, color: Color) -> &mut Cell{\n        self.fg = color;\n        self\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::set_style":["pub fn set_style(&mut self, style: Style) -> &mut Cell{\n        if let Some(c) = style.fg {\n            self.fg = c;\n        }\n        if let Some(c) = style.bg {\n            self.bg = c;\n        }\n        self.modifier.insert(style.add_modifier);\n        self.modifier.remove(style.sub_modifier);\n        self\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::set_symbol":["pub fn set_symbol(&mut self, symbol: &str) -> &mut Cell{\n        self.symbol.clear();\n        self.symbol.push_str(symbol);\n        self\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"buffer::Cell::style":["pub fn style(&self) -> Style{\n        Style::default()\n            .fg(self.fg)\n            .bg(self.bg)\n            .add_modifier(self.modifier)\n    }","Real(LocalPath(\"src/buffer.rs\"))"],"layout::Alignment":["pub enum Alignment {\n    Left,\n    Center,\n    Right,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Constraint":["pub enum Constraint {\n    // TODO: enforce range 0 - 100\n    Percentage(u16),\n    Ratio(u32, u32),\n    Length(u16),\n    Max(u16),\n    Min(u16),\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Constraint::apply":["pub fn apply(&self, length: u16) -> u16{\n        match *self {\n            Constraint::Percentage(p) => length * p / 100,\n            Constraint::Ratio(num, den) => {\n                let r = num * u32::from(length) / den;\n                r as u16\n            }\n            Constraint::Length(l) => length.min(l),\n            Constraint::Max(m) => length.min(m),\n            Constraint::Min(m) => length.max(m),\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Corner":["pub enum Corner {\n    TopLeft,\n    TopRight,\n    BottomRight,\n    BottomLeft,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Direction":["pub enum Direction {\n    Horizontal,\n    Vertical,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element":["/// A container used by the solver inside split\nstruct Element {\n    x: Variable,\n    y: Variable,\n    width: Variable,\n    height: Variable,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element::bottom":["fn bottom(&self) -> Expression{\n        self.y + self.height\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element::left":["fn left(&self) -> Variable{\n        self.x\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element::new":["fn new() -> Element{\n        Element {\n            x: Variable::new(),\n            y: Variable::new(),\n            width: Variable::new(),\n            height: Variable::new(),\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element::right":["fn right(&self) -> Expression{\n        self.x + self.width\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Element::top":["fn top(&self) -> Variable{\n        self.y\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::LAYOUT_CACHE::__getit":["inline\nunsafe fn __getit(\n                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n            ) -> $crate::option::Option<&'static $t>{\n                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe {\n                    __KEY.get(move || {\n                        if let $crate::option::Option::Some(init) = init {\n                            if let $crate::option::Option::Some(value) = init.take() {\n                                return value;\n                            } else if $crate::cfg!(debug_assertions) {\n                                $crate::unreachable!(\"missing default value\");\n                            }\n                        }\n                        __init()\n                    })\n                }\n            }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"layout::LAYOUT_CACHE::__init":["#[inline]\nfn __init() -> $t{ $init }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"layout::Layout":["pub struct Layout {\n    direction: Direction,\n    margin: Margin,\n    constraints: Vec<Constraint>,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::constraints":["pub fn constraints<C>(mut self, constraints: C) -> Layout\n    where\n        C: Into<Vec<Constraint>>,{\n        self.constraints = constraints.into();\n        self\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::direction":["pub fn direction(mut self, direction: Direction) -> Layout{\n        self.direction = direction;\n        self\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::horizontal_margin":["pub fn horizontal_margin(mut self, horizontal: u16) -> Layout{\n        self.margin.horizontal = horizontal;\n        self\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::margin":["pub fn margin(mut self, margin: u16) -> Layout{\n        self.margin = Margin {\n            horizontal: margin,\n            vertical: margin,\n        };\n        self\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::split":["/// Wrapper function around the cassowary-rs solver to be able to split a given\n/// area into smaller ones based on the preferred widths or heights and the direction.\n///\n/// # Examples\n/// ```\n/// # use tui::layout::{Rect, Constraint, Direction, Layout};\n/// let chunks = Layout::default()\n///     .direction(Direction::Vertical)\n///     .constraints([Constraint::Length(5), Constraint::Min(0)].as_ref())\n///     .split(Rect {\n///         x: 2,\n///         y: 2,\n///         width: 10,\n///         height: 10,\n///     });\n/// assert_eq!(\n///     chunks,\n///     vec![\n///         Rect {\n///             x: 2,\n///             y: 2,\n///             width: 10,\n///             height: 5\n///         },\n///         Rect {\n///             x: 2,\n///             y: 7,\n///             width: 10,\n///             height: 5\n///         }\n///     ]\n/// );\n///\n/// let chunks = Layout::default()\n///     .direction(Direction::Horizontal)\n///     .constraints([Constraint::Ratio(1, 3), Constraint::Ratio(2, 3)].as_ref())\n///     .split(Rect {\n///         x: 0,\n///         y: 0,\n///         width: 9,\n///         height: 2,\n///     });\n/// assert_eq!(\n///     chunks,\n///     vec![\n///         Rect {\n///             x: 0,\n///             y: 0,\n///             width: 3,\n///             height: 2\n///         },\n///         Rect {\n///             x: 3,\n///             y: 0,\n///             width: 6,\n///             height: 2\n///         }\n///     ]\n/// );\n/// ```\npub fn split(&self, area: Rect) -> Vec<Rect>{\n        // TODO: Maybe use a fixed size cache ?\n        LAYOUT_CACHE.with(|c| {\n            c.borrow_mut()\n                .entry((area, self.clone()))\n                .or_insert_with(|| split(area, self))\n                .clone()\n        })\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Layout::vertical_margin":["pub fn vertical_margin(mut self, vertical: u16) -> Layout{\n        self.margin.vertical = vertical;\n        self\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Margin":["pub struct Margin {\n    pub vertical: u16,\n    pub horizontal: u16,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect":["/// A simple rectangle used in the computation of the layout and to give widgets an hint about the\n/// area they are supposed to render to.\npub struct Rect {\n    pub x: u16,\n    pub y: u16,\n    pub width: u16,\n    pub height: u16,\n}","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::area":["pub fn area(self) -> u16{\n        self.width * self.height\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::bottom":["pub fn bottom(self) -> u16{\n        self.y + self.height\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::inner":["pub fn inner(self, margin: &Margin) -> Rect{\n        if self.width < 2 * margin.horizontal || self.height < 2 * margin.vertical {\n            Rect::default()\n        } else {\n            Rect {\n                x: self.x + margin.horizontal,\n                y: self.y + margin.vertical,\n                width: self.width - 2 * margin.horizontal,\n                height: self.height - 2 * margin.vertical,\n            }\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::intersection":["pub fn intersection(self, other: Rect) -> Rect{\n        let x1 = max(self.x, other.x);\n        let y1 = max(self.y, other.y);\n        let x2 = min(self.x + self.width, other.x + other.width);\n        let y2 = min(self.y + self.height, other.y + other.height);\n        Rect {\n            x: x1,\n            y: y1,\n            width: x2 - x1,\n            height: y2 - y1,\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::intersects":["pub fn intersects(self, other: Rect) -> bool{\n        self.x < other.x + other.width\n            && self.x + self.width > other.x\n            && self.y < other.y + other.height\n            && self.y + self.height > other.y\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::left":["pub fn left(self) -> u16{\n        self.x\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::new":["/// Creates a new rect, with width and height limited to keep the area under max u16.\n/// If clipped, aspect ratio will be preserved.\npub fn new(x: u16, y: u16, width: u16, height: u16) -> Rect{\n        let max_area = u16::max_value();\n        let (clipped_width, clipped_height) =\n            if u32::from(width) * u32::from(height) > u32::from(max_area) {\n                let aspect_ratio = f64::from(width) / f64::from(height);\n                let max_area_f = f64::from(max_area);\n                let height_f = (max_area_f / aspect_ratio).sqrt();\n                let width_f = height_f * aspect_ratio;\n                (width_f as u16, height_f as u16)\n            } else {\n                (width, height)\n            };\n        Rect {\n            x,\n            y,\n            width: clipped_width,\n            height: clipped_height,\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::right":["pub fn right(self) -> u16{\n        self.x + self.width\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::top":["pub fn top(self) -> u16{\n        self.y\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::Rect::union":["pub fn union(self, other: Rect) -> Rect{\n        let x1 = min(self.x, other.x);\n        let y1 = min(self.y, other.y);\n        let x2 = max(self.x + self.width, other.x + other.width);\n        let y2 = max(self.y + self.height, other.y + other.height);\n        Rect {\n            x: x1,\n            y: y1,\n            width: x2 - x1,\n            height: y2 - y1,\n        }\n    }","Real(LocalPath(\"src/layout.rs\"))"],"layout::split":["fn split(area: Rect, layout: &Layout) -> Vec<Rect>{\n    let mut solver = Solver::new();\n    let mut vars: HashMap<Variable, (usize, usize)> = HashMap::new();\n    let elements = layout\n        .constraints\n        .iter()\n        .map(|_| Element::new())\n        .collect::<Vec<Element>>();\n    let mut results = layout\n        .constraints\n        .iter()\n        .map(|_| Rect::default())\n        .collect::<Vec<Rect>>();\n\n    let dest_area = area.inner(&layout.margin);\n    for (i, e) in elements.iter().enumerate() {\n        vars.insert(e.x, (i, 0));\n        vars.insert(e.y, (i, 1));\n        vars.insert(e.width, (i, 2));\n        vars.insert(e.height, (i, 3));\n    }\n    let mut ccs: Vec<CassowaryConstraint> =\n        Vec::with_capacity(elements.len() * 4 + layout.constraints.len() * 6);\n    for elt in &elements {\n        ccs.push(elt.width | GE(REQUIRED) | 0f64);\n        ccs.push(elt.height | GE(REQUIRED) | 0f64);\n        ccs.push(elt.left() | GE(REQUIRED) | f64::from(dest_area.left()));\n        ccs.push(elt.top() | GE(REQUIRED) | f64::from(dest_area.top()));\n        ccs.push(elt.right() | LE(REQUIRED) | f64::from(dest_area.right()));\n        ccs.push(elt.bottom() | LE(REQUIRED) | f64::from(dest_area.bottom()));\n    }\n    if let Some(first) = elements.first() {\n        ccs.push(match layout.direction {\n            Direction::Horizontal => first.left() | EQ(REQUIRED) | f64::from(dest_area.left()),\n            Direction::Vertical => first.top() | EQ(REQUIRED) | f64::from(dest_area.top()),\n        });\n    }\n    if let Some(last) = elements.last() {\n        ccs.push(match layout.direction {\n            Direction::Horizontal => last.right() | EQ(REQUIRED) | f64::from(dest_area.right()),\n            Direction::Vertical => last.bottom() | EQ(REQUIRED) | f64::from(dest_area.bottom()),\n        });\n    }\n    match layout.direction {\n        Direction::Horizontal => {\n            for pair in elements.windows(2) {\n                ccs.push((pair[0].x + pair[0].width) | EQ(REQUIRED) | pair[1].x);\n            }\n            for (i, size) in layout.constraints.iter().enumerate() {\n                ccs.push(elements[i].y | EQ(REQUIRED) | f64::from(dest_area.y));\n                ccs.push(elements[i].height | EQ(REQUIRED) | f64::from(dest_area.height));\n                ccs.push(match *size {\n                    Constraint::Length(v) => elements[i].width | EQ(WEAK) | f64::from(v),\n                    Constraint::Percentage(v) => {\n                        elements[i].width | EQ(WEAK) | (f64::from(v * dest_area.width) / 100.0)\n                    }\n                    Constraint::Ratio(n, d) => {\n                        elements[i].width\n                            | EQ(WEAK)\n                            | (f64::from(dest_area.width) * f64::from(n) / f64::from(d))\n                    }\n                    Constraint::Min(v) => elements[i].width | GE(WEAK) | f64::from(v),\n                    Constraint::Max(v) => elements[i].width | LE(WEAK) | f64::from(v),\n                });\n            }\n        }\n        Direction::Vertical => {\n            for pair in elements.windows(2) {\n                ccs.push((pair[0].y + pair[0].height) | EQ(REQUIRED) | pair[1].y);\n            }\n            for (i, size) in layout.constraints.iter().enumerate() {\n                ccs.push(elements[i].x | EQ(REQUIRED) | f64::from(dest_area.x));\n                ccs.push(elements[i].width | EQ(REQUIRED) | f64::from(dest_area.width));\n                ccs.push(match *size {\n                    Constraint::Length(v) => elements[i].height | EQ(WEAK) | f64::from(v),\n                    Constraint::Percentage(v) => {\n                        elements[i].height | EQ(WEAK) | (f64::from(v * dest_area.height) / 100.0)\n                    }\n                    Constraint::Ratio(n, d) => {\n                        elements[i].height\n                            | EQ(WEAK)\n                            | (f64::from(dest_area.height) * f64::from(n) / f64::from(d))\n                    }\n                    Constraint::Min(v) => elements[i].height | GE(WEAK) | f64::from(v),\n                    Constraint::Max(v) => elements[i].height | LE(WEAK) | f64::from(v),\n                });\n            }\n        }\n    }\n    solver.add_constraints(&ccs).unwrap();\n    for &(var, value) in solver.fetch_changes() {\n        let (index, attr) = vars[&var];\n        let value = if value.is_sign_negative() {\n            0\n        } else {\n            value as u16\n        };\n        match attr {\n            0 => {\n                results[index].x = value;\n            }\n            1 => {\n                results[index].y = value;\n            }\n            2 => {\n                results[index].width = value;\n            }\n            3 => {\n                results[index].height = value;\n            }\n            _ => {}\n        }\n    }\n\n    // Fix imprecision by extending the last item a bit if necessary\n    if let Some(last) = results.last_mut() {\n        match layout.direction {\n            Direction::Vertical => {\n                last.height = dest_area.bottom() - last.y;\n            }\n            Direction::Horizontal => {\n                last.width = dest_area.right() - last.x;\n            }\n        }\n    }\n    results\n}","Real(LocalPath(\"src/layout.rs\"))"],"style::Color":["pub enum Color {\n    Reset,\n    Black,\n    Red,\n    Green,\n    Yellow,\n    Blue,\n    Magenta,\n    Cyan,\n    Gray,\n    DarkGray,\n    LightRed,\n    LightGreen,\n    LightYellow,\n    LightBlue,\n    LightMagenta,\n    LightCyan,\n    White,\n    Rgb(u8, u8, u8),\n    Indexed(u8),\n}","Real(LocalPath(\"src/style.rs\"))"],"style::Modifier":["#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n#[$outer]\n$vis struct $BitFlags {\n            bits: $T,\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::all":["/// Returns the set containing all flags.\n#[inline]\npub const fn all() -> Self{\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::all::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n            $(\n                const $Flag: $T = 0;\n            )+\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::bits":["/// Returns the raw value of the flags currently stored.\n#[inline]\npub const fn bits(&self) -> $T{\n                self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::complement":["/// Returns the complement of this set of flags.\n///\n/// Specifically, the returned set contains all the flags which are\n/// not set in `self`, but which are allowed for this type.\n///\n/// Alternatively, it can be thought of as the set difference\n/// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n///\n/// This is equivalent to using the `!` operator (e.g.\n/// [`ops::Not`]), as in `!flags`.\n///\n/// [`Self::all()`]: Self::all\n/// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n#[inline]\n#[must_use]\npub const fn complement(self) -> Self{\n                Self::from_bits_truncate(!self.bits)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::contains":["/// Returns `true` if all of the flags in `other` are contained within `self`.\n#[inline]\npub const fn contains(&self, other: Self) -> bool{\n                (self.bits & other.bits) == other.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::difference":["/// Returns the difference between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags present in\n/// `self`, except for the ones present in `other`.\n///\n/// It is also conceptually equivalent to the \"bit-clear\" operation:\n/// `flags & !other` (and this syntax is also supported).\n///\n/// This is equivalent to using the `-` operator (e.g.\n/// [`ops::Sub`]), as in `flags - other`.\n///\n/// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n#[inline]\n#[must_use]\npub const fn difference(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::empty":["/// Returns an empty set of flags.\n#[inline]\npub const fn empty() -> Self{\n                Self { bits: 0 }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::from_bits":["/// Convert from underlying bit representation, unless that\n/// representation contains bits that do not correspond to a flag.\n#[inline]\npub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self>{\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::from_bits_truncate":["/// Convert from underlying bit representation, dropping any bits\n/// that do not correspond to flags.\n#[inline]\npub const fn from_bits_truncate(bits: $T) -> Self{\n                Self { bits: bits & Self::all().bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::from_bits_unchecked":["/// Convert from underlying bit representation, preserving all\n/// bits (even those not corresponding to a defined flag).\n///\n/// # Safety\n///\n/// The caller of the `bitflags!` macro can chose to allow or\n/// disallow extra bits for their bitflags type.\n///\n/// The caller of `from_bits_unchecked()` has to ensure that\n/// all bits correspond to a defined flag or that extra bits\n/// are valid for this bitflags type.\n#[inline]\npub const unsafe fn from_bits_unchecked(bits: $T) -> Self{\n                Self { bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::insert":["/// Inserts the specified flags in-place.\n#[inline]\npub fn insert(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::intersection":["/// Returns the intersection between the flags in `self` and\n/// `other`.\n///\n/// Specifically, the returned set contains only the flags which are\n/// present in *both* `self` *and* `other`.\n///\n/// This is equivalent to using the `&` operator (e.g.\n/// [`ops::BitAnd`]), as in `flags & other`.\n///\n/// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n#[inline]\n#[must_use]\npub const fn intersection(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::intersects":["/// Returns `true` if there are flags common to both `self` and `other`.\n#[inline]\npub const fn intersects(&self, other: Self) -> bool{\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::is_all":["/// Returns `true` if all flags are currently set.\n#[inline]\npub const fn is_all(&self) -> bool{\n                Self::all().bits | self.bits == self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::is_empty":["/// Returns `true` if no flags are currently stored.\n#[inline]\npub const fn is_empty(&self) -> bool{\n                self.bits() == Self::empty().bits()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::remove":["/// Removes the specified flags in-place.\n#[inline]\npub fn remove(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::set":["/// Inserts or removes the specified flags depending on the passed value.\n#[inline]\npub fn set(&mut self, other: Self, value: bool){\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::symmetric_difference":["/// Returns the [symmetric difference][sym-diff] between the flags\n/// in `self` and `other`.\n///\n/// Specifically, the returned set contains the flags present which\n/// are present in `self` or `other`, but that are not present in\n/// both. Equivalently, it contains the flags present in *exactly\n/// one* of the sets `self` and `other`.\n///\n/// This is equivalent to using the `^` operator (e.g.\n/// [`ops::BitXor`]), as in `flags ^ other`.\n///\n/// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n/// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n#[inline]\n#[must_use]\npub const fn symmetric_difference(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::toggle":["/// Toggles the specified flags in-place.\n#[inline]\npub fn toggle(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Modifier::union":["/// Returns the union of between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags which are\n/// present in *either* `self` *or* `other`, including any which are\n/// present in both (see [`Self::symmetric_difference`] if that\n/// is undesirable).\n///\n/// This is equivalent to using the `|` operator (e.g.\n/// [`ops::BitOr`]), as in `flags | other`.\n///\n/// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n#[inline]\n#[must_use]\npub const fn union(self, other: Self) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"style::Style":["/// Style let you control the main characteristics of the displayed elements.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::style::{Color, Modifier, Style};\n/// Style::default()\n///     .fg(Color::Black)\n///     .bg(Color::Green)\n///     .add_modifier(Modifier::ITALIC | Modifier::BOLD);\n/// ```\npub struct Style {\n    pub fg: Option<Color>,\n    pub bg: Option<Color>,\n    pub add_modifier: Modifier,\n    pub sub_modifier: Modifier,\n}","Real(LocalPath(\"src/style.rs\"))"],"style::Style::add_modifier":["/// Changes the text emphasis.\n///\n/// When applied, it adds the given modifier to the `Style` modifiers.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().add_modifier(Modifier::BOLD);\n/// let diff = Style::default().add_modifier(Modifier::ITALIC);\n/// let patched = style.patch(diff);\n/// assert_eq!(patched.add_modifier, Modifier::BOLD | Modifier::ITALIC);\n/// assert_eq!(patched.sub_modifier, Modifier::empty());\n/// ```\npub fn add_modifier(mut self, modifier: Modifier) -> Style{\n        self.sub_modifier.remove(modifier);\n        self.add_modifier.insert(modifier);\n        self\n    }","Real(LocalPath(\"src/style.rs\"))"],"style::Style::bg":["/// Changes the background color.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::style::{Color, Style};\n/// let style = Style::default().bg(Color::Blue);\n/// let diff = Style::default().bg(Color::Red);\n/// assert_eq!(style.patch(diff), Style::default().bg(Color::Red));\n/// ```\npub fn bg(mut self, color: Color) -> Style{\n        self.bg = Some(color);\n        self\n    }","Real(LocalPath(\"src/style.rs\"))"],"style::Style::fg":["/// Changes the foreground color.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::style::{Color, Style};\n/// let style = Style::default().fg(Color::Blue);\n/// let diff = Style::default().fg(Color::Red);\n/// assert_eq!(style.patch(diff), Style::default().fg(Color::Red));\n/// ```\npub fn fg(mut self, color: Color) -> Style{\n        self.fg = Some(color);\n        self\n    }","Real(LocalPath(\"src/style.rs\"))"],"style::Style::patch":["/// Results in a combined style that is equivalent to applying the two individual styles to\n/// a style one after the other.\n///\n/// ## Examples\n/// ```\n/// # use tui::style::{Color, Modifier, Style};\n/// let style_1 = Style::default().fg(Color::Yellow);\n/// let style_2 = Style::default().bg(Color::Red);\n/// let combined = style_1.patch(style_2);\n/// assert_eq!(\n///     Style::default().patch(style_1).patch(style_2),\n///     Style::default().patch(combined));\n/// ```\npub fn patch(mut self, other: Style) -> Style{\n        self.fg = other.fg.or(self.fg);\n        self.bg = other.bg.or(self.bg);\n\n        self.add_modifier.remove(other.sub_modifier);\n        self.add_modifier.insert(other.add_modifier);\n        self.sub_modifier.remove(other.add_modifier);\n        self.sub_modifier.insert(other.sub_modifier);\n\n        self\n    }","Real(LocalPath(\"src/style.rs\"))"],"style::Style::remove_modifier":["/// Changes the text emphasis.\n///\n/// When applied, it removes the given modifier from the `Style` modifiers.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().add_modifier(Modifier::BOLD | Modifier::ITALIC);\n/// let diff = Style::default().remove_modifier(Modifier::ITALIC);\n/// let patched = style.patch(diff);\n/// assert_eq!(patched.add_modifier, Modifier::BOLD);\n/// assert_eq!(patched.sub_modifier, Modifier::ITALIC);\n/// ```\npub fn remove_modifier(mut self, modifier: Modifier) -> Style{\n        self.add_modifier.remove(modifier);\n        self.sub_modifier.insert(modifier);\n        self\n    }","Real(LocalPath(\"src/style.rs\"))"],"symbols::Marker":["/// Marker to use when plotting data points\npub enum Marker {\n    /// One point per cell in shape of dot\n    Dot,\n    /// One point per cell in shape of a block\n    Block,\n    /// Up to 8 points per cell\n    Braille,\n}","Real(LocalPath(\"src/symbols.rs\"))"],"symbols::bar::Set":["pub struct Set {\n        pub full: &'static str,\n        pub seven_eighths: &'static str,\n        pub three_quarters: &'static str,\n        pub five_eighths: &'static str,\n        pub half: &'static str,\n        pub three_eighths: &'static str,\n        pub one_quarter: &'static str,\n        pub one_eighth: &'static str,\n        pub empty: &'static str,\n    }","Real(LocalPath(\"src/symbols.rs\"))"],"symbols::block::Set":["pub struct Set {\n        pub full: &'static str,\n        pub seven_eighths: &'static str,\n        pub three_quarters: &'static str,\n        pub five_eighths: &'static str,\n        pub half: &'static str,\n        pub three_eighths: &'static str,\n        pub one_quarter: &'static str,\n        pub one_eighth: &'static str,\n        pub empty: &'static str,\n    }","Real(LocalPath(\"src/symbols.rs\"))"],"symbols::line::Set":["pub struct Set {\n        pub vertical: &'static str,\n        pub horizontal: &'static str,\n        pub top_right: &'static str,\n        pub top_left: &'static str,\n        pub bottom_right: &'static str,\n        pub bottom_left: &'static str,\n        pub vertical_left: &'static str,\n        pub vertical_right: &'static str,\n        pub horizontal_down: &'static str,\n        pub horizontal_up: &'static str,\n        pub cross: &'static str,\n    }","Real(LocalPath(\"src/symbols.rs\"))"],"terminal::Frame":["/// Represents a consistent terminal interface for rendering.\npub struct Frame<'a, B: 'a>\nwhere\n    B: Backend,\n{\n    terminal: &'a mut Terminal<B>,\n\n    /// Where should the cursor be after drawing this frame?\n    ///\n    /// If `None`, the cursor is hidden and its position is controlled by the backend. If `Some((x,\n    /// y))`, the cursor is shown and placed at `(x, y)` after the call to `Terminal::draw()`.\n    cursor_position: Option<(u16, u16)>,\n}","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Frame::<'a, B>::render_stateful_widget":["/// Render a [`StatefulWidget`] to the current buffer using [`StatefulWidget::render`].\n///\n/// The last argument should be an instance of the [`StatefulWidget::State`] associated to the\n/// given [`StatefulWidget`].\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use std::io;\n/// # use tui::Terminal;\n/// # use tui::backend::TermionBackend;\n/// # use tui::layout::Rect;\n/// # use tui::widgets::{List, ListItem, ListState};\n/// # let stdout = io::stdout();\n/// # let backend = TermionBackend::new(stdout);\n/// # let mut terminal = Terminal::new(backend).unwrap();\n/// let mut state = ListState::default();\n/// state.select(Some(1));\n/// let items = vec![\n///     ListItem::new(\"Item 1\"),\n///     ListItem::new(\"Item 2\"),\n/// ];\n/// let list = List::new(items);\n/// let area = Rect::new(0, 0, 5, 5);\n/// let mut frame = terminal.get_frame();\n/// frame.render_stateful_widget(list, area, &mut state);\n/// ```\npub fn render_stateful_widget<W>(&mut self, widget: W, area: Rect, state: &mut W::State)\n    where\n        W: StatefulWidget,{\n        widget.render(area, self.terminal.current_buffer_mut(), state);\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Frame::<'a, B>::render_widget":["/// Render a [`Widget`] to the current buffer using [`Widget::render`].\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use std::io;\n/// # use tui::Terminal;\n/// # use tui::backend::TermionBackend;\n/// # use tui::layout::Rect;\n/// # use tui::widgets::Block;\n/// # let stdout = io::stdout();\n/// # let backend = TermionBackend::new(stdout);\n/// # let mut terminal = Terminal::new(backend).unwrap();\n/// let block = Block::default();\n/// let area = Rect::new(0, 0, 5, 5);\n/// let mut frame = terminal.get_frame();\n/// frame.render_widget(block, area);\n/// ```\npub fn render_widget<W>(&mut self, widget: W, area: Rect)\n    where\n        W: Widget,{\n        widget.render(area, self.terminal.current_buffer_mut());\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Frame::<'a, B>::set_cursor":["/// After drawing this frame, make the cursor visible and put it at the specified (x, y)\n/// coordinates. If this method is not called, the cursor will be hidden.\n///\n/// Note that this will interfere with calls to `Terminal::hide_cursor()`,\n/// `Terminal::show_cursor()`, and `Terminal::set_cursor()`. Pick one of the APIs and stick\n/// with it.\npub fn set_cursor(&mut self, x: u16, y: u16){\n        self.cursor_position = Some((x, y));\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Frame::<'a, B>::size":["/// Terminal size, guaranteed not to change when rendering.\npub fn size(&self) -> Rect{\n        self.terminal.viewport.area\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::ResizeBehavior":["/// UNSTABLE\nenum ResizeBehavior {\n    Fixed,\n    Auto,\n}","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal":["/// Interface to the terminal backed by Termion\npub struct Terminal<B>\nwhere\n    B: Backend,\n{\n    backend: B,\n    /// Holds the results of the current and previous draw calls. The two are compared at the end\n    /// of each draw pass to output the necessary updates to the terminal\n    buffers: [Buffer; 2],\n    /// Index of the current buffer in the previous array\n    current: usize,\n    /// Whether the cursor is currently hidden\n    hidden_cursor: bool,\n    /// Viewport\n    viewport: Viewport,\n}","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::autoresize":["/// Queries the backend for size and resizes if it doesn't match the previous size.\npub fn autoresize(&mut self) -> io::Result<()>{\n        if self.viewport.resize_behavior == ResizeBehavior::Auto {\n            let size = self.size()?;\n            if size != self.viewport.area {\n                self.resize(size)?;\n            }\n        };\n        Ok(())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::backend":["pub fn backend(&self) -> &B{\n        &self.backend\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::backend_mut":["pub fn backend_mut(&mut self) -> &mut B{\n        &mut self.backend\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::clear":["/// Clear the terminal and force a full redraw on the next draw call.\npub fn clear(&mut self) -> io::Result<()>{\n        self.backend.clear()?;\n        // Reset the back buffer to make sure the next update will redraw everything.\n        self.buffers[1 - self.current].reset();\n        Ok(())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::current_buffer_mut":["pub fn current_buffer_mut(&mut self) -> &mut Buffer{\n        &mut self.buffers[self.current]\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::draw":["/// Synchronizes terminal size, calls the rendering closure, flushes the current internal state\n/// and prepares for the next draw call.\npub fn draw<F>(&mut self, f: F) -> io::Result<()>\n    where\n        F: FnOnce(&mut Frame<B>),{\n        // Autoresize - otherwise we get glitches if shrinking or potential desync between widgets\n        // and the terminal (if growing), which may OOB.\n        self.autoresize()?;\n\n        let mut frame = self.get_frame();\n        f(&mut frame);\n        // We can't change the cursor position right away because we have to flush the frame to\n        // stdout first. But we also can't keep the frame around, since it holds a &mut to\n        // Terminal. Thus, we're taking the important data out of the Frame and dropping it.\n        let cursor_position = frame.cursor_position;\n\n        // Draw to stdout\n        self.flush()?;\n\n        match cursor_position {\n            None => self.hide_cursor()?,\n            Some((x, y)) => {\n                self.show_cursor()?;\n                self.set_cursor(x, y)?;\n            }\n        }\n\n        // Swap buffers\n        self.buffers[1 - self.current].reset();\n        self.current = 1 - self.current;\n\n        // Flush\n        self.backend.flush()?;\n        Ok(())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::flush":["/// Obtains a difference between the previous and the current buffer and passes it to the\n/// current backend for drawing.\npub fn flush(&mut self) -> io::Result<()>{\n        let previous_buffer = &self.buffers[1 - self.current];\n        let current_buffer = &self.buffers[self.current];\n        let updates = previous_buffer.diff(current_buffer);\n        self.backend.draw(updates.into_iter())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::get_cursor":["pub fn get_cursor(&mut self) -> io::Result<(u16, u16)>{\n        self.backend.get_cursor()\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::get_frame":["/// Get a Frame object which provides a consistent view into the terminal state for rendering.\npub fn get_frame(&mut self) -> Frame<B>{\n        Frame {\n            terminal: self,\n            cursor_position: None,\n        }\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::hide_cursor":["pub fn hide_cursor(&mut self) -> io::Result<()>{\n        self.backend.hide_cursor()?;\n        self.hidden_cursor = true;\n        Ok(())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::new":["/// Wrapper around Terminal initialization. Each buffer is initialized with a blank string and\n/// default colors for the foreground and the background\npub fn new(backend: B) -> io::Result<Terminal<B>>{\n        let size = backend.size()?;\n        Terminal::with_options(\n            backend,\n            TerminalOptions {\n                viewport: Viewport {\n                    area: size,\n                    resize_behavior: ResizeBehavior::Auto,\n                },\n            },\n        )\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::resize":["/// Updates the Terminal so that internal buffers match the requested size. Requested size will\n/// be saved so the size can remain consistent when rendering.\n/// This leads to a full clear of the screen.\npub fn resize(&mut self, area: Rect) -> io::Result<()>{\n        self.buffers[self.current].resize(area);\n        self.buffers[1 - self.current].resize(area);\n        self.viewport.area = area;\n        self.clear()\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::set_cursor":["pub fn set_cursor(&mut self, x: u16, y: u16) -> io::Result<()>{\n        self.backend.set_cursor(x, y)\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::show_cursor":["pub fn show_cursor(&mut self) -> io::Result<()>{\n        self.backend.show_cursor()?;\n        self.hidden_cursor = false;\n        Ok(())\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::size":["/// Queries the real size of the backend.\npub fn size(&self) -> io::Result<Rect>{\n        self.backend.size()\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Terminal::<B>::with_options":["/// UNSTABLE\npub fn with_options(backend: B, options: TerminalOptions) -> io::Result<Terminal<B>>{\n        Ok(Terminal {\n            backend,\n            buffers: [\n                Buffer::empty(options.viewport.area),\n                Buffer::empty(options.viewport.area),\n            ],\n            current: 0,\n            hidden_cursor: false,\n            viewport: options.viewport,\n        })\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::TerminalOptions":["/// Options to pass to [`Terminal::with_options`]\npub struct TerminalOptions {\n    /// Viewport used to draw to the terminal\n    pub viewport: Viewport,\n}","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Viewport":["/// UNSTABLE\npub struct Viewport {\n    area: Rect,\n    resize_behavior: ResizeBehavior,\n}","Real(LocalPath(\"src/terminal.rs\"))"],"terminal::Viewport::fixed":["/// UNSTABLE\npub fn fixed(area: Rect) -> Viewport{\n        Viewport {\n            area,\n            resize_behavior: ResizeBehavior::Fixed,\n        }\n    }","Real(LocalPath(\"src/terminal.rs\"))"],"text::<impl std::convert::From<text::Spans<'a>> for std::string::String>::from":["fn from(line: Spans<'a>) -> String{\n        line.0.iter().fold(String::new(), |mut acc, s| {\n            acc.push_str(s.content.as_ref());\n            acc\n        })\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Span":["/// A string where all graphemes have the same style.\npub struct Span<'a> {\n    pub content: Cow<'a, str>,\n    pub style: Style,\n}","Real(LocalPath(\"src/text.rs\"))"],"text::Span::<'a>::raw":["/// Create a span with no style.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::text::Span;\n/// Span::raw(\"My text\");\n/// Span::raw(String::from(\"My text\"));\n/// ```\npub fn raw<T>(content: T) -> Span<'a>\n    where\n        T: Into<Cow<'a, str>>,{\n        Span {\n            content: content.into(),\n            style: Style::default(),\n        }\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Span::<'a>::styled":["/// Create a span with a style.\n///\n/// # Examples\n///\n/// ```rust\n/// # use tui::text::Span;\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n/// Span::styled(\"My text\", style);\n/// Span::styled(String::from(\"My text\"), style);\n/// ```\npub fn styled<T>(content: T, style: Style) -> Span<'a>\n    where\n        T: Into<Cow<'a, str>>,{\n        Span {\n            content: content.into(),\n            style,\n        }\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Span::<'a>::styled_graphemes":["/// Returns an iterator over the graphemes held by this span.\n///\n/// `base_style` is the [`Style`] that will be patched with each grapheme [`Style`] to get\n/// the resulting [`Style`].\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::text::{Span, StyledGrapheme};\n/// # use tui::style::{Color, Modifier, Style};\n/// # use std::iter::Iterator;\n/// let style = Style::default().fg(Color::Yellow);\n/// let span = Span::styled(\"Text\", style);\n/// let style = Style::default().fg(Color::Green).bg(Color::Black);\n/// let styled_graphemes = span.styled_graphemes(style);\n/// assert_eq!(\n///     vec![\n///         StyledGrapheme {\n///             symbol: \"T\",\n///             style: Style {\n///                 fg: Some(Color::Yellow),\n///                 bg: Some(Color::Black),\n///                 add_modifier: Modifier::empty(),\n///                 sub_modifier: Modifier::empty(),\n///             },\n///         },\n///         StyledGrapheme {\n///             symbol: \"e\",\n///             style: Style {\n///                 fg: Some(Color::Yellow),\n///                 bg: Some(Color::Black),\n///                 add_modifier: Modifier::empty(),\n///                 sub_modifier: Modifier::empty(),\n///             },\n///         },\n///         StyledGrapheme {\n///             symbol: \"x\",\n///             style: Style {\n///                 fg: Some(Color::Yellow),\n///                 bg: Some(Color::Black),\n///                 add_modifier: Modifier::empty(),\n///                 sub_modifier: Modifier::empty(),\n///             },\n///         },\n///         StyledGrapheme {\n///             symbol: \"t\",\n///             style: Style {\n///                 fg: Some(Color::Yellow),\n///                 bg: Some(Color::Black),\n///                 add_modifier: Modifier::empty(),\n///                 sub_modifier: Modifier::empty(),\n///             },\n///         },\n///     ],\n///     styled_graphemes.collect::<Vec<StyledGrapheme>>()\n/// );\n/// ```\npub fn styled_graphemes(\n        &'a self,\n        base_style: Style,\n    ) -> impl Iterator<Item = StyledGrapheme<'a>>{\n        UnicodeSegmentation::graphemes(self.content.as_ref(), true)\n            .map(move |g| StyledGrapheme {\n                symbol: g,\n                style: base_style.patch(self.style),\n            })\n            .filter(|s| s.symbol != \"\\n\")\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Span::<'a>::width":["/// Returns the width of the content held by this span.\npub fn width(&self) -> usize{\n        self.content.width()\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Spans":["/// A string composed of clusters of graphemes, each with their own style.\npub struct Spans<'a>(pub Vec<Span<'a>>);","Real(LocalPath(\"src/text.rs\"))"],"text::Spans::<'a>::width":["/// Returns the width of the underlying string.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::text::{Span, Spans};\n/// # use tui::style::{Color, Style};\n/// let spans = Spans::from(vec![\n///     Span::styled(\"My\", Style::default().fg(Color::Yellow)),\n///     Span::raw(\" text\"),\n/// ]);\n/// assert_eq!(7, spans.width());\n/// ```\npub fn width(&self) -> usize{\n        self.0.iter().map(Span::width).sum()\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::StyledGrapheme":["/// A grapheme associated to a style.\npub struct StyledGrapheme<'a> {\n    pub symbol: &'a str,\n    pub style: Style,\n}","Real(LocalPath(\"src/text.rs\"))"],"text::Text":["/// A string split over multiple lines where each line is composed of several clusters, each with\n/// their own style.\n///\n/// A [`Text`], like a [`Span`], can be constructed using one of the many `From` implementations\n/// or via the [`Text::raw`] and [`Text::styled`] methods. Helpfully, [`Text`] also implements\n/// [`core::iter::Extend`] which enables the concatenation of several [`Text`] blocks.\n///\n/// ```rust\n/// # use tui::text::Text;\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n///\n/// // An initial two lines of `Text` built from a `&str`\n/// let mut text = Text::from(\"The first line\\nThe second line\");\n/// assert_eq!(2, text.height());\n///\n/// // Adding two more unstyled lines\n/// text.extend(Text::raw(\"These are two\\nmore lines!\"));\n/// assert_eq!(4, text.height());\n///\n/// // Adding a final two styled lines\n/// text.extend(Text::styled(\"Some more lines\\nnow with more style!\", style));\n/// assert_eq!(6, text.height());\n/// ```\npub struct Text<'a> {\n    pub lines: Vec<Spans<'a>>,\n}","Real(LocalPath(\"src/text.rs\"))"],"text::Text::<'a>::height":["/// Returns the height.\n///\n/// ## Examples\n///\n/// ```rust\n/// use tui::text::Text;\n/// let text = Text::from(\"The first line\\nThe second line\");\n/// assert_eq!(2, text.height());\n/// ```\npub fn height(&self) -> usize{\n        self.lines.len()\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Text::<'a>::patch_style":["/// Apply a new style to existing text.\n///\n/// # Examples\n///\n/// ```rust\n/// # use tui::text::Text;\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n/// let mut raw_text = Text::raw(\"The first line\\nThe second line\");\n/// let styled_text = Text::styled(String::from(\"The first line\\nThe second line\"), style);\n/// assert_ne!(raw_text, styled_text);\n///\n/// raw_text.patch_style(style);\n/// assert_eq!(raw_text, styled_text);\n/// ```\npub fn patch_style(&mut self, style: Style){\n        for line in &mut self.lines {\n            for span in &mut line.0 {\n                span.style = span.style.patch(style);\n            }\n        }\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Text::<'a>::raw":["/// Create some text (potentially multiple lines) with no style.\n///\n/// ## Examples\n///\n/// ```rust\n/// # use tui::text::Text;\n/// Text::raw(\"The first line\\nThe second line\");\n/// Text::raw(String::from(\"The first line\\nThe second line\"));\n/// ```\npub fn raw<T>(content: T) -> Text<'a>\n    where\n        T: Into<Cow<'a, str>>,{\n        Text {\n            lines: match content.into() {\n                Cow::Borrowed(s) => s.lines().map(Spans::from).collect(),\n                Cow::Owned(s) => s.lines().map(|l| Spans::from(l.to_owned())).collect(),\n            },\n        }\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Text::<'a>::styled":["/// Create some text (potentially multiple lines) with a style.\n///\n/// # Examples\n///\n/// ```rust\n/// # use tui::text::Text;\n/// # use tui::style::{Color, Modifier, Style};\n/// let style = Style::default().fg(Color::Yellow).add_modifier(Modifier::ITALIC);\n/// Text::styled(\"The first line\\nThe second line\", style);\n/// Text::styled(String::from(\"The first line\\nThe second line\"), style);\n/// ```\npub fn styled<T>(content: T, style: Style) -> Text<'a>\n    where\n        T: Into<Cow<'a, str>>,{\n        let mut text = Text::raw(content);\n        text.patch_style(style);\n        text\n    }","Real(LocalPath(\"src/text.rs\"))"],"text::Text::<'a>::width":["/// Returns the max width of all the lines.\n///\n/// ## Examples\n///\n/// ```rust\n/// use tui::text::Text;\n/// let text = Text::from(\"The first line\\nThe second line\");\n/// assert_eq!(15, text.width());\n/// ```\npub fn width(&self) -> usize{\n        self.lines\n            .iter()\n            .map(Spans::width)\n            .max()\n            .unwrap_or_default()\n    }","Real(LocalPath(\"src/text.rs\"))"],"widgets::Borders":["#[$outer]\n$vis struct $BitFlags {\n            bits: $T,\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::all":["/// Returns the set containing all flags.\n#[inline]\npub const fn all() -> Self{\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::all::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n            $(\n                const $Flag: $T = 0;\n            )+\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::bits":["/// Returns the raw value of the flags currently stored.\n#[inline]\npub const fn bits(&self) -> $T{\n                self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::complement":["/// Returns the complement of this set of flags.\n///\n/// Specifically, the returned set contains all the flags which are\n/// not set in `self`, but which are allowed for this type.\n///\n/// Alternatively, it can be thought of as the set difference\n/// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n///\n/// This is equivalent to using the `!` operator (e.g.\n/// [`ops::Not`]), as in `!flags`.\n///\n/// [`Self::all()`]: Self::all\n/// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n#[inline]\n#[must_use]\npub const fn complement(self) -> Self{\n                Self::from_bits_truncate(!self.bits)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::contains":["/// Returns `true` if all of the flags in `other` are contained within `self`.\n#[inline]\npub const fn contains(&self, other: Self) -> bool{\n                (self.bits & other.bits) == other.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::difference":["/// Returns the difference between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags present in\n/// `self`, except for the ones present in `other`.\n///\n/// It is also conceptually equivalent to the \"bit-clear\" operation:\n/// `flags & !other` (and this syntax is also supported).\n///\n/// This is equivalent to using the `-` operator (e.g.\n/// [`ops::Sub`]), as in `flags - other`.\n///\n/// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n#[inline]\n#[must_use]\npub const fn difference(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::empty":["/// Returns an empty set of flags.\n#[inline]\npub const fn empty() -> Self{\n                Self { bits: 0 }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::from_bits":["/// Convert from underlying bit representation, unless that\n/// representation contains bits that do not correspond to a flag.\n#[inline]\npub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self>{\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::from_bits_truncate":["/// Convert from underlying bit representation, dropping any bits\n/// that do not correspond to flags.\n#[inline]\npub const fn from_bits_truncate(bits: $T) -> Self{\n                Self { bits: bits & Self::all().bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::from_bits_unchecked":["/// Convert from underlying bit representation, preserving all\n/// bits (even those not corresponding to a defined flag).\n///\n/// # Safety\n///\n/// The caller of the `bitflags!` macro can chose to allow or\n/// disallow extra bits for their bitflags type.\n///\n/// The caller of `from_bits_unchecked()` has to ensure that\n/// all bits correspond to a defined flag or that extra bits\n/// are valid for this bitflags type.\n#[inline]\npub const unsafe fn from_bits_unchecked(bits: $T) -> Self{\n                Self { bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::insert":["/// Inserts the specified flags in-place.\n#[inline]\npub fn insert(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::intersection":["/// Returns the intersection between the flags in `self` and\n/// `other`.\n///\n/// Specifically, the returned set contains only the flags which are\n/// present in *both* `self` *and* `other`.\n///\n/// This is equivalent to using the `&` operator (e.g.\n/// [`ops::BitAnd`]), as in `flags & other`.\n///\n/// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n#[inline]\n#[must_use]\npub const fn intersection(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::intersects":["/// Returns `true` if there are flags common to both `self` and `other`.\n#[inline]\npub const fn intersects(&self, other: Self) -> bool{\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::is_all":["/// Returns `true` if all flags are currently set.\n#[inline]\npub const fn is_all(&self) -> bool{\n                Self::all().bits | self.bits == self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::is_empty":["/// Returns `true` if no flags are currently stored.\n#[inline]\npub const fn is_empty(&self) -> bool{\n                self.bits() == Self::empty().bits()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::remove":["/// Removes the specified flags in-place.\n#[inline]\npub fn remove(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::set":["/// Inserts or removes the specified flags depending on the passed value.\n#[inline]\npub fn set(&mut self, other: Self, value: bool){\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::symmetric_difference":["/// Returns the [symmetric difference][sym-diff] between the flags\n/// in `self` and `other`.\n///\n/// Specifically, the returned set contains the flags present which\n/// are present in `self` or `other`, but that are not present in\n/// both. Equivalently, it contains the flags present in *exactly\n/// one* of the sets `self` and `other`.\n///\n/// This is equivalent to using the `^` operator (e.g.\n/// [`ops::BitXor`]), as in `flags ^ other`.\n///\n/// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n/// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n#[inline]\n#[must_use]\npub const fn symmetric_difference(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::toggle":["/// Toggles the specified flags in-place.\n#[inline]\npub fn toggle(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::Borders::union":["/// Returns the union of between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags which are\n/// present in *either* `self` *or* `other`, including any which are\n/// present in both (see [`Self::symmetric_difference`] if that\n/// is undesirable).\n///\n/// This is equivalent to using the `|` operator (e.g.\n/// [`ops::BitOr`]), as in `flags | other`.\n///\n/// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n#[inline]\n#[must_use]\npub const fn union(self, other: Self) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"widgets::StatefulWidget":["/// A `StatefulWidget` is a widget that can take advantage of some local state to remember things\n/// between two draw calls.\n///\n/// Most widgets can be drawn directly based on the input parameters. However, some features may\n/// require some kind of associated state to be implemented.\n///\n/// For example, the [`List`] widget can highlight the item currently selected. This can be\n/// translated in an offset, which is the number of elements to skip in order to have the selected\n/// item within the viewport currently allocated to this widget. The widget can therefore only\n/// provide the following behavior: whenever the selected item is out of the viewport scroll to a\n/// predefined position (making the selected item the last viewable item or the one in the middle\n/// for example). Nonetheless, if the widget has access to the last computed offset then it can\n/// implement a natural scrolling experience where the last offset is reused until the selected\n/// item is out of the viewport.\n///\n/// ## Examples\n///\n/// ```rust,no_run\n/// # use std::io;\n/// # use tui::Terminal;\n/// # use tui::backend::{Backend, TermionBackend};\n/// # use tui::widgets::{Widget, List, ListItem, ListState};\n///\n/// // Let's say we have some events to display.\n/// struct Events {\n///     // `items` is the state managed by your application.\n///     items: Vec<String>,\n///     // `state` is the state that can be modified by the UI. It stores the index of the selected\n///     // item as well as the offset computed during the previous draw call (used to implement\n///     // natural scrolling).\n///     state: ListState\n/// }\n///\n/// impl Events {\n///     fn new(items: Vec<String>) -> Events {\n///         Events {\n///             items,\n///             state: ListState::default(),\n///         }\n///     }\n///\n///     pub fn set_items(&mut self, items: Vec<String>) {\n///         self.items = items;\n///         // We reset the state as the associated items have changed. This effectively reset\n///         // the selection as well as the stored offset.\n///         self.state = ListState::default();\n///     }\n///\n///     // Select the next item. This will not be reflected until the widget is drawn in the\n///     // `Terminal::draw` callback using `Frame::render_stateful_widget`.\n///     pub fn next(&mut self) {\n///         let i = match self.state.selected() {\n///             Some(i) => {\n///                 if i >= self.items.len() - 1 {\n///                     0\n///                 } else {\n///                     i + 1\n///                 }\n///             }\n///             None => 0,\n///         };\n///         self.state.select(Some(i));\n///     }\n///\n///     // Select the previous item. This will not be reflected until the widget is drawn in the\n///     // `Terminal::draw` callback using `Frame::render_stateful_widget`.\n///     pub fn previous(&mut self) {\n///         let i = match self.state.selected() {\n///             Some(i) => {\n///                 if i == 0 {\n///                     self.items.len() - 1\n///                 } else {\n///                     i - 1\n///                 }\n///             }\n///             None => 0,\n///         };\n///         self.state.select(Some(i));\n///     }\n///\n///     // Unselect the currently selected item if any. The implementation of `ListState` makes\n///     // sure that the stored offset is also reset.\n///     pub fn unselect(&mut self) {\n///         self.state.select(None);\n///     }\n/// }\n///\n/// let stdout = io::stdout();\n/// let backend = TermionBackend::new(stdout);\n/// let mut terminal = Terminal::new(backend).unwrap();\n///\n/// let mut events = Events::new(vec![\n///     String::from(\"Item 1\"),\n///     String::from(\"Item 2\")\n/// ]);\n///\n/// loop {\n///     terminal.draw(|f| {\n///         // The items managed by the application are transformed to something\n///         // that is understood by tui.\n///         let items: Vec<ListItem>= events.items.iter().map(|i| ListItem::new(i.as_ref())).collect();\n///         // The `List` widget is then built with those items.\n///         let list = List::new(items);\n///         // Finally the widget is rendered using the associated state. `events.state` is\n///         // effectively the only thing that we will \"remember\" from this draw call.\n///         f.render_stateful_widget(list, f.size(), &mut events.state);\n///     });\n///\n///     // In response to some input events or an external http request or whatever:\n///     events.next();\n/// }\n/// ```\npub trait StatefulWidget {\n    type State;\n    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State);\n}","Real(LocalPath(\"src/widgets/mod.rs\"))"],"widgets::Widget":["/// Base requirements for a Widget\npub trait Widget {\n    /// Draws the current state of the widget in the given buffer. That the only method required to\n    /// implement a custom widget.\n    fn render(self, area: Rect, buf: &mut Buffer);\n}","Real(LocalPath(\"src/widgets/mod.rs\"))"],"widgets::barchart::BarChart":["/// Display multiple bars in a single widgets\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders, BarChart};\n/// # use tui::style::{Style, Color, Modifier};\n/// BarChart::default()\n///     .block(Block::default().title(\"BarChart\").borders(Borders::ALL))\n///     .bar_width(3)\n///     .bar_gap(1)\n///     .bar_style(Style::default().fg(Color::Yellow).bg(Color::Red))\n///     .value_style(Style::default().fg(Color::Red).add_modifier(Modifier::BOLD))\n///     .label_style(Style::default().fg(Color::White))\n///     .data(&[(\"B0\", 0), (\"B1\", 2), (\"B2\", 4), (\"B3\", 3)])\n///     .max(4);\n/// ```\npub struct BarChart<'a> {\n    /// Block to wrap the widget in\n    block: Option<Block<'a>>,\n    /// The width of each bar\n    bar_width: u16,\n    /// The gap between each bar\n    bar_gap: u16,\n    /// Set of symbols used to display the data\n    bar_set: symbols::bar::Set,\n    /// Style of the bars\n    bar_style: Style,\n    /// Style of the values printed at the bottom of each bar\n    value_style: Style,\n    /// Style of the labels printed under each bar\n    label_style: Style,\n    /// Style for the widget\n    style: Style,\n    /// Slice of (label, value) pair to plot on the chart\n    data: &'a [(&'a str, u64)],\n    /// Value necessary for a bar to reach the maximum height (if no value is specified,\n    /// the maximum value in the data is taken as reference)\n    max: Option<u64>,\n    /// Values to display on the bar (computed when the data is passed to the widget)\n    values: Vec<String>,\n}","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::bar_gap":["pub fn bar_gap(mut self, gap: u16) -> BarChart<'a>{\n        self.bar_gap = gap;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::bar_set":["pub fn bar_set(mut self, bar_set: symbols::bar::Set) -> BarChart<'a>{\n        self.bar_set = bar_set;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::bar_style":["pub fn bar_style(mut self, style: Style) -> BarChart<'a>{\n        self.bar_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::bar_width":["pub fn bar_width(mut self, width: u16) -> BarChart<'a>{\n        self.bar_width = width;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> BarChart<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::data":["pub fn data(mut self, data: &'a [(&'a str, u64)]) -> BarChart<'a>{\n        self.data = data;\n        self.values = Vec::with_capacity(self.data.len());\n        for &(_, v) in self.data {\n            self.values.push(format!(\"{}\", v));\n        }\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::label_style":["pub fn label_style(mut self, style: Style) -> BarChart<'a>{\n        self.label_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::max":["pub fn max(mut self, max: u64) -> BarChart<'a>{\n        self.max = Some(max);\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::style":["pub fn style(mut self, style: Style) -> BarChart<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::barchart::BarChart::<'a>::value_style":["pub fn value_style(mut self, style: Style) -> BarChart<'a>{\n        self.value_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/barchart.rs\"))"],"widgets::block::Block":["/// Base widget to be used with all upper level ones. It may be used to display a box border around\n/// the widget and/or add a title.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, BorderType, Borders};\n/// # use tui::style::{Style, Color};\n/// Block::default()\n///     .title(\"Block\")\n///     .borders(Borders::LEFT | Borders::RIGHT)\n///     .border_style(Style::default().fg(Color::White))\n///     .border_type(BorderType::Rounded)\n///     .style(Style::default().bg(Color::Black));\n/// ```\npub struct Block<'a> {\n    /// Optional title place on the upper left of the block\n    title: Option<Spans<'a>>,\n    /// Visible borders\n    borders: Borders,\n    /// Border style\n    border_style: Style,\n    /// Type of the border. The default is plain lines but one can choose to have rounded corners\n    /// or doubled lines instead.\n    border_type: BorderType,\n    /// Widget style\n    style: Style,\n}","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::border_style":["pub fn border_style(mut self, style: Style) -> Block<'a>{\n        self.border_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::border_type":["pub fn border_type(mut self, border_type: BorderType) -> Block<'a>{\n        self.border_type = border_type;\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::borders":["pub fn borders(mut self, flag: Borders) -> Block<'a>{\n        self.borders = flag;\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::inner":["/// Compute the inner area of a block based on its border visibility rules.\npub fn inner(&self, area: Rect) -> Rect{\n        if area.width < 2 || area.height < 2 {\n            return Rect::default();\n        }\n        let mut inner = area;\n        if self.borders.intersects(Borders::LEFT) {\n            inner.x += 1;\n            inner.width -= 1;\n        }\n        if self.borders.intersects(Borders::TOP) || self.title.is_some() {\n            inner.y += 1;\n            inner.height -= 1;\n        }\n        if self.borders.intersects(Borders::RIGHT) {\n            inner.width -= 1;\n        }\n        if self.borders.intersects(Borders::BOTTOM) {\n            inner.height -= 1;\n        }\n        inner\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::style":["pub fn style(mut self, style: Style) -> Block<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::title":["pub fn title<T>(mut self, title: T) -> Block<'a>\n    where\n        T: Into<Spans<'a>>,{\n        self.title = Some(title.into());\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::Block::<'a>::title_style":["#[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `text::Spans` given as argument of the `title` method to apply styling to the title.\"\n    )]\npub fn title_style(mut self, style: Style) -> Block<'a>{\n        if let Some(t) = self.title {\n            let title = String::from(t);\n            self.title = Some(Spans::from(Span::styled(title, style)));\n        }\n        self\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::BorderType":["pub enum BorderType {\n    Plain,\n    Rounded,\n    Double,\n    Thick,\n}","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::block::BorderType::line_symbols":["pub fn line_symbols(border_type: BorderType) -> line::Set{\n        match border_type {\n            BorderType::Plain => line::NORMAL,\n            BorderType::Rounded => line::ROUNDED,\n            BorderType::Double => line::DOUBLE,\n            BorderType::Thick => line::THICK,\n        }\n    }","Real(LocalPath(\"src/widgets/block.rs\"))"],"widgets::canvas::BrailleGrid":["struct BrailleGrid {\n    width: u16,\n    height: u16,\n    cells: Vec<u16>,\n    colors: Vec<Color>,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::BrailleGrid::new":["fn new(width: u16, height: u16) -> BrailleGrid{\n        let length = usize::from(width * height);\n        BrailleGrid {\n            width,\n            height,\n            cells: vec![symbols::braille::BLANK; length],\n            colors: vec![Color::Reset; length],\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas":["/// The Canvas widget may be used to draw more detailed figures using braille patterns (each\n/// cell can have a braille character in 8 different positions).\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders};\n/// # use tui::layout::Rect;\n/// # use tui::widgets::canvas::{Canvas, Shape, Line, Rectangle, Map, MapResolution};\n/// # use tui::style::Color;\n/// Canvas::default()\n///     .block(Block::default().title(\"Canvas\").borders(Borders::ALL))\n///     .x_bounds([-180.0, 180.0])\n///     .y_bounds([-90.0, 90.0])\n///     .paint(|ctx| {\n///         ctx.draw(&Map {\n///             resolution: MapResolution::High,\n///             color: Color::White\n///         });\n///         ctx.layer();\n///         ctx.draw(&Line {\n///             x1: 0.0,\n///             y1: 10.0,\n///             x2: 10.0,\n///             y2: 10.0,\n///             color: Color::White,\n///         });\n///         ctx.draw(&Rectangle {\n///             x: 10.0,\n///             y: 20.0,\n///             width: 10.0,\n///             height: 10.0,\n///             color: Color::Red\n///         });\n///     });\n/// ```\npub struct Canvas<'a, F>\nwhere\n    F: Fn(&mut Context),\n{\n    block: Option<Block<'a>>,\n    x_bounds: [f64; 2],\n    y_bounds: [f64; 2],\n    painter: Option<F>,\n    background_color: Color,\n    marker: symbols::Marker,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::background_color":["pub fn background_color(mut self, color: Color) -> Canvas<'a, F>{\n        self.background_color = color;\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::block":["pub fn block(mut self, block: Block<'a>) -> Canvas<'a, F>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::marker":["/// Change the type of points used to draw the shapes. By default the braille patterns are used\n/// as they provide a more fine grained result but you might want to use the simple dot or\n/// block instead if the targeted terminal does not support those symbols.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::canvas::Canvas;\n/// # use tui::symbols;\n/// Canvas::default().marker(symbols::Marker::Braille).paint(|ctx| {});\n///\n/// Canvas::default().marker(symbols::Marker::Dot).paint(|ctx| {});\n///\n/// Canvas::default().marker(symbols::Marker::Block).paint(|ctx| {});\n/// ```\npub fn marker(mut self, marker: symbols::Marker) -> Canvas<'a, F>{\n        self.marker = marker;\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::paint":["/// Store the closure that will be used to draw to the Canvas\npub fn paint(mut self, f: F) -> Canvas<'a, F>{\n        self.painter = Some(f);\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::x_bounds":["pub fn x_bounds(mut self, bounds: [f64; 2]) -> Canvas<'a, F>{\n        self.x_bounds = bounds;\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Canvas::<'a, F>::y_bounds":["pub fn y_bounds(mut self, bounds: [f64; 2]) -> Canvas<'a, F>{\n        self.y_bounds = bounds;\n        self\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::CharGrid":["struct CharGrid {\n    width: u16,\n    height: u16,\n    cells: Vec<char>,\n    colors: Vec<Color>,\n    cell_char: char,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::CharGrid::new":["fn new(width: u16, height: u16, cell_char: char) -> CharGrid{\n        let length = usize::from(width * height);\n        CharGrid {\n            width,\n            height,\n            cells: vec![' '; length],\n            colors: vec![Color::Reset; length],\n            cell_char,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context":["/// Holds the state of the Canvas when painting to it.\npub struct Context<'a> {\n    x_bounds: [f64; 2],\n    y_bounds: [f64; 2],\n    grid: Box<dyn Grid>,\n    dirty: bool,\n    layers: Vec<Layer>,\n    labels: Vec<Label<'a>>,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context::<'a>::draw":["/// Draw any object that may implement the Shape trait\npub fn draw<S>(&mut self, shape: &S)\n    where\n        S: Shape,{\n        self.dirty = true;\n        let mut painter = Painter::from(self);\n        shape.draw(&mut painter);\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context::<'a>::finish":["/// Push the last layer if necessary\nfn finish(&mut self){\n        if self.dirty {\n            self.layer()\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context::<'a>::layer":["/// Go one layer above in the canvas.\npub fn layer(&mut self){\n        self.layers.push(self.grid.save());\n        self.grid.reset();\n        self.dirty = false;\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context::<'a>::new":["pub fn new(\n        width: u16,\n        height: u16,\n        x_bounds: [f64; 2],\n        y_bounds: [f64; 2],\n        marker: symbols::Marker,\n    ) -> Context<'a>{\n        let grid: Box<dyn Grid> = match marker {\n            symbols::Marker::Dot => Box::new(CharGrid::new(width, height, '')),\n            symbols::Marker::Block => Box::new(CharGrid::new(width, height, '')),\n            symbols::Marker::Braille => Box::new(BrailleGrid::new(width, height)),\n        };\n        Context {\n            x_bounds,\n            y_bounds,\n            grid,\n            dirty: false,\n            layers: Vec::new(),\n            labels: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Context::<'a>::print":["/// Print a string on the canvas at the given position\npub fn print(&mut self, x: f64, y: f64, text: &'a str, color: Color){\n        self.labels.push(Label { x, y, text, color });\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Grid":["trait Grid: Debug {\n    fn width(&self) -> u16;\n    fn height(&self) -> u16;\n    fn resolution(&self) -> (f64, f64);\n    fn paint(&mut self, x: usize, y: usize, color: Color);\n    fn save(&self) -> Layer;\n    fn reset(&mut self);\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Label":["/// Label to draw some text on the canvas\npub struct Label<'a> {\n    pub x: f64,\n    pub y: f64,\n    pub text: &'a str,\n    pub color: Color,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Layer":["struct Layer {\n    string: String,\n    colors: Vec<Color>,\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Painter":["pub struct Painter<'a, 'b> {\n    context: &'a mut Context<'b>,\n    resolution: (f64, f64),\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Painter::<'a, 'b>::get_point":["/// Convert the (x, y) coordinates to location of a point on the grid\n///\n/// # Examples:\n/// ```\n/// use tui::{symbols, widgets::canvas::{Painter, Context}};\n///\n/// let mut ctx = Context::new(2, 2, [1.0, 2.0], [0.0, 2.0], symbols::Marker::Braille);\n/// let mut painter = Painter::from(&mut ctx);\n/// let point = painter.get_point(1.0, 0.0);\n/// assert_eq!(point, Some((0, 7)));\n/// let point = painter.get_point(1.5, 1.0);\n/// assert_eq!(point, Some((1, 3)));\n/// let point = painter.get_point(0.0, 0.0);\n/// assert_eq!(point, None);\n/// let point = painter.get_point(2.0, 2.0);\n/// assert_eq!(point, Some((3, 0)));\n/// let point = painter.get_point(1.0, 2.0);\n/// assert_eq!(point, Some((0, 0)));\n/// ```\npub fn get_point(&self, x: f64, y: f64) -> Option<(usize, usize)>{\n        let left = self.context.x_bounds[0];\n        let right = self.context.x_bounds[1];\n        let top = self.context.y_bounds[1];\n        let bottom = self.context.y_bounds[0];\n        if x < left || x > right || y < bottom || y > top {\n            return None;\n        }\n        let width = (self.context.x_bounds[1] - self.context.x_bounds[0]).abs();\n        let height = (self.context.y_bounds[1] - self.context.y_bounds[0]).abs();\n        if width == 0.0 || height == 0.0 {\n            return None;\n        }\n        let x = ((x - left) * self.resolution.0 / width) as usize;\n        let y = ((top - y) * self.resolution.1 / height) as usize;\n        Some((x, y))\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Painter::<'a, 'b>::paint":["/// Paint a point of the grid\n///\n/// # Examples:\n/// ```\n/// use tui::{style::Color, symbols, widgets::canvas::{Painter, Context}};\n///\n/// let mut ctx = Context::new(1, 1, [0.0, 2.0], [0.0, 2.0], symbols::Marker::Braille);\n/// let mut painter = Painter::from(&mut ctx);\n/// let cell = painter.paint(1, 3, Color::Red);\n/// ```\npub fn paint(&mut self, x: usize, y: usize, color: Color){\n        self.context.grid.paint(x, y, color);\n    }","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::Shape":["/// Interface for all shapes that may be drawn on a Canvas widget.\npub trait Shape {\n    fn draw(&self, painter: &mut Painter);\n}","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))"],"widgets::canvas::line::Line":["/// Shape to draw a line from (x1, y1) to (x2, y2) with the given color\npub struct Line {\n    pub x1: f64,\n    pub y1: f64,\n    pub x2: f64,\n    pub y2: f64,\n    pub color: Color,\n}","Real(LocalPath(\"src/widgets/canvas/line.rs\"))"],"widgets::canvas::line::draw_line_high":["fn draw_line_high(painter: &mut Painter, x1: usize, y1: usize, x2: usize, y2: usize, color: Color){\n    let dx = (x2 as isize - x1 as isize).abs();\n    let dy = (y2 - y1) as isize;\n    let mut d = 2 * dx - dy;\n    let mut x = x1;\n    for y in y1..=y2 {\n        painter.paint(x, y, color);\n        if d > 0 {\n            x = if x1 > x2 {\n                x.saturating_sub(1)\n            } else {\n                x.saturating_add(1)\n            };\n            d -= 2 * dy;\n        }\n        d += 2 * dx;\n    }\n}","Real(LocalPath(\"src/widgets/canvas/line.rs\"))"],"widgets::canvas::line::draw_line_low":["fn draw_line_low(painter: &mut Painter, x1: usize, y1: usize, x2: usize, y2: usize, color: Color){\n    let dx = (x2 - x1) as isize;\n    let dy = (y2 as isize - y1 as isize).abs();\n    let mut d = 2 * dy - dx;\n    let mut y = y1;\n    for x in x1..=x2 {\n        painter.paint(x, y, color);\n        if d > 0 {\n            y = if y1 > y2 {\n                y.saturating_sub(1)\n            } else {\n                y.saturating_add(1)\n            };\n            d -= 2 * dx;\n        }\n        d += 2 * dy;\n    }\n}","Real(LocalPath(\"src/widgets/canvas/line.rs\"))"],"widgets::canvas::map::Map":["/// Shape to draw a world map with the given resolution and color\npub struct Map {\n    pub resolution: MapResolution,\n    pub color: Color,\n}","Real(LocalPath(\"src/widgets/canvas/map.rs\"))"],"widgets::canvas::map::MapResolution":["pub enum MapResolution {\n    Low,\n    High,\n}","Real(LocalPath(\"src/widgets/canvas/map.rs\"))"],"widgets::canvas::map::MapResolution::data":["fn data(self) -> &'static [(f64, f64)]{\n        match self {\n            MapResolution::Low => &WORLD_LOW_RESOLUTION,\n            MapResolution::High => &WORLD_HIGH_RESOLUTION,\n        }\n    }","Real(LocalPath(\"src/widgets/canvas/map.rs\"))"],"widgets::canvas::points::Points":["/// A shape to draw a group of points with the given color\npub struct Points<'a> {\n    pub coords: &'a [(f64, f64)],\n    pub color: Color,\n}","Real(LocalPath(\"src/widgets/canvas/points.rs\"))"],"widgets::canvas::rectangle::Rectangle":["/// Shape to draw a rectangle from a `Rect` with the given color\npub struct Rectangle {\n    pub x: f64,\n    pub y: f64,\n    pub width: f64,\n    pub height: f64,\n    pub color: Color,\n}","Real(LocalPath(\"src/widgets/canvas/rectangle.rs\"))"],"widgets::chart::Axis":["/// An X or Y axis for the chart widget\npub struct Axis<'a> {\n    /// Title displayed next to axis end\n    title: Option<Spans<'a>>,\n    /// Bounds for the axis (all data points outside these limits will not be represented)\n    bounds: [f64; 2],\n    /// A list of labels to put to the left or below the axis\n    labels: Option<Vec<Span<'a>>>,\n    /// The style used to draw the axis itself\n    style: Style,\n}","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Axis::<'a>::bounds":["pub fn bounds(mut self, bounds: [f64; 2]) -> Axis<'a>{\n        self.bounds = bounds;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Axis::<'a>::labels":["pub fn labels(mut self, labels: Vec<Span<'a>>) -> Axis<'a>{\n        self.labels = Some(labels);\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Axis::<'a>::style":["pub fn style(mut self, style: Style) -> Axis<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Axis::<'a>::title":["pub fn title<T>(mut self, title: T) -> Axis<'a>\n    where\n        T: Into<Spans<'a>>,{\n        self.title = Some(title.into());\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Axis::<'a>::title_style":["#[deprecated(\n        since = \"0.10.0\",\n        note = \"You should use styling capabilities of `text::Spans` given as argument of the `title` method to apply styling to the title.\"\n    )]\npub fn title_style(mut self, style: Style) -> Axis<'a>{\n        if let Some(t) = self.title {\n            let title = String::from(t);\n            self.title = Some(Spans::from(Span::styled(title, style)));\n        }\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart":["/// A widget to plot one or more dataset in a cartesian coordinate system\n///\n/// # Examples\n///\n/// ```\n/// # use tui::symbols;\n/// # use tui::widgets::{Block, Borders, Chart, Axis, Dataset, GraphType};\n/// # use tui::style::{Style, Color};\n/// # use tui::text::Span;\n/// let datasets = vec![\n///     Dataset::default()\n///         .name(\"data1\")\n///         .marker(symbols::Marker::Dot)\n///         .graph_type(GraphType::Scatter)\n///         .style(Style::default().fg(Color::Cyan))\n///         .data(&[(0.0, 5.0), (1.0, 6.0), (1.5, 6.434)]),\n///     Dataset::default()\n///         .name(\"data2\")\n///         .marker(symbols::Marker::Braille)\n///         .graph_type(GraphType::Line)\n///         .style(Style::default().fg(Color::Magenta))\n///         .data(&[(4.0, 5.0), (5.0, 8.0), (7.66, 13.5)]),\n/// ];\n/// Chart::new(datasets)\n///     .block(Block::default().title(\"Chart\"))\n///     .x_axis(Axis::default()\n///         .title(Span::styled(\"X Axis\", Style::default().fg(Color::Red)))\n///         .style(Style::default().fg(Color::White))\n///         .bounds([0.0, 10.0])\n///         .labels([\"0.0\", \"5.0\", \"10.0\"].iter().cloned().map(Span::from).collect()))\n///     .y_axis(Axis::default()\n///         .title(Span::styled(\"Y Axis\", Style::default().fg(Color::Red)))\n///         .style(Style::default().fg(Color::White))\n///         .bounds([0.0, 10.0])\n///         .labels([\"0.0\", \"5.0\", \"10.0\"].iter().cloned().map(Span::from).collect()));\n/// ```\npub struct Chart<'a> {\n    /// A block to display around the widget eventually\n    block: Option<Block<'a>>,\n    /// The horizontal axis\n    x_axis: Axis<'a>,\n    /// The vertical axis\n    y_axis: Axis<'a>,\n    /// A reference to the datasets\n    datasets: Vec<Dataset<'a>>,\n    /// The widget base style\n    style: Style,\n    /// Constraints used to determine whether the legend should be shown or not\n    hidden_legend_constraints: (Constraint, Constraint),\n}","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Chart<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::hidden_legend_constraints":["/// Set the constraints used to determine whether the legend should be shown or not.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::Chart;\n/// # use tui::layout::Constraint;\n/// let constraints = (\n///     Constraint::Ratio(1, 3),\n///     Constraint::Ratio(1, 4)\n/// );\n/// // Hide the legend when either its width is greater than 33% of the total widget width\n/// // or if its height is greater than 25% of the total widget height.\n/// let _chart: Chart = Chart::new(vec![])\n///     .hidden_legend_constraints(constraints);\n/// ```\npub fn hidden_legend_constraints(mut self, constraints: (Constraint, Constraint)) -> Chart<'a>{\n        self.hidden_legend_constraints = constraints;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::layout":["/// Compute the internal layout of the chart given the area. If the area is too small some\n/// elements may be automatically hidden\nfn layout(&self, area: Rect) -> ChartLayout{\n        let mut layout = ChartLayout::default();\n        if area.height == 0 || area.width == 0 {\n            return layout;\n        }\n        let mut x = area.left();\n        let mut y = area.bottom() - 1;\n\n        if self.x_axis.labels.is_some() && y > area.top() {\n            layout.label_x = Some(y);\n            y -= 1;\n        }\n\n        if let Some(ref y_labels) = self.y_axis.labels {\n            let mut max_width = y_labels.iter().map(Span::width).max().unwrap_or_default() as u16;\n            if let Some(ref x_labels) = self.x_axis.labels {\n                if !x_labels.is_empty() {\n                    max_width = max(max_width, x_labels[0].content.width() as u16);\n                }\n            }\n            if x + max_width < area.right() {\n                layout.label_y = Some(x);\n                x += max_width;\n            }\n        }\n\n        if self.x_axis.labels.is_some() && y > area.top() {\n            layout.axis_x = Some(y);\n            y -= 1;\n        }\n\n        if self.y_axis.labels.is_some() && x + 1 < area.right() {\n            layout.axis_y = Some(x);\n            x += 1;\n        }\n\n        if x < area.right() && y > 1 {\n            layout.graph_area = Rect::new(x, area.top(), area.right() - x, y - area.top() + 1);\n        }\n\n        if let Some(ref title) = self.x_axis.title {\n            let w = title.width() as u16;\n            if w < layout.graph_area.width && layout.graph_area.height > 2 {\n                layout.title_x = Some((x + layout.graph_area.width - w, y));\n            }\n        }\n\n        if let Some(ref title) = self.y_axis.title {\n            let w = title.width() as u16;\n            if w + 1 < layout.graph_area.width && layout.graph_area.height > 2 {\n                layout.title_y = Some((x, area.top()));\n            }\n        }\n\n        if let Some(inner_width) = self.datasets.iter().map(|d| d.name.width() as u16).max() {\n            let legend_width = inner_width + 2;\n            let legend_height = self.datasets.len() as u16 + 2;\n            let max_legend_width = self\n                .hidden_legend_constraints\n                .0\n                .apply(layout.graph_area.width);\n            let max_legend_height = self\n                .hidden_legend_constraints\n                .1\n                .apply(layout.graph_area.height);\n            if inner_width > 0\n                && legend_width < max_legend_width\n                && legend_height < max_legend_height\n            {\n                layout.legend_area = Some(Rect::new(\n                    layout.graph_area.right() - legend_width,\n                    layout.graph_area.top(),\n                    legend_width,\n                    legend_height,\n                ));\n            }\n        }\n        layout\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::new":["pub fn new(datasets: Vec<Dataset<'a>>) -> Chart<'a>{\n        Chart {\n            block: None,\n            x_axis: Axis::default(),\n            y_axis: Axis::default(),\n            style: Default::default(),\n            datasets,\n            hidden_legend_constraints: (Constraint::Ratio(1, 4), Constraint::Ratio(1, 4)),\n        }\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::style":["pub fn style(mut self, style: Style) -> Chart<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::x_axis":["pub fn x_axis(mut self, axis: Axis<'a>) -> Chart<'a>{\n        self.x_axis = axis;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Chart::<'a>::y_axis":["pub fn y_axis(mut self, axis: Axis<'a>) -> Chart<'a>{\n        self.y_axis = axis;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::ChartLayout":["/// A container that holds all the infos about where to display each elements of the chart (axis,\n/// labels, legend, ...).\nstruct ChartLayout {\n    /// Location of the title of the x axis\n    title_x: Option<(u16, u16)>,\n    /// Location of the title of the y axis\n    title_y: Option<(u16, u16)>,\n    /// Location of the first label of the x axis\n    label_x: Option<u16>,\n    /// Location of the first label of the y axis\n    label_y: Option<u16>,\n    /// Y coordinate of the horizontal axis\n    axis_x: Option<u16>,\n    /// X coordinate of the vertical axis\n    axis_y: Option<u16>,\n    /// Area of the legend\n    legend_area: Option<Rect>,\n    /// Area of the graph\n    graph_area: Rect,\n}","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset":["/// A group of data points\npub struct Dataset<'a> {\n    /// Name of the dataset (used in the legend if shown)\n    name: Cow<'a, str>,\n    /// A reference to the actual data\n    data: &'a [(f64, f64)],\n    /// Symbol used for each points of this dataset\n    marker: symbols::Marker,\n    /// Determines graph type used for drawing points\n    graph_type: GraphType,\n    /// Style used to plot this dataset\n    style: Style,\n}","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset::<'a>::data":["pub fn data(mut self, data: &'a [(f64, f64)]) -> Dataset<'a>{\n        self.data = data;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset::<'a>::graph_type":["pub fn graph_type(mut self, graph_type: GraphType) -> Dataset<'a>{\n        self.graph_type = graph_type;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset::<'a>::marker":["pub fn marker(mut self, marker: symbols::Marker) -> Dataset<'a>{\n        self.marker = marker;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset::<'a>::name":["pub fn name<S>(mut self, name: S) -> Dataset<'a>\n    where\n        S: Into<Cow<'a, str>>,{\n        self.name = name.into();\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::Dataset::<'a>::style":["pub fn style(mut self, style: Style) -> Dataset<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::chart::GraphType":["/// Used to determine which style of graphing to use\npub enum GraphType {\n    /// Draw each point\n    Scatter,\n    /// Draw each point and lines between each point using the same marker\n    Line,\n}","Real(LocalPath(\"src/widgets/chart.rs\"))"],"widgets::clear::Clear":["/// A widget to to clear/reset a certain area to allow overdrawing (e.g. for popups)\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Clear, Block, Borders};\n/// # use tui::layout::Rect;\n/// # use tui::Frame;\n/// # use tui::backend::Backend;\n/// fn draw_on_clear<B: Backend>(f: &mut Frame<B>, area: Rect) {\n///     let block = Block::default().title(\"Block\").borders(Borders::ALL);\n///     f.render_widget(Clear, area); // <- this will clear/reset the area first\n///     f.render_widget(block, area); // now render the block widget\n/// }\n/// ```\n///\n/// # Popup Example\n///\n/// For a more complete example how to utilize `Clear` to realize popups see\n/// the example `examples/popup.rs`\npub struct Clear;","Real(LocalPath(\"src/widgets/clear.rs\"))"],"widgets::gauge::Gauge":["/// A widget to display a task progress.\n///\n/// # Examples:\n///\n/// ```\n/// # use tui::widgets::{Widget, Gauge, Block, Borders};\n/// # use tui::style::{Style, Color, Modifier};\n/// Gauge::default()\n///     .block(Block::default().borders(Borders::ALL).title(\"Progress\"))\n///     .gauge_style(Style::default().fg(Color::White).bg(Color::Black).add_modifier(Modifier::ITALIC))\n///     .percent(20);\n/// ```\npub struct Gauge<'a> {\n    block: Option<Block<'a>>,\n    ratio: f64,\n    label: Option<Span<'a>>,\n    style: Style,\n    gauge_style: Style,\n}","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Gauge<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::gauge_style":["pub fn gauge_style(mut self, style: Style) -> Gauge<'a>{\n        self.gauge_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::label":["pub fn label<T>(mut self, label: T) -> Gauge<'a>\n    where\n        T: Into<Span<'a>>,{\n        self.label = Some(label.into());\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::percent":["pub fn percent(mut self, percent: u16) -> Gauge<'a>{\n        assert!(\n            percent <= 100,\n            \"Percentage should be between 0 and 100 inclusively.\"\n        );\n        self.ratio = f64::from(percent) / 100.0;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::ratio":["/// Sets ratio ([0.0, 1.0]) directly.\npub fn ratio(mut self, ratio: f64) -> Gauge<'a>{\n        assert!(\n            ratio <= 1.0 && ratio >= 0.0,\n            \"Ratio should be between 0 and 1 inclusively.\"\n        );\n        self.ratio = ratio;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::Gauge::<'a>::style":["pub fn style(mut self, style: Style) -> Gauge<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge":["/// A compact widget to display a task progress over a single line.\n///\n/// # Examples:\n///\n/// ```\n/// # use tui::widgets::{Widget, LineGauge, Block, Borders};\n/// # use tui::style::{Style, Color, Modifier};\n/// # use tui::symbols;\n/// LineGauge::default()\n///     .block(Block::default().borders(Borders::ALL).title(\"Progress\"))\n///     .gauge_style(Style::default().fg(Color::White).bg(Color::Black).add_modifier(Modifier::BOLD))\n///     .line_set(symbols::line::THICK)\n///     .ratio(0.4);\n/// ```\npub struct LineGauge<'a> {\n    block: Option<Block<'a>>,\n    ratio: f64,\n    label: Option<Spans<'a>>,\n    line_set: symbols::line::Set,\n    style: Style,\n    gauge_style: Style,\n}","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Self{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::gauge_style":["pub fn gauge_style(mut self, style: Style) -> Self{\n        self.gauge_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::label":["pub fn label<T>(mut self, label: T) -> Self\n    where\n        T: Into<Spans<'a>>,{\n        self.label = Some(label.into());\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::line_set":["pub fn line_set(mut self, set: symbols::line::Set) -> Self{\n        self.line_set = set;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::ratio":["pub fn ratio(mut self, ratio: f64) -> Self{\n        assert!(\n            ratio <= 1.0 && ratio >= 0.0,\n            \"Ratio should be between 0 and 1 inclusively.\"\n        );\n        self.ratio = ratio;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::gauge::LineGauge::<'a>::style":["pub fn style(mut self, style: Style) -> Self{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/gauge.rs\"))"],"widgets::list::List":["/// A widget to display several items among which one can be selected (optional)\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders, List, ListItem};\n/// # use tui::style::{Style, Color, Modifier};\n/// let items = [ListItem::new(\"Item 1\"), ListItem::new(\"Item 2\"), ListItem::new(\"Item 3\")];\n/// List::new(items)\n///     .block(Block::default().title(\"List\").borders(Borders::ALL))\n///     .style(Style::default().fg(Color::White))\n///     .highlight_style(Style::default().add_modifier(Modifier::ITALIC))\n///     .highlight_symbol(\">>\");\n/// ```\npub struct List<'a> {\n    block: Option<Block<'a>>,\n    items: Vec<ListItem<'a>>,\n    /// Style used as a base style for the widget\n    style: Style,\n    start_corner: Corner,\n    /// Style used to render selected item\n    highlight_style: Style,\n    /// Symbol in front of the selected item (Shift all items to the right)\n    highlight_symbol: Option<&'a str>,\n}","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> List<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::highlight_style":["pub fn highlight_style(mut self, style: Style) -> List<'a>{\n        self.highlight_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::highlight_symbol":["pub fn highlight_symbol(mut self, highlight_symbol: &'a str) -> List<'a>{\n        self.highlight_symbol = Some(highlight_symbol);\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::new":["pub fn new<T>(items: T) -> List<'a>\n    where\n        T: Into<Vec<ListItem<'a>>>,{\n        List {\n            block: None,\n            style: Style::default(),\n            items: items.into(),\n            start_corner: Corner::TopLeft,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n        }\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::start_corner":["pub fn start_corner(mut self, corner: Corner) -> List<'a>{\n        self.start_corner = corner;\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::List::<'a>::style":["pub fn style(mut self, style: Style) -> List<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListItem":["pub struct ListItem<'a> {\n    content: Text<'a>,\n    style: Style,\n}","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListItem::<'a>::height":["pub fn height(&self) -> usize{\n        self.content.height()\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListItem::<'a>::new":["pub fn new<T>(content: T) -> ListItem<'a>\n    where\n        T: Into<Text<'a>>,{\n        ListItem {\n            content: content.into(),\n            style: Style::default(),\n        }\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListItem::<'a>::style":["pub fn style(mut self, style: Style) -> ListItem<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListState":["pub struct ListState {\n    offset: usize,\n    selected: Option<usize>,\n}","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListState::select":["pub fn select(&mut self, index: Option<usize>){\n        self.selected = index;\n        if index.is_none() {\n            self.offset = 0;\n        }\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::list::ListState::selected":["pub fn selected(&self) -> Option<usize>{\n        self.selected\n    }","Real(LocalPath(\"src/widgets/list.rs\"))"],"widgets::paragraph::Paragraph":["/// A widget to display some text.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::text::{Text, Spans, Span};\n/// # use tui::widgets::{Block, Borders, Paragraph, Wrap};\n/// # use tui::style::{Style, Color, Modifier};\n/// # use tui::layout::{Alignment};\n/// let text = vec![\n///     Spans::from(vec![\n///         Span::raw(\"First\"),\n///         Span::styled(\"line\",Style::default().add_modifier(Modifier::ITALIC)),\n///         Span::raw(\".\"),\n///     ]),\n///     Spans::from(Span::styled(\"Second line\", Style::default().fg(Color::Red))),\n/// ];\n/// Paragraph::new(text)\n///     .block(Block::default().title(\"Paragraph\").borders(Borders::ALL))\n///     .style(Style::default().fg(Color::White).bg(Color::Black))\n///     .alignment(Alignment::Center)\n///     .wrap(Wrap { trim: true });\n/// ```\npub struct Paragraph<'a> {\n    /// A block to wrap the widget in\n    block: Option<Block<'a>>,\n    /// Widget style\n    style: Style,\n    /// How to wrap the text\n    wrap: Option<Wrap>,\n    /// The text to display\n    text: Text<'a>,\n    /// Scroll\n    scroll: (u16, u16),\n    /// Alignment of the text\n    alignment: Alignment,\n}","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::alignment":["pub fn alignment(mut self, alignment: Alignment) -> Paragraph<'a>{\n        self.alignment = alignment;\n        self\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Paragraph<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::new":["pub fn new<T>(text: T) -> Paragraph<'a>\n    where\n        T: Into<Text<'a>>,{\n        Paragraph {\n            block: None,\n            style: Default::default(),\n            wrap: None,\n            text: text.into(),\n            scroll: (0, 0),\n            alignment: Alignment::Left,\n        }\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::scroll":["pub fn scroll(mut self, offset: (u16, u16)) -> Paragraph<'a>{\n        self.scroll = offset;\n        self\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::style":["pub fn style(mut self, style: Style) -> Paragraph<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Paragraph::<'a>::wrap":["pub fn wrap(mut self, wrap: Wrap) -> Paragraph<'a>{\n        self.wrap = Some(wrap);\n        self\n    }","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::Wrap":["/// Describes how to wrap text across lines.\n///\n/// ## Examples\n///\n/// ```\n/// # use tui::widgets::{Paragraph, Wrap};\n/// # use tui::text::Text;\n/// let bullet_points = Text::from(r#\"Some indented points:\n///     - First thing goes here and is long so that it wraps\n///     - Here is another point that is long enough to wrap\"#);\n///\n/// // With leading spaces trimmed (window width of 30 chars):\n/// Paragraph::new(bullet_points.clone()).wrap(Wrap { trim: true });\n/// // Some indented points:\n/// // - First thing goes here and is\n/// // long so that it wraps\n/// // - Here is another point that\n/// // is long enough to wrap\n///\n/// // But without trimming, indentation is preserved:\n/// Paragraph::new(bullet_points).wrap(Wrap { trim: false });\n/// // Some indented points:\n/// //     - First thing goes here\n/// // and is long so that it wraps\n/// //     - Here is another point\n/// // that is long enough to wrap\n/// ```\npub struct Wrap {\n    /// Should leading whitespace be trimmed\n    pub trim: bool,\n}","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::paragraph::get_line_offset":["fn get_line_offset(line_width: u16, text_area_width: u16, alignment: Alignment) -> u16{\n    match alignment {\n        Alignment::Center => (text_area_width / 2).saturating_sub(line_width / 2),\n        Alignment::Right => text_area_width.saturating_sub(line_width),\n        Alignment::Left => 0,\n    }\n}","Real(LocalPath(\"src/widgets/paragraph.rs\"))"],"widgets::reflow::LineComposer":["/// A state machine to pack styled symbols into lines.\n/// Cannot implement it as Iterator since it yields slices of the internal buffer (need streaming\n/// iterators for that).\npub trait LineComposer<'a> {\n    fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)>;\n}","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::LineTruncator":["/// A state machine that truncates overhanging lines.\npub struct LineTruncator<'a, 'b> {\n    symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n    max_line_width: u16,\n    current_line: Vec<StyledGrapheme<'a>>,\n    /// Record the offet to skip render\n    horizontal_offset: u16,\n}","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::LineTruncator::<'a, 'b>::new":["pub fn new(\n        symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n        max_line_width: u16,\n    ) -> LineTruncator<'a, 'b>{\n        LineTruncator {\n            symbols,\n            max_line_width,\n            horizontal_offset: 0,\n            current_line: vec![],\n        }\n    }","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::LineTruncator::<'a, 'b>::set_horizontal_offset":["pub fn set_horizontal_offset(&mut self, horizontal_offset: u16){\n        self.horizontal_offset = horizontal_offset;\n    }","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::WordWrapper":["/// A state machine that wraps lines on word boundaries.\npub struct WordWrapper<'a, 'b> {\n    symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n    max_line_width: u16,\n    current_line: Vec<StyledGrapheme<'a>>,\n    next_line: Vec<StyledGrapheme<'a>>,\n    /// Removes the leading whitespace from lines\n    trim: bool,\n}","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::WordWrapper::<'a, 'b>::new":["pub fn new(\n        symbols: &'b mut dyn Iterator<Item = StyledGrapheme<'a>>,\n        max_line_width: u16,\n        trim: bool,\n    ) -> WordWrapper<'a, 'b>{\n        WordWrapper {\n            symbols,\n            max_line_width,\n            current_line: vec![],\n            next_line: vec![],\n            trim,\n        }\n    }","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::reflow::trim_offset":["/// This function will return a str slice which start at specified offset.\n/// As src is a unicode str, start offset has to be calculated with each character.\nfn trim_offset(src: &str, mut offset: usize) -> &str{\n    let mut start = 0;\n    for c in UnicodeSegmentation::graphemes(src, true) {\n        let w = c.width();\n        if w <= offset {\n            offset -= w;\n            start += c.len();\n        } else {\n            break;\n        }\n    }\n    &src[start..]\n}","Real(LocalPath(\"src/widgets/reflow.rs\"))"],"widgets::sparkline::Sparkline":["/// Widget to render a sparkline over one or more lines.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders, Sparkline};\n/// # use tui::style::{Style, Color};\n/// Sparkline::default()\n///     .block(Block::default().title(\"Sparkline\").borders(Borders::ALL))\n///     .data(&[0, 2, 3, 4, 1, 4, 10])\n///     .max(5)\n///     .style(Style::default().fg(Color::Red).bg(Color::White));\n/// ```\npub struct Sparkline<'a> {\n    /// A block to wrap the widget in\n    block: Option<Block<'a>>,\n    /// Widget style\n    style: Style,\n    /// A slice of the data to display\n    data: &'a [u64],\n    /// The maximum value to take to compute the maximum bar height (if nothing is specified, the\n    /// widget uses the max of the dataset)\n    max: Option<u64>,\n    /// A set of bar symbols used to represent the give data\n    bar_set: symbols::bar::Set,\n}","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::sparkline::Sparkline::<'a>::bar_set":["pub fn bar_set(mut self, bar_set: symbols::bar::Set) -> Sparkline<'a>{\n        self.bar_set = bar_set;\n        self\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::sparkline::Sparkline::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Sparkline<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::sparkline::Sparkline::<'a>::data":["pub fn data(mut self, data: &'a [u64]) -> Sparkline<'a>{\n        self.data = data;\n        self\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::sparkline::Sparkline::<'a>::max":["pub fn max(mut self, max: u64) -> Sparkline<'a>{\n        self.max = Some(max);\n        self\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::sparkline::Sparkline::<'a>::style":["pub fn style(mut self, style: Style) -> Sparkline<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/sparkline.rs\"))"],"widgets::table::Row":["/// Holds data to be displayed in a Table widget\npub enum Row<D>\nwhere\n    D: Iterator,\n    D::Item: Display,\n{\n    Data(D),\n    StyledData(D, Style),\n}","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table":["/// A widget to display data in formatted columns\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders, Table, Row};\n/// # use tui::layout::Constraint;\n/// # use tui::style::{Style, Color};\n/// let row_style = Style::default().fg(Color::White);\n/// Table::new(\n///         [\"Col1\", \"Col2\", \"Col3\"].into_iter(),\n///         vec![\n///             Row::StyledData([\"Row11\", \"Row12\", \"Row13\"].into_iter(), row_style),\n///             Row::StyledData([\"Row21\", \"Row22\", \"Row23\"].into_iter(), row_style),\n///             Row::StyledData([\"Row31\", \"Row32\", \"Row33\"].into_iter(), row_style),\n///             Row::Data([\"Row41\", \"Row42\", \"Row43\"].into_iter())\n///         ].into_iter()\n///     )\n///     .block(Block::default().title(\"Table\"))\n///     .header_style(Style::default().fg(Color::Yellow))\n///     .widths(&[Constraint::Length(5), Constraint::Length(5), Constraint::Length(10)])\n///     .style(Style::default().fg(Color::White))\n///     .column_spacing(1);\n/// ```\npub struct Table<'a, H, R> {\n    /// A block to wrap the widget in\n    block: Option<Block<'a>>,\n    /// Base style for the widget\n    style: Style,\n    /// Header row for all columns\n    header: H,\n    /// Style for the header\n    header_style: Style,\n    /// Width constraints for each column\n    widths: &'a [Constraint],\n    /// Space between each column\n    column_spacing: u16,\n    /// Space between the header and the rows\n    header_gap: u16,\n    /// Style used to render the selected row\n    highlight_style: Style,\n    /// Symbol in front of the selected rom\n    highlight_symbol: Option<&'a str>,\n    /// Data to display in each row\n    rows: R,\n}","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::block":["pub fn block(mut self, block: Block<'a>) -> Table<'a, H, R>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::column_spacing":["pub fn column_spacing(mut self, spacing: u16) -> Table<'a, H, R>{\n        self.column_spacing = spacing;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::header":["pub fn header<II>(mut self, header: II) -> Table<'a, H, R>\n    where\n        II: IntoIterator<Item = H::Item, IntoIter = H>,{\n        self.header = header.into_iter();\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::header_gap":["pub fn header_gap(mut self, gap: u16) -> Table<'a, H, R>{\n        self.header_gap = gap;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::header_style":["pub fn header_style(mut self, style: Style) -> Table<'a, H, R>{\n        self.header_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::highlight_style":["pub fn highlight_style(mut self, highlight_style: Style) -> Table<'a, H, R>{\n        self.highlight_style = highlight_style;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::highlight_symbol":["pub fn highlight_symbol(mut self, highlight_symbol: &'a str) -> Table<'a, H, R>{\n        self.highlight_symbol = Some(highlight_symbol);\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::new":["pub fn new(header: H, rows: R) -> Table<'a, H, R>{\n        Table {\n            block: None,\n            style: Style::default(),\n            header,\n            header_style: Style::default(),\n            widths: &[],\n            column_spacing: 1,\n            header_gap: 1,\n            highlight_style: Style::default(),\n            highlight_symbol: None,\n            rows,\n        }\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::rows":["pub fn rows<II>(mut self, rows: II) -> Table<'a, H, R>\n    where\n        II: IntoIterator<Item = Row<D>, IntoIter = R>,{\n        self.rows = rows.into_iter();\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::style":["pub fn style(mut self, style: Style) -> Table<'a, H, R>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::Table::<'a, H, R>::widths":["pub fn widths(mut self, widths: &'a [Constraint]) -> Table<'a, H, R>{\n        let between_0_and_100 = |&w| match w {\n            Constraint::Percentage(p) => p <= 100,\n            _ => true,\n        };\n        assert!(\n            widths.iter().all(between_0_and_100),\n            \"Percentages should be between 0 and 100 inclusively.\"\n        );\n        self.widths = widths;\n        self\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::TableState":["pub struct TableState {\n    offset: usize,\n    selected: Option<usize>,\n}","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::TableState::select":["pub fn select(&mut self, index: Option<usize>){\n        self.selected = index;\n        if index.is_none() {\n            self.offset = 0;\n        }\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::table::TableState::selected":["pub fn selected(&self) -> Option<usize>{\n        self.selected\n    }","Real(LocalPath(\"src/widgets/table.rs\"))"],"widgets::tabs::Tabs":["/// A widget to display available tabs in a multiple panels context.\n///\n/// # Examples\n///\n/// ```\n/// # use tui::widgets::{Block, Borders, Tabs};\n/// # use tui::style::{Style, Color};\n/// # use tui::text::{Spans};\n/// # use tui::symbols::{DOT};\n/// let titles = [\"Tab1\", \"Tab2\", \"Tab3\", \"Tab4\"].iter().cloned().map(Spans::from).collect();\n/// Tabs::new(titles)\n///     .block(Block::default().title(\"Tabs\").borders(Borders::ALL))\n///     .style(Style::default().fg(Color::White))\n///     .highlight_style(Style::default().fg(Color::Yellow))\n///     .divider(DOT);\n/// ```\npub struct Tabs<'a> {\n    /// A block to wrap this widget in if necessary\n    block: Option<Block<'a>>,\n    /// One title for each tab\n    titles: Vec<Spans<'a>>,\n    /// The index of the selected tabs\n    selected: usize,\n    /// The style used to draw the text\n    style: Style,\n    /// Style to apply to the selected item\n    highlight_style: Style,\n    /// Tab divider\n    divider: Span<'a>,\n}","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::block":["pub fn block(mut self, block: Block<'a>) -> Tabs<'a>{\n        self.block = Some(block);\n        self\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::divider":["pub fn divider<T>(mut self, divider: T) -> Tabs<'a>\n    where\n        T: Into<Span<'a>>,{\n        self.divider = divider.into();\n        self\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::highlight_style":["pub fn highlight_style(mut self, style: Style) -> Tabs<'a>{\n        self.highlight_style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::new":["pub fn new(titles: Vec<Spans<'a>>) -> Tabs<'a>{\n        Tabs {\n            block: None,\n            titles,\n            selected: 0,\n            style: Default::default(),\n            highlight_style: Default::default(),\n            divider: Span::raw(symbols::line::VERTICAL),\n        }\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::select":["pub fn select(mut self, selected: usize) -> Tabs<'a>{\n        self.selected = selected;\n        self\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"],"widgets::tabs::Tabs::<'a>::style":["pub fn style(mut self, style: Style) -> Tabs<'a>{\n        self.style = style;\n        self\n    }","Real(LocalPath(\"src/widgets/tabs.rs\"))"]},"struct_constructor":{"&'static [(f64, f64)]":["data"],"&[buffer::Cell]":["content"],"&buffer::Buffer":["buffer"],"&buffer::Cell":["get"],"&layout::Rect":["area"],"&mut buffer::Buffer":["current_buffer_mut"],"&mut buffer::Cell":["get_mut"],"(&[text::StyledGrapheme<'a>], u16)":["next_line"],"(f64, f64)":["resolution"],"(u16, u16)":["get_cursor","pos_of","set_span","set_spans","set_stringn"],"(usize, usize)":["get_point"],"<text::Text<'a> as std::iter::IntoIterator>::IntoIter":["into_iter"],"backend::termion::TermionBackend":["new"],"backend::test::TestBackend":["new"],"bool":["ALL","BOLD","BOTTOM","CROSSED_OUT","DIM","HIDDEN","ITALIC","LEFT","NONE","RAPID_BLINK","REVERSED","RIGHT","SLOW_BLINK","TOP","UNDERLINED","contains","eq","intersects","is_all","is_empty"],"buffer::Buffer":["clone","default","empty","filled","with_lines"],"buffer::Cell":["clone","default"],"cassowary::Expression":["bottom","right"],"cassowary::Variable":["left","top"],"impl std::iter::Iterator<Item = text::StyledGrapheme<'a>>":["styled_graphemes"],"layout::Alignment":["clone"],"layout::Constraint":["clone"],"layout::Corner":["clone"],"layout::Direction":["clone"],"layout::Element":["new"],"layout::Layout":["clone","default"],"layout::Margin":["clone"],"layout::Rect":["clone","default","new","size"],"std::cell::RefCell":["__init"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["buffer_view","from"],"std::vec::Vec":["diff","split"],"style::Color":["clone"],"style::Modifier":["all","clone","empty","from_bits","from_bits_truncate","from_bits_unchecked","from_iter"],"style::Style":["clone","default","style"],"symbols::Marker":["clone"],"symbols::bar::Set":["clone"],"symbols::block::Set":["clone"],"symbols::line::Set":["clone","line_symbols"],"terminal::Frame":["get_frame"],"terminal::ResizeBehavior":["clone"],"terminal::Terminal":["new","with_options"],"terminal::TerminalOptions":["clone"],"terminal::Viewport":["clone","fixed"],"text::Span":["clone","from","raw","styled"],"text::Spans":["clone","default","from"],"text::StyledGrapheme":["clone"],"text::Text":["clone","default","from","raw","styled"],"u16":["area","bits","bottom","height","left","right","top","width"],"u32":["bits"],"usize":["height","index_of","selected","width","write"],"widgets::Borders":["all","clone","empty","from_bits","from_bits_truncate","from_bits_unchecked","from_iter"],"widgets::barchart::BarChart":["clone","default"],"widgets::block::Block":["clone","default"],"widgets::block::BorderType":["clone"],"widgets::canvas::BrailleGrid":["clone","new"],"widgets::canvas::Canvas":["default"],"widgets::canvas::CharGrid":["clone","new"],"widgets::canvas::Context":["new"],"widgets::canvas::Label":["clone"],"widgets::canvas::Layer":["clone","save"],"widgets::canvas::Painter":["from"],"widgets::canvas::line::Line":["clone"],"widgets::canvas::map::Map":["clone","default"],"widgets::canvas::map::MapResolution":["clone"],"widgets::canvas::points::Points":["clone","default"],"widgets::canvas::rectangle::Rectangle":["clone"],"widgets::chart::Axis":["clone","default"],"widgets::chart::Chart":["clone","new"],"widgets::chart::ChartLayout":["clone","default","layout"],"widgets::chart::Dataset":["clone","default"],"widgets::chart::GraphType":["clone"],"widgets::clear::Clear":["clone"],"widgets::gauge::Gauge":["clone","default"],"widgets::gauge::LineGauge":["default"],"widgets::list::List":["clone","new"],"widgets::list::ListItem":["clone","new"],"widgets::list::ListState":["clone","default"],"widgets::paragraph::Paragraph":["clone","new"],"widgets::paragraph::Wrap":["clone"],"widgets::reflow::LineTruncator":["new"],"widgets::reflow::WordWrapper":["new"],"widgets::sparkline::Sparkline":["clone","default"],"widgets::table::Row":["clone"],"widgets::table::Table":["clone","default","new"],"widgets::table::TableState":["clone","default"],"widgets::tabs::Tabs":["clone","new"]},"struct_to_trait":{"backend::termion::Bg":["std::fmt::Display"],"backend::termion::Fg":["std::fmt::Display"],"backend::termion::ModifierDiff":["std::fmt::Display"],"backend::termion::TermionBackend":["backend::Backend","std::io::Write"],"backend::test::TestBackend":["backend::Backend","std::fmt::Debug"],"buffer::Buffer":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"buffer::Cell":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"layout::Alignment":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"layout::Constraint":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"layout::Corner":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"layout::Direction":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"layout::Layout":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"layout::Margin":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"layout::Rect":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::string::String":["std::convert::From"],"style::Color":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"style::Modifier":["<style::Modifier as std::fmt::Debug>::fmt::__BitFlags","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Binary","std::fmt::Debug","std::fmt::LowerHex","std::fmt::Octal","std::fmt::UpperHex","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Not","std::ops::Sub","std::ops::SubAssign","style::Modifier::all::__BitFlags"],"style::Style":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"symbols::Marker":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"symbols::bar::Set":["std::clone::Clone","std::fmt::Debug"],"symbols::block::Set":["std::clone::Clone","std::fmt::Debug"],"symbols::line::Set":["std::clone::Clone","std::fmt::Debug"],"terminal::ResizeBehavior":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"terminal::Terminal":["std::fmt::Debug","std::ops::Drop"],"terminal::TerminalOptions":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"terminal::Viewport":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"text::Span":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"text::Spans":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"text::StyledGrapheme":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"text::Text":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::IntoIterator","std::marker::StructuralPartialEq"],"widgets::Borders":["<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Binary","std::fmt::Debug","std::fmt::LowerHex","std::fmt::Octal","std::fmt::UpperHex","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Not","std::ops::Sub","std::ops::SubAssign","widgets::Borders::all::__BitFlags"],"widgets::barchart::BarChart":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::Widget"],"widgets::block::Block":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::Widget"],"widgets::block::BorderType":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"widgets::canvas::BrailleGrid":["std::clone::Clone","std::fmt::Debug","widgets::canvas::Grid"],"widgets::canvas::Canvas":["std::default::Default","widgets::Widget"],"widgets::canvas::CharGrid":["std::clone::Clone","std::fmt::Debug","widgets::canvas::Grid"],"widgets::canvas::Context":["std::fmt::Debug"],"widgets::canvas::Label":["std::clone::Clone","std::fmt::Debug"],"widgets::canvas::Layer":["std::clone::Clone","std::fmt::Debug"],"widgets::canvas::Painter":["std::convert::From","std::fmt::Debug"],"widgets::canvas::line::Line":["std::clone::Clone","std::fmt::Debug","widgets::canvas::Shape"],"widgets::canvas::map::Map":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::canvas::Shape"],"widgets::canvas::map::MapResolution":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"widgets::canvas::points::Points":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::canvas::Shape"],"widgets::canvas::rectangle::Rectangle":["std::clone::Clone","std::fmt::Debug","widgets::canvas::Shape"],"widgets::chart::Axis":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"widgets::chart::Chart":["std::clone::Clone","std::fmt::Debug","widgets::Widget"],"widgets::chart::ChartLayout":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"widgets::chart::Dataset":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"widgets::chart::GraphType":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"widgets::clear::Clear":["std::clone::Clone","std::fmt::Debug","widgets::Widget"],"widgets::gauge::Gauge":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::Widget"],"widgets::gauge::LineGauge":["std::default::Default","widgets::Widget"],"widgets::list::List":["std::clone::Clone","std::fmt::Debug","widgets::StatefulWidget","widgets::Widget"],"widgets::list::ListItem":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"widgets::list::ListState":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"widgets::paragraph::Paragraph":["std::clone::Clone","std::fmt::Debug","widgets::Widget"],"widgets::paragraph::Wrap":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"widgets::reflow::LineTruncator":["widgets::reflow::LineComposer"],"widgets::reflow::WordWrapper":["widgets::reflow::LineComposer"],"widgets::sparkline::Sparkline":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::Widget"],"widgets::table::Row":["std::clone::Clone","std::fmt::Debug"],"widgets::table::Table":["std::clone::Clone","std::default::Default","std::fmt::Debug","widgets::StatefulWidget","widgets::Widget"],"widgets::table::TableState":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"widgets::tabs::Tabs":["std::clone::Clone","std::fmt::Debug","widgets::Widget"]},"targets":{"<backend::termion::Bg as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/backend/termion.rs\"))","std::fmt::Display"],"<backend::termion::Fg as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/backend/termion.rs\"))","std::fmt::Display"],"<backend::termion::ModifierDiff as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/backend/termion.rs\"))","std::fmt::Display"],"<backend::termion::TermionBackend<W> as backend::Backend>::clear":["clear","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::draw":["draw","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::flush":["flush","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::get_cursor":["get_cursor","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::hide_cursor":["hide_cursor","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::set_cursor":["set_cursor","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::show_cursor":["show_cursor","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as backend::Backend>::size":["size","Real(LocalPath(\"src/backend/termion.rs\"))","backend::Backend"],"<backend::termion::TermionBackend<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/backend/termion.rs\"))","std::io::Write"],"<backend::termion::TermionBackend<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/backend/termion.rs\"))","std::io::Write"],"<backend::test::TestBackend as backend::Backend>::clear":["clear","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::draw":["draw","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::flush":["flush","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::get_cursor":["get_cursor","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::hide_cursor":["hide_cursor","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::set_cursor":["set_cursor","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::show_cursor":["show_cursor","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<backend::test::TestBackend as backend::Backend>::size":["size","Real(LocalPath(\"src/backend/test.rs\"))","backend::Backend"],"<buffer::Buffer as std::default::Default>::default":["default","Real(LocalPath(\"src/buffer.rs\"))","std::default::Default"],"<buffer::Cell as std::default::Default>::default":["default","Real(LocalPath(\"src/buffer.rs\"))","std::default::Default"],"<layout::Layout as std::default::Default>::default":["default","Real(LocalPath(\"src/layout.rs\"))","std::default::Default"],"<layout::Rect as std::default::Default>::default":["default","Real(LocalPath(\"src/layout.rs\"))","std::default::Default"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::BOLD":["BOLD","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::CROSSED_OUT":["CROSSED_OUT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::DIM":["DIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::ITALIC":["ITALIC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::RAPID_BLINK":["RAPID_BLINK","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::REVERSED":["REVERSED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::SLOW_BLINK":["SLOW_BLINK","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as <style::Modifier as std::fmt::Debug>::fmt::__BitFlags>::UNDERLINED":["UNDERLINED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<style::Modifier as std::fmt::Debug>::fmt::__BitFlags"],"<style::Modifier as std::fmt::Binary>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Binary"],"<style::Modifier as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Debug"],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::BOLD":["BOLD","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::CROSSED_OUT":["CROSSED_OUT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::DIM":["DIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::ITALIC":["ITALIC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::RAPID_BLINK":["RAPID_BLINK","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::REVERSED":["REVERSED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::SLOW_BLINK":["SLOW_BLINK","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags::UNDERLINED":["UNDERLINED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<style::Modifier as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::LowerHex"],"<style::Modifier as std::fmt::Octal>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Octal"],"<style::Modifier as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::UpperHex"],"<style::Modifier as std::iter::Extend<style::Modifier>>::extend":["extend","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::Extend"],"<style::Modifier as std::iter::FromIterator<style::Modifier>>::from_iter":["from_iter","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::FromIterator"],"<style::Modifier as std::ops::BitAnd>::bitand":["bitand","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAnd"],"<style::Modifier as std::ops::BitAndAssign>::bitand_assign":["bitand_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAndAssign"],"<style::Modifier as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOr"],"<style::Modifier as std::ops::BitOrAssign>::bitor_assign":["bitor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOrAssign"],"<style::Modifier as std::ops::BitXor>::bitxor":["bitxor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXor"],"<style::Modifier as std::ops::BitXorAssign>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXorAssign"],"<style::Modifier as std::ops::Not>::not":["not","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Not"],"<style::Modifier as std::ops::Sub>::sub":["sub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Sub"],"<style::Modifier as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::SubAssign"],"<style::Style as std::default::Default>::default":["default","Real(LocalPath(\"src/style.rs\"))","std::default::Default"],"<terminal::Terminal<B> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/terminal.rs\"))","std::ops::Drop"],"<text::Span<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Span<'a> as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Spans<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Spans<'a> as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Spans<'a> as std::convert::From<std::vec::Vec<text::Span<'a>>>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Spans<'a> as std::convert::From<text::Span<'a>>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Spans<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/text.rs\"))","std::default::Default"],"<text::Text<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Text<'a> as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Text<'a> as std::convert::From<std::vec::Vec<text::Spans<'a>>>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Text<'a> as std::convert::From<text::Span<'a>>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Text<'a> as std::convert::From<text::Spans<'a>>>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"<text::Text<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/text.rs\"))","std::default::Default"],"<text::Text<'a> as std::iter::Extend<text::Spans<'a>>>::extend":["extend","Real(LocalPath(\"src/text.rs\"))","std::iter::Extend"],"<text::Text<'a> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/text.rs\"))","std::iter::IntoIterator"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::ALL":["ALL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::BOTTOM":["BOTTOM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::LEFT":["LEFT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::NONE":["NONE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::RIGHT":["RIGHT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as <widgets::Borders as std::fmt::Debug>::fmt::__BitFlags>::TOP":["TOP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags"],"<widgets::Borders as std::fmt::Binary>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Binary"],"<widgets::Borders as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Debug"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::ALL":["ALL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::BOTTOM":["BOTTOM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::LEFT":["LEFT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::NONE":["NONE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::RIGHT":["RIGHT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags::TOP":["TOP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<widgets::Borders as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::LowerHex"],"<widgets::Borders as std::fmt::Octal>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Octal"],"<widgets::Borders as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::UpperHex"],"<widgets::Borders as std::iter::Extend<widgets::Borders>>::extend":["extend","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::Extend"],"<widgets::Borders as std::iter::FromIterator<widgets::Borders>>::from_iter":["from_iter","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::FromIterator"],"<widgets::Borders as std::ops::BitAnd>::bitand":["bitand","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAnd"],"<widgets::Borders as std::ops::BitAndAssign>::bitand_assign":["bitand_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAndAssign"],"<widgets::Borders as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOr"],"<widgets::Borders as std::ops::BitOrAssign>::bitor_assign":["bitor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOrAssign"],"<widgets::Borders as std::ops::BitXor>::bitxor":["bitxor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXor"],"<widgets::Borders as std::ops::BitXorAssign>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXorAssign"],"<widgets::Borders as std::ops::Not>::not":["not","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Not"],"<widgets::Borders as std::ops::Sub>::sub":["sub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Sub"],"<widgets::Borders as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::SubAssign"],"<widgets::barchart::BarChart<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/barchart.rs\"))","std::default::Default"],"<widgets::barchart::BarChart<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/barchart.rs\"))","widgets::Widget"],"<widgets::block::Block<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/block.rs\"))","std::default::Default"],"<widgets::block::Block<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/block.rs\"))","widgets::Widget"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::height":["height","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::paint":["paint","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::reset":["reset","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::resolution":["resolution","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::save":["save","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::BrailleGrid as widgets::canvas::Grid>::width":["width","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::Canvas<'a, F> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","std::default::Default"],"<widgets::canvas::Canvas<'a, F> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::Widget"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::height":["height","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::paint":["paint","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::reset":["reset","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::resolution":["resolution","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::save":["save","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::CharGrid as widgets::canvas::Grid>::width":["width","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","widgets::canvas::Grid"],"<widgets::canvas::Painter<'a, 'b> as std::convert::From<&'a mut widgets::canvas::Context<'b>>>::from":["from","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))","std::convert::From"],"<widgets::canvas::line::Line as widgets::canvas::Shape>::draw":["draw","Real(LocalPath(\"src/widgets/canvas/line.rs\"))","widgets::canvas::Shape"],"<widgets::canvas::map::Map as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/canvas/map.rs\"))","std::default::Default"],"<widgets::canvas::map::Map as widgets::canvas::Shape>::draw":["draw","Real(LocalPath(\"src/widgets/canvas/map.rs\"))","widgets::canvas::Shape"],"<widgets::canvas::points::Points<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/canvas/points.rs\"))","std::default::Default"],"<widgets::canvas::points::Points<'a> as widgets::canvas::Shape>::draw":["draw","Real(LocalPath(\"src/widgets/canvas/points.rs\"))","widgets::canvas::Shape"],"<widgets::canvas::rectangle::Rectangle as widgets::canvas::Shape>::draw":["draw","Real(LocalPath(\"src/widgets/canvas/rectangle.rs\"))","widgets::canvas::Shape"],"<widgets::chart::Axis<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/chart.rs\"))","std::default::Default"],"<widgets::chart::Chart<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/chart.rs\"))","widgets::Widget"],"<widgets::chart::ChartLayout as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/chart.rs\"))","std::default::Default"],"<widgets::chart::Dataset<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/chart.rs\"))","std::default::Default"],"<widgets::clear::Clear as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/clear.rs\"))","widgets::Widget"],"<widgets::gauge::Gauge<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/gauge.rs\"))","std::default::Default"],"<widgets::gauge::Gauge<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/gauge.rs\"))","widgets::Widget"],"<widgets::gauge::LineGauge<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/gauge.rs\"))","std::default::Default"],"<widgets::gauge::LineGauge<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/gauge.rs\"))","widgets::Widget"],"<widgets::list::List<'a> as widgets::StatefulWidget>::render":["render","Real(LocalPath(\"src/widgets/list.rs\"))","widgets::StatefulWidget"],"<widgets::list::List<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/list.rs\"))","widgets::Widget"],"<widgets::list::ListState as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/list.rs\"))","std::default::Default"],"<widgets::paragraph::Paragraph<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/paragraph.rs\"))","widgets::Widget"],"<widgets::reflow::LineTruncator<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["next_line","Real(LocalPath(\"src/widgets/reflow.rs\"))","widgets::reflow::LineComposer"],"<widgets::reflow::WordWrapper<'a, 'b> as widgets::reflow::LineComposer<'a>>::next_line":["next_line","Real(LocalPath(\"src/widgets/reflow.rs\"))","widgets::reflow::LineComposer"],"<widgets::sparkline::Sparkline<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/sparkline.rs\"))","std::default::Default"],"<widgets::sparkline::Sparkline<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/sparkline.rs\"))","widgets::Widget"],"<widgets::table::Table<'a, H, R> as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/table.rs\"))","std::default::Default"],"<widgets::table::Table<'a, H, R> as widgets::StatefulWidget>::render":["render","Real(LocalPath(\"src/widgets/table.rs\"))","widgets::StatefulWidget"],"<widgets::table::Table<'a, H, R> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/table.rs\"))","widgets::Widget"],"<widgets::table::TableState as std::default::Default>::default":["default","Real(LocalPath(\"src/widgets/table.rs\"))","std::default::Default"],"<widgets::tabs::Tabs<'a> as widgets::Widget>::render":["render","Real(LocalPath(\"src/widgets/tabs.rs\"))","widgets::Widget"],"backend::termion::TermionBackend::<W>::new":["new","Real(LocalPath(\"src/backend/termion.rs\"))",""],"backend::test::TestBackend::assert_buffer":["assert_buffer","Real(LocalPath(\"src/backend/test.rs\"))",""],"backend::test::TestBackend::buffer":["buffer","Real(LocalPath(\"src/backend/test.rs\"))",""],"backend::test::TestBackend::new":["new","Real(LocalPath(\"src/backend/test.rs\"))",""],"backend::test::buffer_view":["buffer_view","Real(LocalPath(\"src/backend/test.rs\"))",""],"buffer::Buffer::area":["area","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::content":["content","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::diff":["diff","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::empty":["empty","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::filled":["filled","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::get":["get","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::get_mut":["get_mut","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::index_of":["index_of","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::merge":["merge","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::pos_of":["pos_of","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::reset":["reset","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::resize":["resize","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_background":["set_background","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_span":["set_span","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_spans":["set_spans","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_string":["set_string","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_stringn":["set_stringn","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::set_style":["set_style","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Buffer::with_lines":["with_lines","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::reset":["reset","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::set_bg":["set_bg","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::set_char":["set_char","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::set_fg":["set_fg","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::set_style":["set_style","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::set_symbol":["set_symbol","Real(LocalPath(\"src/buffer.rs\"))",""],"buffer::Cell::style":["style","Real(LocalPath(\"src/buffer.rs\"))",""],"layout::Constraint::apply":["apply","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Element::bottom":["bottom","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Element::left":["left","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Element::new":["new","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Element::right":["right","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Element::top":["top","Real(LocalPath(\"src/layout.rs\"))",""],"layout::LAYOUT_CACHE::__getit":["__getit","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"layout::LAYOUT_CACHE::__init":["__init","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"layout::Layout::constraints":["constraints","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Layout::direction":["direction","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Layout::horizontal_margin":["horizontal_margin","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Layout::margin":["margin","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Layout::split":["split","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Layout::vertical_margin":["vertical_margin","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::area":["area","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::bottom":["bottom","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::inner":["inner","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::intersection":["intersection","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::intersects":["intersects","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::left":["left","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::new":["new","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::right":["right","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::top":["top","Real(LocalPath(\"src/layout.rs\"))",""],"layout::Rect::union":["union","Real(LocalPath(\"src/layout.rs\"))",""],"layout::split":["split","Real(LocalPath(\"src/layout.rs\"))",""],"style::Modifier::all":["all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::bits":["bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::complement":["complement","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::contains":["contains","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::difference":["difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::empty":["empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::from_bits":["from_bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::from_bits_truncate":["from_bits_truncate","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::from_bits_unchecked":["from_bits_unchecked","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::insert":["insert","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::intersection":["intersection","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::intersects":["intersects","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::is_all":["is_all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::is_empty":["is_empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::remove":["remove","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::set":["set","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::symmetric_difference":["symmetric_difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::toggle":["toggle","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Modifier::union":["union","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"style::Style::add_modifier":["add_modifier","Real(LocalPath(\"src/style.rs\"))",""],"style::Style::bg":["bg","Real(LocalPath(\"src/style.rs\"))",""],"style::Style::fg":["fg","Real(LocalPath(\"src/style.rs\"))",""],"style::Style::patch":["patch","Real(LocalPath(\"src/style.rs\"))",""],"style::Style::remove_modifier":["remove_modifier","Real(LocalPath(\"src/style.rs\"))",""],"terminal::Frame::<'a, B>::render_stateful_widget":["render_stateful_widget","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Frame::<'a, B>::render_widget":["render_widget","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Frame::<'a, B>::set_cursor":["set_cursor","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Frame::<'a, B>::size":["size","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::autoresize":["autoresize","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::backend":["backend","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::backend_mut":["backend_mut","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::clear":["clear","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::current_buffer_mut":["current_buffer_mut","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::draw":["draw","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::flush":["flush","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::get_cursor":["get_cursor","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::get_frame":["get_frame","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::hide_cursor":["hide_cursor","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::new":["new","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::resize":["resize","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::set_cursor":["set_cursor","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::show_cursor":["show_cursor","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::size":["size","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Terminal::<B>::with_options":["with_options","Real(LocalPath(\"src/terminal.rs\"))",""],"terminal::Viewport::fixed":["fixed","Real(LocalPath(\"src/terminal.rs\"))",""],"text::<impl std::convert::From<text::Spans<'a>> for std::string::String>::from":["from","Real(LocalPath(\"src/text.rs\"))","std::convert::From"],"text::Span::<'a>::raw":["raw","Real(LocalPath(\"src/text.rs\"))",""],"text::Span::<'a>::styled":["styled","Real(LocalPath(\"src/text.rs\"))",""],"text::Span::<'a>::styled_graphemes":["styled_graphemes","Real(LocalPath(\"src/text.rs\"))",""],"text::Span::<'a>::width":["width","Real(LocalPath(\"src/text.rs\"))",""],"text::Spans::<'a>::width":["width","Real(LocalPath(\"src/text.rs\"))",""],"text::Text::<'a>::height":["height","Real(LocalPath(\"src/text.rs\"))",""],"text::Text::<'a>::patch_style":["patch_style","Real(LocalPath(\"src/text.rs\"))",""],"text::Text::<'a>::raw":["raw","Real(LocalPath(\"src/text.rs\"))",""],"text::Text::<'a>::styled":["styled","Real(LocalPath(\"src/text.rs\"))",""],"text::Text::<'a>::width":["width","Real(LocalPath(\"src/text.rs\"))",""],"widgets::Borders::all":["all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::bits":["bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::complement":["complement","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::contains":["contains","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::difference":["difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::empty":["empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::from_bits":["from_bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::from_bits_truncate":["from_bits_truncate","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::from_bits_unchecked":["from_bits_unchecked","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::insert":["insert","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::intersection":["intersection","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::intersects":["intersects","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::is_all":["is_all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::is_empty":["is_empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::remove":["remove","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::set":["set","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::symmetric_difference":["symmetric_difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::toggle":["toggle","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::Borders::union":["union","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"widgets::barchart::BarChart::<'a>::bar_gap":["bar_gap","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::bar_set":["bar_set","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::bar_style":["bar_style","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::bar_width":["bar_width","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::block":["block","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::data":["data","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::label_style":["label_style","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::max":["max","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::style":["style","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::barchart::BarChart::<'a>::value_style":["value_style","Real(LocalPath(\"src/widgets/barchart.rs\"))",""],"widgets::block::Block::<'a>::border_style":["border_style","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::border_type":["border_type","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::borders":["borders","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::inner":["inner","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::style":["style","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::title":["title","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::Block::<'a>::title_style":["title_style","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::block::BorderType::line_symbols":["line_symbols","Real(LocalPath(\"src/widgets/block.rs\"))",""],"widgets::canvas::BrailleGrid::new":["new","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::background_color":["background_color","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::block":["block","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::marker":["marker","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::paint":["paint","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::x_bounds":["x_bounds","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Canvas::<'a, F>::y_bounds":["y_bounds","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::CharGrid::new":["new","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Context::<'a>::draw":["draw","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Context::<'a>::finish":["finish","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Context::<'a>::layer":["layer","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Context::<'a>::new":["new","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Context::<'a>::print":["print","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Painter::<'a, 'b>::get_point":["get_point","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::Painter::<'a, 'b>::paint":["paint","Real(LocalPath(\"src/widgets/canvas/mod.rs\"))",""],"widgets::canvas::line::draw_line_high":["draw_line_high","Real(LocalPath(\"src/widgets/canvas/line.rs\"))",""],"widgets::canvas::line::draw_line_low":["draw_line_low","Real(LocalPath(\"src/widgets/canvas/line.rs\"))",""],"widgets::canvas::map::MapResolution::data":["data","Real(LocalPath(\"src/widgets/canvas/map.rs\"))",""],"widgets::chart::Axis::<'a>::bounds":["bounds","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Axis::<'a>::labels":["labels","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Axis::<'a>::style":["style","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Axis::<'a>::title":["title","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Axis::<'a>::title_style":["title_style","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::block":["block","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::hidden_legend_constraints":["hidden_legend_constraints","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::layout":["layout","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::new":["new","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::style":["style","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::x_axis":["x_axis","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Chart::<'a>::y_axis":["y_axis","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Dataset::<'a>::data":["data","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Dataset::<'a>::graph_type":["graph_type","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Dataset::<'a>::marker":["marker","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Dataset::<'a>::name":["name","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::chart::Dataset::<'a>::style":["style","Real(LocalPath(\"src/widgets/chart.rs\"))",""],"widgets::gauge::Gauge::<'a>::block":["block","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::Gauge::<'a>::gauge_style":["gauge_style","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::Gauge::<'a>::label":["label","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::Gauge::<'a>::percent":["percent","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::Gauge::<'a>::ratio":["ratio","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::Gauge::<'a>::style":["style","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::block":["block","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::gauge_style":["gauge_style","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::label":["label","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::line_set":["line_set","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::ratio":["ratio","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::gauge::LineGauge::<'a>::style":["style","Real(LocalPath(\"src/widgets/gauge.rs\"))",""],"widgets::list::List::<'a>::block":["block","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::List::<'a>::highlight_style":["highlight_style","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::List::<'a>::highlight_symbol":["highlight_symbol","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::List::<'a>::new":["new","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::List::<'a>::start_corner":["start_corner","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::List::<'a>::style":["style","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::ListItem::<'a>::height":["height","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::ListItem::<'a>::new":["new","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::ListItem::<'a>::style":["style","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::ListState::select":["select","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::list::ListState::selected":["selected","Real(LocalPath(\"src/widgets/list.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::alignment":["alignment","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::block":["block","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::new":["new","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::scroll":["scroll","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::style":["style","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::Paragraph::<'a>::wrap":["wrap","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::paragraph::get_line_offset":["get_line_offset","Real(LocalPath(\"src/widgets/paragraph.rs\"))",""],"widgets::reflow::LineTruncator::<'a, 'b>::new":["new","Real(LocalPath(\"src/widgets/reflow.rs\"))",""],"widgets::reflow::LineTruncator::<'a, 'b>::set_horizontal_offset":["set_horizontal_offset","Real(LocalPath(\"src/widgets/reflow.rs\"))",""],"widgets::reflow::WordWrapper::<'a, 'b>::new":["new","Real(LocalPath(\"src/widgets/reflow.rs\"))",""],"widgets::reflow::trim_offset":["trim_offset","Real(LocalPath(\"src/widgets/reflow.rs\"))",""],"widgets::sparkline::Sparkline::<'a>::bar_set":["bar_set","Real(LocalPath(\"src/widgets/sparkline.rs\"))",""],"widgets::sparkline::Sparkline::<'a>::block":["block","Real(LocalPath(\"src/widgets/sparkline.rs\"))",""],"widgets::sparkline::Sparkline::<'a>::data":["data","Real(LocalPath(\"src/widgets/sparkline.rs\"))",""],"widgets::sparkline::Sparkline::<'a>::max":["max","Real(LocalPath(\"src/widgets/sparkline.rs\"))",""],"widgets::sparkline::Sparkline::<'a>::style":["style","Real(LocalPath(\"src/widgets/sparkline.rs\"))",""],"widgets::table::Table::<'a, H, R>::block":["block","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::column_spacing":["column_spacing","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::header":["header","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::header_gap":["header_gap","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::header_style":["header_style","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::highlight_style":["highlight_style","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::highlight_symbol":["highlight_symbol","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::new":["new","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::rows":["rows","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::style":["style","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::Table::<'a, H, R>::widths":["widths","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::TableState::select":["select","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::table::TableState::selected":["selected","Real(LocalPath(\"src/widgets/table.rs\"))",""],"widgets::tabs::Tabs::<'a>::block":["block","Real(LocalPath(\"src/widgets/tabs.rs\"))",""],"widgets::tabs::Tabs::<'a>::divider":["divider","Real(LocalPath(\"src/widgets/tabs.rs\"))",""],"widgets::tabs::Tabs::<'a>::highlight_style":["highlight_style","Real(LocalPath(\"src/widgets/tabs.rs\"))",""],"widgets::tabs::Tabs::<'a>::new":["new","Real(LocalPath(\"src/widgets/tabs.rs\"))",""],"widgets::tabs::Tabs::<'a>::select":["select","Real(LocalPath(\"src/widgets/tabs.rs\"))",""],"widgets::tabs::Tabs::<'a>::style":["style","Real(LocalPath(\"src/widgets/tabs.rs\"))",""]},"trait_to_struct":{"<style::Modifier as std::fmt::Debug>::fmt::__BitFlags":["style::Modifier"],"<widgets::Borders as std::fmt::Debug>::fmt::__BitFlags":["widgets::Borders"],"backend::Backend":["backend::termion::TermionBackend","backend::test::TestBackend"],"std::clone::Clone":["buffer::Buffer","buffer::Cell","layout::Alignment","layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Color","style::Modifier","style::Style","symbols::Marker","symbols::bar::Set","symbols::block::Set","symbols::line::Set","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport","text::Span","text::Spans","text::StyledGrapheme","text::Text","widgets::Borders","widgets::barchart::BarChart","widgets::block::Block","widgets::block::BorderType","widgets::canvas::BrailleGrid","widgets::canvas::CharGrid","widgets::canvas::Label","widgets::canvas::Layer","widgets::canvas::line::Line","widgets::canvas::map::Map","widgets::canvas::map::MapResolution","widgets::canvas::points::Points","widgets::canvas::rectangle::Rectangle","widgets::chart::Axis","widgets::chart::Chart","widgets::chart::ChartLayout","widgets::chart::Dataset","widgets::chart::GraphType","widgets::clear::Clear","widgets::gauge::Gauge","widgets::list::List","widgets::list::ListItem","widgets::list::ListState","widgets::paragraph::Paragraph","widgets::paragraph::Wrap","widgets::sparkline::Sparkline","widgets::table::Row","widgets::table::Table","widgets::table::TableState","widgets::tabs::Tabs"],"std::cmp::Eq":["layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Modifier","widgets::Borders"],"std::cmp::Ord":["style::Modifier","widgets::Borders"],"std::cmp::PartialEq":["buffer::Buffer","buffer::Cell","layout::Alignment","layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Color","style::Modifier","style::Style","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport","text::Span","text::Spans","text::StyledGrapheme","text::Text","widgets::Borders","widgets::chart::ChartLayout","widgets::list::ListItem"],"std::cmp::PartialOrd":["style::Modifier","widgets::Borders"],"std::convert::From":["std::string::String","text::Span","text::Spans","text::Text","widgets::canvas::Painter"],"std::default::Default":["buffer::Buffer","buffer::Cell","layout::Layout","layout::Rect","style::Style","text::Spans","text::Text","widgets::barchart::BarChart","widgets::block::Block","widgets::canvas::Canvas","widgets::canvas::map::Map","widgets::canvas::points::Points","widgets::chart::Axis","widgets::chart::ChartLayout","widgets::chart::Dataset","widgets::gauge::Gauge","widgets::gauge::LineGauge","widgets::list::ListState","widgets::sparkline::Sparkline","widgets::table::Table","widgets::table::TableState"],"std::fmt::Binary":["style::Modifier","widgets::Borders"],"std::fmt::Debug":["backend::test::TestBackend","buffer::Buffer","buffer::Cell","layout::Alignment","layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Color","style::Modifier","style::Style","symbols::Marker","symbols::bar::Set","symbols::block::Set","symbols::line::Set","terminal::ResizeBehavior","terminal::Terminal","terminal::TerminalOptions","terminal::Viewport","text::Span","text::Spans","text::StyledGrapheme","text::Text","widgets::Borders","widgets::barchart::BarChart","widgets::block::Block","widgets::block::BorderType","widgets::canvas::BrailleGrid","widgets::canvas::CharGrid","widgets::canvas::Context","widgets::canvas::Label","widgets::canvas::Layer","widgets::canvas::Painter","widgets::canvas::line::Line","widgets::canvas::map::Map","widgets::canvas::map::MapResolution","widgets::canvas::points::Points","widgets::canvas::rectangle::Rectangle","widgets::chart::Axis","widgets::chart::Chart","widgets::chart::ChartLayout","widgets::chart::Dataset","widgets::chart::GraphType","widgets::clear::Clear","widgets::gauge::Gauge","widgets::list::List","widgets::list::ListItem","widgets::list::ListState","widgets::paragraph::Paragraph","widgets::paragraph::Wrap","widgets::sparkline::Sparkline","widgets::table::Row","widgets::table::Table","widgets::table::TableState","widgets::tabs::Tabs"],"std::fmt::Display":["backend::termion::Bg","backend::termion::Fg","backend::termion::ModifierDiff"],"std::fmt::LowerHex":["style::Modifier","widgets::Borders"],"std::fmt::Octal":["style::Modifier","widgets::Borders"],"std::fmt::UpperHex":["style::Modifier","widgets::Borders"],"std::hash::Hash":["layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Modifier","widgets::Borders"],"std::io::Write":["backend::termion::TermionBackend"],"std::iter::Extend":["style::Modifier","text::Text","widgets::Borders"],"std::iter::FromIterator":["style::Modifier","widgets::Borders"],"std::iter::IntoIterator":["text::Text"],"std::marker::Copy":["layout::Alignment","layout::Constraint","layout::Corner","layout::Rect","style::Color","style::Modifier","style::Style","symbols::Marker","widgets::Borders","widgets::block::BorderType","widgets::canvas::map::MapResolution","widgets::chart::GraphType","widgets::paragraph::Wrap"],"std::marker::StructuralEq":["layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Modifier","widgets::Borders"],"std::marker::StructuralPartialEq":["buffer::Buffer","buffer::Cell","layout::Alignment","layout::Constraint","layout::Corner","layout::Direction","layout::Layout","layout::Margin","layout::Rect","style::Color","style::Modifier","style::Style","terminal::ResizeBehavior","terminal::TerminalOptions","terminal::Viewport","text::Span","text::Spans","text::StyledGrapheme","text::Text","widgets::Borders","widgets::chart::ChartLayout","widgets::list::ListItem"],"std::ops::BitAnd":["style::Modifier","widgets::Borders"],"std::ops::BitAndAssign":["style::Modifier","widgets::Borders"],"std::ops::BitOr":["style::Modifier","widgets::Borders"],"std::ops::BitOrAssign":["style::Modifier","widgets::Borders"],"std::ops::BitXor":["style::Modifier","widgets::Borders"],"std::ops::BitXorAssign":["style::Modifier","widgets::Borders"],"std::ops::Drop":["terminal::Terminal"],"std::ops::Not":["style::Modifier","widgets::Borders"],"std::ops::Sub":["style::Modifier","widgets::Borders"],"std::ops::SubAssign":["style::Modifier","widgets::Borders"],"style::Modifier::all::__BitFlags":["style::Modifier"],"widgets::Borders::all::__BitFlags":["widgets::Borders"],"widgets::StatefulWidget":["widgets::list::List","widgets::table::Table"],"widgets::Widget":["widgets::barchart::BarChart","widgets::block::Block","widgets::canvas::Canvas","widgets::chart::Chart","widgets::clear::Clear","widgets::gauge::Gauge","widgets::gauge::LineGauge","widgets::list::List","widgets::paragraph::Paragraph","widgets::sparkline::Sparkline","widgets::table::Table","widgets::tabs::Tabs"],"widgets::canvas::Grid":["widgets::canvas::BrailleGrid","widgets::canvas::CharGrid"],"widgets::canvas::Shape":["widgets::canvas::line::Line","widgets::canvas::map::Map","widgets::canvas::points::Points","widgets::canvas::rectangle::Rectangle"],"widgets::reflow::LineComposer":["widgets::reflow::LineTruncator","widgets::reflow::WordWrapper"]},"type_to_def_path":{"backend::termion::Bg":"backend::termion::Bg","backend::termion::Fg":"backend::termion::Fg","backend::termion::ModifierDiff":"backend::termion::ModifierDiff","backend::termion::TermionBackend<W>":"backend::termion::TermionBackend","backend::test::TestBackend":"backend::test::TestBackend","buffer::Buffer":"buffer::Buffer","buffer::Cell":"buffer::Cell","layout::Alignment":"layout::Alignment","layout::Constraint":"layout::Constraint","layout::Corner":"layout::Corner","layout::Direction":"layout::Direction","layout::Element":"layout::Element","layout::Layout":"layout::Layout","layout::Margin":"layout::Margin","layout::Rect":"layout::Rect","style::Color":"style::Color","style::Modifier":"style::Modifier","style::Style":"style::Style","symbols::Marker":"symbols::Marker","symbols::bar::Set":"symbols::bar::Set","symbols::block::Set":"symbols::block::Set","symbols::line::Set":"symbols::line::Set","terminal::Frame<'a, B>":"terminal::Frame","terminal::ResizeBehavior":"terminal::ResizeBehavior","terminal::Terminal<B>":"terminal::Terminal","terminal::TerminalOptions":"terminal::TerminalOptions","terminal::Viewport":"terminal::Viewport","text::Span<'a>":"text::Span","text::Spans<'a>":"text::Spans","text::StyledGrapheme<'a>":"text::StyledGrapheme","text::Text<'a>":"text::Text","widgets::Borders":"widgets::Borders","widgets::barchart::BarChart<'a>":"widgets::barchart::BarChart","widgets::block::Block<'a>":"widgets::block::Block","widgets::block::BorderType":"widgets::block::BorderType","widgets::canvas::BrailleGrid":"widgets::canvas::BrailleGrid","widgets::canvas::Canvas<'a, F>":"widgets::canvas::Canvas","widgets::canvas::CharGrid":"widgets::canvas::CharGrid","widgets::canvas::Context<'a>":"widgets::canvas::Context","widgets::canvas::Label<'a>":"widgets::canvas::Label","widgets::canvas::Layer":"widgets::canvas::Layer","widgets::canvas::Painter<'a, 'b>":"widgets::canvas::Painter","widgets::canvas::line::Line":"widgets::canvas::line::Line","widgets::canvas::map::Map":"widgets::canvas::map::Map","widgets::canvas::map::MapResolution":"widgets::canvas::map::MapResolution","widgets::canvas::points::Points<'a>":"widgets::canvas::points::Points","widgets::canvas::rectangle::Rectangle":"widgets::canvas::rectangle::Rectangle","widgets::chart::Axis<'a>":"widgets::chart::Axis","widgets::chart::Chart<'a>":"widgets::chart::Chart","widgets::chart::ChartLayout":"widgets::chart::ChartLayout","widgets::chart::Dataset<'a>":"widgets::chart::Dataset","widgets::chart::GraphType":"widgets::chart::GraphType","widgets::clear::Clear":"widgets::clear::Clear","widgets::gauge::Gauge<'a>":"widgets::gauge::Gauge","widgets::gauge::LineGauge<'a>":"widgets::gauge::LineGauge","widgets::list::List<'a>":"widgets::list::List","widgets::list::ListItem<'a>":"widgets::list::ListItem","widgets::list::ListState":"widgets::list::ListState","widgets::paragraph::Paragraph<'a>":"widgets::paragraph::Paragraph","widgets::paragraph::Wrap":"widgets::paragraph::Wrap","widgets::reflow::LineTruncator<'a, 'b>":"widgets::reflow::LineTruncator","widgets::reflow::WordWrapper<'a, 'b>":"widgets::reflow::WordWrapper","widgets::sparkline::Sparkline<'a>":"widgets::sparkline::Sparkline","widgets::table::Row<D>":"widgets::table::Row","widgets::table::Table<'a, H, R>":"widgets::table::Table","widgets::table::TableState":"widgets::table::TableState","widgets::tabs::Tabs<'a>":"widgets::tabs::Tabs"}}