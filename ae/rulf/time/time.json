{"dependencies":{"<T as ext::NumericalStdDurationShort>::days":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::hours":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::microseconds":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::milliseconds":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::minutes":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::nanoseconds":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::seconds":["std::time::Duration"],"<T as ext::NumericalStdDurationShort>::weeks":["std::time::Duration"],"<date::Date as private::Parsable>::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"<date::Date as std::clone::Clone>::clone":["date::Date"],"<date::Date as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date"],"<date::Date as std::cmp::Ord>::cmp":["date::Date","std::cmp::Ordering"],"<date::Date as std::cmp::PartialEq>::eq":["date::Date"],"<date::Date as std::cmp::PartialOrd>::partial_cmp":["date::Date","std::marker::Sized","std::option::Option"],"<date::Date as std::fmt::Debug>::fmt":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date as std::fmt::Display>::fmt":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date as std::hash::Hash>::hash":["date::Date","std::hash::Hasher","std::marker::Sized"],"<date::Date as std::ops::Add<duration::Duration>>::add":["date::Date","duration::Duration"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["date::Date","std::time::Duration"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","std::time::Duration"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["date::Date","duration::Duration"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["date::Date","std::time::Duration"],"<date::Date as std::ops::Sub>::sub":["date::Date"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","std::time::Duration"],"<duration::Duration as std::clone::Clone>::clone":["duration::Duration"],"<duration::Duration as std::cmp::Eq>::assert_receiver_is_total_eq":["duration::Duration"],"<duration::Duration as std::cmp::Ord>::cmp":["duration::Duration","std::cmp::Ordering"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["duration::Duration","std::time::Duration"],"<duration::Duration as std::cmp::PartialEq>::eq":["duration::Duration"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["duration::Duration","std::marker::Sized","std::option::Option","std::time::Duration"],"<duration::Duration as std::cmp::PartialOrd>::partial_cmp":["duration::Duration","std::marker::Sized","std::option::Option"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["std::marker::Sized","std::result::Result","std::time::Duration"],"<duration::Duration as std::default::Default>::default":["duration::Duration"],"<duration::Duration as std::fmt::Debug>::fmt":["duration::Duration","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<duration::Duration as std::hash::Hash>::hash":["duration::Duration","std::hash::Hasher","std::marker::Sized"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["duration::Duration","std::time::Duration"],"<duration::Duration as std::ops::Add>::add":["duration::Duration"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["duration::Duration","std::time::Duration"],"<duration::Duration as std::ops::AddAssign>::add_assign":["duration::Duration"],"<duration::Duration as std::ops::Div<f32>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<f64>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<i16>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<i32>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<i8>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["duration::Duration","std::time::Duration"],"<duration::Duration as std::ops::Div<u16>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<u32>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div<u8>>::div":["duration::Duration"],"<duration::Duration as std::ops::Div>::div":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["duration::Duration"],"<duration::Duration as std::ops::Mul<f32>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<f64>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<i16>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<i32>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<i8>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<u16>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<u32>>::mul":["duration::Duration"],"<duration::Duration as std::ops::Mul<u8>>::mul":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["duration::Duration"],"<duration::Duration as std::ops::Neg>::neg":["duration::Duration"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["duration::Duration","std::time::Duration"],"<duration::Duration as std::ops::Sub>::sub":["duration::Duration"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["duration::Duration","std::time::Duration"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["duration::Duration"],"<error::ComponentRange as std::clone::Clone>::clone":["error::ComponentRange"],"<error::ComponentRange as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ComponentRange"],"<error::ComponentRange as std::cmp::PartialEq>::eq":["error::ComponentRange"],"<error::ComponentRange as std::fmt::Debug>::fmt":["error::ComponentRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ComponentRange as std::fmt::Display>::fmt":["error::ComponentRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ComponentRange as std::hash::Hash>::hash":["error::ComponentRange","std::hash::Hasher","std::marker::Sized"],"<error::ConversionRange as std::clone::Clone>::clone":["error::ConversionRange"],"<error::ConversionRange as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ConversionRange"],"<error::ConversionRange as std::cmp::PartialEq>::eq":["error::ConversionRange"],"<error::ConversionRange as std::fmt::Debug>::fmt":["error::ConversionRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ConversionRange as std::fmt::Display>::fmt":["error::ConversionRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::clone::Clone>::clone":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::cmp::PartialEq>::eq":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::convert::From<error::ComponentRange>>::from":["error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::convert::From<error::ConversionRange>>::from":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::convert::From<error::Format>>::from":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::convert::From<error::IndeterminateOffset>>::from":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::convert::From<format::parse::Error>>::from":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as std::error::Error>::source":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<error::Error as std::fmt::Debug>::fmt":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::fmt::Display>::fmt":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Format as std::clone::Clone>::clone":["error::Format"],"<error::Format as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Format"],"<error::Format as std::cmp::Ord>::cmp":["error::Format","std::cmp::Ordering"],"<error::Format as std::cmp::PartialEq>::eq":["error::Format"],"<error::Format as std::cmp::PartialOrd>::partial_cmp":["error::Format","std::marker::Sized","std::option::Option"],"<error::Format as std::convert::From<std::fmt::Error>>::from":["error::Format","std::fmt::Error"],"<error::Format as std::error::Error>::source":["error::Format","std::marker::Sized","std::option::Option"],"<error::Format as std::fmt::Debug>::fmt":["error::Format","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Format as std::fmt::Display>::fmt":["error::Format","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Format as std::hash::Hash>::hash":["error::Format","std::hash::Hasher","std::marker::Sized"],"<error::IndeterminateOffset as std::clone::Clone>::clone":["error::IndeterminateOffset"],"<error::IndeterminateOffset as std::cmp::Eq>::assert_receiver_is_total_eq":["error::IndeterminateOffset"],"<error::IndeterminateOffset as std::cmp::PartialEq>::eq":["error::IndeterminateOffset"],"<error::IndeterminateOffset as std::fmt::Debug>::fmt":["error::IndeterminateOffset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::IndeterminateOffset as std::fmt::Display>::fmt":["error::IndeterminateOffset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<f32 as ext::NumericalDuration>::days":["duration::Duration"],"<f32 as ext::NumericalDuration>::hours":["duration::Duration"],"<f32 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<f32 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<f32 as ext::NumericalDuration>::minutes":["duration::Duration"],"<f32 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<f32 as ext::NumericalDuration>::seconds":["duration::Duration"],"<f32 as ext::NumericalDuration>::weeks":["duration::Duration"],"<f64 as ext::NumericalDuration>::days":["duration::Duration"],"<f64 as ext::NumericalDuration>::hours":["duration::Duration"],"<f64 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<f64 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<f64 as ext::NumericalDuration>::minutes":["duration::Duration"],"<f64 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<f64 as ext::NumericalDuration>::seconds":["duration::Duration"],"<f64 as ext::NumericalDuration>::weeks":["duration::Duration"],"<f64 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<format::FormatItem<'a> as std::clone::Clone>::clone":["format::FormatItem","format::Padding","format::Specifier"],"<format::FormatItem<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["format::FormatItem","format::Padding","format::Specifier"],"<format::FormatItem<'a> as std::cmp::PartialEq>::eq":["format::FormatItem","format::Padding","format::Specifier"],"<format::FormatItem<'a> as std::fmt::Debug>::fmt":["format::FormatItem","format::Padding","format::Specifier","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::FormatItem<'a> as std::hash::Hash>::hash":["format::FormatItem","format::Padding","format::Specifier","std::hash::Hasher","std::marker::Sized"],"<format::Padding as std::clone::Clone>::clone":["format::Padding"],"<format::Padding as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Padding"],"<format::Padding as std::cmp::PartialEq>::eq":["format::Padding"],"<format::Padding as std::fmt::Debug>::fmt":["format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Padding as std::hash::Hash>::hash":["format::Padding","std::hash::Hasher","std::marker::Sized"],"<format::Specifier as std::clone::Clone>::clone":["format::Padding","format::Specifier"],"<format::Specifier as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Padding","format::Specifier"],"<format::Specifier as std::cmp::PartialEq>::eq":["format::Padding","format::Specifier"],"<format::Specifier as std::fmt::Debug>::fmt":["format::Padding","format::Specifier","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Specifier as std::hash::Hash>::hash":["format::Padding","format::Specifier","std::hash::Hasher","std::marker::Sized"],"<format::deferred_format::DeferredFormat as std::clone::Clone>::clone":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"<format::deferred_format::DeferredFormat as std::cmp::Eq>::assert_receiver_is_total_eq":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"<format::deferred_format::DeferredFormat as std::cmp::PartialEq>::eq":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"<format::deferred_format::DeferredFormat as std::fmt::Debug>::fmt":["format::deferred_format::DeferredFormat","format::format::Format","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<format::deferred_format::DeferredFormat as std::fmt::Display>::fmt":["format::deferred_format::DeferredFormat","format::format::Format","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<format::deferred_format::DeferredFormat as std::hash::Hash>::hash":["format::deferred_format::DeferredFormat","format::format::Format","std::hash::Hasher","std::marker::Sized","std::option::Option","std::string::String"],"<format::format::Format as std::clone::Clone>::clone":["format::format::Format","std::string::String"],"<format::format::Format as std::cmp::Eq>::assert_receiver_is_total_eq":["format::format::Format","std::string::String"],"<format::format::Format as std::cmp::PartialEq>::eq":["format::format::Format","std::string::String"],"<format::format::Format as std::convert::From<T>>::from":["format::format::Format","std::string::String"],"<format::format::Format as std::fmt::Debug>::fmt":["format::format::Format","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<format::format::Format as std::hash::Hash>::hash":["format::format::Format","std::hash::Hasher","std::marker::Sized","std::string::String"],"<format::parse::AmPm as std::clone::Clone>::clone":["format::parse::AmPm"],"<format::parse::AmPm as std::cmp::Eq>::assert_receiver_is_total_eq":["format::parse::AmPm"],"<format::parse::AmPm as std::cmp::PartialEq>::eq":["format::parse::AmPm"],"<format::parse::AmPm as std::fmt::Debug>::fmt":["format::parse::AmPm","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::parse::Error as std::clone::Clone>::clone":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::parse::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::parse::Error as std::cmp::PartialEq>::eq":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::parse::Error as std::convert::From<error::ComponentRange>>::from":["error::ComponentRange","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::parse::Error as std::error::Error>::source":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<format::parse::Error as std::fmt::Debug>::fmt":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::parse::Error as std::fmt::Display>::fmt":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::parse::Error as std::hash::Hash>::hash":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<format::parse::ParsedItems as std::clone::Clone>::clone":["format::parse::ParsedItems","std::marker::Sized","std::option::Option"],"<format::parse::ParsedItems as std::fmt::Debug>::fmt":["format::parse::ParsedItems","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<i16 as ext::NumericalDuration>::days":["duration::Duration"],"<i16 as ext::NumericalDuration>::hours":["duration::Duration"],"<i16 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<i16 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<i16 as ext::NumericalDuration>::minutes":["duration::Duration"],"<i16 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<i16 as ext::NumericalDuration>::seconds":["duration::Duration"],"<i16 as ext::NumericalDuration>::weeks":["duration::Duration"],"<i32 as ext::NumericalDuration>::days":["duration::Duration"],"<i32 as ext::NumericalDuration>::hours":["duration::Duration"],"<i32 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<i32 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<i32 as ext::NumericalDuration>::minutes":["duration::Duration"],"<i32 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<i32 as ext::NumericalDuration>::seconds":["duration::Duration"],"<i32 as ext::NumericalDuration>::weeks":["duration::Duration"],"<i32 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<i32 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<i64 as ext::NumericalDuration>::days":["duration::Duration"],"<i64 as ext::NumericalDuration>::hours":["duration::Duration"],"<i64 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<i64 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<i64 as ext::NumericalDuration>::minutes":["duration::Duration"],"<i64 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<i64 as ext::NumericalDuration>::seconds":["duration::Duration"],"<i64 as ext::NumericalDuration>::weeks":["duration::Duration"],"<i8 as ext::NumericalDuration>::days":["duration::Duration"],"<i8 as ext::NumericalDuration>::hours":["duration::Duration"],"<i8 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<i8 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<i8 as ext::NumericalDuration>::minutes":["duration::Duration"],"<i8 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<i8 as ext::NumericalDuration>::seconds":["duration::Duration"],"<i8 as ext::NumericalDuration>::weeks":["duration::Duration"],"<instant::Instant as std::clone::Clone>::clone":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::Eq>::assert_receiver_is_total_eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::Ord>::cmp":["instant::Instant","std::cmp::Ordering","std::time::Instant"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::PartialEq>::eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"<instant::Instant as std::cmp::PartialOrd>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["instant::Instant","std::time::Instant"],"<instant::Instant as std::fmt::Debug>::fmt":["instant::Instant","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Instant"],"<instant::Instant as std::hash::Hash>::hash":["instant::Instant","std::hash::Hasher","std::marker::Sized","std::time::Instant"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["duration::Duration","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["duration::Duration","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["duration::Duration","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Sub>::sub":["instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["duration::Duration","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["instant::Instant","std::time::Duration","std::time::Instant"],"<offset_date_time::OffsetDateTime as private::Parsable>::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"<offset_date_time::OffsetDateTime as std::clone::Clone>::clone":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::cmp::Ordering","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::fmt::Debug>::fmt":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::hash::Hasher","std::marker::Sized","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Add<duration::Duration>>::add":["date::Date","duration::Duration","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Add<std::time::Duration>>::add":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub<duration::Duration>>::sub":["date::Date","duration::Duration","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::Duration>>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time","utc_offset::UtcOffset"],"<primitive_date_time::PrimitiveDateTime as private::Parsable>::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"<primitive_date_time::PrimitiveDateTime as std::clone::Clone>::clone":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::cmp::Ordering","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq>::eq":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::convert::From<std::time::SystemTime>>::from":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Debug>::fmt":["date::Date","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["date::Date","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash":["date::Date","primitive_date_time::PrimitiveDateTime","std::hash::Hasher","std::marker::Sized","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["date::Date","duration::Duration","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["date::Date","duration::Duration","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time_mod::Time"],"<sign::Sign as std::clone::Clone>::clone":["sign::Sign"],"<sign::Sign as std::cmp::Eq>::assert_receiver_is_total_eq":["sign::Sign"],"<sign::Sign as std::cmp::PartialEq>::eq":["sign::Sign"],"<sign::Sign as std::default::Default>::default":["sign::Sign"],"<sign::Sign as std::fmt::Debug>::fmt":["sign::Sign","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<sign::Sign as std::hash::Hash>::hash":["sign::Sign","std::hash::Hasher","std::marker::Sized"],"<sign::Sign as std::ops::Div>::div":["sign::Sign"],"<sign::Sign as std::ops::DivAssign>::div_assign":["sign::Sign"],"<sign::Sign as std::ops::Mul<f32>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<f64>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<i128>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<i16>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<i32>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<i64>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul<i8>>::mul":["sign::Sign"],"<sign::Sign as std::ops::Mul>::mul":["sign::Sign"],"<sign::Sign as std::ops::MulAssign>::mul_assign":["sign::Sign"],"<sign::Sign as std::ops::Neg>::neg":["sign::Sign"],"<sign::Sign as std::ops::Not>::not":["sign::Sign"],"<std::num::NonZeroI16 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI16 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroI16"],"<std::num::NonZeroI32 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI32 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroI32"],"<std::num::NonZeroI64 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI64 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroI64"],"<std::num::NonZeroI8 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroI8 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroI8"],"<std::num::NonZeroU16 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroU16"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_days":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_hours":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_microseconds":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_milliseconds":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_minutes":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_nanoseconds":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_seconds":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_weeks":["std::num::NonZeroU16","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroU32"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_days":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_hours":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_microseconds":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_milliseconds":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_minutes":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_nanoseconds":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_seconds":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_weeks":["std::num::NonZeroU32","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_days":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_hours":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_microseconds":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_milliseconds":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_minutes":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_nanoseconds":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_seconds":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_weeks":["std::num::NonZeroU64","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::days":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::hours":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::microseconds":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::milliseconds":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::minutes":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::nanoseconds":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::seconds":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalDuration>::weeks":["duration::Duration","std::num::NonZeroU8"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_days":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_hours":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_microseconds":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_milliseconds":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_minutes":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_nanoseconds":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_seconds":["std::num::NonZeroU8","std::time::Duration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_weeks":["std::num::NonZeroU8","std::time::Duration"],"<time_mod::Time as private::Parsable>::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"<time_mod::Time as std::clone::Clone>::clone":["time_mod::Time"],"<time_mod::Time as std::cmp::Eq>::assert_receiver_is_total_eq":["time_mod::Time"],"<time_mod::Time as std::cmp::Ord>::cmp":["std::cmp::Ordering","time_mod::Time"],"<time_mod::Time as std::cmp::PartialEq>::eq":["time_mod::Time"],"<time_mod::Time as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","time_mod::Time"],"<time_mod::Time as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"<time_mod::Time as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"<time_mod::Time as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","time_mod::Time"],"<time_mod::Time as std::ops::Add<duration::Duration>>::add":["duration::Duration","time_mod::Time"],"<time_mod::Time as std::ops::Add<std::time::Duration>>::add":["std::time::Duration","time_mod::Time"],"<time_mod::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["duration::Duration","time_mod::Time"],"<time_mod::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["std::time::Duration","time_mod::Time"],"<time_mod::Time as std::ops::Sub<duration::Duration>>::sub":["duration::Duration","time_mod::Time"],"<time_mod::Time as std::ops::Sub<std::time::Duration>>::sub":["std::time::Duration","time_mod::Time"],"<time_mod::Time as std::ops::Sub>::sub":["time_mod::Time"],"<time_mod::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["duration::Duration","time_mod::Time"],"<time_mod::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["std::time::Duration","time_mod::Time"],"<u16 as ext::NumericalDuration>::days":["duration::Duration"],"<u16 as ext::NumericalDuration>::hours":["duration::Duration"],"<u16 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<u16 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<u16 as ext::NumericalDuration>::minutes":["duration::Duration"],"<u16 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<u16 as ext::NumericalDuration>::seconds":["duration::Duration"],"<u16 as ext::NumericalDuration>::weeks":["duration::Duration"],"<u16 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<u16 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<u32 as ext::NumericalDuration>::days":["duration::Duration"],"<u32 as ext::NumericalDuration>::hours":["duration::Duration"],"<u32 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<u32 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<u32 as ext::NumericalDuration>::minutes":["duration::Duration"],"<u32 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<u32 as ext::NumericalDuration>::seconds":["duration::Duration"],"<u32 as ext::NumericalDuration>::weeks":["duration::Duration"],"<u32 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<u32 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<u8 as ext::NumericalDuration>::days":["duration::Duration"],"<u8 as ext::NumericalDuration>::hours":["duration::Duration"],"<u8 as ext::NumericalDuration>::microseconds":["duration::Duration"],"<u8 as ext::NumericalDuration>::milliseconds":["duration::Duration"],"<u8 as ext::NumericalDuration>::minutes":["duration::Duration"],"<u8 as ext::NumericalDuration>::nanoseconds":["duration::Duration"],"<u8 as ext::NumericalDuration>::seconds":["duration::Duration"],"<u8 as ext::NumericalDuration>::weeks":["duration::Duration"],"<u8 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<u8 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<utc_offset::UtcOffset as private::Parsable>::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"<utc_offset::UtcOffset as std::clone::Clone>::clone":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::Eq>::assert_receiver_is_total_eq":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::Ord>::cmp":["std::cmp::Ordering","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::PartialEq>::eq":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","utc_offset::UtcOffset"],"<weekday::Weekday as std::clone::Clone>::clone":["weekday::Weekday"],"<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq":["weekday::Weekday"],"<weekday::Weekday as std::cmp::PartialEq>::eq":["weekday::Weekday"],"<weekday::Weekday as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","weekday::Weekday"],"date::Date":["date::Date"],"date::Date::as_ymd":["date::Date"],"date::Date::as_yo":["date::Date"],"date::Date::day":["date::Date"],"date::Date::format":["date::Date","std::convert::AsRef","std::marker::Sized","std::string::String"],"date::Date::from_julian_day":["date::Date"],"date::Date::iso_weekday_number":["date::Date"],"date::Date::iso_year_week":["date::Date"],"date::Date::julian_day":["date::Date"],"date::Date::lazy_format":["date::Date","std::convert::AsRef","std::marker::Sized"],"date::Date::midnight":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"date::Date::monday_based_week":["date::Date"],"date::Date::month":["date::Date"],"date::Date::month_day":["date::Date"],"date::Date::next_day":["date::Date"],"date::Date::number_days_from_monday":["date::Date"],"date::Date::number_days_from_sunday":["date::Date"],"date::Date::ordinal":["date::Date"],"date::Date::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"date::Date::previous_day":["date::Date"],"date::Date::sunday_based_week":["date::Date"],"date::Date::today":["date::Date"],"date::Date::try_from_iso_ywd":["std::marker::Sized","std::result::Result","weekday::Weekday"],"date::Date::try_from_parsed_items":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"date::Date::try_from_parsed_items::adjustment":[],"date::Date::try_from_ymd":["std::marker::Sized","std::result::Result"],"date::Date::try_from_yo":["std::marker::Sized","std::result::Result"],"date::Date::try_with_hms":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::try_with_hms_micro":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::try_with_hms_milli":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::try_with_hms_nano":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::week":["date::Date"],"date::Date::weekday":["date::Date","weekday::Weekday"],"date::Date::with_time":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"date::Date::year":["date::Date"],"date::div_floor":[],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["duration::Duration","std::time::Duration"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["duration::Duration","std::marker::Sized","std::option::Option","std::time::Duration"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["duration::Duration","std::marker::Sized","std::result::Result"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["duration::Duration","std::time::Duration"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["duration::Duration","std::time::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["duration::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["duration::Duration"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["duration::Duration","std::time::Duration"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["duration::Duration","std::time::Duration"],"duration::Duration":["duration::Duration"],"duration::Duration::abs":["duration::Duration"],"duration::Duration::abs_std":["duration::Duration","std::time::Duration"],"duration::Duration::as_seconds_f32":["duration::Duration"],"duration::Duration::as_seconds_f64":["duration::Duration"],"duration::Duration::checked_add":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::checked_div":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::checked_mul":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::checked_sub":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::day":["duration::Duration"],"duration::Duration::days":["duration::Duration"],"duration::Duration::from_std":["std::marker::Sized","std::result::Result","std::time::Duration"],"duration::Duration::hour":["duration::Duration"],"duration::Duration::hours":["duration::Duration"],"duration::Duration::is_negative":["duration::Duration"],"duration::Duration::is_positive":["duration::Duration"],"duration::Duration::is_zero":["duration::Duration"],"duration::Duration::max_value":["duration::Duration"],"duration::Duration::microsecond":["duration::Duration"],"duration::Duration::microseconds":["duration::Duration"],"duration::Duration::millisecond":["duration::Duration"],"duration::Duration::milliseconds":["duration::Duration"],"duration::Duration::min_value":["duration::Duration"],"duration::Duration::minute":["duration::Duration"],"duration::Duration::minutes":["duration::Duration"],"duration::Duration::nanosecond":["duration::Duration"],"duration::Duration::nanoseconds":["duration::Duration"],"duration::Duration::nanoseconds_i128":["duration::Duration"],"duration::Duration::new":["duration::Duration"],"duration::Duration::num_days":["duration::Duration"],"duration::Duration::num_hours":["duration::Duration"],"duration::Duration::num_microseconds":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::num_milliseconds":["duration::Duration"],"duration::Duration::num_minutes":["duration::Duration"],"duration::Duration::num_nanoseconds":["duration::Duration","std::marker::Sized","std::option::Option"],"duration::Duration::num_seconds":["duration::Duration"],"duration::Duration::num_weeks":["duration::Duration"],"duration::Duration::second":["duration::Duration"],"duration::Duration::seconds":["duration::Duration"],"duration::Duration::seconds_f32":["duration::Duration"],"duration::Duration::seconds_f64":["duration::Duration"],"duration::Duration::sign":["duration::Duration","sign::Sign"],"duration::Duration::span":["duration::Duration","std::marker::Sized","std::ops::FnOnce"],"duration::Duration::subsec_microseconds":["duration::Duration"],"duration::Duration::subsec_milliseconds":["duration::Duration"],"duration::Duration::subsec_nanoseconds":["duration::Duration"],"duration::Duration::time_fn":["duration::Duration","std::marker::Sized","std::ops::FnOnce"],"duration::Duration::to_std":["duration::Duration","std::marker::Sized","std::result::Result"],"duration::Duration::week":["duration::Duration"],"duration::Duration::weeks":["duration::Duration"],"duration::Duration::whole_days":["duration::Duration"],"duration::Duration::whole_hours":["duration::Duration"],"duration::Duration::whole_microseconds":["duration::Duration"],"duration::Duration::whole_milliseconds":["duration::Duration"],"duration::Duration::whole_minutes":["duration::Duration"],"duration::Duration::whole_nanoseconds":["duration::Duration"],"duration::Duration::whole_seconds":["duration::Duration"],"duration::Duration::whole_weeks":["duration::Duration"],"duration::Duration::zero":["duration::Duration"],"error::ComponentRange":["error::ComponentRange"],"error::ConversionRange":["error::ConversionRange"],"error::Error":["error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Format":["error::Format"],"error::IndeterminateOffset":["error::IndeterminateOffset"],"ext::NumericalDuration::days":["duration::Duration"],"ext::NumericalDuration::hours":["duration::Duration"],"ext::NumericalDuration::microseconds":["duration::Duration"],"ext::NumericalDuration::milliseconds":["duration::Duration"],"ext::NumericalDuration::minutes":["duration::Duration"],"ext::NumericalDuration::nanoseconds":["duration::Duration"],"ext::NumericalDuration::seconds":["duration::Duration"],"ext::NumericalDuration::weeks":["duration::Duration"],"ext::NumericalStdDuration::std_days":["std::time::Duration"],"ext::NumericalStdDuration::std_hours":["std::time::Duration"],"ext::NumericalStdDuration::std_microseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_milliseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_minutes":["std::time::Duration"],"ext::NumericalStdDuration::std_nanoseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_seconds":["std::time::Duration"],"ext::NumericalStdDuration::std_weeks":["std::time::Duration"],"ext::NumericalStdDurationShort::days":["std::time::Duration"],"ext::NumericalStdDurationShort::hours":["std::time::Duration"],"ext::NumericalStdDurationShort::microseconds":["std::time::Duration"],"ext::NumericalStdDurationShort::milliseconds":["std::time::Duration"],"ext::NumericalStdDurationShort::minutes":["std::time::Duration"],"ext::NumericalStdDurationShort::nanoseconds":["std::time::Duration"],"ext::NumericalStdDurationShort::seconds":["std::time::Duration"],"ext::NumericalStdDurationShort::weeks":["std::time::Duration"],"format::FormatItem":["format::FormatItem","format::Padding","format::Specifier"],"format::Padding":["format::Padding"],"format::Specifier":["format::Padding","format::Specifier"],"format::date::fmt_A":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_B":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_C":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_G":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_U":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_V":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_W":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_Y":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_a":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_b":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_d":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_g":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_j":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_m":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_u":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_w":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::fmt_y":["date::Date","format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"format::date::parse_A":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_B":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_C":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_G":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_U":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_V":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_W":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_Y":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_a":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_b":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_d":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_g":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_j":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_m":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_u":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_w":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::date::parse_y":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::deferred_format::DeferredFormat":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::date":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::new":["format::deferred_format::DeferredFormat","format::format::Format","std::convert::Into","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::offset":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::time":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::with_date":["date::Date","format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String"],"format::deferred_format::DeferredFormat::with_offset":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String","utc_offset::UtcOffset"],"format::deferred_format::DeferredFormat::with_time":["format::deferred_format::DeferredFormat","format::format::Format","std::marker::Sized","std::option::Option","std::string::String","time_mod::Time"],"format::format::Format":["format::format::Format","std::string::String"],"format::format_specifier":["format::Padding","format::Specifier","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"format::offset::fmt_z":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utc_offset::UtcOffset"],"format::offset::parse_z":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::AmPm":["format::parse::AmPm"],"format::parse::Error":["format::parse::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"format::parse::ParsedItems":["format::parse::ParsedItems","std::marker::Sized","std::option::Option"],"format::parse::ParsedItems::new":["format::parse::ParsedItems","std::marker::Sized","std::option::Option"],"format::parse::consume_padding":["format::Padding"],"format::parse::parse":["format::format::Format","std::marker::Sized","std::result::Result","std::string::String"],"format::parse::try_consume_char":["std::marker::Sized","std::result::Result"],"format::parse::try_consume_char_case_insensitive":["std::marker::Sized","std::result::Result"],"format::parse::try_consume_digits":["std::marker::Sized","std::option::Option","std::str::FromStr"],"format::parse::try_consume_exact_digits":["format::Padding","std::marker::Sized","std::option::Option","std::str::FromStr"],"format::parse::try_consume_first_match":["date::Date","std::convert::AsRef","std::iter::IntoIterator","std::marker::Copy","std::marker::Sized","std::option::Option"],"format::parse::try_consume_str":["std::marker::Sized","std::result::Result"],"format::parse_items::parse_fmt_string":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"format::parse_items::try_parse_fmt_string":["std::marker::Sized","std::result::Result"],"format::time::fmt_H":["format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_I":["format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_M":["format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_N":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_P":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_S":["format::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::fmt_p":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time_mod::Time"],"format::time::parse_H":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_I":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_M":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_N":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_P":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_S":["format::Padding","format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::time::parse_p":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"format::well_known::rfc3339::fmt":["format::deferred_format::DeferredFormat","format::format::Format","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"format::well_known::rfc3339::parse":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["instant::Instant","std::time::Instant"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["instant::Instant","std::time::Instant"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["duration::Duration","std::time::Instant"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["duration::Duration","std::time::Instant"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["duration::Duration","std::time::Instant"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["instant::Instant","std::time::Instant"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["duration::Duration","std::time::Instant"],"instant::Instant":["instant::Instant","std::time::Instant"],"instant::Instant::checked_add":["duration::Duration","instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::Instant::checked_sub":["duration::Duration","instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::Instant::elapsed":["duration::Duration","instant::Instant","std::time::Instant"],"instant::Instant::now":["instant::Instant","std::time::Instant"],"instant::Instant::to":["duration::Duration","instant::Instant","std::time::Instant"],"internals::Date":["internals::Date"],"internals::Date::from_iso_ywd_unchecked":["date::Date","weekday::Weekday"],"internals::Date::from_ymd_unchecked":["date::Date"],"internals::Date::from_yo_unchecked":["date::Date"],"internals::Time":["internals::Time"],"internals::Time::from_hms_nanos_unchecked":["time_mod::Time"],"internals::jan_weekday":[],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["duration::Duration","std::time::SystemTime"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["duration::Duration","std::time::SystemTime"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["duration::Duration","std::time::SystemTime"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["duration::Duration","std::time::SystemTime"],"offset_date_time::OffsetDateTime":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::date":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::day":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::format":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::convert::Into","std::marker::Sized","std::string::String","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::from_unix_timestamp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::hour":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::iso_year_week":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::lazy_format":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::convert::Into","std::marker::Sized","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::microsecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::millisecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::minute":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::month":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::month_day":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::nanosecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::new_assuming_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::new_assuming_utc":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::now":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::now_local":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::now_utc":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::ordinal":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::parse":["std::convert::AsRef","std::convert::Into","std::marker::Sized","std::result::Result"],"offset_date_time::OffsetDateTime::second":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::time":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::timestamp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::timestamp_nanos":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::try_from_parsed_items":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"offset_date_time::OffsetDateTime::try_now_local":["std::marker::Sized","std::result::Result"],"offset_date_time::OffsetDateTime::unix_epoch":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::unix_timestamp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::week":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::weekday":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"offset_date_time::OffsetDateTime::year":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"parse":["date::Date","private::Parsable","std::convert::AsRef","std::marker::Sized","std::result::Result"],"precise_time_ns":[],"precise_time_s":[],"primitive_date_time::<impl std::cmp::PartialEq<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::eq":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"primitive_date_time::<impl std::cmp::PartialOrd<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::partial_cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time_mod::Time"],"primitive_date_time::<impl std::convert::From<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::from":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"primitive_date_time::<impl std::ops::Sub<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::assume_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::assume_utc":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::date":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::day":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::format":["date::Date","primitive_date_time::PrimitiveDateTime","std::convert::AsRef","std::marker::Sized","std::string::String","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::from_unix_timestamp":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::hour":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::iso_year_week":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::lazy_format":["date::Date","primitive_date_time::PrimitiveDateTime","std::convert::AsRef","std::marker::Sized","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::microsecond":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::millisecond":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::minute":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::monday_based_week":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::month":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::month_day":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::nanosecond":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::new":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::now":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::ordinal":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"primitive_date_time::PrimitiveDateTime::second":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::time":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::timestamp":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::try_from_parsed_items":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"primitive_date_time::PrimitiveDateTime::unix_epoch":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::using_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::week":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"primitive_date_time::PrimitiveDateTime::weekday":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time","weekday::Weekday"],"primitive_date_time::PrimitiveDateTime::year":["date::Date","primitive_date_time::PrimitiveDateTime","time_mod::Time"],"private::Parsable::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"sign::<impl std::ops::Div<sign::Sign> for f32>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for f64>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for i128>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for i16>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for i32>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for i64>::div":["sign::Sign"],"sign::<impl std::ops::Div<sign::Sign> for i8>::div":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for f32>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for f64>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i128>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i16>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i32>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i64>::div_assign":["sign::Sign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i8>::div_assign":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for f32>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for f64>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for i128>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for i16>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for i32>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for i64>::mul":["sign::Sign"],"sign::<impl std::ops::Mul<sign::Sign> for i8>::mul":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for f32>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for f64>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i128>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i16>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i32>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i64>::mul_assign":["sign::Sign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i8>::mul_assign":["sign::Sign"],"sign::Sign":["sign::Sign"],"sign::Sign::is_negative":["sign::Sign"],"sign::Sign::is_positive":["sign::Sign"],"sign::Sign::is_zero":["sign::Sign"],"sign::Sign::negate":["sign::Sign"],"time_mod::Time":["time_mod::Time"],"time_mod::Time::format":["std::convert::AsRef","std::marker::Sized","std::string::String","time_mod::Time"],"time_mod::Time::from_nanoseconds_since_midnight":["time_mod::Time"],"time_mod::Time::hour":["time_mod::Time"],"time_mod::Time::lazy_format":["std::convert::AsRef","std::marker::Sized","time_mod::Time"],"time_mod::Time::microsecond":["time_mod::Time"],"time_mod::Time::midnight":["time_mod::Time"],"time_mod::Time::millisecond":["time_mod::Time"],"time_mod::Time::minute":["time_mod::Time"],"time_mod::Time::nanosecond":["time_mod::Time"],"time_mod::Time::nanoseconds_since_midnight":["time_mod::Time"],"time_mod::Time::now":["time_mod::Time"],"time_mod::Time::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"time_mod::Time::second":["time_mod::Time"],"time_mod::Time::try_from_hms":["std::marker::Sized","std::result::Result"],"time_mod::Time::try_from_hms_micro":["std::marker::Sized","std::result::Result"],"time_mod::Time::try_from_hms_milli":["std::marker::Sized","std::result::Result"],"time_mod::Time::try_from_hms_nano":["std::marker::Sized","std::result::Result"],"time_mod::Time::try_from_parsed_items":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"time_mod::Time::try_from_parsed_items::hour_12_to_24":["format::parse::AmPm","std::num::NonZeroU8"],"utc_offset::UtcOffset":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::as_duration":["duration::Duration","utc_offset::UtcOffset"],"utc_offset::UtcOffset::as_hours":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::as_minutes":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::as_seconds":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::current_local_offset":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::east_hours":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::east_minutes":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::east_seconds":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::format":["std::convert::AsRef","std::marker::Sized","std::string::String","utc_offset::UtcOffset"],"utc_offset::UtcOffset::hours":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::lazy_format":["std::convert::AsRef","std::marker::Sized","utc_offset::UtcOffset"],"utc_offset::UtcOffset::local_offset_at":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"utc_offset::UtcOffset::minutes":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::parse":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"utc_offset::UtcOffset::seconds":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::try_current_local_offset":["std::marker::Sized","std::result::Result"],"utc_offset::UtcOffset::try_from_parsed_items":["format::parse::ParsedItems","std::marker::Sized","std::option::Option","std::result::Result"],"utc_offset::UtcOffset::try_local_offset_at":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::result::Result","time_mod::Time","utc_offset::UtcOffset"],"utc_offset::UtcOffset::west_hours":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::west_minutes":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::west_seconds":["utc_offset::UtcOffset"],"utc_offset::try_local_offset_at":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time_mod::Time","utc_offset::UtcOffset"],"util::days_in_year":[],"util::days_in_year_month":[],"util::is_leap_year":[],"util::validate_format_string":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"util::weeks_in_year":[],"weekday::Weekday":["weekday::Weekday"],"weekday::Weekday::iso_weekday_number":["weekday::Weekday"],"weekday::Weekday::next":["weekday::Weekday"],"weekday::Weekday::number_days_from_monday":["weekday::Weekday"],"weekday::Weekday::number_days_from_sunday":["weekday::Weekday"],"weekday::Weekday::number_from_monday":["weekday::Weekday"],"weekday::Weekday::number_from_sunday":["weekday::Weekday"],"weekday::Weekday::previous":["weekday::Weekday"]},"glob_path_import":{},"self_to_fn":{"<T as ext::NumericalStdDurationShort>::T":["impl<T: NumericalStdDuration> NumericalStdDurationShort for T {\n    fn nanoseconds(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_nanoseconds(self)\n    }\n\n    fn microseconds(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_microseconds(self)\n    }\n\n    fn milliseconds(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_milliseconds(self)\n    }\n\n    fn seconds(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_seconds(self)\n    }\n\n    fn minutes(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_minutes(self)\n    }\n\n    fn hours(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_hours(self)\n    }\n\n    fn days(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_days(self)\n    }\n\n    fn weeks(self) -> StdDuration {\n        <Self as NumericalStdDuration>::std_weeks(self)\n    }\n}"],"date::Date":["Clone","Copy","Eq","Hash","PartialEq","impl Add<Duration> for Date {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        Self::from_julian_day(self.julian_day() + duration.whole_days())\n    }\n}","impl Add<StdDuration> for Date {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        Self::from_julian_day(self.julian_day() + (duration.as_secs() / 86_400) as i64)\n    }\n}","impl AddAssign<Duration> for Date {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl AddAssign<StdDuration> for Date {\n    fn add_assign(&mut self, duration: StdDuration) {\n        *self = *self + duration;\n    }\n}","impl Date {\n    /// Create a `Date` from the year, month, and day.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{Date, date};\n    /// assert_eq!(Date::from_ymd(2019, 1, 1), date!(2019-001));\n    /// assert_eq!(Date::from_ymd(2019, 12, 31), date!(2019-365));\n    /// ```\n    ///\n    /// Panics if the date is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Date;\n    /// Date::from_ymd(2019, 2, 29); // 2019 isn't a leap year.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For dates knowable at compile-time, use the `date!` macro. For situations where a \\\n                value isn't known, use `Date::try_from_ymd`.\"\n    )]\n    pub fn from_ymd(year: i32, month: u8, day: u8) -> Self {\n        assert_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        assert_value_in_range!(month in 1 => 12);\n        assert_value_in_range!(day in 1 => days_in_year_month(year, month), given year, month);\n\n        internals::Date::from_ymd_unchecked(year, month, day)\n    }\n\n    /// Attempt to create a `Date` from the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::try_from_ymd(2019, 1, 1).is_ok());\n    /// assert!(Date::try_from_ymd(2019, 12, 31).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if the date is not valid.\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::try_from_ymd(2019, 2, 29).is_err()); // 2019 isn't a leap year.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_ymd(\n        year: i32,\n        month: u8,\n        day: u8,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(month in 1 => 12);\n        ensure_value_in_range!(day conditionally in 1 => days_in_year_month(year, month));\n\n        Ok(internals::Date::from_ymd_unchecked(year, month, day))\n    }\n\n    /// Create a `Date` from the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{Date, date};\n    /// assert_eq!(Date::from_yo(2019, 1), date!(2019-01-01));\n    /// assert_eq!(Date::from_yo(2019, 365), date!(2019-12-31));\n    /// ```\n    ///\n    /// Panics if the date is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Date;\n    /// Date::from_yo(2019, 366); // 2019 isn't a leap year.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For dates knowable at compile-time, use the `date!` macro. For situations where a \\\n                value isn't known, use `Date::try_from_yo`.\"\n    )]\n    pub fn from_yo(year: i32, ordinal: u16) -> Self {\n        assert_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        assert_value_in_range!(ordinal in 1 => days_in_year(year), given year);\n        internals::Date::from_yo_unchecked(year, ordinal)\n    }\n\n    /// Attempt to create a `Date` from the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::try_from_yo(2019, 1).is_ok());\n    /// assert!(Date::try_from_yo(2019, 365).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if the date is not valid.\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::try_from_yo(2019, 366).is_err()); // 2019 isn't a leap year.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_yo(year: i32, ordinal: u16) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(ordinal conditionally in 1 => days_in_year(year));\n        Ok(internals::Date::from_yo_unchecked(year, ordinal))\n    }\n\n    /// Create a `Date` from the ISO year, week, and weekday.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{Date, Weekday::*, date};\n    /// assert_eq!(\n    ///     Date::from_iso_ywd(2019, 1, Monday),\n    ///     date!(2018-12-31)\n    /// );\n    /// assert_eq!(\n    ///     Date::from_iso_ywd(2019, 1, Tuesday),\n    ///     date!(2019-01-01)\n    /// );\n    /// assert_eq!(\n    ///     Date::from_iso_ywd(2020, 53, Friday),\n    ///     date!(2021-01-01)\n    /// );\n    /// ```\n    ///\n    /// Panics if the week is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::{Date, Weekday::*};\n    /// Date::from_iso_ywd(2019, 53, Monday); // 2019 doesn't have 53 weeks.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For dates knowable at compile-time, use the `date!` macro. For situations where a \\\n                value isn't known, use `Date::try_from_iso_ywd`.\"\n    )]\n    pub fn from_iso_ywd(year: i32, week: u8, weekday: Weekday) -> Self {\n        assert_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        assert_value_in_range!(week in 1 => weeks_in_year(year), given year);\n        internals::Date::from_iso_ywd_unchecked(year, week, weekday)\n    }\n\n    /// Attempt to create a `Date` from the ISO year, week, and weekday.\n    ///\n    /// ```rust\n    /// # use time::{Date, Weekday::*};\n    /// assert!(Date::try_from_iso_ywd(2019, 1, Monday).is_ok());\n    /// assert!(Date::try_from_iso_ywd(2019, 1, Tuesday).is_ok());\n    /// assert!(Date::try_from_iso_ywd(2020, 53, Friday).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if the week is not valid.\n    ///\n    /// ```rust\n    /// # use time::{Date, Weekday::*};\n    /// assert!(Date::try_from_iso_ywd(2019, 53, Monday).is_err()); // 2019 doesn't have 53 weeks.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_iso_ywd(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(week conditionally in 1 => weeks_in_year(year));\n        Ok(internals::Date::from_iso_ywd_unchecked(year, week, weekday))\n    }\n\n    /// Create a `Date` representing the current date.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Date;\n    /// assert!(Date::today().year() >= 2019);\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n    #[allow(deprecated)]\n    pub fn today() -> Self {\n        PrimitiveDateTime::now().date()\n    }\n\n    /// Get the year of the date.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).year(), 2019);\n    /// assert_eq!(date!(2019-12-31).year(), 2019);\n    /// assert_eq!(date!(2020-01-01).year(), 2020);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[allow(clippy::missing_const_for_fn)]\n    #[const_fn(\"1.46\")]\n    pub const fn year(self) -> i32 {\n        self.value >> 9\n    }\n\n    /// Get the month. If fetching both the month and day, it is more efficient\n    /// to use [`Date::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=12`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).month(), 1);\n    /// assert_eq!(date!(2019-12-31).month(), 12);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn month(self) -> u8 {\n        self.month_day().0\n    }\n\n    /// Get the day of the month. If fetching both the month and day, it is more\n    /// efficient to use [`Date::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).day(), 1);\n    /// assert_eq!(date!(2019-12-31).day(), 31);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn day(self) -> u8 {\n        self.month_day().1\n    }\n\n    /// Get the month and day. This is more efficient than fetching the\n    /// components individually.\n    ///\n    /// The month component will always be in the range `1..=12`;\n    /// the day component in `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).month_day(), (1, 1));\n    /// assert_eq!(date!(2019-12-31).month_day(), (12, 31));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    // For whatever reason, rustc has difficulty optimizing this function. It's\n    // significantly faster to write the statements out by hand.\n    #[const_fn(\"1.46\")]\n    pub const fn month_day(self) -> (u8, u8) {\n        /// The number of days up to and including the given month. Common years\n        /// are first, followed by leap years.\n        #[allow(clippy::items_after_statements)]\n        const CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP: [[u16; 11]; 2] = [\n            [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        let days = CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP[is_leap_year(self.year()) as usize];\n        let ordinal = self.ordinal();\n\n        if ordinal > days[10] {\n            (12, (ordinal - days[10]) as u8)\n        } else if ordinal > days[9] {\n            (11, (ordinal - days[9]) as u8)\n        } else if ordinal > days[8] {\n            (10, (ordinal - days[8]) as u8)\n        } else if ordinal > days[7] {\n            (9, (ordinal - days[7]) as u8)\n        } else if ordinal > days[6] {\n            (8, (ordinal - days[6]) as u8)\n        } else if ordinal > days[5] {\n            (7, (ordinal - days[5]) as u8)\n        } else if ordinal > days[4] {\n            (6, (ordinal - days[4]) as u8)\n        } else if ordinal > days[3] {\n            (5, (ordinal - days[3]) as u8)\n        } else if ordinal > days[2] {\n            (4, (ordinal - days[2]) as u8)\n        } else if ordinal > days[1] {\n            (3, (ordinal - days[1]) as u8)\n        } else if ordinal > days[0] {\n            (2, (ordinal - days[0]) as u8)\n        } else {\n            (1, ordinal as u8)\n        }\n    }\n\n    /// Get the day of the year.\n    ///\n    /// The returned value will always be in the range `1..=366` (`1..=365` for\n    /// common years).\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).ordinal(), 1);\n    /// assert_eq!(date!(2019-12-31).ordinal(), 365);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[allow(clippy::missing_const_for_fn)]\n    #[const_fn(\"1.46\")]\n    pub const fn ordinal(self) -> u16 {\n        (self.value & 0x1FF) as u16\n    }\n\n    /// Get the ISO 8601 year and week number.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).iso_year_week(), (2019, 1));\n    /// assert_eq!(date!(2019-10-04).iso_year_week(), (2019, 40));\n    /// assert_eq!(date!(2020-01-01).iso_year_week(), (2020, 1));\n    /// assert_eq!(date!(2020-12-31).iso_year_week(), (2020, 53));\n    /// assert_eq!(date!(2021-01-01).iso_year_week(), (2020, 53));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn iso_year_week(self) -> (i32, u8) {\n        let (year, ordinal) = self.as_yo();\n\n        match ((ordinal + 10 - self.iso_weekday_number() as u16) / 7) as u8 {\n            0 => (year - 1, weeks_in_year(year - 1)),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1),\n            _ => (\n                year,\n                ((ordinal + 10 - self.iso_weekday_number() as u16) / 7) as u8,\n            ),\n        }\n    }\n\n    /// Get the ISO week number.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).week(), 1);\n    /// assert_eq!(date!(2019-10-04).week(), 40);\n    /// assert_eq!(date!(2020-01-01).week(), 1);\n    /// assert_eq!(date!(2020-12-31).week(), 53);\n    /// assert_eq!(date!(2021-01-01).week(), 53);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn week(self) -> u8 {\n        self.iso_year_week().1\n    }\n\n    /// Get the week number where week 1 begins on the first Sunday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).sunday_based_week(), 0);\n    /// assert_eq!(date!(2020-01-01).sunday_based_week(), 0);\n    /// assert_eq!(date!(2020-12-31).sunday_based_week(), 52);\n    /// assert_eq!(date!(2021-01-01).sunday_based_week(), 0);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn sunday_based_week(self) -> u8 {\n        ((self.ordinal() as i16 - self.number_days_from_sunday() as i16 + 6) / 7) as u8\n    }\n\n    /// Get the week number where week 1 begins on the first Monday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).monday_based_week(), 0);\n    /// assert_eq!(date!(2020-01-01).monday_based_week(), 0);\n    /// assert_eq!(date!(2020-12-31).monday_based_week(), 52);\n    /// assert_eq!(date!(2021-01-01).monday_based_week(), 0);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn monday_based_week(self) -> u8 {\n        ((self.ordinal() as i16 - self.number_days_from_monday() as i16 + 6) / 7) as u8\n    }\n\n    /// Get the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).as_ymd(), (2019, 1, 1));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn as_ymd(self) -> (i32, u8, u8) {\n        let (month, day) = self.month_day();\n        (self.year(), month, day)\n    }\n\n    /// Get the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).as_yo(), (2019, 1));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[allow(clippy::missing_const_for_fn)]\n    #[const_fn(\"1.46\")]\n    pub const fn as_yo(self) -> (i32, u16) {\n        (self.year(), self.ordinal())\n    }\n\n    /// Get the ISO weekday number.\n    ///\n    /// This is equivalent to calling `.weekday().iso_weekday_number()`, but is\n    /// usable in `const` contexts.\n    #[const_fn(\"1.46\")]\n    pub(crate) const fn iso_weekday_number(self) -> u8 {\n        self.number_days_from_monday() + 1\n    }\n\n    /// Get the number of days from Sunday.\n    ///\n    /// This is equivalent to calling `.weekday().number_days_from_sunday()`,\n    /// but is usable in `const` contexts.\n    #[const_fn(\"1.46\")]\n    pub(crate) const fn number_days_from_sunday(self) -> u8 {\n        self.iso_weekday_number() % 7\n    }\n\n    /// Get the number of days from Monday.\n    ///\n    /// This is equivalent to calling `.weekday().number_days_from_monday()`,\n    /// but is usable in `const` contexts.\n    #[const_fn(\"1.46\")]\n    pub(crate) const fn number_days_from_monday(self) -> u8 {\n        let (year, month, day) = self.as_ymd();\n\n        let (month, adjusted_year) = if month < 3 {\n            (month + 12, year - 1)\n        } else {\n            (month, year)\n        };\n\n        let raw_weekday =\n            (day as i32 + (13 * (month as i32 + 1)) / 5 + adjusted_year + adjusted_year / 4\n                - adjusted_year / 100\n                + adjusted_year / 400)\n                % 7\n                - 2;\n\n        if raw_weekday < 0 {\n            (raw_weekday + 7) as u8\n        } else {\n            raw_weekday as u8\n        }\n    }\n\n    /// Get the weekday.\n    ///\n    /// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n    /// internally.\n    ///\n    /// ```rust\n    /// # use time::{date, Weekday::*};\n    /// assert_eq!(date!(2019-01-01).weekday(), Tuesday);\n    /// assert_eq!(date!(2019-02-01).weekday(), Friday);\n    /// assert_eq!(date!(2019-03-01).weekday(), Friday);\n    /// assert_eq!(date!(2019-04-01).weekday(), Monday);\n    /// assert_eq!(date!(2019-05-01).weekday(), Wednesday);\n    /// assert_eq!(date!(2019-06-01).weekday(), Saturday);\n    /// assert_eq!(date!(2019-07-01).weekday(), Monday);\n    /// assert_eq!(date!(2019-08-01).weekday(), Thursday);\n    /// assert_eq!(date!(2019-09-01).weekday(), Sunday);\n    /// assert_eq!(date!(2019-10-01).weekday(), Tuesday);\n    /// assert_eq!(date!(2019-11-01).weekday(), Friday);\n    /// assert_eq!(date!(2019-12-01).weekday(), Sunday);\n    /// ```\n    pub fn weekday(self) -> Weekday {\n        match self.number_days_from_monday() {\n            0 => Weekday::Monday,\n            1 => Weekday::Tuesday,\n            2 => Weekday::Wednesday,\n            3 => Weekday::Thursday,\n            4 => Weekday::Friday,\n            5 => Weekday::Saturday,\n            6 => Weekday::Sunday,\n            // FIXME The compiler isn't able to optimize this away. See\n            // rust-lang/rust#66993.\n            _ => unreachable!(\"A value mod 7 is always in the range 0..7\"),\n        }\n    }\n\n    /// Get the next calendar date.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).next_day(), date!(2019-01-02));\n    /// assert_eq!(date!(2019-01-31).next_day(), date!(2019-02-01));\n    /// assert_eq!(date!(2019-12-31).next_day(), date!(2020-01-01));\n    /// ```\n    pub fn next_day(self) -> Self {\n        let (mut year, mut ordinal) = self.as_yo();\n\n        ordinal += 1;\n\n        if ordinal > days_in_year(year) {\n            year += 1;\n            ordinal = 1;\n        }\n\n        if year > MAX_YEAR {\n            panic!(\"overflow when fetching next day\");\n        }\n\n        internals::Date::from_yo_unchecked(year, ordinal)\n    }\n\n    /// Get the previous calendar date.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-02).previous_day(), date!(2019-01-01));\n    /// assert_eq!(date!(2019-02-01).previous_day(), date!(2019-01-31));\n    /// assert_eq!(date!(2020-01-01).previous_day(), date!(2019-12-31));\n    /// ```\n    pub fn previous_day(self) -> Self {\n        let (mut year, mut ordinal) = self.as_yo();\n\n        ordinal -= 1;\n\n        if ordinal == 0 {\n            year -= 1;\n            ordinal = days_in_year(year);\n        }\n\n        if year < MIN_YEAR {\n            panic!(\"overflow when fetching previous day\");\n        }\n\n        internals::Date::from_yo_unchecked(year, ordinal)\n    }\n\n    /// Get the Julian day for the date.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by\n    /// Peter Baum; it is freely available\n    /// [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(-4713-11-24).julian_day(), 0);\n    /// assert_eq!(date!(2000-01-01).julian_day(), 2_451_545);\n    /// assert_eq!(date!(2019-01-01).julian_day(), 2_458_485);\n    /// assert_eq!(date!(2019-12-31).julian_day(), 2_458_849);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn julian_day(self) -> i64 {\n        let (mut year, mut month, day) = self.as_ymd();\n\n        if month < 3 {\n            year -= 1;\n            month += 12;\n        }\n\n        let year = year as i64;\n        let month = month as i64;\n        let day = day as i64;\n\n        day + (153 * month - 457) / 5 + 365 * year + div_floor(year, 4) - div_floor(year, 100)\n            + div_floor(year, 400)\n            + 1_721_119\n    }\n\n    /// Create a `Date` from the Julian day.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by\n    /// Peter Baum; it is freely available\n    /// [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::{Date, date};\n    /// assert_eq!(\n    ///     Date::from_julian_day(0),\n    ///     date!(-4713-11-24)\n    /// );\n    /// assert_eq!(Date::from_julian_day(2_451_545), date!(2000-01-01));\n    /// assert_eq!(Date::from_julian_day(2_458_485), date!(2019-01-01));\n    /// assert_eq!(Date::from_julian_day(2_458_849), date!(2019-12-31));\n    /// ```\n    // TODO Return a `Result<Self, error::ComponentRange>` in 0.3\n    pub fn from_julian_day(julian_day: i64) -> Self {\n        #![allow(clippy::many_single_char_names)]\n        let z = julian_day - 1_721_119;\n        let h = 100 * z - 25;\n        let a = div_floor(h, 3_652_425);\n        let b = a - div_floor(a, 4);\n        let mut year = div_floor(100 * b + h, 36_525);\n        let c = b + z - 365 * year - div_floor(year, 4);\n        let mut month = (5 * c + 456) / 153;\n        let day = c - (153 * month - 457) / 5;\n\n        if month > 12 {\n            year += 1;\n            month -= 12;\n        }\n\n        match Date::try_from_ymd(year as i32, month as u8, day as u8) {\n            Ok(date) => date,\n            Err(err) => panic!(\"{}\", err),\n        }\n    }\n}","impl Date {\n    /// Create a `PrimitiveDateTime` using the existing date. The `Time` component will\n    /// be set to midnight.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).midnight(),\n    ///     date!(1970-01-01).with_time(time!(0:00))\n    /// );\n    /// ```\n    pub const fn midnight(self) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, Time::midnight())\n    }\n\n    /// Create a `PrimitiveDateTime` using the existing date and the provided `Time`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    ///     date!(1970-01-01).midnight(),\n    /// );\n    /// ```\n    pub const fn with_time(self, time: Time) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, time)\n    }\n\n    /// Create a `PrimitiveDateTime` using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_hms(0, 0, 0),\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    /// );\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro and `Date::with_time`. \\\n                For situations where a value isn't known, use `Date::try_with_hms`.\"\n    )]\n    pub fn with_hms(self, hour: u8, minute: u8, second: u8) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, Time::from_hms(hour, minute, second))\n    }\n\n    /// Attempt to create a `PrimitiveDateTime` using the existing date and the\n    /// provided time.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert!(date!(1970-01-01).try_with_hms(0, 0, 0).is_ok());\n    /// assert!(date!(1970-01-01).try_with_hms(24, 0, 0).is_err());\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_with_hms(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms(hour, minute, second)),\n        ))\n    }\n\n    /// Create a `PrimitiveDateTime` using the existing date and the provided\n    /// time.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_hms_milli(0, 0, 0, 0),\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    /// );\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro and `Date::with_time`. \\\n                For situations where a value isn't known, use `Date::try_with_hms_milli`.\"\n    )]\n    pub fn with_hms_milli(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(\n            self,\n            Time::from_hms_milli(hour, minute, second, millisecond),\n        )\n    }\n\n    /// Attempt to create a `PrimitiveDateTime` using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert!(date!(1970-01-01).try_with_hms_milli(0, 0, 0, 0).is_ok());\n    /// assert!(date!(1970-01-01).try_with_hms_milli(24, 0, 0, 0).is_err());\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_with_hms_milli(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_milli(hour, minute, second, millisecond)),\n        ))\n    }\n\n    /// Create a `PrimitiveDateTime` using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_hms_micro(0, 0, 0, 0),\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    /// );\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro and `Date::with_time`. \\\n                For situations where a value isn't known, use `Date::try_with_hms_micro`.\"\n    )]\n    pub fn with_hms_micro(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(\n            self,\n            Time::from_hms_micro(hour, minute, second, microsecond),\n        )\n    }\n\n    /// Attempt to create a `PrimitiveDateTime` using the existing date and the\n    /// provided time.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert!(date!(1970-01-01)\n    ///     .try_with_hms_micro(0, 0, 0, 0)\n    ///     .is_ok());\n    /// assert!(date!(1970-01-01)\n    ///     .try_with_hms_micro(24, 0, 0, 0)\n    ///     .is_err());\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_with_hms_micro(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_micro(hour, minute, second, microsecond)),\n        ))\n    }\n\n    /// Create a `PrimitiveDateTime` using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_hms_nano(0, 0, 0, 0),\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    /// );\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro and `Date::with_time`. \\\n                For situations where a value isn't known, use `Date::try_with_hms_nano`.\"\n    )]\n    pub fn with_hms_nano(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, Time::from_hms_nano(hour, minute, second, nanosecond))\n    }\n\n    /// Attempt to create a `PrimitiveDateTime` using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert!(date!(1970-01-01).try_with_hms_nano(0, 0, 0, 0).is_ok());\n    /// assert!(date!(1970-01-01).try_with_hms_nano(24, 0, 0, 0).is_err());\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_with_hms_nano(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_nano(hour, minute, second, nanosecond)),\n        ))\n    }\n}","impl Date {\n    /// Format the `Date` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-02).format(\"%Y-%m-%d\"), \"2019-01-02\");\n    /// ```\n    pub fn format(self, format: impl AsRef<str>) -> String {\n        self.lazy_format(format).to_string()\n    }\n\n    /// Format the `Date` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-02).lazy_format(\"%Y-%m-%d\").to_string(), \"2019-01-02\");\n    /// ```\n    pub fn lazy_format(self, format: impl AsRef<str>) -> impl Display {\n        DeferredFormat::new(format.as_ref())\n            .with_date(self)\n            .to_owned()\n    }\n\n    /// Attempt to parse a `Date` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::{Date, date};\n    /// assert_eq!(\n    ///     Date::parse(\"2019-01-02\", \"%F\"),\n    ///     Ok(date!(2019-01-02))\n    /// );\n    /// assert_eq!(\n    ///     Date::parse(\"2019-002\", \"%Y-%j\"),\n    ///     Ok(date!(2019-002))\n    /// );\n    /// assert_eq!(\n    ///     Date::parse(\"2019-W01-3\", \"%G-W%V-%u\"),\n    ///     Ok(date!(2019-W01-3))\n    /// );\n    /// ```\n    pub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }\n\n    /// Given the items already parsed, attempt to create a `Date`.\n    pub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self> {\n        macro_rules! items {\n            ($($item:ident),* $(,)?) => {\n                ParsedItems { $($item: Some($item)),*, .. }\n            };\n        }\n\n        /// Get the value needed to adjust the ordinal day for Sunday and\n        /// Monday-based week numbering.\n        fn adjustment(year: i32) -> i16 {\n            match internals::Date::from_yo_unchecked(year, 1).weekday() {\n                Weekday::Monday => 7,\n                Weekday::Tuesday => 1,\n                Weekday::Wednesday => 2,\n                Weekday::Thursday => 3,\n                Weekday::Friday => 4,\n                Weekday::Saturday => 5,\n                Weekday::Sunday => 6,\n            }\n        }\n\n        match items {\n            items!(year, month, day) => {\n                Date::try_from_ymd(year, month.get(), day.get()).map_err(Into::into)\n            }\n            items!(year, ordinal_day) => {\n                Date::try_from_yo(year, ordinal_day.get()).map_err(Into::into)\n            }\n            items!(week_based_year, iso_week, weekday) => {\n                Date::try_from_iso_ywd(week_based_year, iso_week.get(), weekday).map_err(Into::into)\n            }\n            items!(year, sunday_week, weekday) => Date::try_from_yo(\n                year,\n                (sunday_week as i16 * 7 + weekday.number_days_from_sunday() as i16\n                    - adjustment(year)\n                    + 1) as u16,\n            )\n            .map_err(Into::into),\n            items!(year, monday_week, weekday) => Date::try_from_yo(\n                year,\n                (monday_week as i16 * 7 + weekday.number_days_from_monday() as i16\n                    - adjustment(year)\n                    + 1) as u16,\n            )\n            .map_err(Into::into),\n            _ => Err(error::Parse::InsufficientInformation),\n        }\n    }\n}","impl Display for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use crate::format::{date, Padding};\n\n        date::fmt_Y(f, *self, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_m(f, *self, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_d(f, *self, Padding::Zero)?;\n\n        Ok(())\n    }\n}","impl Ord for Date {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.year()\n            .cmp(&other.year())\n            .then_with(|| self.ordinal().cmp(&other.ordinal()))\n    }\n}","impl Parsable for $type {\n                    fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n                        Self::parse(s, format)\n                    }\n                }","impl PartialOrd for Date {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Sub<Date> for Date {\n    type Output = Duration;\n\n    fn sub(self, other: Self) -> Self::Output {\n        Duration::days(self.julian_day() - other.julian_day())\n    }\n}","impl Sub<Duration> for Date {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        self + -duration\n    }\n}","impl Sub<StdDuration> for Date {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        Self::from_julian_day(self.julian_day() - (duration.as_secs() / 86_400) as i64)\n    }\n}","impl SubAssign<Duration> for Date {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}","impl SubAssign<StdDuration> for Date {\n    fn sub_assign(&mut self, duration: StdDuration) {\n        *self = *self - duration;\n    }\n}","impl fmt::Debug for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        f.debug_struct(\"Date\")\n            .field(\"year\", &self.year())\n            .field(\"ordinal\", &self.ordinal())\n            .finish()\n    }\n}"],"duration::Duration":["Clone","Copy","Debug","Default","Eq","Hash","PartialEq","impl Add for Duration {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        self.checked_add(rhs)\n            .expect(\"overflow when adding durations\")\n    }\n}","impl Add<StdDuration> for Duration {\n    type Output = Self;\n\n    fn add(self, std_duration: StdDuration) -> Self::Output {\n        self + Self::try_from(std_duration)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }\n}","impl AddAssign for Duration {\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}","impl AddAssign<StdDuration> for Duration {\n    fn add_assign(&mut self, rhs: StdDuration) {\n        *self = *self + rhs;\n    }\n}","impl Div<$type> for Duration {\n                type Output = Self;\n\n                fn div(self, rhs: $type) -> Self::Output {\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }\n            }","impl Div<Duration> for Duration {\n    type Output = f64;\n\n    fn div(self, rhs: Self) -> Self::Output {\n        self.as_seconds_f64() / rhs.as_seconds_f64()\n    }\n}","impl Div<StdDuration> for Duration {\n    type Output = f64;\n\n    fn div(self, rhs: StdDuration) -> Self::Output {\n        self.as_seconds_f64() / rhs.as_secs_f64()\n    }\n}","impl Div<f32> for Duration {\n    type Output = Self;\n\n    fn div(self, rhs: f32) -> Self::Output {\n        Self::seconds_f32(self.as_seconds_f32() / rhs)\n    }\n}","impl Div<f64> for Duration {\n    type Output = Self;\n\n    fn div(self, rhs: f64) -> Self::Output {\n        Self::seconds_f64(self.as_seconds_f64() / rhs)\n    }\n}","impl DivAssign<$type> for Duration {\n                fn div_assign(&mut self, rhs: $type) {\n                    *self = *self / rhs;\n                }\n            }","impl DivAssign<f32> for Duration {\n    fn div_assign(&mut self, rhs: f32) {\n        *self = *self / rhs;\n    }\n}","impl DivAssign<f64> for Duration {\n    fn div_assign(&mut self, rhs: f64) {\n        *self = *self / rhs;\n    }\n}","impl Duration {\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_weeks` function\")]\n    pub fn num_weeks(&self) -> i64 {\n        self.whole_weeks()\n    }\n\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_days` function\")]\n    pub fn num_days(&self) -> i64 {\n        self.whole_days()\n    }\n\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_hours` function\")]\n    pub fn num_hours(&self) -> i64 {\n        self.whole_hours()\n    }\n\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_minutes` function\")]\n    pub fn num_minutes(&self) -> i64 {\n        self.whole_minutes()\n    }\n\n    #[allow(clippy::missing_const_for_fn)]\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_seconds` function\")]\n    pub fn num_seconds(&self) -> i64 {\n        self.whole_seconds()\n    }\n\n    /// [`Duration::whole_milliseconds`] returns an `i128`, rather than\n    /// panicking on overflow. To avoid panicking, this method currently limits\n    /// the value to the range `i64::min_value()..=i64::max_value()`.\n    #[deprecated(\n        since = \"0.2.0\",\n        note = \"Use the `whole_milliseconds` function. The value is clamped between \\\n                `i64::min_value()` and `i64::max_value()`.\"\n    )]\n    pub fn num_milliseconds(&self) -> i64 {\n        let millis = self.whole_milliseconds();\n\n        if millis > i64::max_value() as i128 {\n            return i64::max_value();\n        }\n\n        if millis < i64::min_value() as i128 {\n            return i64::min_value();\n        }\n\n        millis as i64\n    }\n\n    /// [`Duration::whole_microseconds`] returns an `i128` rather than returning\n    /// `None` on `i64` overflow.\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_microseconds` function\")]\n    pub fn num_microseconds(&self) -> Option<i64> {\n        let micros = self.whole_microseconds();\n\n        if micros.abs() > i64::max_value() as i128 {\n            None\n        } else {\n            Some(micros as i64)\n        }\n    }\n\n    /// [`Duration::whole_nanoseconds`] returns an `i128` rather than returning\n    /// `None` on `i64` overflow.\n    #[deprecated(since = \"0.2.0\", note = \"Use the `whole_nanoseconds` function\")]\n    pub fn num_nanoseconds(&self) -> Option<i64> {\n        let nanos = self.whole_nanoseconds();\n\n        if nanos.abs() > i64::max_value() as i128 {\n            None\n        } else {\n            Some(nanos as i64)\n        }\n    }\n\n    #[cfg(feature = \"std\")]\n    #[deprecated(since = \"0.2.0\", note = \"Use the `time_fn` function\")]\n    pub fn span<F: FnOnce()>(f: F) -> Self {\n        Self::time_fn(f).0\n    }\n\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.0\",\n        note = \"Use `Duration::try_from(value)` or `value.try_into()`\"\n    )]\n    pub fn from_std(std: StdDuration) -> Result<Self, error::ConversionRange> {\n        std.try_into()\n    }\n\n    #[allow(deprecated)]\n    #[deprecated(\n        since = \"0.2.0\",\n        note = \"Use `std::time::Duration::try_from(value)` or `value.try_into()`\"\n    )]\n    pub fn to_std(&self) -> Result<StdDuration, error::ConversionRange> {\n        (*self).try_into()\n    }\n}","impl Duration {\n    /// Equivalent to `0.seconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::zero(), 0.seconds());\n    /// ```\n    pub const fn zero() -> Self {\n        Self::seconds(0)\n    }\n\n    /// Equivalent to `1.nanoseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::nanosecond(), 1.nanoseconds());\n    /// ```\n    pub const fn nanosecond() -> Self {\n        Self::nanoseconds(1)\n    }\n\n    /// Equivalent to `1.microseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::microsecond(), 1.microseconds());\n    /// ```\n    pub const fn microsecond() -> Self {\n        Self::microseconds(1)\n    }\n\n    /// Equivalent to `1.milliseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::millisecond(), 1.milliseconds());\n    /// ```\n    pub const fn millisecond() -> Self {\n        Self::milliseconds(1)\n    }\n\n    /// Equivalent to `1.seconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::second(), 1.seconds());\n    /// ```\n    pub const fn second() -> Self {\n        Self::seconds(1)\n    }\n\n    /// Equivalent to `1.minutes()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::minute(), 1.minutes());\n    /// ```\n    pub const fn minute() -> Self {\n        Self::minutes(1)\n    }\n\n    /// Equivalent to `1.hours()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::hour(), 1.hours());\n    /// ```\n    pub const fn hour() -> Self {\n        Self::hours(1)\n    }\n\n    /// Equivalent to `1.days()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::day(), 1.days());\n    /// ```\n    pub const fn day() -> Self {\n        Self::days(1)\n    }\n\n    /// Equivalent to `1.weeks()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::week(), 1.weeks());\n    /// ```\n    pub const fn week() -> Self {\n        Self::weeks(1)\n    }\n\n    /// The maximum possible duration. Adding any positive duration to this will\n    /// cause an overflow.\n    ///\n    /// The value returned by this method may change at any time.\n    pub const fn max_value() -> Self {\n        Self::new(i64::max_value(), 999_999_999)\n    }\n\n    /// The minimum possible duration. Adding any negative duration to this will\n    /// cause an overflow.\n    ///\n    /// The value returned by this method may change at any time.\n    pub const fn min_value() -> Self {\n        Self::new(i64::min_value(), -999_999_999)\n    }\n\n    /// Check if a duration is exactly zero.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert!(0.seconds().is_zero());\n    /// assert!(!1.nanoseconds().is_zero());\n    /// ```\n    pub const fn is_zero(self) -> bool {\n        (self.seconds == 0) & (self.nanoseconds == 0)\n    }\n\n    /// Check if a duration is negative.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert!((-1).seconds().is_negative());\n    /// assert!(!0.seconds().is_negative());\n    /// assert!(!1.seconds().is_negative());\n    /// ```\n    pub const fn is_negative(self) -> bool {\n        (self.seconds < 0) | (self.nanoseconds < 0)\n    }\n\n    /// Check if a duration is positive.\n    ///\n    /// ```rust\n    /// # use time::{prelude::*};\n    /// assert!(1.seconds().is_positive());\n    /// assert!(!0.seconds().is_positive());\n    /// assert!(!(-1).seconds().is_positive());\n    /// ```\n    pub const fn is_positive(self) -> bool {\n        (self.seconds > 0) | (self.nanoseconds > 0)\n    }\n\n    /// Get the sign of the duration.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{Sign, prelude::*};\n    /// assert_eq!(1.seconds().sign(), Sign::Positive);\n    /// assert_eq!((-1).seconds().sign(), Sign::Negative);\n    /// assert_eq!(0.seconds().sign(), Sign::Zero);\n    /// ```\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"To obtain the sign of a `Duration`, you should use the `is_positive`, \\\n                `is_negative`, and `is_zero` methods.\"\n    )]\n    #[allow(deprecated, clippy::missing_const_for_fn)]\n    pub fn sign(self) -> crate::Sign {\n        use crate::Sign::*;\n\n        if self.nanoseconds > 0 {\n            Positive\n        } else if self.nanoseconds < 0 {\n            Negative\n        } else if self.seconds > 0 {\n            Positive\n        } else if self.seconds < 0 {\n            Negative\n        } else {\n            Zero\n        }\n    }\n\n    /// Get the absolute value of the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.seconds().abs(), 1.seconds());\n    /// assert_eq!(0.seconds().abs(), 0.seconds());\n    /// assert_eq!((-1).seconds().abs(), 1.seconds());\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.39.\n    #[const_fn(\"1.39\")]\n    pub const fn abs(self) -> Self {\n        Self {\n            seconds: self.seconds.abs(),\n            nanoseconds: self.nanoseconds.abs(),\n        }\n    }\n\n    /// Convert the existing `Duration` to a `std::time::Duration` and its sign.\n    // This doesn't actually require the standard library, but is currently only\n    // used when it's enabled.\n    #[allow(clippy::missing_const_for_fn)] // false positive\n    #[cfg(feature = \"std\")]\n    pub(crate) fn abs_std(self) -> StdDuration {\n        StdDuration::new(self.seconds.abs() as u64, self.nanoseconds.abs() as u32)\n    }\n\n    /// Create a new `Duration` with the provided seconds and nanoseconds. If\n    /// nanoseconds is at least 10<sup>9</sup>, it will wrap to the number of\n    /// seconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::new(1, 0), 1.seconds());\n    /// assert_eq!(Duration::new(-1, 0), (-1).seconds());\n    /// assert_eq!(Duration::new(1, 2_000_000_000), 3.seconds());\n    /// ```\n    // FIXME This code is stupidly complex for the sole reason of maintaining\n    // back-compatibility with Rust 1.32.0. The equivalent code is commented out\n    // immediately below this function implementation. Thankfully, the compiler\n    // is able to do quite well at deduplicating the operations.\n    pub const fn new(seconds: i64, nanoseconds: i32) -> Self {\n        Self {\n            seconds: (seconds + nanoseconds as i64 / 1_000_000_000)\n                + (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                    - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                    == -1)\n                    & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                        - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                        == 1)) as i64\n                - (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                    - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                    == 1)\n                    & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                        - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                        == -1)) as i64,\n            nanoseconds: (nanoseconds % 1_000_000_000)\n                + 1_000_000_000\n                    * ((((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                        - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                        == 1)\n                        & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                            - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                            == -1)) as i32\n                        - (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                            - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                            == -1)\n                            & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                                - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                                == 1)) as i32),\n        }\n    }\n\n    // pub const fn new(mut seconds: i64, mut nanoseconds: i32) -> Self {\n    //     seconds += nanoseconds as i64 / 1_000_000_000;\n    //     nanoseconds %= 1_000_000_000;\n    //\n    //     // Alternatively, we can use `(nano)seconds.signum()` once it is\n    //     // stabilized within `const fn`. The behavior is identical.\n    //     let seconds_sign = match seconds {\n    //         n if n > 0 => 1,\n    //         0 => 0,\n    //         _ => -1,\n    //     };\n    //     let nanoseconds_sign = match nanoseconds {\n    //         n if n > 0 => 1,\n    //         0 => 0,\n    //         _ => -1,\n    //     };\n    //\n    //     if seconds_sign == 1 && nanoseconds_sign == -1 {\n    //         seconds -= 1;\n    //         nanoseconds += 1_000_000_000;\n    //     } else if seconds_sign == -1 && nanoseconds_sign == 1 {\n    //         seconds += 1;\n    //         nanoseconds -= 1_000_000_000;\n    //     }\n    //\n    //     Self {\n    //         seconds,\n    //         nanoseconds,\n    //     }\n    // }\n\n    /// Create a new `Duration` with the given number of weeks. Equivalent to\n    /// `Duration::seconds(weeks * 604_800)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::weeks(1), 604_800.seconds());\n    /// ```\n    pub const fn weeks(weeks: i64) -> Self {\n        Self::seconds(weeks * SECONDS_PER_WEEK)\n    }\n\n    /// Get the number of whole weeks in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.weeks().whole_weeks(), 1);\n    /// assert_eq!((-1).weeks().whole_weeks(), -1);\n    /// assert_eq!(6.days().whole_weeks(), 0);\n    /// assert_eq!((-6).days().whole_weeks(), 0);\n    /// ```\n    pub const fn whole_weeks(self) -> i64 {\n        self.whole_seconds() / SECONDS_PER_WEEK\n    }\n\n    /// Create a new `Duration` with the given number of days. Equivalent to\n    /// `Duration::seconds(days * 86_400)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::days(1), 86_400.seconds());\n    /// ```\n    pub const fn days(days: i64) -> Self {\n        Self::seconds(days * SECONDS_PER_DAY)\n    }\n\n    /// Get the number of whole days in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.days().whole_days(), 1);\n    /// assert_eq!((-1).days().whole_days(), -1);\n    /// assert_eq!(23.hours().whole_days(), 0);\n    /// assert_eq!((-23).hours().whole_days(), 0);\n    /// ```\n    pub const fn whole_days(self) -> i64 {\n        self.whole_seconds() / SECONDS_PER_DAY\n    }\n\n    /// Create a new `Duration` with the given number of hours. Equivalent to\n    /// `Duration::seconds(hours * 3_600)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::hours(1), 3_600.seconds());\n    /// ```\n    pub const fn hours(hours: i64) -> Self {\n        Self::seconds(hours * SECONDS_PER_HOUR)\n    }\n\n    /// Get the number of whole hours in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.hours().whole_hours(), 1);\n    /// assert_eq!((-1).hours().whole_hours(), -1);\n    /// assert_eq!(59.minutes().whole_hours(), 0);\n    /// assert_eq!((-59).minutes().whole_hours(), 0);\n    /// ```\n    pub const fn whole_hours(self) -> i64 {\n        self.whole_seconds() / SECONDS_PER_HOUR\n    }\n\n    /// Create a new `Duration` with the given number of minutes. Equivalent to\n    /// `Duration::seconds(minutes * 60)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::minutes(1), 60.seconds());\n    /// ```\n    pub const fn minutes(minutes: i64) -> Self {\n        Self::seconds(minutes * SECONDS_PER_MINUTE)\n    }\n\n    /// Get the number of whole minutes in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.minutes().whole_minutes(), 1);\n    /// assert_eq!((-1).minutes().whole_minutes(), -1);\n    /// assert_eq!(59.seconds().whole_minutes(), 0);\n    /// assert_eq!((-59).seconds().whole_minutes(), 0);\n    /// ```\n    pub const fn whole_minutes(self) -> i64 {\n        self.whole_seconds() / SECONDS_PER_MINUTE\n    }\n\n    /// Create a new `Duration` with the given number of seconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::seconds(1), 1_000.milliseconds());\n    /// ```\n    pub const fn seconds(seconds: i64) -> Self {\n        Self {\n            seconds,\n            nanoseconds: 0,\n        }\n    }\n\n    /// Get the number of whole seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.seconds().whole_seconds(), 1);\n    /// assert_eq!((-1).seconds().whole_seconds(), -1);\n    /// assert_eq!(1.minutes().whole_seconds(), 60);\n    /// assert_eq!((-1).minutes().whole_seconds(), -60);\n    /// ```\n    pub const fn whole_seconds(self) -> i64 {\n        self.seconds\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds\n    /// represented as `f64`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::seconds_f64(0.5), 0.5.seconds());\n    /// assert_eq!(Duration::seconds_f64(-0.5), -0.5.seconds());\n    /// ```\n    pub fn seconds_f64(seconds: f64) -> Self {\n        Self {\n            seconds: seconds as i64,\n            nanoseconds: ((seconds % 1.) * 1_000_000_000.) as i32,\n        }\n    }\n\n    /// Get the number of fractional seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.5.seconds().as_seconds_f64(), 1.5);\n    /// assert_eq!((-1.5).seconds().as_seconds_f64(), -1.5);\n    /// ```\n    pub fn as_seconds_f64(self) -> f64 {\n        self.seconds as f64 + self.nanoseconds as f64 / 1_000_000_000.\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds\n    /// represented as `f32`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::seconds_f32(0.5), 0.5.seconds());\n    /// assert_eq!(Duration::seconds_f32(-0.5), (-0.5).seconds());\n    /// ```\n    pub fn seconds_f32(seconds: f32) -> Self {\n        Self {\n            seconds: seconds as i64,\n            nanoseconds: ((seconds % 1.) * 1_000_000_000.) as i32,\n        }\n    }\n\n    /// Get the number of fractional seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.5.seconds().as_seconds_f32(), 1.5);\n    /// assert_eq!((-1.5).seconds().as_seconds_f32(), -1.5);\n    /// ```\n    pub fn as_seconds_f32(self) -> f32 {\n        self.seconds as f32 + self.nanoseconds as f32 / 1_000_000_000.\n    }\n\n    /// Create a new `Duration` with the given number of milliseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::milliseconds(1), 1_000.microseconds());\n    /// assert_eq!(Duration::milliseconds(-1), (-1_000).microseconds());\n    /// ```\n    pub const fn milliseconds(milliseconds: i64) -> Self {\n        Self {\n            seconds: milliseconds / 1_000,\n            nanoseconds: ((milliseconds % 1_000) * 1_000_000) as i32,\n        }\n    }\n\n    /// Get the number of whole milliseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.seconds().whole_milliseconds(), 1_000);\n    /// assert_eq!((-1).seconds().whole_milliseconds(), -1_000);\n    /// assert_eq!(1.milliseconds().whole_milliseconds(), 1);\n    /// assert_eq!((-1).milliseconds().whole_milliseconds(), -1);\n    /// ```\n    pub const fn whole_milliseconds(self) -> i128 {\n        self.seconds as i128 * 1_000 + self.nanoseconds as i128 / 1_000_000\n    }\n\n    /// Get the number of milliseconds past the number of whole seconds.\n    ///\n    /// Always in the range `-1_000..1_000`.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.4.seconds().subsec_milliseconds(), 400);\n    /// assert_eq!((-1.4).seconds().subsec_milliseconds(), -400);\n    /// ```\n    // Allow the lint, as the value is guaranteed to be less than 1000.\n    pub const fn subsec_milliseconds(self) -> i16 {\n        (self.nanoseconds / 1_000_000) as i16\n    }\n\n    /// Create a new `Duration` with the given number of microseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::microseconds(1), 1_000.nanoseconds());\n    /// assert_eq!(Duration::microseconds(-1), (-1_000).nanoseconds());\n    /// ```\n    pub const fn microseconds(microseconds: i64) -> Self {\n        Self {\n            seconds: microseconds / 1_000_000,\n            nanoseconds: ((microseconds % 1_000_000) * 1_000) as i32,\n        }\n    }\n\n    /// Get the number of whole microseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.milliseconds().whole_microseconds(), 1_000);\n    /// assert_eq!((-1).milliseconds().whole_microseconds(), -1_000);\n    /// assert_eq!(1.microseconds().whole_microseconds(), 1);\n    /// assert_eq!((-1).microseconds().whole_microseconds(), -1);\n    /// ```\n    pub const fn whole_microseconds(self) -> i128 {\n        self.seconds as i128 * 1_000_000 + self.nanoseconds as i128 / 1_000\n    }\n\n    /// Get the number of microseconds past the number of whole seconds.\n    ///\n    /// Always in the range `-1_000_000..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.0004.seconds().subsec_microseconds(), 400);\n    /// assert_eq!((-1.0004).seconds().subsec_microseconds(), -400);\n    /// ```\n    pub const fn subsec_microseconds(self) -> i32 {\n        self.nanoseconds / 1_000\n    }\n\n    /// Create a new `Duration` with the given number of nanoseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(Duration::nanoseconds(1), 1.microseconds() / 1_000);\n    /// assert_eq!(Duration::nanoseconds(-1), (-1).microseconds() / 1_000);\n    /// ```\n    pub const fn nanoseconds(nanoseconds: i64) -> Self {\n        Self {\n            seconds: nanoseconds / 1_000_000_000,\n            nanoseconds: (nanoseconds % 1_000_000_000) as i32,\n        }\n    }\n\n    /// Create a new `Duration` with the given number of nanoseconds.\n    ///\n    /// As the input range cannot be fully mapped to the output, this should\n    /// only be used where it's known to result in a valid value.\n    pub(crate) const fn nanoseconds_i128(nanoseconds: i128) -> Self {\n        Self {\n            seconds: (nanoseconds / 1_000_000_000) as i64,\n            nanoseconds: (nanoseconds % 1_000_000_000) as i32,\n        }\n    }\n\n    /// Get the number of nanoseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.microseconds().whole_nanoseconds(), 1_000);\n    /// assert_eq!((-1).microseconds().whole_nanoseconds(), -1_000);\n    /// assert_eq!(1.nanoseconds().whole_nanoseconds(), 1);\n    /// assert_eq!((-1).nanoseconds().whole_nanoseconds(), -1);\n    /// ```\n    pub const fn whole_nanoseconds(self) -> i128 {\n        self.seconds as i128 * 1_000_000_000 + self.nanoseconds as i128\n    }\n\n    /// Get the number of nanoseconds past the number of whole seconds.\n    ///\n    /// The returned value will always be in the range\n    /// `-1_000_000_000..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(1.000_000_400.seconds().subsec_nanoseconds(), 400);\n    /// assert_eq!((-1.000_000_400).seconds().subsec_nanoseconds(), -400);\n    /// ```\n    pub const fn subsec_nanoseconds(self) -> i32 {\n        self.nanoseconds\n    }\n\n    /// Computes `self + rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(5.seconds().checked_add(5.seconds()), Some(10.seconds()));\n    /// assert_eq!(Duration::max_value().checked_add(1.nanoseconds()), None);\n    /// assert_eq!((-5).seconds().checked_add(5.seconds()), Some(0.seconds()));\n    /// ```\n    pub fn checked_add(self, rhs: Self) -> Option<Self> {\n        let mut seconds = self.seconds.checked_add(rhs.seconds)?;\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = seconds.checked_add(1)?;\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = seconds.checked_sub(1)?;\n        }\n\n        // Ensure that the signs match _unless_ one of them is zero.\n        debug_assert_ne!(seconds.signum() * nanoseconds.signum() as i64, -1);\n        debug_assert!((-999_999_999..1_000_000_000).contains(&nanoseconds));\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }\n\n    /// Computes `self - rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(5.seconds().checked_sub(5.seconds()), Some(Duration::zero()));\n    /// assert_eq!(Duration::min_value().checked_sub(1.nanoseconds()), None);\n    /// assert_eq!(5.seconds().checked_sub(10.seconds()), Some((-5).seconds()));\n    /// ```\n    pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n        self.checked_add(-rhs)\n    }\n\n    /// Computes `self * rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, prelude::*};\n    /// assert_eq!(5.seconds().checked_mul(2), Some(10.seconds()));\n    /// assert_eq!(5.seconds().checked_mul(-2), Some((-10).seconds()));\n    /// assert_eq!(5.seconds().checked_mul(0), Some(0.seconds()));\n    /// assert_eq!(Duration::max_value().checked_mul(2), None);\n    /// assert_eq!(Duration::min_value().checked_mul(2), None);\n    /// ```\n    pub fn checked_mul(self, rhs: i32) -> Option<Self> {\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as i32;\n        let seconds = self\n            .seconds\n            .checked_mul(rhs as i64)?\n            .checked_add(extra_secs)?;\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }\n\n    /// Computes `self / rhs`, returning `None` if `rhs == 0`.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// assert_eq!(10.seconds().checked_div(2), Some(5.seconds()));\n    /// assert_eq!(10.seconds().checked_div(-2), Some((-5).seconds()));\n    /// assert_eq!(1.seconds().checked_div(0), None);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn checked_div(self, rhs: i32) -> Option<Self> {\n        if rhs == 0 {\n            return None;\n        }\n\n        let seconds = self.seconds / (rhs as i64);\n        let carry = self.seconds - seconds * (rhs as i64);\n        let extra_nanos = carry * 1_000_000_000 / (rhs as i64);\n        let nanoseconds = self.nanoseconds / rhs + (extra_nanos as i32);\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }\n\n    /// Runs a closure, returning the duration of time it took to run. The\n    /// return value of the closure is provided in the second part of the tuple.\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn time_fn<T>(f: impl FnOnce() -> T) -> (Self, T) {\n        let start = Instant::now();\n        let return_value = f();\n        let end = Instant::now();\n\n        (end - start, return_value)\n    }\n}","impl Mul<$type> for Duration {\n                type Output = Self;\n\n                fn mul(self, rhs: $type) -> Self::Output {\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }\n            }","impl Mul<f32> for Duration {\n    type Output = Self;\n\n    fn mul(self, rhs: f32) -> Self::Output {\n        Self::seconds_f32(self.as_seconds_f32() * rhs)\n    }\n}","impl Mul<f64> for Duration {\n    type Output = Self;\n\n    fn mul(self, rhs: f64) -> Self::Output {\n        Self::seconds_f64(self.as_seconds_f64() * rhs)\n    }\n}","impl MulAssign<$type> for Duration {\n                fn mul_assign(&mut self, rhs: $type) {\n                    *self = *self * rhs;\n                }\n            }","impl MulAssign<f32> for Duration {\n    fn mul_assign(&mut self, rhs: f32) {\n        *self = *self * rhs;\n    }\n}","impl MulAssign<f64> for Duration {\n    fn mul_assign(&mut self, rhs: f64) {\n        *self = *self * rhs;\n    }\n}","impl Neg for Duration {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        -1 * self\n    }\n}","impl Ord for Duration {\n    fn cmp(&self, rhs: &Self) -> Ordering {\n        self.seconds\n            .cmp(&rhs.seconds)\n            .then_with(|| self.nanoseconds.cmp(&rhs.nanoseconds))\n    }\n}","impl PartialEq<StdDuration> for Duration {\n    fn eq(&self, rhs: &StdDuration) -> bool {\n        Ok(*self) == Self::try_from(*rhs)\n    }\n}","impl PartialOrd for Duration {\n    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n        Some(self.cmp(rhs))\n    }\n}","impl PartialOrd<StdDuration> for Duration {\n    fn partial_cmp(&self, rhs: &StdDuration) -> Option<Ordering> {\n        if rhs.as_secs() > i64::max_value() as u64 {\n            return Some(Ordering::Less);\n        }\n\n        Some(\n            self.seconds\n                .cmp(&(rhs.as_secs() as i64))\n                .then_with(|| self.nanoseconds.cmp(&(rhs.subsec_nanos() as i32))),\n        )\n    }\n}","impl Sub for Duration {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        self.checked_sub(rhs)\n            .expect(\"overflow when subtracting durations\")\n    }\n}","impl Sub<StdDuration> for Duration {\n    type Output = Self;\n\n    fn sub(self, rhs: StdDuration) -> Self::Output {\n        self - Self::try_from(rhs)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }\n}","impl SubAssign for Duration {\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}","impl SubAssign<StdDuration> for Duration {\n    fn sub_assign(&mut self, rhs: StdDuration) {\n        *self = *self - rhs;\n    }\n}","impl TryFrom<StdDuration> for Duration {\n    type Error = error::ConversionRange;\n\n    fn try_from(original: StdDuration) -> Result<Self, error::ConversionRange> {\n        Ok(Self::new(\n            original\n                .as_secs()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            original\n                .subsec_nanos()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }\n}"],"error::ComponentRange":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl fmt::Display for ComponentRange {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{} must be in the range {}..={}\",\n            self.name, self.minimum, self.maximum\n        )?;\n\n        if self.conditional_range {\n            write!(f, \", given values of other parameters\")?;\n        }\n\n        Ok(())\n    }\n}","impl std::error::Error for ComponentRange {}"],"error::ConversionRange":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for ConversionRange {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Source value is out of range for the target type\")\n    }\n}","impl std::error::Error for ConversionRange {}"],"error::Error":["Clone","Debug","Eq","PartialEq","impl From<ComponentRange> for Error {\n    fn from(original: ComponentRange) -> Self {\n        Error::ComponentRange(Box::new(original))\n    }\n}","impl From<ConversionRange> for Error {\n    fn from(original: ConversionRange) -> Self {\n        Error::ConversionRange(original)\n    }\n}","impl From<Format> for Error {\n    fn from(error: Format) -> Self {\n        Error::Format(error)\n    }\n}","impl From<IndeterminateOffset> for Error {\n    fn from(original: IndeterminateOffset) -> Self {\n        Error::IndeterminateOffset(original)\n    }\n}","impl From<Parse> for Error {\n    fn from(original: Parse) -> Self {\n        Error::Parse(original)\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::ConversionRange(e) => e.fmt(f),\n            Error::ComponentRange(e) => e.fmt(f),\n            Error::Parse(e) => e.fmt(f),\n            Error::IndeterminateOffset(e) => e.fmt(f),\n            Error::Format(e) => e.fmt(f),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Error::__NonExhaustive => unreachable!(),\n        }\n    }\n}","impl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Error::ConversionRange(err) => Some(err),\n            Error::ComponentRange(box_err) => Some(box_err.as_ref()),\n            Error::Parse(err) => Some(err),\n            Error::IndeterminateOffset(err) => Some(err),\n            Error::Format(err) => Some(err),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Error::__NonExhaustive => unreachable!(),\n        }\n    }\n}"],"error::Format":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<fmt::Error> for Format {\n    fn from(_: fmt::Error) -> Self {\n        Format::StdFmtError\n    }\n}","impl fmt::Display for Format {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Format::InsufficientTypeInformation => {\n                f.write_str(\"The format provided requires more information than the type provides.\")\n            }\n            Format::StdFmtError => fmt::Error.fmt(f),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Format::__NonExhaustive => unreachable!(),\n        }\n    }\n}","impl std::error::Error for Format {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Format::StdFmtError => Some(&fmt::Error),\n            _ => None,\n        }\n    }\n}"],"error::IndeterminateOffset":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for IndeterminateOffset {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"The system's UTC offset could not be determined\")\n    }\n}","impl std::error::Error for IndeterminateOffset {}"],"format::FormatItem":["Clone","Debug","Eq","Hash","PartialEq"],"format::Padding":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"format::Specifier":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"format::deferred_format::DeferredFormat":["Clone","Debug","Eq","Hash","PartialEq","impl DeferredFormat {\n    /// Create a new `DeferredFormat` with the provided formatting string.\n    pub(crate) fn new(format: impl Into<Format>) -> Self {\n        Self {\n            date: None,\n            time: None,\n            offset: None,\n            format: format.into(),\n        }\n    }\n\n    /// Provide the `Date` component.\n    pub(crate) fn with_date(&mut self, date: Date) -> &mut Self {\n        self.date = Some(date);\n        self\n    }\n\n    /// Provide the `Time` component.\n    pub(crate) fn with_time(&mut self, time: Time) -> &mut Self {\n        self.time = Some(time);\n        self\n    }\n\n    /// Provide the `UtcOffset` component.\n    pub(crate) fn with_offset(&mut self, offset: UtcOffset) -> &mut Self {\n        self.offset = Some(offset);\n        self\n    }\n\n    /// Obtain the `Date` component.\n    pub(crate) const fn date(&self) -> Option<Date> {\n        self.date\n    }\n\n    /// Obtain the `Time` component.\n    pub(crate) const fn time(&self) -> Option<Time> {\n        self.time\n    }\n\n    /// Obtain the `UtcOffset` component.\n    pub(crate) const fn offset(&self) -> Option<UtcOffset> {\n        self.offset\n    }\n}","impl Display for DeferredFormat {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        match &self.format {\n            Format::Custom(s) => {\n                for item in parse_fmt_string(s) {\n                    match item {\n                        FormatItem::Literal(value) => f.write_str(value)?,\n                        FormatItem::Specifier(specifier) => {\n                            format_specifier(f, self.date, self.time, self.offset, specifier)\n                                .map_err(|_| fmt::Error)?\n                        }\n                    }\n                }\n\n                Ok(())\n            }\n            Format::Rfc3339 => well_known::rfc3339::fmt(self, f).map_err(|_| fmt::Error),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Format::__NonExhaustive => unreachable!(),\n        }\n    }\n}"],"format::format::Format":["Clone","Debug","Eq","Hash","PartialEq","impl<T: AsRef<str>> From<T> for Format {\n    fn from(s: T) -> Self {\n        Format::Custom(s.as_ref().to_owned())\n    }\n}"],"format::parse::AmPm":["Clone","Copy","Debug","Eq","PartialEq"],"format::parse::Error":["Clone","Debug","Eq","Hash","PartialEq","impl Display for Error {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        use Error::*;\n        match self {\n            InvalidNanosecond => f.write_str(\"invalid nanosecond\"),\n            InvalidSecond => f.write_str(\"invalid second\"),\n            InvalidMinute => f.write_str(\"invalid minute\"),\n            InvalidHour => f.write_str(\"invalid hour\"),\n            InvalidAmPm => f.write_str(\"invalid am/pm\"),\n            InvalidMonth => f.write_str(\"invalid month\"),\n            InvalidYear => f.write_str(\"invalid year\"),\n            InvalidWeek => f.write_str(\"invalid week\"),\n            InvalidDayOfWeek => f.write_str(\"invalid day of week\"),\n            InvalidDayOfMonth => f.write_str(\"invalid day of month\"),\n            InvalidDayOfYear => f.write_str(\"invalid day of year\"),\n            InvalidOffset => f.write_str(\"invalid offset\"),\n            MissingFormatSpecifier => f.write_str(\"missing format specifier after `%`\"),\n            InvalidFormatSpecifier(c) => write!(f, \"invalid format specifier `{}` after `%`\", c),\n            UnexpectedCharacter { expected, actual } => {\n                write!(f, \"expected character `{}`, found `{}`\", expected, actual)\n            }\n            UnexpectedEndOfString => f.write_str(\"unexpected end of string\"),\n            InsufficientInformation => {\n                f.write_str(\"insufficient information provided to create the requested type\")\n            }\n            ComponentOutOfRange(e) => write!(f, \"{}\", e),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            __NonExhaustive => unreachable!(),\n        }\n    }\n}","impl From<error::ComponentRange> for Error {\n    fn from(error: error::ComponentRange) -> Self {\n        Error::ComponentOutOfRange(Box::new(error))\n    }\n}","impl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Error::ComponentOutOfRange(e) => Some(e.as_ref()),\n            _ => None,\n        }\n    }\n}"],"format::parse::ParsedItems":["Clone","Copy","Debug","impl ParsedItems {\n    /// Create a new `ParsedItems` with nothing known.\n    pub(crate) const fn new() -> Self {\n        Self {\n            week_based_year: None,\n            year: None,\n            month: None,\n            day: None,\n            weekday: None,\n            ordinal_day: None,\n            iso_week: None,\n            sunday_week: None,\n            monday_week: None,\n            hour_12: None,\n            hour_24: None,\n            minute: None,\n            second: None,\n            nanosecond: None,\n            offset: None,\n            am_pm: None,\n        }\n    }\n}"],"instant::Instant":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Duration> for Instant {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        if duration.is_positive() {\n            (self.inner + duration.abs_std()).into()\n        } else if duration.is_negative() {\n            (self.inner - duration.abs_std()).into()\n        } else {\n            self\n        }\n    }\n}","impl Add<StdDuration> for Instant {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        Self {\n            inner: self.inner + duration,\n        }\n    }\n}","impl AddAssign<Duration> for Instant {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl AddAssign<StdDuration> for Instant {\n    fn add_assign(&mut self, duration: StdDuration) {\n        *self = *self + duration;\n    }\n}","impl From<StdInstant> for Instant {\n    fn from(instant: StdInstant) -> Self {\n        Self { inner: instant }\n    }\n}","impl Instant {\n    #[cfg(feature = \"deprecated\")]\n    #[deprecated(since = \"0.2.0\", note = \"Use `rhs - lhs`\")]\n    pub fn to(&self, later: Self) -> Duration {\n        later - *self\n    }\n}","impl Instant {\n    /// Returns an `Instant` corresponding to \"now\".\n    ///\n    /// ```rust\n    /// # use time::Instant;\n    /// println!(\"{:?}\", Instant::now());\n    /// ```\n    pub fn now() -> Self {\n        Self {\n            inner: StdInstant::now(),\n        }\n    }\n\n    /// Returns the amount of time elapsed since this instant was created. The\n    /// duration will always be nonnegative if the instant is not synthetically\n    /// created.\n    ///\n    /// ```rust\n    /// # use time::{Instant, prelude::*};\n    /// # use std::thread;\n    /// let instant = Instant::now();\n    /// thread::sleep(1.std_milliseconds());\n    /// assert!(instant.elapsed() >= 1.milliseconds());\n    /// ```\n    pub fn elapsed(self) -> Duration {\n        Self::now() - self\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be\n    /// represented as `Instant` (which means it's inside the bounds of the\n    /// underlying data structure), `None` otherwise.\n    ///\n    /// ```rust\n    /// # use time::{Instant, prelude::*};\n    /// let now = Instant::now();\n    /// assert_eq!(\n    ///     now.checked_add(5.seconds()),\n    ///     Some(now + 5.seconds())\n    /// );\n    /// assert_eq!(\n    ///     now.checked_add((-5).seconds()),\n    ///     Some(now + (-5).seconds())\n    /// );\n    /// ```\n    ///\n    /// This function is only present when using rustc >= 1.34.0.\n    #[cfg(__time_02_instant_checked_ops)]\n    pub fn checked_add(self, duration: Duration) -> Option<Self> {\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.inner.checked_add(duration.abs_std()).map(From::from)\n        } else {\n            // duration.is_negative()\n            self.inner.checked_sub(duration.abs_std()).map(From::from)\n        }\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be\n    /// represented as `Instant` (which means it's inside the bounds of the\n    /// underlying data structure), `None` otherwise.\n    ///\n    /// ```rust\n    /// # use time::{Instant, prelude::*};\n    /// let now = Instant::now();\n    /// assert_eq!(\n    ///     now.checked_sub(5.seconds()),\n    ///     Some(now - 5.seconds())\n    /// );\n    /// assert_eq!(\n    ///     now.checked_sub((-5).seconds()),\n    ///     Some(now - (-5).seconds())\n    /// );\n    /// ```\n    ///\n    /// This function is only present when using rustc >= 1.34.0.\n    #[cfg(__time_02_instant_checked_ops)]\n    pub fn checked_sub(self, duration: Duration) -> Option<Self> {\n        self.checked_add(-duration)\n    }\n}","impl PartialEq<StdInstant> for Instant {\n    fn eq(&self, rhs: &StdInstant) -> bool {\n        self.inner.eq(rhs)\n    }\n}","impl PartialOrd<StdInstant> for Instant {\n    fn partial_cmp(&self, rhs: &StdInstant) -> Option<Ordering> {\n        self.inner.partial_cmp(rhs)\n    }\n}","impl Sub for Instant {\n    type Output = Duration;\n\n    fn sub(self, other: Self) -> Self::Output {\n        match self.inner.cmp(&other.inner) {\n            Ordering::Equal => Duration::zero(),\n            Ordering::Greater => (self.inner - other.inner)\n                .try_into()\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Ordering::Less => -Duration::try_from(other.inner - self.inner)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        }\n    }\n}","impl Sub<Duration> for Instant {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        self + -duration\n    }\n}","impl Sub<StdDuration> for Instant {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        Self {\n            inner: self.inner - duration,\n        }\n    }\n}","impl Sub<StdInstant> for Instant {\n    type Output = Duration;\n\n    fn sub(self, other: StdInstant) -> Self::Output {\n        self - Self::from(other)\n    }\n}","impl SubAssign<Duration> for Instant {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}","impl SubAssign<StdDuration> for Instant {\n    fn sub_assign(&mut self, duration: StdDuration) {\n        *self = *self - duration;\n    }\n}"],"internals::Date":["impl Date {\n    // macros\n    pub const fn from_yo_unchecked(year: i32, ordinal: u16) -> crate::Date {\n        crate::Date {\n            value: (year << 9) | ordinal as i32,\n        }\n    }\n\n    // reduce duplication\n    pub(crate) const fn from_ymd_unchecked(year: i32, month: u8, day: u8) -> crate::Date {\n        /// Cumulative days through the beginning of a month in both common and\n        /// leap years.\n        const DAYS_CUMULATIVE_COMMON_LEAP: [[u16; 12]; 2] = [\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        Date::from_yo_unchecked(\n            year,\n            DAYS_CUMULATIVE_COMMON_LEAP[is_leap_year(year) as usize][month as usize - 1]\n                + day as u16,\n        )\n    }\n\n    // reduce duplication\n    #[const_fn(\"1.46\")]\n    pub(crate) const fn from_iso_ywd_unchecked(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> crate::Date {\n        let (ordinal, overflow) = (week as u16 * 7 + weekday.iso_weekday_number() as u16)\n            .overflowing_sub(jan_weekday(year, 4) as u16 + 4);\n\n        if overflow || ordinal == 0 {\n            return Self::from_yo_unchecked(year - 1, ordinal.wrapping_add(days_in_year(year - 1)));\n        }\n\n        let days_in_cur_year = days_in_year(year);\n        if ordinal > days_in_cur_year {\n            Self::from_yo_unchecked(year + 1, ordinal - days_in_cur_year)\n        } else {\n            Self::from_yo_unchecked(year, ordinal)\n        }\n    }\n}"],"internals::Time":["impl Time {\n    /// Create a `Time` from its components.\n    pub const fn from_hms_nanos_unchecked(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> crate::Time {\n        crate::Time {\n            hour,\n            minute,\n            second,\n            nanosecond,\n        }\n    }\n}"],"offset_date_time::OffsetDateTime":["Clone","Copy","Debug","Eq","impl Add<Duration> for OffsetDateTime {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        Self {\n            utc_datetime: self.utc_datetime + duration,\n            offset: self.offset,\n        }\n    }\n}","impl Add<StdDuration> for OffsetDateTime {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        Self {\n            utc_datetime: self.utc_datetime + duration,\n            offset: self.offset,\n        }\n    }\n}","impl AddAssign<Duration> for OffsetDateTime {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl AddAssign<StdDuration> for OffsetDateTime {\n    fn add_assign(&mut self, duration: StdDuration) {\n        *self = *self + duration;\n    }\n}","impl Display for OffsetDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} {} {}\", self.date(), self.time(), self.offset())\n    }\n}","impl From<SystemTime> for OffsetDateTime {\n    // There is definitely some way to have this conversion be infallible, but\n    // it won't be an issue for over 500 years.\n    fn from(system_time: SystemTime) -> Self {\n        let duration = match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Duration::try_from(duration)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Err(err) => -Duration::try_from(err.duration())\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        };\n\n        Self::unix_epoch() + duration\n    }\n}","impl Hash for OffsetDateTime {\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        // We need to distinguish this from a `PrimitiveDateTime`, which would\n        // otherwise conflict.\n        hasher.write(b\"OffsetDateTime\");\n        self.utc_datetime.hash(hasher);\n    }\n}","impl OffsetDateTime {\n    /// Create a new `OffsetDateTime` from the provided `PrimitiveDateTime` and\n    /// `UtcOffset`. The `PrimitiveDateTime` is assumed to be in the provided\n    /// offset.\n    // TODO Should this be made public?\n    pub(crate) fn new_assuming_offset(utc_datetime: PrimitiveDateTime, offset: UtcOffset) -> Self {\n        Self {\n            utc_datetime: utc_datetime - offset.as_duration(),\n            offset,\n        }\n    }\n\n    /// Create a new `OffsetDateTime` from the provided `PrimitiveDateTime` and\n    /// `UtcOffset`. The `PrimitiveDateTime` is assumed to be in UTC.\n    // TODO Should this be made public?\n    pub(crate) const fn new_assuming_utc(utc_datetime: PrimitiveDateTime) -> Self {\n        Self {\n            utc_datetime,\n            offset: UtcOffset::UTC,\n        }\n    }\n\n    /// Create a new `OffsetDateTime` with the current date and time in UTC.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{OffsetDateTime, offset};\n    /// assert!(OffsetDateTime::now().year() >= 2019);\n    /// assert_eq!(OffsetDateTime::now().offset(), offset!(UTC));\n    /// ```\n    #[deprecated(\n        since = \"0.2.11\",\n        note = \"This function returns a value with an offset of UTC, which is not apparent from \\\n                its name alone. You should use `OffsetDateTime::now_utc()` instead.\"\n    )]\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn now() -> Self {\n        SystemTime::now().into()\n    }\n\n    /// Create a new `OffsetDateTime` with the current date and time in UTC.\n    ///\n    /// ```rust\n    /// # use time::{OffsetDateTime, offset};\n    /// assert!(OffsetDateTime::now_utc().year() >= 2019);\n    /// assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn now_utc() -> Self {\n        SystemTime::now().into()\n    }\n\n    /// Create a new `OffsetDateTime` with the current date and time in the\n    /// local offset.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::OffsetDateTime;\n    /// assert!(OffsetDateTime::now_local().year() >= 2019);\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\n    #[allow(deprecated)]\n    pub fn now_local() -> Self {\n        let t = Self::now_utc();\n        t.to_offset(UtcOffset::local_offset_at(t))\n    }\n\n    /// Attempt to create a new `OffsetDateTime` with the current date and time\n    /// in the local offset. If the offset cannot be determined, an error is\n    /// returned.\n    ///\n    /// ```rust\n    /// # use time::OffsetDateTime;\n    /// let now = OffsetDateTime::try_now_local();\n    /// # if false {\n    /// assert!(now.is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn try_now_local() -> Result<Self, error::IndeterminateOffset> {\n        let t = Self::now_utc();\n        Ok(t.to_offset(UtcOffset::try_local_offset_at(t)?))\n    }\n\n    /// Convert the `OffsetDateTime` from the current `UtcOffset` to the\n    /// provided `UtcOffset`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(2000-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .year(),\n    ///     1999,\n    /// );\n    ///\n    /// // Let's see what time Sydney's new year's celebration is in New York\n    /// // and Los Angeles.\n    ///\n    /// // Construct midnight on new year's in Sydney. This is equivalent to\n    /// // 13:00 UTC.\n    /// let sydney = date!(2000-01-01).midnight().assume_offset(offset!(+11));\n    /// let new_york = sydney.to_offset(offset!(-5));\n    /// let los_angeles = sydney.to_offset(offset!(-8));\n    /// assert_eq!(sydney.hour(), 0);\n    /// assert_eq!(new_york.hour(), 8);\n    /// assert_eq!(los_angeles.hour(), 5);\n    /// ```\n    pub const fn to_offset(self, offset: UtcOffset) -> Self {\n        Self {\n            utc_datetime: self.utc_datetime,\n            offset,\n        }\n    }\n\n    /// Midnight, 1 January, 1970 (UTC).\n    ///\n    /// ```rust\n    /// # use time::{date, OffsetDateTime};\n    /// assert_eq!(\n    ///     OffsetDateTime::unix_epoch(),\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc(),\n    /// );\n    /// ```\n    pub const fn unix_epoch() -> Self {\n        internals::Date::from_yo_unchecked(1970, 1)\n            .midnight()\n            .assume_utc()\n    }\n\n    /// Create an `OffsetDateTime` from the provided [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n    ///\n    /// ```rust\n    /// # use time::{date, OffsetDateTime};\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(0),\n    ///     OffsetDateTime::unix_epoch(),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(1_546_300_800),\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc(),\n    /// );\n    /// ```\n    ///\n    /// If you have a timestamp-nanosecond pair, you can use something along the\n    /// lines of the following:\n    ///\n    /// ```rust\n    /// # use time::{Duration, OffsetDateTime, ext::NumericalDuration};\n    /// let (timestamp, nanos) = (1, 500_000_000);\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(timestamp) + Duration::nanoseconds(nanos),\n    ///     OffsetDateTime::unix_epoch() + 1.5.seconds()\n    /// );\n    /// ```\n    pub fn from_unix_timestamp(timestamp: i64) -> Self {\n        OffsetDateTime::unix_epoch() + Duration::seconds(timestamp)\n    }\n\n    /// Construct an `OffsetDateTime` from the provided Unix timestamp (in\n    /// nanoseconds).\n    ///\n    /// ```rust\n    /// # use time::{date, OffsetDateTime};\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp_nanos(0),\n    ///     OffsetDateTime::unix_epoch(),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp_nanos(1_546_300_800_000_000_000),\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc(),\n    /// );\n    /// ```\n    ///\n    /// Note that the range of timestamps possible here is far larger than the\n    /// valid range of dates storable in this crate. It is the _user's\n    /// responsibility_ to ensure the timestamp provided as a parameter is\n    /// valid. No behavior is guaranteed if this parameter would not result in a\n    /// valid value.\n    pub fn from_unix_timestamp_nanos(timestamp: i128) -> Self {\n        OffsetDateTime::unix_epoch() + Duration::nanoseconds_i128(timestamp)\n    }\n\n    /// Get the `UtcOffset`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .offset(),\n    ///     offset!(UTC),\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_offset(offset!(+1))\n    ///         .offset(),\n    ///     offset!(+1),\n    /// );\n    /// ```\n    pub const fn offset(self) -> UtcOffset {\n        self.offset\n    }\n\n    /// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n    ///\n    /// ```rust\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .unix_timestamp(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .unix_timestamp(),\n    ///     0,\n    /// );\n    /// ```\n    pub fn unix_timestamp(self) -> i64 {\n        let days = (self.utc_datetime.date.julian_day()\n            - internals::Date::from_yo_unchecked(1970, 1).julian_day())\n            * 86_400;\n        let hours = self.utc_datetime.hour() as i64 * 3_600;\n        let minutes = self.utc_datetime.minute() as i64 * 60;\n        let seconds = self.utc_datetime.second() as i64;\n        days + hours + minutes + seconds\n    }\n\n    /// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .timestamp(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .timestamp(),\n    ///     0,\n    /// );\n    /// ```\n    #[deprecated(\n        since = \"0.2.23\",\n        note = \"Use `OffsetDateTime::unix_timestamp` instead\"\n    )]\n    pub fn timestamp(self) -> i64 {\n        self.unix_timestamp()\n    }\n\n    /// Get the Unix timestamp in nanoseconds.\n    ///\n    /// ```rust\n    /// use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .unix_timestamp_nanos(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .with_time(time!(1:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .unix_timestamp_nanos(),\n    ///     3_600_000_000_000,\n    /// );\n    /// ```\n    pub fn unix_timestamp_nanos(self) -> i128 {\n        (self - Self::unix_epoch()).whole_nanoseconds()\n    }\n\n    /// Get the Unix timestamp in nanoseconds.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .unix_timestamp_nanos(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(1970-01-01)\n    ///         .with_time(time!(1:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .unix_timestamp_nanos(),\n    ///     3_600_000_000_000,\n    /// );\n    /// ```\n    #[deprecated(\n        since = \"0.2.23\",\n        note = \"Use `OffsetDateTime::unix_timestamp_nanos` instead\"\n    )]\n    pub fn timestamp_nanos(self) -> i128 {\n        self.unix_timestamp_nanos()\n    }\n\n    /// Get the `Date` in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .date(),\n    ///     date!(2019-01-01),\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .date(),\n    ///     date!(2018-12-31),\n    /// );\n    /// ```\n    pub fn date(self) -> Date {\n        (self.utc_datetime + self.offset.as_duration()).date()\n    }\n\n    /// Get the `Time` in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .time(),\n    ///     time!(0:00)\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-1))\n    ///         .time(),\n    ///     time!(23:00)\n    /// );\n    /// ```\n    pub fn time(self) -> Time {\n        (self.utc_datetime + self.offset.as_duration()).time()\n    }\n\n    /// Get the year of the date in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .year(),\n    ///     2019,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-12-31)\n    ///         .with_time(time!(23:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+1))\n    ///         .year(),\n    ///     2020,\n    /// );\n    /// assert_eq!(\n    ///     date!(2020-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .year(),\n    ///     2020,\n    /// );\n    /// ```\n    pub fn year(self) -> i32 {\n        self.date().year()\n    }\n\n    /// Get the month of the date in the stored offset. If fetching both the\n    /// month and day, it is more efficient to use\n    /// [`OffsetDateTime::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=12`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .month(),\n    ///     1,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-12-31)\n    ///         .with_time(time!(23:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+1))\n    ///         .month(),\n    ///     1,\n    /// );\n    /// ```\n    pub fn month(self) -> u8 {\n        self.date().month()\n    }\n\n    /// Get the day of the date in the stored offset. If fetching both the month\n    /// and day, it is more efficient to use [`OffsetDateTime::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .day(),\n    ///     1,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-12-31)\n    ///         .with_time(time!(23:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+1))\n    ///         .day(),\n    ///     1,\n    /// );\n    /// ```\n    pub fn day(self) -> u8 {\n        self.date().day()\n    }\n\n    /// Get the month and day of the date in the stored offset.\n    ///\n    /// The month component will always be in the range `1..=12`;\n    /// the day component in `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .month_day(),\n    ///     (1, 1),\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-12-31)\n    ///         .with_time(time!(23:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+1))\n    ///         .month_day(),\n    ///     (1, 1),\n    /// );\n    /// ```\n    pub fn month_day(self) -> (u8, u8) {\n        self.date().month_day()\n    }\n\n    /// Get the day of the year of the date in the stored offset.\n    ///\n    /// The returned value will always be in the range `1..=366`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .ordinal(),\n    ///     1,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-12-31)\n    ///         .with_time(time!(23:00))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+1))\n    ///         .ordinal(),\n    ///     1,\n    /// );\n    /// ```\n    pub fn ordinal(self) -> u16 {\n        self.date().ordinal()\n    }\n\n    /// Get the ISO 8601 year and week number in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .iso_year_week(),\n    ///     (2019, 1),\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-10-04)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .iso_year_week(),\n    ///     (2019, 40),\n    /// );\n    /// assert_eq!(\n    ///     date!(2020-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .iso_year_week(),\n    ///     (2020, 1),\n    /// );\n    /// assert_eq!(\n    ///     date!(2020-12-31)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .iso_year_week(),\n    ///     (2020, 53),\n    /// );\n    /// assert_eq!(\n    ///     date!(2021-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .iso_year_week(),\n    ///     (2020, 53),\n    /// );\n    /// ```\n    pub fn iso_year_week(self) -> (i32, u8) {\n        self.date().iso_year_week()\n    }\n\n    /// Get the ISO week number of the date in the stored offset.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .week(),\n    ///     1,\n    /// );\n    /// assert_eq!(\n    ///     date!(2020-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .week(),\n    ///     1,\n    /// );\n    /// assert_eq!(\n    ///     date!(2020-12-31)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .week(),\n    ///     53,\n    /// );\n    /// assert_eq!(\n    ///     date!(2021-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .week(),\n    ///     53,\n    /// );\n    /// ```\n    pub fn week(self) -> u8 {\n        self.date().week()\n    }\n\n    /// Get the weekday of the date in the stored offset.\n    ///\n    /// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n    /// internally.\n    ///\n    /// ```rust\n    /// # use time::{date, Weekday::*};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .weekday(),\n    ///     Tuesday,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-02-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .weekday(),\n    ///     Friday,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-03-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .weekday(),\n    ///     Friday,\n    /// );\n    /// ```\n    pub fn weekday(self) -> Weekday {\n        self.date().weekday()\n    }\n\n    /// Get the clock hour in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::{date, time, offset};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .hour(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(-2))\n    ///         .hour(),\n    ///     21,\n    /// );\n    /// ```\n    pub fn hour(self) -> u8 {\n        self.time().hour()\n    }\n\n    /// Get the minute within the hour in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .minute(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+0:30))\n    ///         .minute(),\n    ///     29,\n    /// );\n    /// ```\n    pub fn minute(self) -> u8 {\n        self.time().minute()\n    }\n\n    /// Get the second within the minute in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .second(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59))\n    ///         .assume_utc()\n    ///         .to_offset(offset!(+0:00:30))\n    ///         .second(),\n    ///     29,\n    /// );\n    /// ```\n    pub fn second(self) -> u8 {\n        self.time().second()\n    }\n\n    /// Get the milliseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .millisecond(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59.999))\n    ///         .assume_utc()\n    ///         .millisecond(),\n    ///     999,\n    /// );\n    /// ```\n    pub fn millisecond(self) -> u16 {\n        self.time().millisecond()\n    }\n\n    /// Get the microseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .microsecond(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59.999_999))\n    ///         .assume_utc()\n    ///         .microsecond(),\n    ///     999_999,\n    /// );\n    /// ```\n    pub fn microsecond(self) -> u32 {\n        self.time().microsecond()\n    }\n\n    /// Get the nanoseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .nanosecond(),\n    ///     0,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01)\n    ///         .with_time(time!(23:59:59.999_999_999))\n    ///         .assume_utc()\n    ///         .nanosecond(),\n    ///     999_999_999,\n    /// );\n    /// ```\n    pub fn nanosecond(self) -> u32 {\n        self.time().nanosecond()\n    }\n}","impl OffsetDateTime {\n    /// Format the `OffsetDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::{date};\n    /// assert_eq!(\n    ///     date!(2019-01-02)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .format(\"%F %r %z\"),\n    ///     \"2019-01-02 12:00:00 am +0000\",\n    /// );\n    /// ```\n    pub fn format(self, format: impl Into<Format>) -> String {\n        self.lazy_format(format).to_string()\n    }\n\n    /// Format the `OffsetDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-02)\n    ///         .midnight()\n    ///         .assume_utc()\n    ///         .lazy_format(\"%F %r %z\")\n    ///         .to_string(),\n    ///     \"2019-01-02 12:00:00 am +0000\",\n    /// );\n    /// ```\n    pub fn lazy_format(self, format: impl Into<Format>) -> impl Display {\n        DeferredFormat::new(format)\n            .with_date(self.date())\n            .with_time(self.time())\n            .with_offset(self.offset())\n            .to_owned()\n    }\n\n    /// Attempt to parse an `OffsetDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::{date, OffsetDateTime, time};\n    /// assert_eq!(\n    ///     OffsetDateTime::parse(\"2019-01-02 00:00:00 +0000\", \"%F %T %z\"),\n    ///     Ok(date!(2019-01-02).midnight().assume_utc()),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::parse(\"2019-002 23:59:59 +0000\", \"%Y-%j %T %z\"),\n    ///     Ok(date!(2019-002).with_time(time!(23:59:59)).assume_utc()),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::parse(\"2019-W01-3 12:00:00 pm +0000\", \"%G-W%V-%u %r %z\"),\n    ///     Ok(date!(2019-W01-3).with_time(time!(12:00)).assume_utc()),\n    /// );\n    /// ```\n    pub fn parse(s: impl AsRef<str>, format: impl Into<Format>) -> ParseResult<Self> {\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }\n\n    /// Given the items already parsed, attempt to create an `OffsetDateTime`.\n    pub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self> {\n        let offset = UtcOffset::try_from_parsed_items(items)?;\n        Ok(PrimitiveDateTime::try_from_parsed_items(items)?.assume_offset(offset))\n    }\n}","impl Ord for OffsetDateTime {\n    fn cmp(&self, rhs: &Self) -> Ordering {\n        self.utc_datetime.cmp(&rhs.utc_datetime)\n    }\n}","impl Parsable for $type {\n                    fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n                        Self::parse(s, format)\n                    }\n                }","impl PartialEq for OffsetDateTime {\n    fn eq(&self, rhs: &Self) -> bool {\n        self.utc_datetime.eq(&rhs.utc_datetime)\n    }\n}","impl PartialEq<SystemTime> for OffsetDateTime {\n    fn eq(&self, rhs: &SystemTime) -> bool {\n        self == &Self::from(*rhs)\n    }\n}","impl PartialOrd for OffsetDateTime {\n    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n        Some(self.cmp(rhs))\n    }\n}","impl PartialOrd<SystemTime> for OffsetDateTime {\n    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n        self.partial_cmp(&Self::from(*other))\n    }\n}","impl Sub<Duration> for OffsetDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        Self {\n            utc_datetime: self.utc_datetime - duration,\n            offset: self.offset,\n        }\n    }\n}","impl Sub<OffsetDateTime> for OffsetDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        self.utc_datetime - rhs.utc_datetime\n    }\n}","impl Sub<StdDuration> for OffsetDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        Self {\n            utc_datetime: self.utc_datetime - duration,\n            offset: self.offset,\n        }\n    }\n}","impl Sub<SystemTime> for OffsetDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: SystemTime) -> Self::Output {\n        self - Self::from(rhs)\n    }\n}","impl SubAssign<Duration> for OffsetDateTime {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}","impl SubAssign<StdDuration> for OffsetDateTime {\n    fn sub_assign(&mut self, duration: StdDuration) {\n        *self = *self - duration;\n    }\n}"],"primitive_date_time::PrimitiveDateTime":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Add<Duration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        let nanos = self.time.nanoseconds_since_midnight() as i64\n            + (duration.whole_nanoseconds() % 86_400_000_000_000) as i64;\n\n        let date_modifier = if nanos < 0 {\n            Duration::days(-1)\n        } else if nanos >= 86_400_000_000_000 {\n            Duration::day()\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date + duration + date_modifier, self.time + duration)\n    }\n}","impl Add<StdDuration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        let nanos = self.time.nanoseconds_since_midnight()\n            + (duration.as_nanos() % 86_400_000_000_000) as u64;\n\n        let date_modifier = if nanos >= 86_400_000_000_000 {\n            Duration::day()\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date + duration + date_modifier, self.time + duration)\n    }\n}","impl AddAssign<Duration> for PrimitiveDateTime {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl AddAssign<StdDuration> for PrimitiveDateTime {\n    fn add_assign(&mut self, duration: StdDuration) {\n        *self = *self + duration;\n    }\n}","impl Display for PrimitiveDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} {}\", self.date(), self.time())\n    }\n}","impl From<SystemTime> for PrimitiveDateTime {\n    // There is definitely some way to have this conversion be infallible, but\n    // it won't be an issue for over 500 years.\n    fn from(system_time: SystemTime) -> Self {\n        let duration = match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Duration::try_from(duration)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Err(err) => -Duration::try_from(err.duration())\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        };\n\n        Self::unix_epoch() + duration\n    }\n}","impl Ord for PrimitiveDateTime {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.date\n            .cmp(&other.date)\n            .then_with(|| self.time.cmp(&other.time))\n    }\n}","impl Parsable for $type {\n                    fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n                        Self::parse(s, format)\n                    }\n                }","impl PartialEq<SystemTime> for PrimitiveDateTime {\n    fn eq(&self, rhs: &SystemTime) -> bool {\n        self == &Self::from(*rhs)\n    }\n}","impl PartialOrd for PrimitiveDateTime {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl PartialOrd<SystemTime> for PrimitiveDateTime {\n    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n        self.partial_cmp(&Self::from(*other))\n    }\n}","impl PrimitiveDateTime {\n    /// Create a new `PrimitiveDateTime` from the provided `Date` and `Time`.\n    ///\n    /// ```rust\n    /// # use time::{PrimitiveDateTime, time, date};\n    /// assert_eq!(\n    ///     PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)),\n    ///     date!(2019-01-01).midnight(),\n    /// );\n    /// ```\n    pub const fn new(date: Date, time: Time) -> Self {\n        Self { date, time }\n    }\n\n    /// Create a new `PrimitiveDateTime` with the current date and time (UTC).\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::PrimitiveDateTime;\n    /// assert!(PrimitiveDateTime::now().year() >= 2019);\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n    pub fn now() -> Self {\n        SystemTime::now().into()\n    }\n\n    /// Midnight, 1 January, 1970 (UTC).\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{PrimitiveDateTime, date};\n    /// assert_eq!(\n    ///     PrimitiveDateTime::unix_epoch(),\n    ///     date!(1970-01-01).midnight()\n    /// );\n    /// ```\n    #[deprecated(since = \"0.2.7\", note = \"This method assumes an offset of UTC.\")]\n    pub const fn unix_epoch() -> Self {\n        Self {\n            date: internals::Date::from_yo_unchecked(1970, 1),\n            time: Time::midnight(),\n        }\n    }\n\n    /// Create a `PrimitiveDateTime` from the provided [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, PrimitiveDateTime};\n    /// assert_eq!(\n    ///     PrimitiveDateTime::from_unix_timestamp(0),\n    ///     PrimitiveDateTime::unix_epoch()\n    /// );\n    /// assert_eq!(\n    ///     PrimitiveDateTime::from_unix_timestamp(1_546_300_800),\n    ///     date!(2019-01-01).midnight(),\n    /// );\n    /// ```\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n    #[allow(deprecated)]\n    pub fn from_unix_timestamp(timestamp: i64) -> Self {\n        Self::unix_epoch() + Duration::seconds(timestamp)\n    }\n\n    /// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time)\n    /// representing the `PrimitiveDateTime`.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, PrimitiveDateTime};\n    /// assert_eq!(PrimitiveDateTime::unix_epoch().timestamp(), 0);\n    /// assert_eq!(date!(2019-01-01).midnight().timestamp(), 1_546_300_800);\n    /// ```\n    #[allow(deprecated)]\n    #[deprecated(since = \"0.2.7\", note = \"This method assumes an offset of UTC.\")]\n    pub fn timestamp(self) -> i64 {\n        let days = (self.date.julian_day()\n            - internals::Date::from_yo_unchecked(1970, 1).julian_day())\n            * 86_400;\n        let hours = self.hour() as i64 * 3_600;\n        let minutes = self.minute() as i64 * 60;\n        let seconds = self.second() as i64;\n        days + hours + minutes + seconds\n    }\n\n    /// Get the `Date` component of the `PrimitiveDateTime`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().date(),\n    ///     date!(2019-01-01)\n    /// );\n    /// ```\n    pub const fn date(self) -> Date {\n        self.date\n    }\n\n    /// Get the `Time` component of the `PrimitiveDateTime`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().time(), time!(0:00));\n    pub const fn time(self) -> Time {\n        self.time\n    }\n\n    /// Get the year of the date.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().year(), 2019);\n    /// assert_eq!(date!(2019-12-31).midnight().year(), 2019);\n    /// assert_eq!(date!(2020-01-01).midnight().year(), 2020);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn year(self) -> i32 {\n        self.date().year()\n    }\n\n    /// Get the month of the date. If fetching both the month and day, it is\n    /// more efficient to use [`PrimitiveDateTime::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=12`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().month(), 1);\n    /// assert_eq!(date!(2019-12-31).midnight().month(), 12);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn month(self) -> u8 {\n        self.date().month()\n    }\n\n    /// Get the day of the date.  If fetching both the month and day, it is\n    /// more efficient to use [`PrimitiveDateTime::month_day`].\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-1-1).midnight().day(), 1);\n    /// assert_eq!(date!(2019-12-31).midnight().day(), 31);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn day(self) -> u8 {\n        self.date().day()\n    }\n\n    /// Get the month and day of the date. This is more efficient than fetching\n    /// the components individually.\n    ///\n    /// The month component will always be in the range `1..=12`;\n    /// the day component in `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().month_day(), (1, 1));\n    /// assert_eq!(date!(2019-12-31).midnight().month_day(), (12, 31));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn month_day(self) -> (u8, u8) {\n        self.date().month_day()\n    }\n\n    /// Get the day of the year.\n    ///\n    /// The returned value will always be in the range `1..=366` (`1..=365` for\n    /// common years).\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().ordinal(), 1);\n    /// assert_eq!(date!(2019-12-31).midnight().ordinal(), 365);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn ordinal(self) -> u16 {\n        self.date().ordinal()\n    }\n\n    /// Get the ISO 8601 year and week number.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().iso_year_week(), (2019, 1));\n    /// assert_eq!(date!(2019-10-04).midnight().iso_year_week(), (2019, 40));\n    /// assert_eq!(date!(2020-01-01).midnight().iso_year_week(), (2020, 1));\n    /// assert_eq!(date!(2020-12-31).midnight().iso_year_week(), (2020, 53));\n    /// assert_eq!(date!(2021-01-01).midnight().iso_year_week(), (2020, 53));\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn iso_year_week(self) -> (i32, u8) {\n        self.date().iso_year_week()\n    }\n\n    /// Get the ISO week number.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().week(), 1);\n    /// assert_eq!(date!(2019-10-04).midnight().week(), 40);\n    /// assert_eq!(date!(2020-01-01).midnight().week(), 1);\n    /// assert_eq!(date!(2020-12-31).midnight().week(), 53);\n    /// assert_eq!(date!(2021-01-01).midnight().week(), 53);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn week(self) -> u8 {\n        self.date().week()\n    }\n\n    /// Get the week number where week 1 begins on the first Sunday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().sunday_based_week(), 0);\n    /// assert_eq!(date!(2020-01-01).midnight().sunday_based_week(), 0);\n    /// assert_eq!(date!(2020-12-31).midnight().sunday_based_week(), 52);\n    /// assert_eq!(date!(2021-01-01).midnight().sunday_based_week(), 0);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn sunday_based_week(self) -> u8 {\n        self.date().sunday_based_week()\n    }\n\n    /// Get the week number where week 1 begins on the first Monday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(date!(2019-01-01).midnight().monday_based_week(), 0);\n    /// assert_eq!(date!(2020-01-01).midnight().monday_based_week(), 0);\n    /// assert_eq!(date!(2020-12-31).midnight().monday_based_week(), 52);\n    /// assert_eq!(date!(2021-01-01).midnight().monday_based_week(), 0);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn monday_based_week(self) -> u8 {\n        self.date().monday_based_week()\n    }\n\n    /// Get the weekday.\n    ///\n    /// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n    /// internally.\n    ///\n    /// ```rust\n    /// # use time::{date, Weekday::*};\n    /// assert_eq!(date!(2019-01-01).midnight().weekday(), Tuesday);\n    /// assert_eq!(date!(2019-02-01).midnight().weekday(), Friday);\n    /// assert_eq!(date!(2019-03-01).midnight().weekday(), Friday);\n    /// assert_eq!(date!(2019-04-01).midnight().weekday(), Monday);\n    /// assert_eq!(date!(2019-05-01).midnight().weekday(), Wednesday);\n    /// assert_eq!(date!(2019-06-01).midnight().weekday(), Saturday);\n    /// assert_eq!(date!(2019-07-01).midnight().weekday(), Monday);\n    /// assert_eq!(date!(2019-08-01).midnight().weekday(), Thursday);\n    /// assert_eq!(date!(2019-09-01).midnight().weekday(), Sunday);\n    /// assert_eq!(date!(2019-10-01).midnight().weekday(), Tuesday);\n    /// assert_eq!(date!(2019-11-01).midnight().weekday(), Friday);\n    /// assert_eq!(date!(2019-12-01).midnight().weekday(), Sunday);\n    /// ```\n    pub fn weekday(self) -> Weekday {\n        self.date().weekday()\n    }\n\n    /// Get the clock hour.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().hour(), 0);\n    /// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).hour(), 23);\n    /// ```\n    pub const fn hour(self) -> u8 {\n        self.time().hour()\n    }\n\n    /// Get the minute within the hour.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().minute(), 0);\n    /// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).minute(), 59);\n    /// ```\n    pub const fn minute(self) -> u8 {\n        self.time().minute()\n    }\n\n    /// Get the second within the minute.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().second(), 0);\n    /// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).second(), 59);\n    /// ```\n    pub const fn second(self) -> u8 {\n        self.time().second()\n    }\n\n    /// Get the milliseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().millisecond(), 0);\n    /// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59.999)).millisecond(), 999);\n    /// ```\n    pub const fn millisecond(self) -> u16 {\n        self.time().millisecond()\n    }\n\n    /// Get the microseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().microsecond(), 0);\n    /// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59.999_999)).microsecond(), 999_999);\n    /// ```\n    pub const fn microsecond(self) -> u32 {\n        self.time().microsecond()\n    }\n\n    /// Get the nanoseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::{date, time};\n    /// assert_eq!(date!(2019-01-01).midnight().nanosecond(), 0);\n    /// assert_eq!(\n    ///     date!(2019-01-01).with_time(time!(23:59:59.999_999_999)).nanosecond(),\n    ///     999_999_999,\n    /// );\n    /// ```\n    pub const fn nanosecond(self) -> u32 {\n        self.time().nanosecond()\n    }\n\n    /// Assuming that the existing `PrimitiveDateTime` represents a moment in\n    /// the UTC, return an `OffsetDateTime` with the provided `UtcOffset`.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().using_offset(offset!(UTC)).unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().using_offset(offset!(-1)).unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// ```\n    ///\n    /// This function is the same as calling `.assume_utc().to_offset(offset)`.\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"Due to behavior not clear by its name alone, it is preferred to use \\\n                `.assume_utc().to_offset(offset)`. This has the same behavior and can be used in \\\n                `const` contexts.\"\n    )]\n    pub const fn using_offset(self, offset: UtcOffset) -> OffsetDateTime {\n        self.assume_utc().to_offset(offset)\n    }\n\n    /// Assuming that the existing `PrimitiveDateTime` represents a moment in\n    /// the provided `UtcOffset`, return an `OffsetDateTime`.\n    ///\n    /// ```rust\n    /// # use time::{date, offset};\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().assume_offset(offset!(UTC)).unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().assume_offset(offset!(-1)).unix_timestamp(),\n    ///     1_546_304_400,\n    /// );\n    /// ```\n    pub fn assume_offset(self, offset: UtcOffset) -> OffsetDateTime {\n        OffsetDateTime::new_assuming_offset(self, offset)\n    }\n\n    /// Assuming that the existing `PrimitiveDateTime` represents a moment in\n    /// the UTC, return an `OffsetDateTime`.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-01).midnight().assume_utc().unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// ```\n    ///\n    /// This function is the same as calling `.assume_offset(offset!(UTC))`,\n    /// except it is usable in `const` contexts.\n    pub const fn assume_utc(self) -> OffsetDateTime {\n        OffsetDateTime::new_assuming_utc(self)\n    }\n}","impl PrimitiveDateTime {\n    /// Format the `PrimitiveDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-02).midnight().format(\"%F %r\"),\n    ///     \"2019-01-02 12:00:00 am\"\n    /// );\n    /// ```\n    pub fn format(self, format: impl AsRef<str>) -> String {\n        self.lazy_format(format).to_string()\n    }\n\n    /// Format the `PrimitiveDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::date;\n    /// assert_eq!(\n    ///     date!(2019-01-02).midnight().lazy_format(\"%F %r\").to_string(),\n    ///     \"2019-01-02 12:00:00 am\"\n    /// );\n    /// ```\n    pub fn lazy_format(self, format: impl AsRef<str>) -> impl Display {\n        DeferredFormat::new(format.as_ref())\n            .with_date(self.date())\n            .with_time(self.time())\n            .to_owned()\n    }\n\n    /// Attempt to parse a `PrimitiveDateTime` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::{date, PrimitiveDateTime, time};\n    /// assert_eq!(\n    ///     PrimitiveDateTime::parse(\"2019-01-02 00:00:00\", \"%F %T\"),\n    ///     Ok(date!(2019-01-02).midnight()),\n    /// );\n    /// assert_eq!(\n    ///     PrimitiveDateTime::parse(\"2019-002 23:59:59\", \"%Y-%j %T\"),\n    ///     Ok(date!(2019-002).with_time(time!(23:59:59)))\n    /// );\n    /// assert_eq!(\n    ///     PrimitiveDateTime::parse(\"2019-W01-3 12:00:00 pm\", \"%G-W%V-%u %r\"),\n    ///     Ok(date!(2019-W01-3).with_time(time!(12:00))),\n    /// );\n    /// ```\n    pub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }\n\n    /// Given the items already parsed, attempt to create a `PrimitiveDateTime`.\n    pub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self> {\n        Ok(Self {\n            date: Date::try_from_parsed_items(items)?,\n            time: Time::try_from_parsed_items(items)?,\n        })\n    }\n}","impl Sub<Duration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        self + -duration\n    }\n}","impl Sub<PrimitiveDateTime> for PrimitiveDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        (self.date - rhs.date) + (self.time - rhs.time)\n    }\n}","impl Sub<StdDuration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        let nanos = self.time.nanoseconds_since_midnight() as i64\n            - (duration.as_nanos() % 86_400_000_000_000) as i64;\n\n        let date_modifier = if nanos < 0 {\n            Duration::days(-1)\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date - duration + date_modifier, self.time - duration)\n    }\n}","impl Sub<SystemTime> for PrimitiveDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: SystemTime) -> Self::Output {\n        self - Self::from(rhs)\n    }\n}","impl SubAssign<Duration> for PrimitiveDateTime {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}","impl SubAssign<StdDuration> for PrimitiveDateTime {\n    fn sub_assign(&mut self, duration: StdDuration) {\n        *self = *self - duration;\n    }\n}"],"sign::Sign":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Default for Sign {\n    /// `Sign` defaults to `Zero`.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Sign;\n    /// assert_eq!(Sign::default(), Sign::Zero);\n    /// ```\n    fn default() -> Self {\n        Zero\n    }\n}","impl Div<Sign> for Sign {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs\n    }\n}","impl DivAssign<Sign> for Sign {\n    fn div_assign(&mut self, rhs: Self) {\n        *self *= rhs\n    }\n}","impl Mul<$type> for Sign {\n                type Output = $type;\n\n                #[allow(trivial_numeric_casts)]\n                fn mul(self, rhs: $type) -> Self::Output {\n                    (self as i8) as $type * rhs\n                }\n            }","impl Mul<Sign> for Sign {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        match (self, rhs) {\n            (Zero, _) | (_, Zero) => Zero,\n            (Positive, Positive) | (Negative, Negative) => Positive,\n            (Positive, Negative) | (Negative, Positive) => Negative,\n        }\n    }\n}","impl MulAssign<Sign> for Sign {\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}","impl Neg for Sign {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        self.negate()\n    }\n}","impl Not for Sign {\n    type Output = Self;\n\n    fn not(self) -> Self::Output {\n        self.negate()\n    }\n}","impl Sign {\n    /// Return the opposite of the current sign.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Sign;\n    /// assert_eq!(Sign::Positive.negate(), Sign::Negative);\n    /// assert_eq!(Sign::Negative.negate(), Sign::Positive);\n    /// assert_eq!(Sign::Zero.negate(), Sign::Zero);\n    /// ```\n    pub fn negate(self) -> Self {\n        match self {\n            Positive => Negative,\n            Negative => Positive,\n            Zero => Zero,\n        }\n    }\n\n    /// Is the sign positive?\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Sign;\n    /// assert!(Sign::Positive.is_positive());\n    /// assert!(!Sign::Negative.is_positive());\n    /// assert!(!Sign::Zero.is_positive());\n    /// ```\n    pub const fn is_positive(self) -> bool {\n        self as u8 == Positive as u8\n    }\n\n    /// Is the sign negative?\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Sign;\n    /// assert!(!Sign::Positive.is_negative());\n    /// assert!(Sign::Negative.is_negative());\n    /// assert!(!Sign::Zero.is_negative());\n    /// ```\n    pub const fn is_negative(self) -> bool {\n        self as u8 == Negative as u8\n    }\n\n    /// Is the value exactly zero?\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Sign;\n    /// assert!(!Sign::Positive.is_zero());\n    /// assert!(!Sign::Negative.is_zero());\n    /// assert!(Sign::Zero.is_zero());\n    /// ```\n    pub const fn is_zero(self) -> bool {\n        self as u8 == Zero as u8\n    }\n}"],"std::num::NonZeroI16":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }"],"std::num::NonZeroI32":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }"],"std::num::NonZeroI64":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }"],"std::num::NonZeroI8":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }"],"std::num::NonZeroU16":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }","impl NumericalStdDuration for $type {\n                fn std_nanoseconds(self) -> StdDuration {\n                    StdDuration::from_nanos(self.get() as u64)\n                }\n\n                fn std_microseconds(self) -> StdDuration {\n                    StdDuration::from_micros(self.get() as u64)\n                }\n\n                fn std_milliseconds(self) -> StdDuration {\n                    StdDuration::from_millis(self.get() as u64)\n                }\n\n                fn std_seconds(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64)\n                }\n\n                fn std_minutes(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }\n\n                fn std_hours(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }\n\n                fn std_days(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }\n\n                fn std_weeks(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }\n            }"],"std::num::NonZeroU32":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }","impl NumericalStdDuration for $type {\n                fn std_nanoseconds(self) -> StdDuration {\n                    StdDuration::from_nanos(self.get() as u64)\n                }\n\n                fn std_microseconds(self) -> StdDuration {\n                    StdDuration::from_micros(self.get() as u64)\n                }\n\n                fn std_milliseconds(self) -> StdDuration {\n                    StdDuration::from_millis(self.get() as u64)\n                }\n\n                fn std_seconds(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64)\n                }\n\n                fn std_minutes(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }\n\n                fn std_hours(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }\n\n                fn std_days(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }\n\n                fn std_weeks(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }\n            }"],"std::num::NonZeroU64":["impl NumericalStdDuration for $type {\n                fn std_nanoseconds(self) -> StdDuration {\n                    StdDuration::from_nanos(self.get() as u64)\n                }\n\n                fn std_microseconds(self) -> StdDuration {\n                    StdDuration::from_micros(self.get() as u64)\n                }\n\n                fn std_milliseconds(self) -> StdDuration {\n                    StdDuration::from_millis(self.get() as u64)\n                }\n\n                fn std_seconds(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64)\n                }\n\n                fn std_minutes(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }\n\n                fn std_hours(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }\n\n                fn std_days(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }\n\n                fn std_weeks(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }\n            }"],"std::num::NonZeroU8":["impl NumericalDuration for $type {\n                fn nanoseconds(self) -> Duration {\n                    Duration::nanoseconds(self.get() as i64)\n                }\n\n                fn microseconds(self) -> Duration {\n                    Duration::microseconds(self.get() as i64)\n                }\n\n                fn milliseconds(self) -> Duration {\n                    Duration::milliseconds(self.get() as i64)\n                }\n\n                fn seconds(self) -> Duration {\n                    Duration::seconds(self.get() as i64)\n                }\n\n                fn minutes(self) -> Duration {\n                    Duration::minutes(self.get() as i64)\n                }\n\n                fn hours(self) -> Duration {\n                    Duration::hours(self.get() as i64)\n                }\n\n                fn days(self) -> Duration {\n                    Duration::days(self.get() as i64)\n                }\n\n                fn weeks(self) -> Duration {\n                    Duration::weeks(self.get() as i64)\n                }\n            }","impl NumericalStdDuration for $type {\n                fn std_nanoseconds(self) -> StdDuration {\n                    StdDuration::from_nanos(self.get() as u64)\n                }\n\n                fn std_microseconds(self) -> StdDuration {\n                    StdDuration::from_micros(self.get() as u64)\n                }\n\n                fn std_milliseconds(self) -> StdDuration {\n                    StdDuration::from_millis(self.get() as u64)\n                }\n\n                fn std_seconds(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64)\n                }\n\n                fn std_minutes(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }\n\n                fn std_hours(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }\n\n                fn std_days(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }\n\n                fn std_weeks(self) -> StdDuration {\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }\n            }"],"std::time::Duration":["impl Add<Duration> for StdDuration {\n    type Output = Duration;\n\n    fn add(self, rhs: Duration) -> Self::Output {\n        rhs + self\n    }\n}","impl Div<Duration> for StdDuration {\n    type Output = f64;\n\n    fn div(self, rhs: Duration) -> Self::Output {\n        self.as_secs_f64() / rhs.as_seconds_f64()\n    }\n}","impl PartialEq<Duration> for StdDuration {\n    fn eq(&self, rhs: &Duration) -> bool {\n        rhs == self\n    }\n}","impl PartialOrd<Duration> for StdDuration {\n    fn partial_cmp(&self, rhs: &Duration) -> Option<Ordering> {\n        rhs.partial_cmp(self).map(Ordering::reverse)\n    }\n}","impl Sub<Duration> for StdDuration {\n    type Output = Duration;\n\n    fn sub(self, rhs: Duration) -> Self::Output {\n        Duration::try_from(self)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n            - rhs\n    }\n}","impl SubAssign<Duration> for StdDuration {\n    fn sub_assign(&mut self, rhs: Duration) {\n        *self = (*self - rhs).try_into().expect(\n            \"Cannot represent a resulting duration in std. Try `let x = x - rhs;`, which will \\\n             change the type.\",\n        );\n    }\n}","impl TryFrom<Duration> for StdDuration {\n    type Error = error::ConversionRange;\n\n    fn try_from(duration: Duration) -> Result<Self, error::ConversionRange> {\n        Ok(Self::new(\n            duration\n                .seconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            duration\n                .nanoseconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }\n}"],"std::time::Instant":["impl Add<Duration> for StdInstant {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        (Instant::from(self) + duration).into()\n    }\n}","impl AddAssign<Duration> for StdInstant {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl From<Instant> for StdInstant {\n    fn from(instant: Instant) -> Self {\n        instant.inner\n    }\n}","impl PartialEq<Instant> for StdInstant {\n    fn eq(&self, rhs: &Instant) -> bool {\n        self.eq(&rhs.inner)\n    }\n}","impl PartialOrd<Instant> for StdInstant {\n    fn partial_cmp(&self, rhs: &Instant) -> Option<Ordering> {\n        self.partial_cmp(&rhs.inner)\n    }\n}","impl Sub<Duration> for StdInstant {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        (Instant::from(self) - duration).into()\n    }\n}","impl Sub<Instant> for StdInstant {\n    type Output = Duration;\n\n    fn sub(self, other: Instant) -> Self::Output {\n        Instant::from(self) - other\n    }\n}","impl SubAssign<Duration> for StdInstant {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}"],"std::time::SystemTime":["impl Add<Duration> for SystemTime {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        if duration.is_zero() {\n            self\n        } else if duration.is_positive() {\n            self + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            self - duration.abs_std()\n        }\n    }\n}","impl AddAssign<Duration> for SystemTime {\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl From<OffsetDateTime> for SystemTime {\n    fn from(datetime: OffsetDateTime) -> Self {\n        let duration = datetime - OffsetDateTime::unix_epoch();\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }\n}","impl From<PrimitiveDateTime> for SystemTime {\n    fn from(datetime: PrimitiveDateTime) -> Self {\n        let duration = datetime - PrimitiveDateTime::unix_epoch();\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }\n}","impl PartialEq<OffsetDateTime> for SystemTime {\n    fn eq(&self, rhs: &OffsetDateTime) -> bool {\n        &OffsetDateTime::from(*self) == rhs\n    }\n}","impl PartialEq<PrimitiveDateTime> for SystemTime {\n    fn eq(&self, rhs: &PrimitiveDateTime) -> bool {\n        &PrimitiveDateTime::from(*self) == rhs\n    }\n}","impl PartialOrd<OffsetDateTime> for SystemTime {\n    fn partial_cmp(&self, other: &OffsetDateTime) -> Option<Ordering> {\n        OffsetDateTime::from(*self).partial_cmp(other)\n    }\n}","impl PartialOrd<PrimitiveDateTime> for SystemTime {\n    fn partial_cmp(&self, other: &PrimitiveDateTime) -> Option<Ordering> {\n        PrimitiveDateTime::from(*self).partial_cmp(other)\n    }\n}","impl Sub<Duration> for SystemTime {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        (OffsetDateTime::from(self) - duration).into()\n    }\n}","impl Sub<OffsetDateTime> for SystemTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: OffsetDateTime) -> Self::Output {\n        OffsetDateTime::from(self) - rhs\n    }\n}","impl Sub<PrimitiveDateTime> for SystemTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: PrimitiveDateTime) -> Self::Output {\n        PrimitiveDateTime::from(self) - rhs\n    }\n}","impl SubAssign<Duration> for SystemTime {\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}"],"time_mod::Time":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Add<Duration> for Time {\n    type Output = Self;\n\n    /// Add the sub-day time of the `Duration` to the `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// assert_eq!(time!(12:00) + 2.hours(), time!(14:00));\n    /// assert_eq!(time!(0:00:01) + (-2).seconds(), time!(23:59:59));\n    /// ```\n    fn add(self, duration: Duration) -> Self::Output {\n        Self::from_nanoseconds_since_midnight(\n            self.nanoseconds_since_midnight()\n                + duration\n                    .whole_nanoseconds()\n                    .rem_euclid(NANOS_PER_DAY as i128) as u64,\n        )\n    }\n}","impl Add<StdDuration> for Time {\n    type Output = Self;\n\n    /// Add the sub-day time of the `std::time::Duration` to the `Time`. Wraps\n    /// on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// assert_eq!(time!(12:00) + 2.std_hours(), time!(14:00));\n    /// assert_eq!(time!(23:59:59) + 2.std_seconds(), time!(0:00:01));\n    /// ```\n    fn add(self, duration: StdDuration) -> Self::Output {\n        self + Duration::try_from(duration)\n            .expect(\"overflow converting `core::time::Duration` to `time::Duration`\")\n    }\n}","impl AddAssign<Duration> for Time {\n    /// Add the sub-day time of the `Duration` to the existing `Time`. Wraps on\n    /// overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// let mut time = time!(12:00);\n    /// time += 2.hours();\n    /// assert_eq!(time, time!(14:00));\n    ///\n    /// let mut time = time!(0:00:01);\n    /// time += (-2).seconds();\n    /// assert_eq!(time, time!(23:59:59));\n    /// ```\n    fn add_assign(&mut self, duration: Duration) {\n        *self = *self + duration;\n    }\n}","impl AddAssign<StdDuration> for Time {\n    /// Add the sub-day time of the `std::time::Duration` to the existing\n    /// `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// let mut time = time!(12:00);\n    /// time += 2.std_hours();\n    /// assert_eq!(time, time!(14:00));\n    ///\n    /// let mut time = time!(23:59:59);\n    /// time += 2.std_seconds();\n    /// assert_eq!(time, time!(0:00:01));\n    /// ```\n    fn add_assign(&mut self, duration: StdDuration) {\n        *self = *self + duration;\n    }\n}","impl Display for Time {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use crate::format::{time, Padding};\n\n        time::fmt_H(f, *self, Padding::None)?;\n        f.write_str(\":\")?;\n        time::fmt_M(f, *self, Padding::Zero)?;\n\n        if self.second != 0 || self.nanosecond != 0 {\n            f.write_str(\":\")?;\n            time::fmt_S(f, *self, Padding::Zero)?;\n        }\n\n        if self.nanosecond != 0 {\n            f.write_str(\".\")?;\n\n            if self.nanosecond % 1_000_000 == 0 {\n                write!(f, \"{:03}\", self.nanosecond / 1_000_000)?;\n            } else if self.nanosecond % 1_000 == 0 {\n                write!(f, \"{:06}\", self.nanosecond / 1_000)?;\n            } else {\n                write!(f, \"{:09}\", self.nanosecond)?;\n            }\n        }\n\n        Ok(())\n    }\n}","impl Ord for Time {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.hour\n            .cmp(&other.hour)\n            .then_with(|| self.minute.cmp(&other.minute))\n            .then_with(|| self.second.cmp(&other.second))\n            .then_with(|| self.nanosecond.cmp(&other.nanosecond))\n    }\n}","impl Parsable for $type {\n                    fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n                        Self::parse(s, format)\n                    }\n                }","impl PartialOrd for Time {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.cmp(other).into()\n    }\n}","impl Sub<Duration> for Time {\n    type Output = Self;\n\n    /// Subtract the sub-day time of the `Duration` from the `Time`. Wraps on\n    /// overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// assert_eq!(\n    ///     time!(14:00) - 2.hours(),\n    ///     time!(12:00)\n    /// );\n    /// assert_eq!(\n    ///     time!(23:59:59) - (-2).seconds(),\n    ///     time!(0:00:01)\n    /// );\n    /// ```\n    fn sub(self, duration: Duration) -> Self::Output {\n        self + -duration\n    }\n}","impl Sub<StdDuration> for Time {\n    type Output = Self;\n\n    /// Subtract the sub-day time of the `std::time::Duration` from the `Time`.\n    /// Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// assert_eq!(time!(14:00) - 2.std_hours(), time!(12:00));\n    /// assert_eq!(time!(0:00:01) - 2.std_seconds(), time!(23:59:59));\n    /// ```\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        self - Duration::try_from(duration)\n            .expect(\"overflow converting `core::time::Duration` to `time::Duration`\")\n    }\n}","impl Sub<Time> for Time {\n    type Output = Duration;\n\n    /// Subtract two `Time`s, returning the `Duration` between. This assumes\n    /// both `Time`s are in the same calendar day.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// assert_eq!(time!(0:00) - time!(0:00), 0.seconds());\n    /// assert_eq!(time!(1:00) - time!(0:00), 1.hours());\n    /// assert_eq!(time!(0:00) - time!(1:00), (-1).hours());\n    /// assert_eq!(time!(0:00) - time!(23:00), (-23).hours());\n    /// ```\n    fn sub(self, rhs: Self) -> Self::Output {\n        Duration::nanoseconds(\n            self.nanoseconds_since_midnight() as i64 - rhs.nanoseconds_since_midnight() as i64,\n        )\n    }\n}","impl SubAssign<Duration> for Time {\n    /// Subtract the sub-day time of the `Duration` from the existing `Time`.\n    /// Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// let mut time = time!(14:00);\n    /// time -= 2.hours();\n    /// assert_eq!(time, time!(12:00));\n    ///\n    /// let mut time = time!(23:59:59);\n    /// time -= (-2).seconds();\n    /// assert_eq!(time, time!(0:00:01));\n    /// ```\n    fn sub_assign(&mut self, duration: Duration) {\n        *self = *self - duration;\n    }\n}","impl SubAssign<StdDuration> for Time {\n    /// Subtract the sub-day time of the `std::time::Duration` from the existing\n    /// `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::prelude::*;\n    /// # use time_macros::time;\n    /// let mut time = time!(14:00);\n    /// time -= 2.std_hours();\n    /// assert_eq!(time, time!(12:00));\n    ///\n    /// let mut time = time!(0:00:01);\n    /// time -= 2.std_seconds();\n    /// assert_eq!(time, time!(23:59:59));\n    /// ```\n    fn sub_assign(&mut self, duration: StdDuration) {\n        *self = *self - duration;\n    }\n}","impl Time {\n    /// Create a `Time` that is exactly midnight.\n    ///\n    /// ```rust\n    /// # use time::{Time, time};\n    /// assert_eq!(Time::midnight(), time!(0:00));\n    /// ```\n    pub const fn midnight() -> Self {\n        Time {\n            hour: 0,\n            minute: 0,\n            second: 0,\n            nanosecond: 0,\n        }\n    }\n\n    /// Create a `Time` from the hour, minute, and second.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// let time = Time::from_hms(1, 2, 3);\n    /// assert_eq!(time.hour(), 1);\n    /// assert_eq!(time.minute(), 2);\n    /// assert_eq!(time.second(), 3);\n    /// assert_eq!(time.nanosecond(), 0);\n    /// ```\n    ///\n    /// Panics if any component is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms(24, 0, 0); // 24 isn't a valid hour.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms(0, 60, 0); // 60 isn't a valid minute.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms(0, 0, 60); // 60 isn't a valid second.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro. For situations where a \\\n                value isn't known, use `Time::try_from_hms`.\"\n    )]\n    pub fn from_hms(hour: u8, minute: u8, second: u8) -> Self {\n        assert_value_in_range!(hour in 0 => 23);\n        assert_value_in_range!(minute in 0 => 59);\n        assert_value_in_range!(second in 0 => 59);\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond: 0,\n        }\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, and second.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms(1, 2, 3).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if any component is not valid.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms(24, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::try_from_hms(0, 60, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::try_from_hms(0, 0, 60).is_err()); // 60 isn't a valid second.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_hms(\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: 0,\n        })\n    }\n\n    /// Create a `Time` from the hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// let time = Time::from_hms_milli(1, 2, 3, 4);\n    /// assert_eq!(time.hour(), 1);\n    /// assert_eq!(time.minute(), 2);\n    /// assert_eq!(time.second(), 3);\n    /// assert_eq!(time.millisecond(), 4);\n    /// assert_eq!(time.nanosecond(), 4_000_000);\n    /// ```\n    ///\n    /// Panics if any component is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_milli(24, 0, 0, 0); // 24 isn't a valid hour.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_milli(0, 60, 0, 0); // 60 isn't a valid minute.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_milli(0, 0, 60, 0); // 60 isn't a valid second.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_milli(0, 0, 0, 1_000); // 1_000 isn't a valid millisecond.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro. For situations where a \\\n                value isn't known, use `Time::try_from_hms_milli`.\"\n    )]\n    pub fn from_hms_milli(hour: u8, minute: u8, second: u8, millisecond: u16) -> Self {\n        assert_value_in_range!(hour in 0 => 23);\n        assert_value_in_range!(minute in 0 => 59);\n        assert_value_in_range!(second in 0 => 59);\n        assert_value_in_range!(millisecond in 0 => 999);\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond: millisecond as u32 * 1_000_000,\n        }\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_milli(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if any component is not valid.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_milli(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::try_from_hms_milli(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::try_from_hms_milli(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::try_from_hms_milli(0, 0, 0, 1_000).is_err()); // 1_000 isn't a valid millisecond.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_hms_milli(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(millisecond in 0 => 999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: millisecond as u32 * 1_000_000,\n        })\n    }\n\n    /// Create a `Time` from the hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// let time = Time::from_hms_micro(1, 2, 3, 4);\n    /// assert_eq!(time.hour(), 1);\n    /// assert_eq!(time.minute(), 2);\n    /// assert_eq!(time.second(), 3);\n    /// assert_eq!(time.microsecond(), 4);\n    /// assert_eq!(time.nanosecond(), 4_000);\n    /// ```\n    ///\n    /// Panics if any component is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_micro(24, 0, 0, 0); // 24 isn't a valid hour.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_micro(0, 60, 0, 0); // 60 isn't a valid minute.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_micro(0, 0, 60, 0); // 60 isn't a valid second.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_micro(0, 0, 0, 1_000_000); // 1_000_000 isn't a valid microsecond.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro. For situations where a \\\n                value isn't known, use `Time::try_from_hms_micro`.\"\n    )]\n    pub fn from_hms_micro(hour: u8, minute: u8, second: u8, microsecond: u32) -> Self {\n        assert_value_in_range!(hour in 0 => 23);\n        assert_value_in_range!(minute in 0 => 59);\n        assert_value_in_range!(second in 0 => 59);\n        assert_value_in_range!(microsecond in 0 => 999_999);\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond: microsecond * 1_000,\n        }\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_micro(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if any component is not valid.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_micro(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::try_from_hms_micro(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::try_from_hms_micro(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::try_from_hms_micro(0, 0, 0, 1_000_000).is_err()); // 1_000_000 isn't a valid microsecond.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_hms_micro(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(microsecond in 0 => 999_999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: microsecond * 1_000,\n        })\n    }\n\n    /// Create a `Time` from the hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// let time = Time::from_hms_nano(1, 2, 3, 4);\n    /// assert_eq!(time.hour(), 1);\n    /// assert_eq!(time.minute(), 2);\n    /// assert_eq!(time.second(), 3);\n    /// assert_eq!(time.nanosecond(), 4);\n    /// ```\n    ///\n    /// Panics if any component is not valid.\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_nano(24, 0, 0, 0); // 24 isn't a valid hour.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_nano(0, 60, 0, 0); // 60 isn't a valid minute.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_nano(0, 0, 60, 0); // 60 isn't a valid second.\n    /// ```\n    ///\n    /// ```rust,should_panic\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// Time::from_hms_nano(0, 0, 0, 1_000_000_000); // 1_000_000_000 isn't a valid nanosecond.\n    /// ```\n    #[cfg(feature = \"panicking-api\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"panicking-api\")))]\n    #[deprecated(\n        since = \"0.2.3\",\n        note = \"For times knowable at compile-time, use the `time!` macro. For situations where a \\\n                value isn't known, use `Time::try_from_hms_nano`.\"\n    )]\n    pub fn from_hms_nano(hour: u8, minute: u8, second: u8, nanosecond: u32) -> Self {\n        assert_value_in_range!(hour in 0 => 23);\n        assert_value_in_range!(minute in 0 => 59);\n        assert_value_in_range!(second in 0 => 59);\n        assert_value_in_range!(nanosecond in 0 => 999_999_999);\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond,\n        }\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_nano(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// Returns `None` if any component is not valid.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::try_from_hms_nano(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::try_from_hms_nano(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::try_from_hms_nano(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::try_from_hms_nano(0, 0, 0, 1_000_000_000).is_err()); // 1_000_000_000 isn't a valid nanosecond.\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn try_from_hms_nano(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(nanosecond in 0 => 999_999_999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond,\n        })\n    }\n\n    /// Create a `Time` representing the current time (UTC).\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::Time;\n    /// println!(\"{:?}\", Time::now());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n    #[allow(deprecated)]\n    pub fn now() -> Self {\n        PrimitiveDateTime::now().time()\n    }\n\n    /// Get the clock hour.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00:00).hour(), 0);\n    /// assert_eq!(time!(23:59:59).hour(), 23);\n    /// ```\n    pub const fn hour(self) -> u8 {\n        self.hour\n    }\n\n    /// Get the minute within the hour.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00:00).minute(), 0);\n    /// assert_eq!(time!(23:59:59).minute(), 59);\n    /// ```\n    pub const fn minute(self) -> u8 {\n        self.minute\n    }\n\n    /// Get the second within the minute.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00:00).second(), 0);\n    /// assert_eq!(time!(23:59:59).second(), 59);\n    /// ```\n    pub const fn second(self) -> u8 {\n        self.second\n    }\n\n    /// Get the milliseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00).millisecond(), 0);\n    /// assert_eq!(time!(23:59:59.999).millisecond(), 999);\n    /// ```\n    pub const fn millisecond(self) -> u16 {\n        (self.nanosecond() / 1_000_000) as u16\n    }\n\n    /// Get the microseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00).microsecond(), 0);\n    /// assert_eq!(time!(23:59:59.999_999).microsecond(), 999_999);\n    /// ```\n    pub const fn microsecond(self) -> u32 {\n        self.nanosecond() / 1_000\n    }\n\n    /// Get the nanoseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00).nanosecond(), 0);\n    /// assert_eq!(time!(23:59:59.999_999_999).nanosecond(), 999_999_999);\n    /// ```\n    pub const fn nanosecond(self) -> u32 {\n        self.nanosecond\n    }\n\n    /// Get the number of nanoseconds since midnight.\n    pub(crate) const fn nanoseconds_since_midnight(self) -> u64 {\n        self.hour() as u64 * 60 * 60 * 1_000_000_000\n            + self.minute() as u64 * 60 * 1_000_000_000\n            + self.second() as u64 * 1_000_000_000\n            + self.nanosecond() as u64\n    }\n\n    /// Create a `Time` from the number of nanoseconds since midnight.\n    pub(crate) const fn from_nanoseconds_since_midnight(nanosecond: u64) -> Self {\n        Self {\n            hour: (nanosecond / 1_000_000_000 / 60 / 60 % 24) as u8,\n            minute: (nanosecond / 1_000_000_000 / 60 % 60) as u8,\n            second: (nanosecond / 1_000_000_000 % 60) as u8,\n            nanosecond: (nanosecond % 1_000_000_000) as u32,\n        }\n    }\n}","impl Time {\n    /// Format the `Time` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00).format(\"%r\"), \"12:00:00 am\");\n    /// ```\n    pub fn format(self, format: impl AsRef<str>) -> String {\n        self.lazy_format(format).to_string()\n    }\n\n    /// Format the `Time` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::time;\n    /// assert_eq!(time!(0:00).lazy_format(\"%r\").to_string(), \"12:00:00 am\");\n    /// ```\n    pub fn lazy_format(self, format: impl AsRef<str>) -> impl Display {\n        DeferredFormat::new(format.as_ref())\n            .with_time(self)\n            .to_owned()\n    }\n\n    /// Attempt to parse a `Time` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::{Time, time};\n    /// assert_eq!(\n    ///     Time::parse(\"0:00:00\", \"%T\"),\n    ///     Ok(time!(0:00))\n    /// );\n    /// assert_eq!(\n    ///     Time::parse(\"23:59:59\", \"%T\"),\n    ///     Ok(time!(23:59:59))\n    /// );\n    /// assert_eq!(\n    ///     Time::parse(\"12:00:00 am\", \"%r\"),\n    ///     Ok(time!(0:00))\n    /// );\n    /// assert_eq!(\n    ///     Time::parse(\"12:00:00 pm\", \"%r\"),\n    ///     Ok(time!(12:00))\n    /// );\n    /// assert_eq!(\n    ///     Time::parse(\"11:59:59 pm\", \"%r\"),\n    ///     Ok(time!(23:59:59))\n    /// );\n    /// ```\n    pub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }\n\n    /// Given the items already parsed, attempt to create a `Time`.\n    pub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self> {\n        macro_rules! items {\n            ($($item:ident),* $(,)?) => {\n                ParsedItems { $($item: Some($item)),*, .. }\n            };\n        }\n\n        /// Convert a 12-hour time to a 24-hour time.\n        #[allow(clippy::missing_const_for_fn)] // internal fn in non-const outer fn\n        fn hour_12_to_24(hour: NonZeroU8, am_pm: AmPm) -> u8 {\n            use AmPm::{AM, PM};\n            match (hour.get(), am_pm) {\n                (12, AM) => 0,\n                (12, PM) => 12,\n                (h, AM) => h,\n                (h, PM) => h + 12,\n            }\n        }\n\n        match items {\n            items!(hour_24, minute, second, nanosecond) => {\n                Self::try_from_hms_nano(hour_24, minute, second, nanosecond).map_err(Into::into)\n            }\n            items!(hour_12, minute, second, nanosecond, am_pm) => {\n                Self::try_from_hms_nano(hour_12_to_24(hour_12, am_pm), minute, second, nanosecond)\n                    .map_err(Into::into)\n            }\n            items!(hour_24, minute, second) => {\n                Self::try_from_hms(hour_24, minute, second).map_err(Into::into)\n            }\n            items!(hour_12, minute, second, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), minute, second)\n                    .map_err(Into::into)\n            }\n            items!(hour_24, minute) => Self::try_from_hms(hour_24, minute, 0).map_err(Into::into),\n            items!(hour_12, minute, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), minute, 0).map_err(Into::into)\n            }\n            items!(hour_24) => Self::try_from_hms(hour_24, 0, 0).map_err(Into::into),\n            items!(hour_12, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), 0, 0).map_err(Into::into)\n            }\n            _ => Err(error::Parse::InsufficientInformation),\n        }\n    }\n}"],"utc_offset::UtcOffset":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Display for UtcOffset {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let sign = if self.seconds < 0 { '-' } else { '+' };\n        let hours = self.as_hours().abs();\n        let minutes = self.as_minutes().abs() - hours as i16 * 60;\n        let seconds = self.as_seconds().abs() - hours as i32 * 3_600 - minutes as i32 * 60;\n\n        write!(f, \"{}{}\", sign, hours)?;\n\n        if minutes != 0 || seconds != 0 {\n            write!(f, \":{:02}\", minutes)?;\n        }\n\n        if seconds != 0 {\n            write!(f, \":{:02}\", seconds)?;\n        }\n\n        Ok(())\n    }\n}","impl Parsable for $type {\n                    fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n                        Self::parse(s, format)\n                    }\n                }","impl UtcOffset {\n    /// A `UtcOffset` that is UTC.\n    ///\n    /// ```rust\n    /// # use time::{UtcOffset, offset};\n    /// assert_eq!(UtcOffset::UTC, offset!(UTC));\n    /// ```\n    pub const UTC: Self = Self::seconds(0);\n\n    /// Create a `UtcOffset` representing an easterly offset by the number of\n    /// hours provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::east_hours(1).as_hours(), 1);\n    /// assert_eq!(UtcOffset::east_hours(2).as_minutes(), 120);\n    /// ```\n    pub const fn east_hours(hours: u8) -> Self {\n        Self::hours(hours as i8)\n    }\n\n    /// Create a `UtcOffset` representing a westerly offset by the number of\n    /// hours provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::west_hours(1).as_hours(), -1);\n    /// assert_eq!(UtcOffset::west_hours(2).as_minutes(), -120);\n    /// ```\n    pub const fn west_hours(hours: u8) -> Self {\n        Self::hours(-(hours as i8))\n    }\n\n    /// Create a `UtcOffset` representing an offset by the number of hours\n    /// provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::hours(2).as_minutes(), 120);\n    /// assert_eq!(UtcOffset::hours(-2).as_minutes(), -120);\n    /// ```\n    pub const fn hours(hours: i8) -> Self {\n        Self::seconds(hours as i32 * 3_600)\n    }\n\n    /// Create a `UtcOffset` representing an easterly offset by the number of\n    /// minutes provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::east_minutes(60).as_hours(), 1);\n    /// ```\n    pub const fn east_minutes(minutes: u16) -> Self {\n        Self::minutes(minutes as i16)\n    }\n\n    /// Create a `UtcOffset` representing a westerly offset by the number of\n    /// minutes provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::west_minutes(60).as_hours(), -1);\n    /// ```\n    pub const fn west_minutes(minutes: u16) -> Self {\n        Self::minutes(-(minutes as i16))\n    }\n\n    /// Create a `UtcOffset` representing a offset by the number of minutes\n    /// provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::minutes(60).as_hours(), 1);\n    /// assert_eq!(UtcOffset::minutes(-60).as_hours(), -1);\n    /// ```\n    pub const fn minutes(minutes: i16) -> Self {\n        Self::seconds(minutes as i32 * 60)\n    }\n\n    /// Create a `UtcOffset` representing an easterly offset by the number of\n    /// seconds provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::east_seconds(3_600).as_hours(), 1);\n    /// assert_eq!(UtcOffset::east_seconds(1_800).as_minutes(), 30);\n    /// ```\n    pub const fn east_seconds(seconds: u32) -> Self {\n        Self::seconds(seconds as i32)\n    }\n\n    /// Create a `UtcOffset` representing a westerly offset by the number of\n    /// seconds provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::west_seconds(3_600).as_hours(), -1);\n    /// assert_eq!(UtcOffset::west_seconds(1_800).as_minutes(), -30);\n    /// ```\n    pub const fn west_seconds(seconds: u32) -> Self {\n        Self::seconds(-(seconds as i32))\n    }\n\n    /// Create a `UtcOffset` representing an offset by the number of seconds\n    /// provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::seconds(3_600).as_hours(), 1);\n    /// assert_eq!(UtcOffset::seconds(-3_600).as_hours(), -1);\n    /// ```\n    pub const fn seconds(seconds: i32) -> Self {\n        Self { seconds }\n    }\n\n    /// Get the number of seconds from UTC the value is. Positive is east,\n    /// negative is west.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::UTC.as_seconds(), 0);\n    /// assert_eq!(UtcOffset::hours(12).as_seconds(), 43_200);\n    /// assert_eq!(UtcOffset::hours(-12).as_seconds(), -43_200);\n    /// ```\n    pub const fn as_seconds(self) -> i32 {\n        self.seconds\n    }\n\n    /// Get the number of minutes from UTC the value is. Positive is east,\n    /// negative is west.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::UTC.as_minutes(), 0);\n    /// assert_eq!(UtcOffset::hours(12).as_minutes(), 720);\n    /// assert_eq!(UtcOffset::hours(-12).as_minutes(), -720);\n    /// ```\n    pub const fn as_minutes(self) -> i16 {\n        (self.as_seconds() / 60) as i16\n    }\n\n    /// Get the number of hours from UTC the value is. Positive is east,\n    /// negative is west.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::UTC.as_hours(), 0);\n    /// assert_eq!(UtcOffset::hours(12).as_hours(), 12);\n    /// assert_eq!(UtcOffset::hours(-12).as_hours(), -12);\n    /// ```\n    pub const fn as_hours(self) -> i8 {\n        (self.as_seconds() / 3_600) as i8\n    }\n\n    /// Convert a `UtcOffset` to ` Duration`. Useful for implementing operators.\n    pub(crate) const fn as_duration(self) -> Duration {\n        Duration::seconds(self.seconds as i64)\n    }\n\n    /// Obtain the system's UTC offset at a known moment in time. If the offset\n    /// cannot be determined, UTC is returned.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::{UtcOffset, OffsetDateTime};\n    /// let unix_epoch = OffsetDateTime::unix_epoch();\n    /// let local_offset = UtcOffset::local_offset_at(unix_epoch);\n    /// println!(\"{}\", local_offset.format(\"%z\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\n    pub fn local_offset_at(datetime: OffsetDateTime) -> Self {\n        try_local_offset_at(datetime).unwrap_or(Self::UTC)\n    }\n\n    /// Attempt to obtain the system's UTC offset at a known moment in time. If\n    /// the offset cannot be determined, an error is returned.\n    ///\n    /// ```rust\n    /// # use time::{UtcOffset, OffsetDateTime};\n    /// let unix_epoch = OffsetDateTime::unix_epoch();\n    /// let local_offset = UtcOffset::try_local_offset_at(unix_epoch);\n    /// # if false {\n    /// assert!(local_offset.is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn try_local_offset_at(\n        datetime: OffsetDateTime,\n    ) -> Result<Self, error::IndeterminateOffset> {\n        try_local_offset_at(datetime).ok_or(error::IndeterminateOffset)\n    }\n\n    /// Obtain the system's current UTC offset. If the offset cannot be\n    /// determined, UTC is returned.\n    ///\n    /// ```rust\n    /// # #![allow(deprecated)]\n    /// # use time::UtcOffset;\n    /// let local_offset = UtcOffset::current_local_offset();\n    /// println!(\"{}\", local_offset.format(\"%z\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    #[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\n    pub fn current_local_offset() -> Self {\n        let now = OffsetDateTime::now_utc();\n        try_local_offset_at(now).unwrap_or(Self::UTC)\n    }\n\n    /// Attempt to obtain the system's current UTC offset. If the offset cannot\n    /// be determined, an error is returned.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// let local_offset = UtcOffset::try_current_local_offset();\n    /// # if false {\n    /// assert!(local_offset.is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_02_docs, doc(cfg(feature = \"std\")))]\n    pub fn try_current_local_offset() -> Result<Self, error::IndeterminateOffset> {\n        let now = OffsetDateTime::now_utc();\n        try_local_offset_at(now).ok_or(error::IndeterminateOffset)\n    }\n}","impl UtcOffset {\n    /// Format the `UtcOffset` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::hours(2).format(\"%z\"), \"+0200\");\n    /// assert_eq!(UtcOffset::hours(-2).format(\"%z\"), \"-0200\");\n    /// ```\n    pub fn format(self, format: impl AsRef<str>) -> String {\n        self.lazy_format(format).to_string()\n    }\n\n    /// Format the `UtcOffset` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::hours(2).lazy_format(\"%z\").to_string(), \"+0200\");\n    /// assert_eq!(UtcOffset::hours(-2).lazy_format(\"%z\").to_string(), \"-0200\");\n    /// ```\n    pub fn lazy_format(self, format: impl AsRef<str>) -> impl Display {\n        DeferredFormat::new(format.as_ref())\n            .with_offset(self)\n            .to_owned()\n    }\n\n    /// Attempt to parse the `UtcOffset` using the provided string.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::parse(\"+0200\", \"%z\"), Ok(UtcOffset::hours(2)));\n    /// assert_eq!(UtcOffset::parse(\"-0200\", \"%z\"), Ok(UtcOffset::hours(-2)));\n    /// ```\n    pub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self> {\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }\n\n    /// Given the items already parsed, attempt to create a `UtcOffset`.\n    pub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self> {\n        items.offset.ok_or(error::Parse::InsufficientInformation)\n    }\n}"],"weekday::Weekday":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Display for Weekday {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match self {\n            Monday => \"Monday\",\n            Tuesday => \"Tuesday\",\n            Wednesday => \"Wednesday\",\n            Thursday => \"Thursday\",\n            Friday => \"Friday\",\n            Saturday => \"Saturday\",\n            Sunday => \"Sunday\",\n        })\n    }\n}","impl Weekday {\n    /// Get the previous weekday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Tuesday.previous(), Weekday::Monday);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn previous(self) -> Self {\n        match self {\n            Monday => Sunday,\n            Tuesday => Monday,\n            Wednesday => Tuesday,\n            Thursday => Wednesday,\n            Friday => Thursday,\n            Saturday => Friday,\n            Sunday => Saturday,\n        }\n    }\n\n    /// Get the next weekday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);\n    /// ```\n    ///\n    /// This function is `const fn` when using rustc >= 1.46.\n    #[const_fn(\"1.46\")]\n    pub const fn next(self) -> Self {\n        match self {\n            Monday => Tuesday,\n            Tuesday => Wednesday,\n            Wednesday => Thursday,\n            Thursday => Friday,\n            Friday => Saturday,\n            Saturday => Sunday,\n            Sunday => Monday,\n        }\n    }\n\n    /// Get the ISO 8601 weekday number. Equivalent to\n    /// [`Weekday::number_from_monday`].\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.iso_weekday_number(), 1);\n    /// ```\n    pub const fn iso_weekday_number(self) -> u8 {\n        self.number_from_monday()\n    }\n\n    /// Get the one-indexed number of days from Monday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_from_monday(), 1);\n    /// ```\n    pub const fn number_from_monday(self) -> u8 {\n        self.number_days_from_monday() + 1\n    }\n\n    /// Get the one-indexed number of days from Sunday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_from_sunday(), 2);\n    /// ```\n    pub const fn number_from_sunday(self) -> u8 {\n        self.number_days_from_sunday() + 1\n    }\n\n    /// Get the zero-indexed number of days from Monday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_days_from_monday(), 0);\n    /// ```\n    pub const fn number_days_from_monday(self) -> u8 {\n        self as u8\n    }\n\n    /// Get the zero-indexed number of days from Sunday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_days_from_sunday(), 1);\n    /// ```\n    pub const fn number_days_from_sunday(self) -> u8 {\n        (self as u8 + 1) % 7\n    }\n}"]},"single_path_import":{"date::Date":"Date","duration::Duration":"Duration","error::ComponentRange":"ComponentRange","error::ConversionRange":"ConversionRange","error::Error":"Error","error::IndeterminateOffset":"IndeterminateOffset","ext::NumericalDuration":"prelude::NumericalDuration","ext::NumericalStdDuration":"prelude::NumericalStdDuration","ext::NumericalStdDurationShort":"NumericalStdDurationShort","format::format::Format":"Format","format::parse::Error":"Parse","instant::Instant":"Instant","offset_date_time::OffsetDateTime":"OffsetDateTime","primitive_date_time::PrimitiveDateTime":"PrimitiveDateTime","sign::Sign":"Sign","time_macros::date":"macros::date","time_macros::offset":"macros::offset","time_macros::time":"macros::time","time_mod::Time":"Time","utc_offset::UtcOffset":"UtcOffset","util::days_in_year":"days_in_year","util::is_leap_year":"is_leap_year","util::validate_format_string":"validate_format_string","util::weeks_in_year":"weeks_in_year","weekday::Weekday":"Weekday"},"srcs":{"<T as ext::NumericalStdDurationShort>::days":["fn days(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_days(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::hours":["fn hours(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_hours(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::microseconds":["fn microseconds(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_microseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::milliseconds":["fn milliseconds(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_milliseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::minutes":["fn minutes(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_minutes(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::nanoseconds":["fn nanoseconds(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_nanoseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::seconds":["fn seconds(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_seconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<T as ext::NumericalStdDurationShort>::weeks":["fn weeks(self) -> StdDuration{\n        <Self as NumericalStdDuration>::std_weeks(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<date::Date as private::Parsable>::parse":["fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n                        Self::parse(s, format)\n                    }","Real(LocalPath(\"src/lib.rs\"))"],"<date::Date as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.year()\n            .cmp(&other.year())\n            .then_with(|| self.ordinal().cmp(&other.ordinal()))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error>{\n        f.debug_struct(\"Date\")\n            .field(\"year\", &self.year())\n            .field(\"ordinal\", &self.ordinal())\n            .finish()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use crate::format::{date, Padding};\n\n        date::fmt_Y(f, *self, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_m(f, *self, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_d(f, *self, Padding::Zero)?;\n\n        Ok(())\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        Self::from_julian_day(self.julian_day() + duration.whole_days())\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        Self::from_julian_day(self.julian_day() + (duration.as_secs() / 86_400) as i64)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn add_assign(&mut self, duration: StdDuration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        self + -duration\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        Self::from_julian_day(self.julian_day() - (duration.as_secs() / 86_400) as i64)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Sub>::sub":["fn sub(self, other: Self) -> Self::Output{\n        Duration::days(self.julian_day() - other.julian_day())\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: StdDuration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/date.rs\"))"],"<duration::Duration as std::cmp::Ord>::cmp":["fn cmp(&self, rhs: &Self) -> Ordering{\n        self.seconds\n            .cmp(&rhs.seconds)\n            .then_with(|| self.nanoseconds.cmp(&rhs.nanoseconds))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["fn eq(&self, rhs: &StdDuration) -> bool{\n        Ok(*self) == Self::try_from(*rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["fn partial_cmp(&self, rhs: &StdDuration) -> Option<Ordering>{\n        if rhs.as_secs() > i64::max_value() as u64 {\n            return Some(Ordering::Less);\n        }\n\n        Some(\n            self.seconds\n                .cmp(&(rhs.as_secs() as i64))\n                .then_with(|| self.nanoseconds.cmp(&(rhs.subsec_nanos() as i32))),\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, rhs: &Self) -> Option<Ordering>{\n        Some(self.cmp(rhs))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["fn try_from(original: StdDuration) -> Result<Self, error::ConversionRange>{\n        Ok(Self::new(\n            original\n                .as_secs()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            original\n                .subsec_nanos()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["fn add(self, std_duration: StdDuration) -> Self::Output{\n        self + Self::try_from(std_duration)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Add>::add":["fn add(self, rhs: Self) -> Self::Output{\n        self.checked_add(rhs)\n            .expect(\"overflow when adding durations\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn add_assign(&mut self, rhs: StdDuration){\n        *self = *self + rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::AddAssign>::add_assign":["fn add_assign(&mut self, rhs: Self){\n        *self = *self + rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<f32>>::div":["fn div(self, rhs: f32) -> Self::Output{\n        Self::seconds_f32(self.as_seconds_f32() / rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<f64>>::div":["fn div(self, rhs: f64) -> Self::Output{\n        Self::seconds_f64(self.as_seconds_f64() / rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i16>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i32>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i8>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["fn div(self, rhs: StdDuration) -> Self::Output{\n        self.as_seconds_f64() / rhs.as_secs_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u16>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u32>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u8>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div>::div":["fn div(self, rhs: Self) -> Self::Output{\n        self.as_seconds_f64() / rhs.as_seconds_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["fn div_assign(&mut self, rhs: f32){\n        *self = *self / rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["fn div_assign(&mut self, rhs: f64){\n        *self = *self / rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["fn div_assign(&mut self, rhs: $type){\n                    *self = *self / rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<f32>>::mul":["fn mul(self, rhs: f32) -> Self::Output{\n        Self::seconds_f32(self.as_seconds_f32() * rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<f64>>::mul":["fn mul(self, rhs: f64) -> Self::Output{\n        Self::seconds_f64(self.as_seconds_f64() * rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i16>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i32>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i8>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u16>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u32>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u8>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                    Self::nanoseconds_i128(\n                        self.whole_nanoseconds()\n                            .checked_mul(rhs as i128)\n                            .expect(\"overflow when multiplying duration\")\n                    )\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["fn mul_assign(&mut self, rhs: f32){\n        *self = *self * rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["fn mul_assign(&mut self, rhs: f64){\n        *self = *self * rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["fn mul_assign(&mut self, rhs: $type){\n                    *self = *self * rhs;\n                }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Neg>::neg":["fn neg(self) -> Self::Output{\n        -1 * self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, rhs: StdDuration) -> Self::Output{\n        self - Self::try_from(rhs)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        self.checked_sub(rhs)\n            .expect(\"overflow when subtracting durations\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn sub_assign(&mut self, rhs: StdDuration){\n        *self = *self - rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["fn sub_assign(&mut self, rhs: Self){\n        *self = *self - rhs;\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<error::ComponentRange as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(\n            f,\n            \"{} must be in the range {}..={}\",\n            self.name, self.minimum, self.maximum\n        )?;\n\n        if self.conditional_range {\n            write!(f, \", given values of other parameters\")?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ConversionRange as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Source value is out of range for the target type\")\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<error::ComponentRange>>::from":["fn from(original: ComponentRange) -> Self{\n        Error::ComponentRange(Box::new(original))\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<error::ConversionRange>>::from":["fn from(original: ConversionRange) -> Self{\n        Error::ConversionRange(original)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<error::Format>>::from":["fn from(error: Format) -> Self{\n        Error::Format(error)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<error::IndeterminateOffset>>::from":["fn from(original: IndeterminateOffset) -> Self{\n        Error::IndeterminateOffset(original)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<format::parse::Error>>::from":["fn from(original: Parse) -> Self{\n        Error::Parse(original)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Error::ConversionRange(err) => Some(err),\n            Error::ComponentRange(box_err) => Some(box_err.as_ref()),\n            Error::Parse(err) => Some(err),\n            Error::IndeterminateOffset(err) => Some(err),\n            Error::Format(err) => Some(err),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Error::__NonExhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Error::ConversionRange(e) => e.fmt(f),\n            Error::ComponentRange(e) => e.fmt(f),\n            Error::Parse(e) => e.fmt(f),\n            Error::IndeterminateOffset(e) => e.fmt(f),\n            Error::Format(e) => e.fmt(f),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Error::__NonExhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Format as std::convert::From<std::fmt::Error>>::from":["fn from(_: fmt::Error) -> Self{\n        Format::StdFmtError\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Format as std::error::Error>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Format::StdFmtError => Some(&fmt::Error),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Format as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Format::InsufficientTypeInformation => {\n                f.write_str(\"The format provided requires more information than the type provides.\")\n            }\n            Format::StdFmtError => fmt::Error.fmt(f),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Format::__NonExhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::IndeterminateOffset as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"The system's UTC offset could not be determined\")\n    }","Real(LocalPath(\"src/error.rs\"))"],"<f32 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::nanoseconds((self * 86_400_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::nanoseconds((self * 3_600_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::nanoseconds((self * 60_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f32 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::nanoseconds((self * 604_800_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::nanoseconds((self * 86_400_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::nanoseconds((self * 3_600_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::nanoseconds((self * 60_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::nanoseconds((self * 1_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::nanoseconds((self * 604_800_000_000_000.) as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 86_400_000_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 3_600_000_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 60_000_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos(self as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 604_800_000_000_000.) as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<format::deferred_format::DeferredFormat as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        match &self.format {\n            Format::Custom(s) => {\n                for item in parse_fmt_string(s) {\n                    match item {\n                        FormatItem::Literal(value) => f.write_str(value)?,\n                        FormatItem::Specifier(specifier) => {\n                            format_specifier(f, self.date, self.time, self.offset, specifier)\n                                .map_err(|_| fmt::Error)?\n                        }\n                    }\n                }\n\n                Ok(())\n            }\n            Format::Rfc3339 => well_known::rfc3339::fmt(self, f).map_err(|_| fmt::Error),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            Format::__NonExhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"<format::format::Format as std::convert::From<T>>::from":["fn from(s: T) -> Self{\n        Format::Custom(s.as_ref().to_owned())\n    }","Real(LocalPath(\"src/format/format.rs\"))"],"<format::parse::Error as std::convert::From<error::ComponentRange>>::from":["fn from(error: error::ComponentRange) -> Self{\n        Error::ComponentOutOfRange(Box::new(error))\n    }","Real(LocalPath(\"src/format/parse.rs\"))"],"<format::parse::Error as std::error::Error>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Error::ComponentOutOfRange(e) => Some(e.as_ref()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/format/parse.rs\"))"],"<format::parse::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        use Error::*;\n        match self {\n            InvalidNanosecond => f.write_str(\"invalid nanosecond\"),\n            InvalidSecond => f.write_str(\"invalid second\"),\n            InvalidMinute => f.write_str(\"invalid minute\"),\n            InvalidHour => f.write_str(\"invalid hour\"),\n            InvalidAmPm => f.write_str(\"invalid am/pm\"),\n            InvalidMonth => f.write_str(\"invalid month\"),\n            InvalidYear => f.write_str(\"invalid year\"),\n            InvalidWeek => f.write_str(\"invalid week\"),\n            InvalidDayOfWeek => f.write_str(\"invalid day of week\"),\n            InvalidDayOfMonth => f.write_str(\"invalid day of month\"),\n            InvalidDayOfYear => f.write_str(\"invalid day of year\"),\n            InvalidOffset => f.write_str(\"invalid offset\"),\n            MissingFormatSpecifier => f.write_str(\"missing format specifier after `%`\"),\n            InvalidFormatSpecifier(c) => write!(f, \"invalid format specifier `{}` after `%`\", c),\n            UnexpectedCharacter { expected, actual } => {\n                write!(f, \"expected character `{}`, found `{}`\", expected, actual)\n            }\n            UnexpectedEndOfString => f.write_str(\"unexpected end of string\"),\n            InsufficientInformation => {\n                f.write_str(\"insufficient information provided to create the requested type\")\n            }\n            ComponentOutOfRange(e) => write!(f, \"{}\", e),\n            #[cfg(not(__time_02_supports_non_exhaustive))]\n            __NonExhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/format/parse.rs\"))"],"<i16 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i16 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_secs(self as u64 * 86_400)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_secs(self as u64 * 3_600)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_micros(self as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_millis(self as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_secs(self as u64 * 60)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_nanos(self as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_secs(self as u64)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i32 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n        assert!(self >= 0);\n        StdDuration::from_secs(self as u64 * 604_800)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<i8 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["fn eq(&self, rhs: &StdInstant) -> bool{\n        self.inner.eq(rhs)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["fn partial_cmp(&self, rhs: &StdInstant) -> Option<Ordering>{\n        self.inner.partial_cmp(rhs)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["fn from(instant: StdInstant) -> Self{\n        Self { inner: instant }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        if duration.is_positive() {\n            (self.inner + duration.abs_std()).into()\n        } else if duration.is_negative() {\n            (self.inner - duration.abs_std()).into()\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        Self {\n            inner: self.inner + duration,\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn add_assign(&mut self, duration: StdDuration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        self + -duration\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        Self {\n            inner: self.inner - duration,\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["fn sub(self, other: StdInstant) -> Self::Output{\n        self - Self::from(other)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub>::sub":["fn sub(self, other: Self) -> Self::Output{\n        match self.inner.cmp(&other.inner) {\n            Ordering::Equal => Duration::zero(),\n            Ordering::Greater => (self.inner - other.inner)\n                .try_into()\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Ordering::Less => -Duration::try_from(other.inner - self.inner)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: StdDuration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<offset_date_time::OffsetDateTime as private::Parsable>::parse":["fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n                        Self::parse(s, format)\n                    }","Real(LocalPath(\"src/lib.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["fn cmp(&self, rhs: &Self) -> Ordering{\n        self.utc_datetime.cmp(&rhs.utc_datetime)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["fn eq(&self, rhs: &SystemTime) -> bool{\n        self == &Self::from(*rhs)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        self.utc_datetime.eq(&rhs.utc_datetime)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering>{\n        self.partial_cmp(&Self::from(*other))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, rhs: &Self) -> Option<Ordering>{\n        Some(self.cmp(rhs))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["fn from(system_time: SystemTime) -> Self{\n        let duration = match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Duration::try_from(duration)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Err(err) => -Duration::try_from(err.duration())\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        };\n\n        Self::unix_epoch() + duration\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{} {} {}\", self.date(), self.time(), self.offset())\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, hasher: &mut H){\n        // We need to distinguish this from a `PrimitiveDateTime`, which would\n        // otherwise conflict.\n        hasher.write(b\"OffsetDateTime\");\n        self.utc_datetime.hash(hasher);\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        Self {\n            utc_datetime: self.utc_datetime + duration,\n            offset: self.offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        Self {\n            utc_datetime: self.utc_datetime + duration,\n            offset: self.offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn add_assign(&mut self, duration: StdDuration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        Self {\n            utc_datetime: self.utc_datetime - duration,\n            offset: self.offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        Self {\n            utc_datetime: self.utc_datetime - duration,\n            offset: self.offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["fn sub(self, rhs: SystemTime) -> Self::Output{\n        self - Self::from(rhs)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        self.utc_datetime - rhs.utc_datetime\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: StdDuration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as private::Parsable>::parse":["fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n                        Self::parse(s, format)\n                    }","Real(LocalPath(\"src/lib.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.date\n            .cmp(&other.date)\n            .then_with(|| self.time.cmp(&other.time))\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["fn eq(&self, rhs: &SystemTime) -> bool{\n        self == &Self::from(*rhs)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering>{\n        self.partial_cmp(&Self::from(*other))\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::convert::From<std::time::SystemTime>>::from":["fn from(system_time: SystemTime) -> Self{\n        let duration = match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Duration::try_from(duration)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Err(err) => -Duration::try_from(err.duration())\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        };\n\n        Self::unix_epoch() + duration\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{} {}\", self.date(), self.time())\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        let nanos = self.time.nanoseconds_since_midnight() as i64\n            + (duration.whole_nanoseconds() % 86_400_000_000_000) as i64;\n\n        let date_modifier = if nanos < 0 {\n            Duration::days(-1)\n        } else if nanos >= 86_400_000_000_000 {\n            Duration::day()\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date + duration + date_modifier, self.time + duration)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        let nanos = self.time.nanoseconds_since_midnight()\n            + (duration.as_nanos() % 86_400_000_000_000) as u64;\n\n        let date_modifier = if nanos >= 86_400_000_000_000 {\n            Duration::day()\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date + duration + date_modifier, self.time + duration)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn add_assign(&mut self, duration: StdDuration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        self + -duration\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        let nanos = self.time.nanoseconds_since_midnight() as i64\n            - (duration.as_nanos() % 86_400_000_000_000) as i64;\n\n        let date_modifier = if nanos < 0 {\n            Duration::days(-1)\n        } else {\n            Duration::zero()\n        };\n\n        Self::new(self.date - duration + date_modifier, self.time - duration)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["fn sub(self, rhs: SystemTime) -> Self::Output{\n        self - Self::from(rhs)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        (self.date - rhs.date) + (self.time - rhs.time)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn sub_assign(&mut self, duration: StdDuration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<sign::Sign as std::default::Default>::default":["/// `Sign` defaults to `Zero`.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Sign;\n/// assert_eq!(Sign::default(), Sign::Zero);\n/// ```\nfn default() -> Self{\n        Zero\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Div>::div":["fn div(self, rhs: Self) -> Self::Output{\n        self * rhs\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::DivAssign>::div_assign":["fn div_assign(&mut self, rhs: Self){\n        *self *= rhs\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<f32>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<f64>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<i128>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<i16>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<i32>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<i64>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul<i8>>::mul":["#[allow(trivial_numeric_casts)]\nfn mul(self, rhs: $type) -> Self::Output{\n                    (self as i8) as $type * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Mul>::mul":["fn mul(self, rhs: Self) -> Self::Output{\n        match (self, rhs) {\n            (Zero, _) | (_, Zero) => Zero,\n            (Positive, Positive) | (Negative, Negative) => Positive,\n            (Positive, Negative) | (Negative, Positive) => Negative,\n        }\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::MulAssign>::mul_assign":["fn mul_assign(&mut self, rhs: Self){\n        *self = *self * rhs;\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Neg>::neg":["fn neg(self) -> Self::Output{\n        self.negate()\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<sign::Sign as std::ops::Not>::not":["fn not(self) -> Self::Output{\n        self.negate()\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI16 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI32 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI64 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroI8 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self.get() as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self.get() as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<time_mod::Time as private::Parsable>::parse":["fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n                        Self::parse(s, format)\n                    }","Real(LocalPath(\"src/lib.rs\"))"],"<time_mod::Time as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.hour\n            .cmp(&other.hour)\n            .then_with(|| self.minute.cmp(&other.minute))\n            .then_with(|| self.second.cmp(&other.second))\n            .then_with(|| self.nanosecond.cmp(&other.nanosecond))\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.cmp(other).into()\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use crate::format::{time, Padding};\n\n        time::fmt_H(f, *self, Padding::None)?;\n        f.write_str(\":\")?;\n        time::fmt_M(f, *self, Padding::Zero)?;\n\n        if self.second != 0 || self.nanosecond != 0 {\n            f.write_str(\":\")?;\n            time::fmt_S(f, *self, Padding::Zero)?;\n        }\n\n        if self.nanosecond != 0 {\n            f.write_str(\".\")?;\n\n            if self.nanosecond % 1_000_000 == 0 {\n                write!(f, \"{:03}\", self.nanosecond / 1_000_000)?;\n            } else if self.nanosecond % 1_000 == 0 {\n                write!(f, \"{:06}\", self.nanosecond / 1_000)?;\n            } else {\n                write!(f, \"{:09}\", self.nanosecond)?;\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::Add<duration::Duration>>::add":["/// Add the sub-day time of the `Duration` to the `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// assert_eq!(time!(12:00) + 2.hours(), time!(14:00));\n/// assert_eq!(time!(0:00:01) + (-2).seconds(), time!(23:59:59));\n/// ```\nfn add(self, duration: Duration) -> Self::Output{\n        Self::from_nanoseconds_since_midnight(\n            self.nanoseconds_since_midnight()\n                + duration\n                    .whole_nanoseconds()\n                    .rem_euclid(NANOS_PER_DAY as i128) as u64,\n        )\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::Add<std::time::Duration>>::add":["/// Add the sub-day time of the `std::time::Duration` to the `Time`. Wraps\n/// on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// assert_eq!(time!(12:00) + 2.std_hours(), time!(14:00));\n/// assert_eq!(time!(23:59:59) + 2.std_seconds(), time!(0:00:01));\n/// ```\nfn add(self, duration: StdDuration) -> Self::Output{\n        self + Duration::try_from(duration)\n            .expect(\"overflow converting `core::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["/// Add the sub-day time of the `Duration` to the existing `Time`. Wraps on\n/// overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// let mut time = time!(12:00);\n/// time += 2.hours();\n/// assert_eq!(time, time!(14:00));\n///\n/// let mut time = time!(0:00:01);\n/// time += (-2).seconds();\n/// assert_eq!(time, time!(23:59:59));\n/// ```\nfn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["/// Add the sub-day time of the `std::time::Duration` to the existing\n/// `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// let mut time = time!(12:00);\n/// time += 2.std_hours();\n/// assert_eq!(time, time!(14:00));\n///\n/// let mut time = time!(23:59:59);\n/// time += 2.std_seconds();\n/// assert_eq!(time, time!(0:00:01));\n/// ```\nfn add_assign(&mut self, duration: StdDuration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::Sub<duration::Duration>>::sub":["/// Subtract the sub-day time of the `Duration` from the `Time`. Wraps on\n/// overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// assert_eq!(\n///     time!(14:00) - 2.hours(),\n///     time!(12:00)\n/// );\n/// assert_eq!(\n///     time!(23:59:59) - (-2).seconds(),\n///     time!(0:00:01)\n/// );\n/// ```\nfn sub(self, duration: Duration) -> Self::Output{\n        self + -duration\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::Sub<std::time::Duration>>::sub":["/// Subtract the sub-day time of the `std::time::Duration` from the `Time`.\n/// Wraps on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// assert_eq!(time!(14:00) - 2.std_hours(), time!(12:00));\n/// assert_eq!(time!(0:00:01) - 2.std_seconds(), time!(23:59:59));\n/// ```\nfn sub(self, duration: StdDuration) -> Self::Output{\n        self - Duration::try_from(duration)\n            .expect(\"overflow converting `core::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::Sub>::sub":["/// Subtract two `Time`s, returning the `Duration` between. This assumes\n/// both `Time`s are in the same calendar day.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// assert_eq!(time!(0:00) - time!(0:00), 0.seconds());\n/// assert_eq!(time!(1:00) - time!(0:00), 1.hours());\n/// assert_eq!(time!(0:00) - time!(1:00), (-1).hours());\n/// assert_eq!(time!(0:00) - time!(23:00), (-23).hours());\n/// ```\nfn sub(self, rhs: Self) -> Self::Output{\n        Duration::nanoseconds(\n            self.nanoseconds_since_midnight() as i64 - rhs.nanoseconds_since_midnight() as i64,\n        )\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["/// Subtract the sub-day time of the `Duration` from the existing `Time`.\n/// Wraps on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// let mut time = time!(14:00);\n/// time -= 2.hours();\n/// assert_eq!(time, time!(12:00));\n///\n/// let mut time = time!(23:59:59);\n/// time -= (-2).seconds();\n/// assert_eq!(time, time!(0:00:01));\n/// ```\nfn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<time_mod::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["/// Subtract the sub-day time of the `std::time::Duration` from the existing\n/// `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// # use time_macros::time;\n/// let mut time = time!(14:00);\n/// time -= 2.std_hours();\n/// assert_eq!(time, time!(12:00));\n///\n/// let mut time = time!(0:00:01);\n/// time -= 2.std_seconds();\n/// assert_eq!(time, time!(23:59:59));\n/// ```\nfn sub_assign(&mut self, duration: StdDuration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"<u16 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u16 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u32 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n                    Duration::days(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n                    Duration::hours(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n                    Duration::microseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n                    Duration::milliseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n                    Duration::minutes(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n                    Duration::nanoseconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n                    Duration::seconds(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n                    Duration::weeks(self as i64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 86_400)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 3_600)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n                    StdDuration::from_micros(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n                    StdDuration::from_millis(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 60)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n                    StdDuration::from_nanos(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<u8 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n                    StdDuration::from_secs(self as u64 * 604_800)\n                }","Real(LocalPath(\"src/ext.rs\"))"],"<utc_offset::UtcOffset as private::Parsable>::parse":["fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n                        Self::parse(s, format)\n                    }","Real(LocalPath(\"src/lib.rs\"))"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let sign = if self.seconds < 0 { '-' } else { '+' };\n        let hours = self.as_hours().abs();\n        let minutes = self.as_minutes().abs() - hours as i16 * 60;\n        let seconds = self.as_seconds().abs() - hours as i32 * 3_600 - minutes as i32 * 60;\n\n        write!(f, \"{}{}\", sign, hours)?;\n\n        if minutes != 0 || seconds != 0 {\n            write!(f, \":{:02}\", minutes)?;\n        }\n\n        if seconds != 0 {\n            write!(f, \":{:02}\", seconds)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"<weekday::Weekday as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(match self {\n            Monday => \"Monday\",\n            Tuesday => \"Tuesday\",\n            Wednesday => \"Wednesday\",\n            Thursday => \"Thursday\",\n            Friday => \"Friday\",\n            Saturday => \"Saturday\",\n            Sunday => \"Sunday\",\n        })\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"date::Date":["/// Calendar date.\n///\n/// Years between `-100_000` and `+100_000` inclusive are guaranteed to be\n/// representable. Any values outside this range may have incidental support\n/// that can change at any time without notice. If you need support outside this\n/// range, please [file an issue](https://github.com/time-rs/time/issues/new)\n/// with your use case.\npub struct Date {\n    /// Bitpacked field containing both the year and ordinal.\n    // |     xx     | xxxxxxxxxxxxxxxxxxxxx | xxxxxxxxx |\n    // |   2 bits   |        21 bits        |  9 bits   |\n    // | unassigned |         year          |  ordinal  |\n    pub(crate) value: i32,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Date::as_ymd":["/// Get the year, month, and day.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).as_ymd(), (2019, 1, 1));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn as_ymd(self) -> (i32, u8, u8){\n        let (month, day) = self.month_day();\n        (self.year(), month, day)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::as_yo":["/// Get the year and ordinal day number.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).as_yo(), (2019, 1));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\n#[allow(clippy::missing_const_for_fn)]\npub const fn as_yo(self) -> (i32, u16){\n        (self.year(), self.ordinal())\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::day":["/// Get the day of the month. If fetching both the month and day, it is more\n/// efficient to use [`Date::month_day`].\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).day(), 1);\n/// assert_eq!(date!(2019-12-31).day(), 31);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn day(self) -> u8{\n        self.month_day().1\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::format":["/// Format the `Date` using the provided string.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-02).format(\"%Y-%m-%d\"), \"2019-01-02\");\n/// ```\npub fn format(self, format: impl AsRef<str>) -> String{\n        self.lazy_format(format).to_string()\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_julian_day":["/// Create a `Date` from the Julian day.\n///\n/// The algorithm to perform this conversion is derived from one provided by\n/// Peter Baum; it is freely available\n/// [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::{Date, date};\n/// assert_eq!(\n///     Date::from_julian_day(0),\n///     date!(-4713-11-24)\n/// );\n/// assert_eq!(Date::from_julian_day(2_451_545), date!(2000-01-01));\n/// assert_eq!(Date::from_julian_day(2_458_485), date!(2019-01-01));\n/// assert_eq!(Date::from_julian_day(2_458_849), date!(2019-12-31));\n/// ```\n#![allow(clippy::many_single_char_names)]\npub fn from_julian_day(julian_day: i64) -> Self{\n        #![allow(clippy::many_single_char_names)]\n        let z = julian_day - 1_721_119;\n        let h = 100 * z - 25;\n        let a = div_floor(h, 3_652_425);\n        let b = a - div_floor(a, 4);\n        let mut year = div_floor(100 * b + h, 36_525);\n        let c = b + z - 365 * year - div_floor(year, 4);\n        let mut month = (5 * c + 456) / 153;\n        let day = c - (153 * month - 457) / 5;\n\n        if month > 12 {\n            year += 1;\n            month -= 12;\n        }\n\n        match Date::try_from_ymd(year as i32, month as u8, day as u8) {\n            Ok(date) => date,\n            Err(err) => panic!(\"{}\", err),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::iso_weekday_number":["/// Get the ISO weekday number.\n///\n/// This is equivalent to calling `.weekday().iso_weekday_number()`, but is\n/// usable in `const` contexts.\npub(crate) const fn iso_weekday_number(self) -> u8{\n        self.number_days_from_monday() + 1\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::iso_year_week":["/// Get the ISO 8601 year and week number.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).iso_year_week(), (2019, 1));\n/// assert_eq!(date!(2019-10-04).iso_year_week(), (2019, 40));\n/// assert_eq!(date!(2020-01-01).iso_year_week(), (2020, 1));\n/// assert_eq!(date!(2020-12-31).iso_year_week(), (2020, 53));\n/// assert_eq!(date!(2021-01-01).iso_year_week(), (2020, 53));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn iso_year_week(self) -> (i32, u8){\n        let (year, ordinal) = self.as_yo();\n\n        match ((ordinal + 10 - self.iso_weekday_number() as u16) / 7) as u8 {\n            0 => (year - 1, weeks_in_year(year - 1)),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1),\n            _ => (\n                year,\n                ((ordinal + 10 - self.iso_weekday_number() as u16) / 7) as u8,\n            ),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::julian_day":["/// Get the Julian day for the date.\n///\n/// The algorithm to perform this conversion is derived from one provided by\n/// Peter Baum; it is freely available\n/// [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(-4713-11-24).julian_day(), 0);\n/// assert_eq!(date!(2000-01-01).julian_day(), 2_451_545);\n/// assert_eq!(date!(2019-01-01).julian_day(), 2_458_485);\n/// assert_eq!(date!(2019-12-31).julian_day(), 2_458_849);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn julian_day(self) -> i64{\n        let (mut year, mut month, day) = self.as_ymd();\n\n        if month < 3 {\n            year -= 1;\n            month += 12;\n        }\n\n        let year = year as i64;\n        let month = month as i64;\n        let day = day as i64;\n\n        day + (153 * month - 457) / 5 + 365 * year + div_floor(year, 4) - div_floor(year, 100)\n            + div_floor(year, 400)\n            + 1_721_119\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::lazy_format":["/// Format the `Date` using the provided string.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-02).lazy_format(\"%Y-%m-%d\").to_string(), \"2019-01-02\");\n/// ```\npub fn lazy_format(self, format: impl AsRef<str>) -> impl Display{\n        DeferredFormat::new(format.as_ref())\n            .with_date(self)\n            .to_owned()\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::midnight":["/// Create a `PrimitiveDateTime` using the existing date. The `Time` component will\n/// be set to midnight.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(\n///     date!(1970-01-01).midnight(),\n///     date!(1970-01-01).with_time(time!(0:00))\n/// );\n/// ```\npub const fn midnight(self) -> PrimitiveDateTime{\n        PrimitiveDateTime::new(self, Time::midnight())\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::monday_based_week":["/// Get the week number where week 1 begins on the first Monday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).monday_based_week(), 0);\n/// assert_eq!(date!(2020-01-01).monday_based_week(), 0);\n/// assert_eq!(date!(2020-12-31).monday_based_week(), 52);\n/// assert_eq!(date!(2021-01-01).monday_based_week(), 0);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn monday_based_week(self) -> u8{\n        ((self.ordinal() as i16 - self.number_days_from_monday() as i16 + 6) / 7) as u8\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::month":["/// Get the month. If fetching both the month and day, it is more efficient\n/// to use [`Date::month_day`].\n///\n/// The returned value will always be in the range `1..=12`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).month(), 1);\n/// assert_eq!(date!(2019-12-31).month(), 12);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn month(self) -> u8{\n        self.month_day().0\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::month_day":["/// Get the month and day. This is more efficient than fetching the\n/// components individually.\n///\n/// The month component will always be in the range `1..=12`;\n/// the day component in `1..=31`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).month_day(), (1, 1));\n/// assert_eq!(date!(2019-12-31).month_day(), (12, 31));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn month_day(self) -> (u8, u8){\n        /// The number of days up to and including the given month. Common years\n        /// are first, followed by leap years.\n        #[allow(clippy::items_after_statements)]\n        const CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP: [[u16; 11]; 2] = [\n            [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        let days = CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP[is_leap_year(self.year()) as usize];\n        let ordinal = self.ordinal();\n\n        if ordinal > days[10] {\n            (12, (ordinal - days[10]) as u8)\n        } else if ordinal > days[9] {\n            (11, (ordinal - days[9]) as u8)\n        } else if ordinal > days[8] {\n            (10, (ordinal - days[8]) as u8)\n        } else if ordinal > days[7] {\n            (9, (ordinal - days[7]) as u8)\n        } else if ordinal > days[6] {\n            (8, (ordinal - days[6]) as u8)\n        } else if ordinal > days[5] {\n            (7, (ordinal - days[5]) as u8)\n        } else if ordinal > days[4] {\n            (6, (ordinal - days[4]) as u8)\n        } else if ordinal > days[3] {\n            (5, (ordinal - days[3]) as u8)\n        } else if ordinal > days[2] {\n            (4, (ordinal - days[2]) as u8)\n        } else if ordinal > days[1] {\n            (3, (ordinal - days[1]) as u8)\n        } else if ordinal > days[0] {\n            (2, (ordinal - days[0]) as u8)\n        } else {\n            (1, ordinal as u8)\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::next_day":["/// Get the next calendar date.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).next_day(), date!(2019-01-02));\n/// assert_eq!(date!(2019-01-31).next_day(), date!(2019-02-01));\n/// assert_eq!(date!(2019-12-31).next_day(), date!(2020-01-01));\n/// ```\npub fn next_day(self) -> Self{\n        let (mut year, mut ordinal) = self.as_yo();\n\n        ordinal += 1;\n\n        if ordinal > days_in_year(year) {\n            year += 1;\n            ordinal = 1;\n        }\n\n        if year > MAX_YEAR {\n            panic!(\"overflow when fetching next day\");\n        }\n\n        internals::Date::from_yo_unchecked(year, ordinal)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::number_days_from_monday":["/// Get the number of days from Monday.\n///\n/// This is equivalent to calling `.weekday().number_days_from_monday()`,\n/// but is usable in `const` contexts.\npub(crate) const fn number_days_from_monday(self) -> u8{\n        let (year, month, day) = self.as_ymd();\n\n        let (month, adjusted_year) = if month < 3 {\n            (month + 12, year - 1)\n        } else {\n            (month, year)\n        };\n\n        let raw_weekday =\n            (day as i32 + (13 * (month as i32 + 1)) / 5 + adjusted_year + adjusted_year / 4\n                - adjusted_year / 100\n                + adjusted_year / 400)\n                % 7\n                - 2;\n\n        if raw_weekday < 0 {\n            (raw_weekday + 7) as u8\n        } else {\n            raw_weekday as u8\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::number_days_from_sunday":["/// Get the number of days from Sunday.\n///\n/// This is equivalent to calling `.weekday().number_days_from_sunday()`,\n/// but is usable in `const` contexts.\npub(crate) const fn number_days_from_sunday(self) -> u8{\n        self.iso_weekday_number() % 7\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::ordinal":["/// Get the day of the year.\n///\n/// The returned value will always be in the range `1..=366` (`1..=365` for\n/// common years).\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).ordinal(), 1);\n/// assert_eq!(date!(2019-12-31).ordinal(), 365);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\n#[allow(clippy::missing_const_for_fn)]\npub const fn ordinal(self) -> u16{\n        (self.value & 0x1FF) as u16\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::parse":["/// Attempt to parse a `Date` using the provided string.\n///\n/// ```rust\n/// # use time::{Date, date};\n/// assert_eq!(\n///     Date::parse(\"2019-01-02\", \"%F\"),\n///     Ok(date!(2019-01-02))\n/// );\n/// assert_eq!(\n///     Date::parse(\"2019-002\", \"%Y-%j\"),\n///     Ok(date!(2019-002))\n/// );\n/// assert_eq!(\n///     Date::parse(\"2019-W01-3\", \"%G-W%V-%u\"),\n///     Ok(date!(2019-W01-3))\n/// );\n/// ```\npub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::previous_day":["/// Get the previous calendar date.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-02).previous_day(), date!(2019-01-01));\n/// assert_eq!(date!(2019-02-01).previous_day(), date!(2019-01-31));\n/// assert_eq!(date!(2020-01-01).previous_day(), date!(2019-12-31));\n/// ```\npub fn previous_day(self) -> Self{\n        let (mut year, mut ordinal) = self.as_yo();\n\n        ordinal -= 1;\n\n        if ordinal == 0 {\n            year -= 1;\n            ordinal = days_in_year(year);\n        }\n\n        if year < MIN_YEAR {\n            panic!(\"overflow when fetching previous day\");\n        }\n\n        internals::Date::from_yo_unchecked(year, ordinal)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::sunday_based_week":["/// Get the week number where week 1 begins on the first Sunday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).sunday_based_week(), 0);\n/// assert_eq!(date!(2020-01-01).sunday_based_week(), 0);\n/// assert_eq!(date!(2020-12-31).sunday_based_week(), 52);\n/// assert_eq!(date!(2021-01-01).sunday_based_week(), 0);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn sunday_based_week(self) -> u8{\n        ((self.ordinal() as i16 - self.number_days_from_sunday() as i16 + 6) / 7) as u8\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::today":["/// Create a `Date` representing the current date.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Date;\n/// assert!(Date::today().year() >= 2019);\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n#[allow(deprecated)]\npub fn today() -> Self{\n        PrimitiveDateTime::now().date()\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_from_iso_ywd":["/// Attempt to create a `Date` from the ISO year, week, and weekday.\n///\n/// ```rust\n/// # use time::{Date, Weekday::*};\n/// assert!(Date::try_from_iso_ywd(2019, 1, Monday).is_ok());\n/// assert!(Date::try_from_iso_ywd(2019, 1, Tuesday).is_ok());\n/// assert!(Date::try_from_iso_ywd(2020, 53, Friday).is_ok());\n/// ```\n///\n/// Returns `None` if the week is not valid.\n///\n/// ```rust\n/// # use time::{Date, Weekday::*};\n/// assert!(Date::try_from_iso_ywd(2019, 53, Monday).is_err()); // 2019 doesn't have 53 weeks.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_iso_ywd(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(week conditionally in 1 => weeks_in_year(year));\n        Ok(internals::Date::from_iso_ywd_unchecked(year, week, weekday))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_from_parsed_items":["/// Given the items already parsed, attempt to create a `Date`.\npub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self>{\n        macro_rules! items {\n            ($($item:ident),* $(,)?) => {\n                ParsedItems { $($item: Some($item)),*, .. }\n            };\n        }\n\n        /// Get the value needed to adjust the ordinal day for Sunday and\n        /// Monday-based week numbering.\n        fn adjustment(year: i32) -> i16 {\n            match internals::Date::from_yo_unchecked(year, 1).weekday() {\n                Weekday::Monday => 7,\n                Weekday::Tuesday => 1,\n                Weekday::Wednesday => 2,\n                Weekday::Thursday => 3,\n                Weekday::Friday => 4,\n                Weekday::Saturday => 5,\n                Weekday::Sunday => 6,\n            }\n        }\n\n        match items {\n            items!(year, month, day) => {\n                Date::try_from_ymd(year, month.get(), day.get()).map_err(Into::into)\n            }\n            items!(year, ordinal_day) => {\n                Date::try_from_yo(year, ordinal_day.get()).map_err(Into::into)\n            }\n            items!(week_based_year, iso_week, weekday) => {\n                Date::try_from_iso_ywd(week_based_year, iso_week.get(), weekday).map_err(Into::into)\n            }\n            items!(year, sunday_week, weekday) => Date::try_from_yo(\n                year,\n                (sunday_week as i16 * 7 + weekday.number_days_from_sunday() as i16\n                    - adjustment(year)\n                    + 1) as u16,\n            )\n            .map_err(Into::into),\n            items!(year, monday_week, weekday) => Date::try_from_yo(\n                year,\n                (monday_week as i16 * 7 + weekday.number_days_from_monday() as i16\n                    - adjustment(year)\n                    + 1) as u16,\n            )\n            .map_err(Into::into),\n            _ => Err(error::Parse::InsufficientInformation),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_from_parsed_items::adjustment":["/// Get the value needed to adjust the ordinal day for Sunday and\n/// Monday-based week numbering.\nfn adjustment(year: i32) -> i16{\n            match internals::Date::from_yo_unchecked(year, 1).weekday() {\n                Weekday::Monday => 7,\n                Weekday::Tuesday => 1,\n                Weekday::Wednesday => 2,\n                Weekday::Thursday => 3,\n                Weekday::Friday => 4,\n                Weekday::Saturday => 5,\n                Weekday::Sunday => 6,\n            }\n        }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_from_ymd":["/// Attempt to create a `Date` from the year, month, and day.\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::try_from_ymd(2019, 1, 1).is_ok());\n/// assert!(Date::try_from_ymd(2019, 12, 31).is_ok());\n/// ```\n///\n/// Returns `None` if the date is not valid.\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::try_from_ymd(2019, 2, 29).is_err()); // 2019 isn't a leap year.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_ymd(\n        year: i32,\n        month: u8,\n        day: u8,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(month in 1 => 12);\n        ensure_value_in_range!(day conditionally in 1 => days_in_year_month(year, month));\n\n        Ok(internals::Date::from_ymd_unchecked(year, month, day))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_from_yo":["/// Attempt to create a `Date` from the year and ordinal day number.\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::try_from_yo(2019, 1).is_ok());\n/// assert!(Date::try_from_yo(2019, 365).is_ok());\n/// ```\n///\n/// Returns `None` if the date is not valid.\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::try_from_yo(2019, 366).is_err()); // 2019 isn't a leap year.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_yo(year: i32, ordinal: u16) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(ordinal conditionally in 1 => days_in_year(year));\n        Ok(internals::Date::from_yo_unchecked(year, ordinal))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_with_hms":["/// Attempt to create a `PrimitiveDateTime` using the existing date and the\n/// provided time.\n///\n/// ```rust\n/// # use time::date;\n/// assert!(date!(1970-01-01).try_with_hms(0, 0, 0).is_ok());\n/// assert!(date!(1970-01-01).try_with_hms(24, 0, 0).is_err());\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_with_hms(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms(hour, minute, second)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_with_hms_micro":["/// Attempt to create a `PrimitiveDateTime` using the existing date and the\n/// provided time.\n///\n/// ```rust\n/// # use time::date;\n/// assert!(date!(1970-01-01)\n///     .try_with_hms_micro(0, 0, 0, 0)\n///     .is_ok());\n/// assert!(date!(1970-01-01)\n///     .try_with_hms_micro(24, 0, 0, 0)\n///     .is_err());\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_with_hms_micro(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_micro(hour, minute, second, microsecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_with_hms_milli":["/// Attempt to create a `PrimitiveDateTime` using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::date;\n/// assert!(date!(1970-01-01).try_with_hms_milli(0, 0, 0, 0).is_ok());\n/// assert!(date!(1970-01-01).try_with_hms_milli(24, 0, 0, 0).is_err());\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_with_hms_milli(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_milli(hour, minute, second, millisecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::try_with_hms_nano":["/// Attempt to create a `PrimitiveDateTime` using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::date;\n/// assert!(date!(1970-01-01).try_with_hms_nano(0, 0, 0, 0).is_ok());\n/// assert!(date!(1970-01-01).try_with_hms_nano(24, 0, 0, 0).is_err());\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_with_hms_nano(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::try_from_hms_nano(hour, minute, second, nanosecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::week":["/// Get the ISO week number.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).week(), 1);\n/// assert_eq!(date!(2019-10-04).week(), 40);\n/// assert_eq!(date!(2020-01-01).week(), 1);\n/// assert_eq!(date!(2020-12-31).week(), 53);\n/// assert_eq!(date!(2021-01-01).week(), 53);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn week(self) -> u8{\n        self.iso_year_week().1\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::weekday":["/// Get the weekday.\n///\n/// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n/// internally.\n///\n/// ```rust\n/// # use time::{date, Weekday::*};\n/// assert_eq!(date!(2019-01-01).weekday(), Tuesday);\n/// assert_eq!(date!(2019-02-01).weekday(), Friday);\n/// assert_eq!(date!(2019-03-01).weekday(), Friday);\n/// assert_eq!(date!(2019-04-01).weekday(), Monday);\n/// assert_eq!(date!(2019-05-01).weekday(), Wednesday);\n/// assert_eq!(date!(2019-06-01).weekday(), Saturday);\n/// assert_eq!(date!(2019-07-01).weekday(), Monday);\n/// assert_eq!(date!(2019-08-01).weekday(), Thursday);\n/// assert_eq!(date!(2019-09-01).weekday(), Sunday);\n/// assert_eq!(date!(2019-10-01).weekday(), Tuesday);\n/// assert_eq!(date!(2019-11-01).weekday(), Friday);\n/// assert_eq!(date!(2019-12-01).weekday(), Sunday);\n/// ```\npub fn weekday(self) -> Weekday{\n        match self.number_days_from_monday() {\n            0 => Weekday::Monday,\n            1 => Weekday::Tuesday,\n            2 => Weekday::Wednesday,\n            3 => Weekday::Thursday,\n            4 => Weekday::Friday,\n            5 => Weekday::Saturday,\n            6 => Weekday::Sunday,\n            // FIXME The compiler isn't able to optimize this away. See\n            // rust-lang/rust#66993.\n            _ => unreachable!(\"A value mod 7 is always in the range 0..7\"),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_time":["/// Create a `PrimitiveDateTime` using the existing date and the provided `Time`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(\n///     date!(1970-01-01).with_time(time!(0:00)),\n///     date!(1970-01-01).midnight(),\n/// );\n/// ```\npub const fn with_time(self, time: Time) -> PrimitiveDateTime{\n        PrimitiveDateTime::new(self, time)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::year":["/// Get the year of the date.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).year(), 2019);\n/// assert_eq!(date!(2019-12-31).year(), 2019);\n/// assert_eq!(date!(2020-01-01).year(), 2020);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\n#[allow(clippy::missing_const_for_fn)]\npub const fn year(self) -> i32{\n        self.value >> 9\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::div_floor":["/// Floored division for integers. This differs from the default behavior, which\n/// is truncation.\npub(crate) const fn div_floor(a: i64, b: i64) -> i64{\n    let (quotient, remainder) = (a / b, a % b);\n\n    if (remainder > 0 && b < 0) || (remainder < 0 && b > 0) {\n        quotient - 1\n    } else {\n        quotient\n    }\n}","Real(LocalPath(\"src/date.rs\"))"],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["fn eq(&self, rhs: &Duration) -> bool{\n        rhs == self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["fn partial_cmp(&self, rhs: &Duration) -> Option<Ordering>{\n        rhs.partial_cmp(self).map(Ordering::reverse)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["fn try_from(duration: Duration) -> Result<Self, error::ConversionRange>{\n        Ok(Self::new(\n            duration\n                .seconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            duration\n                .nanoseconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["fn add(self, rhs: Duration) -> Self::Output{\n        rhs + self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["fn div(self, rhs: Duration) -> Self::Output{\n        self.as_secs_f64() / rhs.as_seconds_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n        rhs * self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n        rhs * self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["fn sub(self, rhs: Duration) -> Self::Output{\n        Duration::try_from(self)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n            - rhs\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["fn sub_assign(&mut self, rhs: Duration){\n        *self = (*self - rhs).try_into().expect(\n            \"Cannot represent a resulting duration in std. Try `let x = x - rhs;`, which will \\\n             change the type.\",\n        );\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration":["/// A span of time with nanosecond precision.\n///\n/// Each `Duration` is composed of a whole number of seconds and a fractional\n/// part represented in nanoseconds.\n///\n/// `Duration` implements many traits, including [`Add`], [`Sub`], [`Mul`], and\n/// [`Div`], among others.\n///\n/// This implementation allows for negative durations, unlike\n/// [`core::time::Duration`].\npub struct Duration {\n    /// Number of whole seconds.\n    seconds: i64,\n    /// Number of nanoseconds within the second. The sign always matches the\n    /// `seconds` field.\n    nanoseconds: i32, // always -10^9 < nanoseconds < 10^9\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::abs":["/// Get the absolute value of the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.seconds().abs(), 1.seconds());\n/// assert_eq!(0.seconds().abs(), 0.seconds());\n/// assert_eq!((-1).seconds().abs(), 1.seconds());\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.39.\npub const fn abs(self) -> Self{\n        Self {\n            seconds: self.seconds.abs(),\n            nanoseconds: self.nanoseconds.abs(),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::abs_std":["/// Convert the existing `Duration` to a `std::time::Duration` and its sign.\n#[allow(clippy::missing_const_for_fn)]\n#[cfg(feature = \"std\")]\npub(crate) fn abs_std(self) -> StdDuration{\n        StdDuration::new(self.seconds.abs() as u64, self.nanoseconds.abs() as u32)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::as_seconds_f32":["/// Get the number of fractional seconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.5.seconds().as_seconds_f32(), 1.5);\n/// assert_eq!((-1.5).seconds().as_seconds_f32(), -1.5);\n/// ```\npub fn as_seconds_f32(self) -> f32{\n        self.seconds as f32 + self.nanoseconds as f32 / 1_000_000_000.\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::as_seconds_f64":["/// Get the number of fractional seconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.5.seconds().as_seconds_f64(), 1.5);\n/// assert_eq!((-1.5).seconds().as_seconds_f64(), -1.5);\n/// ```\npub fn as_seconds_f64(self) -> f64{\n        self.seconds as f64 + self.nanoseconds as f64 / 1_000_000_000.\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_add":["/// Computes `self + rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(5.seconds().checked_add(5.seconds()), Some(10.seconds()));\n/// assert_eq!(Duration::max_value().checked_add(1.nanoseconds()), None);\n/// assert_eq!((-5).seconds().checked_add(5.seconds()), Some(0.seconds()));\n/// ```\npub fn checked_add(self, rhs: Self) -> Option<Self>{\n        let mut seconds = self.seconds.checked_add(rhs.seconds)?;\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = seconds.checked_add(1)?;\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = seconds.checked_sub(1)?;\n        }\n\n        // Ensure that the signs match _unless_ one of them is zero.\n        debug_assert_ne!(seconds.signum() * nanoseconds.signum() as i64, -1);\n        debug_assert!((-999_999_999..1_000_000_000).contains(&nanoseconds));\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_div":["/// Computes `self / rhs`, returning `None` if `rhs == 0`.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(10.seconds().checked_div(2), Some(5.seconds()));\n/// assert_eq!(10.seconds().checked_div(-2), Some((-5).seconds()));\n/// assert_eq!(1.seconds().checked_div(0), None);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn checked_div(self, rhs: i32) -> Option<Self>{\n        if rhs == 0 {\n            return None;\n        }\n\n        let seconds = self.seconds / (rhs as i64);\n        let carry = self.seconds - seconds * (rhs as i64);\n        let extra_nanos = carry * 1_000_000_000 / (rhs as i64);\n        let nanoseconds = self.nanoseconds / rhs + (extra_nanos as i32);\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_mul":["/// Computes `self * rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(5.seconds().checked_mul(2), Some(10.seconds()));\n/// assert_eq!(5.seconds().checked_mul(-2), Some((-10).seconds()));\n/// assert_eq!(5.seconds().checked_mul(0), Some(0.seconds()));\n/// assert_eq!(Duration::max_value().checked_mul(2), None);\n/// assert_eq!(Duration::min_value().checked_mul(2), None);\n/// ```\npub fn checked_mul(self, rhs: i32) -> Option<Self>{\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as i32;\n        let seconds = self\n            .seconds\n            .checked_mul(rhs as i64)?\n            .checked_add(extra_secs)?;\n\n        Some(Self {\n            seconds,\n            nanoseconds,\n        })\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_sub":["/// Computes `self - rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(5.seconds().checked_sub(5.seconds()), Some(Duration::zero()));\n/// assert_eq!(Duration::min_value().checked_sub(1.nanoseconds()), None);\n/// assert_eq!(5.seconds().checked_sub(10.seconds()), Some((-5).seconds()));\n/// ```\npub fn checked_sub(self, rhs: Self) -> Option<Self>{\n        self.checked_add(-rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::day":["/// Equivalent to `1.days()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::day(), 1.days());\n/// ```\npub const fn day() -> Self{\n        Self::days(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::days":["/// Create a new `Duration` with the given number of days. Equivalent to\n/// `Duration::seconds(days * 86_400)`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::days(1), 86_400.seconds());\n/// ```\npub const fn days(days: i64) -> Self{\n        Self::seconds(days * SECONDS_PER_DAY)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::from_std":["#[allow(deprecated)]\n#[deprecated(\n        since = \"0.2.0\",\n        note = \"Use `Duration::try_from(value)` or `value.try_into()`\"\n    )]\npub fn from_std(std: StdDuration) -> Result<Self, error::ConversionRange>{\n        std.try_into()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::hour":["/// Equivalent to `1.hours()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::hour(), 1.hours());\n/// ```\npub const fn hour() -> Self{\n        Self::hours(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::hours":["/// Create a new `Duration` with the given number of hours. Equivalent to\n/// `Duration::seconds(hours * 3_600)`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::hours(1), 3_600.seconds());\n/// ```\npub const fn hours(hours: i64) -> Self{\n        Self::seconds(hours * SECONDS_PER_HOUR)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_negative":["/// Check if a duration is negative.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert!((-1).seconds().is_negative());\n/// assert!(!0.seconds().is_negative());\n/// assert!(!1.seconds().is_negative());\n/// ```\npub const fn is_negative(self) -> bool{\n        (self.seconds < 0) | (self.nanoseconds < 0)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_positive":["/// Check if a duration is positive.\n///\n/// ```rust\n/// # use time::{prelude::*};\n/// assert!(1.seconds().is_positive());\n/// assert!(!0.seconds().is_positive());\n/// assert!(!(-1).seconds().is_positive());\n/// ```\npub const fn is_positive(self) -> bool{\n        (self.seconds > 0) | (self.nanoseconds > 0)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_zero":["/// Check if a duration is exactly zero.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert!(0.seconds().is_zero());\n/// assert!(!1.nanoseconds().is_zero());\n/// ```\npub const fn is_zero(self) -> bool{\n        (self.seconds == 0) & (self.nanoseconds == 0)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::max_value":["/// The maximum possible duration. Adding any positive duration to this will\n/// cause an overflow.\n///\n/// The value returned by this method may change at any time.\npub const fn max_value() -> Self{\n        Self::new(i64::max_value(), 999_999_999)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::microsecond":["/// Equivalent to `1.microseconds()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::microsecond(), 1.microseconds());\n/// ```\npub const fn microsecond() -> Self{\n        Self::microseconds(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::microseconds":["/// Create a new `Duration` with the given number of microseconds.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::microseconds(1), 1_000.nanoseconds());\n/// assert_eq!(Duration::microseconds(-1), (-1_000).nanoseconds());\n/// ```\npub const fn microseconds(microseconds: i64) -> Self{\n        Self {\n            seconds: microseconds / 1_000_000,\n            nanoseconds: ((microseconds % 1_000_000) * 1_000) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::millisecond":["/// Equivalent to `1.milliseconds()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::millisecond(), 1.milliseconds());\n/// ```\npub const fn millisecond() -> Self{\n        Self::milliseconds(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::milliseconds":["/// Create a new `Duration` with the given number of milliseconds.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::milliseconds(1), 1_000.microseconds());\n/// assert_eq!(Duration::milliseconds(-1), (-1_000).microseconds());\n/// ```\npub const fn milliseconds(milliseconds: i64) -> Self{\n        Self {\n            seconds: milliseconds / 1_000,\n            nanoseconds: ((milliseconds % 1_000) * 1_000_000) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::min_value":["/// The minimum possible duration. Adding any negative duration to this will\n/// cause an overflow.\n///\n/// The value returned by this method may change at any time.\npub const fn min_value() -> Self{\n        Self::new(i64::min_value(), -999_999_999)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::minute":["/// Equivalent to `1.minutes()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::minute(), 1.minutes());\n/// ```\npub const fn minute() -> Self{\n        Self::minutes(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::minutes":["/// Create a new `Duration` with the given number of minutes. Equivalent to\n/// `Duration::seconds(minutes * 60)`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::minutes(1), 60.seconds());\n/// ```\npub const fn minutes(minutes: i64) -> Self{\n        Self::seconds(minutes * SECONDS_PER_MINUTE)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::nanosecond":["/// Equivalent to `1.nanoseconds()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::nanosecond(), 1.nanoseconds());\n/// ```\npub const fn nanosecond() -> Self{\n        Self::nanoseconds(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::nanoseconds":["/// Create a new `Duration` with the given number of nanoseconds.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::nanoseconds(1), 1.microseconds() / 1_000);\n/// assert_eq!(Duration::nanoseconds(-1), (-1).microseconds() / 1_000);\n/// ```\npub const fn nanoseconds(nanoseconds: i64) -> Self{\n        Self {\n            seconds: nanoseconds / 1_000_000_000,\n            nanoseconds: (nanoseconds % 1_000_000_000) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::nanoseconds_i128":["/// Create a new `Duration` with the given number of nanoseconds.\n///\n/// As the input range cannot be fully mapped to the output, this should\n/// only be used where it's known to result in a valid value.\npub(crate) const fn nanoseconds_i128(nanoseconds: i128) -> Self{\n        Self {\n            seconds: (nanoseconds / 1_000_000_000) as i64,\n            nanoseconds: (nanoseconds % 1_000_000_000) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::new":["/// Create a new `Duration` with the provided seconds and nanoseconds. If\n/// nanoseconds is at least 10<sup>9</sup>, it will wrap to the number of\n/// seconds.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::new(1, 0), 1.seconds());\n/// assert_eq!(Duration::new(-1, 0), (-1).seconds());\n/// assert_eq!(Duration::new(1, 2_000_000_000), 3.seconds());\n/// ```\npub const fn new(seconds: i64, nanoseconds: i32) -> Self{\n        Self {\n            seconds: (seconds + nanoseconds as i64 / 1_000_000_000)\n                + (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                    - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                    == -1)\n                    & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                        - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                        == 1)) as i64\n                - (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                    - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                    == 1)\n                    & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                        - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                        == -1)) as i64,\n            nanoseconds: (nanoseconds % 1_000_000_000)\n                + 1_000_000_000\n                    * ((((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                        - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                        == 1)\n                        & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                            - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                            == -1)) as i32\n                        - (((((seconds + nanoseconds as i64 / 1_000_000_000) > 0) as i8\n                            - ((seconds + nanoseconds as i64 / 1_000_000_000) < 0) as i8)\n                            == -1)\n                            & ((((nanoseconds % 1_000_000_000) > 0) as i8\n                                - ((nanoseconds % 1_000_000_000) < 0) as i8)\n                                == 1)) as i32),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_days":["#[deprecated(since = \"0.2.0\", note = \"Use the `whole_days` function\")]\npub fn num_days(&self) -> i64{\n        self.whole_days()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_hours":["#[deprecated(since = \"0.2.0\", note = \"Use the `whole_hours` function\")]\npub fn num_hours(&self) -> i64{\n        self.whole_hours()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_microseconds":["/// [`Duration::whole_microseconds`] returns an `i128` rather than returning\n/// `None` on `i64` overflow.\n#[deprecated(since = \"0.2.0\", note = \"Use the `whole_microseconds` function\")]\npub fn num_microseconds(&self) -> Option<i64>{\n        let micros = self.whole_microseconds();\n\n        if micros.abs() > i64::max_value() as i128 {\n            None\n        } else {\n            Some(micros as i64)\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_milliseconds":["/// [`Duration::whole_milliseconds`] returns an `i128`, rather than\n/// panicking on overflow. To avoid panicking, this method currently limits\n/// the value to the range `i64::min_value()..=i64::max_value()`.\n#[deprecated(\n        since = \"0.2.0\",\n        note = \"Use the `whole_milliseconds` function. The value is clamped between \\\n                `i64::min_value()` and `i64::max_value()`.\"\n    )]\npub fn num_milliseconds(&self) -> i64{\n        let millis = self.whole_milliseconds();\n\n        if millis > i64::max_value() as i128 {\n            return i64::max_value();\n        }\n\n        if millis < i64::min_value() as i128 {\n            return i64::min_value();\n        }\n\n        millis as i64\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_minutes":["#[deprecated(since = \"0.2.0\", note = \"Use the `whole_minutes` function\")]\npub fn num_minutes(&self) -> i64{\n        self.whole_minutes()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_nanoseconds":["/// [`Duration::whole_nanoseconds`] returns an `i128` rather than returning\n/// `None` on `i64` overflow.\n#[deprecated(since = \"0.2.0\", note = \"Use the `whole_nanoseconds` function\")]\npub fn num_nanoseconds(&self) -> Option<i64>{\n        let nanos = self.whole_nanoseconds();\n\n        if nanos.abs() > i64::max_value() as i128 {\n            None\n        } else {\n            Some(nanos as i64)\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_seconds":["#[allow(clippy::missing_const_for_fn)]\n#[deprecated(since = \"0.2.0\", note = \"Use the `whole_seconds` function\")]\npub fn num_seconds(&self) -> i64{\n        self.whole_seconds()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::num_weeks":["#[deprecated(since = \"0.2.0\", note = \"Use the `whole_weeks` function\")]\npub fn num_weeks(&self) -> i64{\n        self.whole_weeks()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::second":["/// Equivalent to `1.seconds()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::second(), 1.seconds());\n/// ```\npub const fn second() -> Self{\n        Self::seconds(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds":["/// Create a new `Duration` with the given number of seconds.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::seconds(1), 1_000.milliseconds());\n/// ```\npub const fn seconds(seconds: i64) -> Self{\n        Self {\n            seconds,\n            nanoseconds: 0,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds_f32":["/// Creates a new `Duration` from the specified number of seconds\n/// represented as `f32`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::seconds_f32(0.5), 0.5.seconds());\n/// assert_eq!(Duration::seconds_f32(-0.5), (-0.5).seconds());\n/// ```\npub fn seconds_f32(seconds: f32) -> Self{\n        Self {\n            seconds: seconds as i64,\n            nanoseconds: ((seconds % 1.) * 1_000_000_000.) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds_f64":["/// Creates a new `Duration` from the specified number of seconds\n/// represented as `f64`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::seconds_f64(0.5), 0.5.seconds());\n/// assert_eq!(Duration::seconds_f64(-0.5), -0.5.seconds());\n/// ```\npub fn seconds_f64(seconds: f64) -> Self{\n        Self {\n            seconds: seconds as i64,\n            nanoseconds: ((seconds % 1.) * 1_000_000_000.) as i32,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::sign":["/// Get the sign of the duration.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{Sign, prelude::*};\n/// assert_eq!(1.seconds().sign(), Sign::Positive);\n/// assert_eq!((-1).seconds().sign(), Sign::Negative);\n/// assert_eq!(0.seconds().sign(), Sign::Zero);\n/// ```\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"To obtain the sign of a `Duration`, you should use the `is_positive`, \\\n                `is_negative`, and `is_zero` methods.\"\n    )]\n#[allow(deprecated, clippy::missing_const_for_fn)]\npub fn sign(self) -> crate::Sign{\n        use crate::Sign::*;\n\n        if self.nanoseconds > 0 {\n            Positive\n        } else if self.nanoseconds < 0 {\n            Negative\n        } else if self.seconds > 0 {\n            Positive\n        } else if self.seconds < 0 {\n            Negative\n        } else {\n            Zero\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::span":["#[cfg(feature = \"std\")]\n#[deprecated(since = \"0.2.0\", note = \"Use the `time_fn` function\")]\npub fn span<F: FnOnce()>(f: F) -> Self{\n        Self::time_fn(f).0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_microseconds":["/// Get the number of microseconds past the number of whole seconds.\n///\n/// Always in the range `-1_000_000..1_000_000`.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.0004.seconds().subsec_microseconds(), 400);\n/// assert_eq!((-1.0004).seconds().subsec_microseconds(), -400);\n/// ```\npub const fn subsec_microseconds(self) -> i32{\n        self.nanoseconds / 1_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_milliseconds":["/// Get the number of milliseconds past the number of whole seconds.\n///\n/// Always in the range `-1_000..1_000`.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.4.seconds().subsec_milliseconds(), 400);\n/// assert_eq!((-1.4).seconds().subsec_milliseconds(), -400);\n/// ```\npub const fn subsec_milliseconds(self) -> i16{\n        (self.nanoseconds / 1_000_000) as i16\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_nanoseconds":["/// Get the number of nanoseconds past the number of whole seconds.\n///\n/// The returned value will always be in the range\n/// `-1_000_000_000..1_000_000_000`.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.000_000_400.seconds().subsec_nanoseconds(), 400);\n/// assert_eq!((-1.000_000_400).seconds().subsec_nanoseconds(), -400);\n/// ```\npub const fn subsec_nanoseconds(self) -> i32{\n        self.nanoseconds\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::time_fn":["/// Runs a closure, returning the duration of time it took to run. The\n/// return value of the closure is provided in the second part of the tuple.\n#[cfg(feature = \"std\")]\npub fn time_fn<T>(f: impl FnOnce() -> T) -> (Self, T){\n        let start = Instant::now();\n        let return_value = f();\n        let end = Instant::now();\n\n        (end - start, return_value)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::to_std":["#[allow(deprecated)]\n#[deprecated(\n        since = \"0.2.0\",\n        note = \"Use `std::time::Duration::try_from(value)` or `value.try_into()`\"\n    )]\npub fn to_std(&self) -> Result<StdDuration, error::ConversionRange>{\n        (*self).try_into()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::week":["/// Equivalent to `1.weeks()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::week(), 1.weeks());\n/// ```\npub const fn week() -> Self{\n        Self::weeks(1)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::weeks":["/// Create a new `Duration` with the given number of weeks. Equivalent to\n/// `Duration::seconds(weeks * 604_800)`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::weeks(1), 604_800.seconds());\n/// ```\npub const fn weeks(weeks: i64) -> Self{\n        Self::seconds(weeks * SECONDS_PER_WEEK)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_days":["/// Get the number of whole days in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.days().whole_days(), 1);\n/// assert_eq!((-1).days().whole_days(), -1);\n/// assert_eq!(23.hours().whole_days(), 0);\n/// assert_eq!((-23).hours().whole_days(), 0);\n/// ```\npub const fn whole_days(self) -> i64{\n        self.whole_seconds() / SECONDS_PER_DAY\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_hours":["/// Get the number of whole hours in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.hours().whole_hours(), 1);\n/// assert_eq!((-1).hours().whole_hours(), -1);\n/// assert_eq!(59.minutes().whole_hours(), 0);\n/// assert_eq!((-59).minutes().whole_hours(), 0);\n/// ```\npub const fn whole_hours(self) -> i64{\n        self.whole_seconds() / SECONDS_PER_HOUR\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_microseconds":["/// Get the number of whole microseconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.milliseconds().whole_microseconds(), 1_000);\n/// assert_eq!((-1).milliseconds().whole_microseconds(), -1_000);\n/// assert_eq!(1.microseconds().whole_microseconds(), 1);\n/// assert_eq!((-1).microseconds().whole_microseconds(), -1);\n/// ```\npub const fn whole_microseconds(self) -> i128{\n        self.seconds as i128 * 1_000_000 + self.nanoseconds as i128 / 1_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_milliseconds":["/// Get the number of whole milliseconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.seconds().whole_milliseconds(), 1_000);\n/// assert_eq!((-1).seconds().whole_milliseconds(), -1_000);\n/// assert_eq!(1.milliseconds().whole_milliseconds(), 1);\n/// assert_eq!((-1).milliseconds().whole_milliseconds(), -1);\n/// ```\npub const fn whole_milliseconds(self) -> i128{\n        self.seconds as i128 * 1_000 + self.nanoseconds as i128 / 1_000_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_minutes":["/// Get the number of whole minutes in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.minutes().whole_minutes(), 1);\n/// assert_eq!((-1).minutes().whole_minutes(), -1);\n/// assert_eq!(59.seconds().whole_minutes(), 0);\n/// assert_eq!((-59).seconds().whole_minutes(), 0);\n/// ```\npub const fn whole_minutes(self) -> i64{\n        self.whole_seconds() / SECONDS_PER_MINUTE\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_nanoseconds":["/// Get the number of nanoseconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.microseconds().whole_nanoseconds(), 1_000);\n/// assert_eq!((-1).microseconds().whole_nanoseconds(), -1_000);\n/// assert_eq!(1.nanoseconds().whole_nanoseconds(), 1);\n/// assert_eq!((-1).nanoseconds().whole_nanoseconds(), -1);\n/// ```\npub const fn whole_nanoseconds(self) -> i128{\n        self.seconds as i128 * 1_000_000_000 + self.nanoseconds as i128\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_seconds":["/// Get the number of whole seconds in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.seconds().whole_seconds(), 1);\n/// assert_eq!((-1).seconds().whole_seconds(), -1);\n/// assert_eq!(1.minutes().whole_seconds(), 60);\n/// assert_eq!((-1).minutes().whole_seconds(), -60);\n/// ```\npub const fn whole_seconds(self) -> i64{\n        self.seconds\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_weeks":["/// Get the number of whole weeks in the duration.\n///\n/// ```rust\n/// # use time::prelude::*;\n/// assert_eq!(1.weeks().whole_weeks(), 1);\n/// assert_eq!((-1).weeks().whole_weeks(), -1);\n/// assert_eq!(6.days().whole_weeks(), 0);\n/// assert_eq!((-6).days().whole_weeks(), 0);\n/// ```\npub const fn whole_weeks(self) -> i64{\n        self.whole_seconds() / SECONDS_PER_WEEK\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::zero":["/// Equivalent to `0.seconds()`.\n///\n/// ```rust\n/// # use time::{Duration, prelude::*};\n/// assert_eq!(Duration::zero(), 0.seconds());\n/// ```\npub const fn zero() -> Self{\n        Self::seconds(0)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"error::ComponentRange":["/// An error type indicating that a component provided to a method was out of\n/// range, causing a failure.\nnon_exhaustive\npub struct ComponentRange {\n    /// Name of the component.\n    pub name: &'static str,\n    /// Minimum allowed value, inclusive.\n    pub minimum: i64,\n    /// Maximum allowed value, inclusive.\n    pub maximum: i64,\n    /// Value that was provided.\n    pub value: i64,\n    /// The minimum and/or maximum value is conditional on the value of other\n    /// parameters.\n    pub conditional_range: bool,\n    #[cfg(not(__time_02_supports_non_exhaustive))]\n    #[doc(hidden)]\n    pub(crate) __non_exhaustive: (),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ConversionRange":["/// An error type indicating that a conversion failed because the target type\n/// could not store the initial value.\npub struct ConversionRange;","Real(LocalPath(\"src/error.rs\"))"],"error::Error":["/// A unified error type for anything returned by a method in the time crate.\n///\n/// This can be used when you either don't know or don't care about the exact\n/// error returned. `Result<_, time::Error>` will work in these situations.\n#[allow(clippy::missing_docs_in_private_items)]\nnon_exhaustive\npub enum Error {\n    ConversionRange(ConversionRange),\n    ComponentRange(Box<ComponentRange>),\n    Parse(Parse),\n    IndeterminateOffset(IndeterminateOffset),\n    Format(Format),\n    #[cfg(not(__time_02_supports_non_exhaustive))]\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Format":["/// An error occurred while formatting.\npub enum Format {\n    /// The format provided requires more information than the type provides.\n    InsufficientTypeInformation,\n    /// An error occurred while formatting into the provided stream.\n    StdFmtError,\n    #[cfg(not(__time_02_supports_non_exhaustive))]\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::IndeterminateOffset":["/// The system's UTC offset could not be determined at the given datetime.\npub struct IndeterminateOffset;","Real(LocalPath(\"src/error.rs\"))"],"ext::NumericalDuration":["/// Create `Duration`s from primitive and core numeric types.\n///\n/// This trait can be imported with `use time::prelude::*`.\n///\n/// Due to limitations in rustc, these methods are currently _not_ `const fn`.\n/// See [RFC 2632](https://github.com/rust-lang/rfcs/pull/2632) for details.\n///\n/// # Examples\n///\n/// Basic construction of `Duration`s.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.nanoseconds(), Duration::nanoseconds(5));\n/// assert_eq!(5.microseconds(), Duration::microseconds(5));\n/// assert_eq!(5.milliseconds(), Duration::milliseconds(5));\n/// assert_eq!(5.seconds(), Duration::seconds(5));\n/// assert_eq!(5.minutes(), Duration::minutes(5));\n/// assert_eq!(5.hours(), Duration::hours(5));\n/// assert_eq!(5.days(), Duration::days(5));\n/// assert_eq!(5.weeks(), Duration::weeks(5));\n/// ```\n///\n/// Signed integers work as well!\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!((-5).nanoseconds(), Duration::nanoseconds(-5));\n/// assert_eq!((-5).microseconds(), Duration::microseconds(-5));\n/// assert_eq!((-5).milliseconds(), Duration::milliseconds(-5));\n/// assert_eq!((-5).seconds(), Duration::seconds(-5));\n/// assert_eq!((-5).minutes(), Duration::minutes(-5));\n/// assert_eq!((-5).hours(), Duration::hours(-5));\n/// assert_eq!((-5).days(), Duration::days(-5));\n/// assert_eq!((-5).weeks(), Duration::weeks(-5));\n/// ```\n///\n/// Just like any other `Duration`, they can be added, subtracted, etc.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(2.seconds() + 500.milliseconds(), 2_500.milliseconds());\n/// assert_eq!(2.seconds() - 500.milliseconds(), 1_500.milliseconds());\n/// ```\n///\n/// When called on floating point values, any remainder of the floating point\n/// value will be truncated. Keep in mind that floating point numbers are\n/// inherently imprecise and have limited capacity.\npub trait NumericalDuration {\n    /// Create a `Duration` from the number of nanoseconds.\n    fn nanoseconds(self) -> Duration;\n    /// Create a `Duration` from the number of microseconds.\n    fn microseconds(self) -> Duration;\n    /// Create a `Duration` from the number of milliseconds.\n    fn milliseconds(self) -> Duration;\n    /// Create a `Duration` from the number of seconds.\n    fn seconds(self) -> Duration;\n    /// Create a `Duration` from the number of minutes.\n    fn minutes(self) -> Duration;\n    /// Create a `Duration` from the number of hours.\n    fn hours(self) -> Duration;\n    /// Create a `Duration` from the number of days.\n    fn days(self) -> Duration;\n    /// Create a `Duration` from the number of weeks.\n    fn weeks(self) -> Duration;\n}","Real(LocalPath(\"src/ext.rs\"))"],"ext::NumericalStdDuration":["/// Create `std::time::Duration`s from primitive and core numeric types.\n///\n/// This trait can be imported (alongside others) with `use time::prelude::*`.\n///\n/// Due to limitations in rustc, these methods are currently _not_ `const fn`.\n/// See [RFC 2632](https://github.com/rust-lang/rfcs/pull/2632) for details.\n///\n/// # Examples\n///\n/// Basic construction of `std::time::Duration`s.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDuration;\n/// # use core::time::Duration;\n/// assert_eq!(5.std_nanoseconds(), Duration::from_nanos(5));\n/// assert_eq!(5.std_microseconds(), Duration::from_micros(5));\n/// assert_eq!(5.std_milliseconds(), Duration::from_millis(5));\n/// assert_eq!(5.std_seconds(), Duration::from_secs(5));\n/// assert_eq!(5.std_minutes(), Duration::from_secs(5 * 60));\n/// assert_eq!(5.std_hours(), Duration::from_secs(5 * 3_600));\n/// assert_eq!(5.std_days(), Duration::from_secs(5 * 86_400));\n/// assert_eq!(5.std_weeks(), Duration::from_secs(5 * 604_800));\n/// ```\n///\n/// Just like any other `std::time::Duration`, they can be added, subtracted,\n/// etc.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDuration;\n/// assert_eq!(\n///     2.std_seconds() + 500.std_milliseconds(),\n///     2_500.std_milliseconds()\n/// );\n/// assert_eq!(\n///     2.std_seconds() - 500.std_milliseconds(),\n///     1_500.std_milliseconds()\n/// );\n/// ```\n///\n/// When called on floating point values, any remainder of the floating point\n/// value will be truncated. Keep in mind that floating point numbers are\n/// inherently imprecise and have limited capacity.\npub trait NumericalStdDuration {\n    /// Create a `std::time::Duration` from the number of nanoseconds.\n    fn std_nanoseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of microseconds.\n    fn std_microseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of milliseconds.\n    fn std_milliseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of seconds.\n    fn std_seconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of minutes.\n    fn std_minutes(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of hours.\n    fn std_hours(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of days.\n    fn std_days(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of weeks.\n    fn std_weeks(self) -> StdDuration;\n}","Real(LocalPath(\"src/ext.rs\"))"],"ext::NumericalStdDurationShort":["/// Create `std::time::Duration`s from primitive and core numeric types. Unless\n/// you are always expecting a `std::time::Duration`, you should prefer to use\n/// [`NumericalStdDuration`] for clarity.\n///\n/// Due to limitations in rustc, these methods are currently _not_ `const fn`.\n/// See [this RFC](https://github.com/rust-lang/rfcs/pull/2632) for details.\n///\n/// # Examples\n///\n/// Basic construction of `std::time::Duration`s.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDurationShort;\n/// # use core::time::Duration;\n/// assert_eq!(5.nanoseconds(), Duration::from_nanos(5));\n/// assert_eq!(5.microseconds(), Duration::from_micros(5));\n/// assert_eq!(5.milliseconds(), Duration::from_millis(5));\n/// assert_eq!(5.seconds(), Duration::from_secs(5));\n/// assert_eq!(5.minutes(), Duration::from_secs(5 * 60));\n/// assert_eq!(5.hours(), Duration::from_secs(5 * 3_600));\n/// assert_eq!(5.days(), Duration::from_secs(5 * 86_400));\n/// assert_eq!(5.weeks(), Duration::from_secs(5 * 604_800));\n/// ```\n///\n/// Just like any other `std::time::Duration`, they can be added, subtracted,\n/// etc.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDurationShort;\n/// assert_eq!(2.seconds() + 500.milliseconds(), 2_500.milliseconds());\n/// assert_eq!(2.seconds() - 500.milliseconds(), 1_500.milliseconds());\n/// ```\n///\n/// When called on floating point values, any remainder of the floating point\n/// value will be truncated. Keep in mind that floating point numbers are\n/// inherently imprecise and have limited capacity.\npub trait NumericalStdDurationShort {\n    /// Create a `std::time::Duration` from the number of nanoseconds.\n    fn nanoseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of microseconds.\n    fn microseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of milliseconds.\n    fn milliseconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of seconds.\n    fn seconds(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of minutes.\n    fn minutes(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of hours.\n    fn hours(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of days.\n    fn days(self) -> StdDuration;\n    /// Create a `std::time::Duration` from the number of weeks.\n    fn weeks(self) -> StdDuration;\n}","Real(LocalPath(\"src/ext.rs\"))"],"format::FormatItem":["/// An enum that can store both literals and specifiers.\n#[allow(variant_size_differences, single_use_lifetimes)]\npub(crate) enum FormatItem<'a> {\n    /// A value that should be printed as-is.\n    Literal(&'a str),\n    /// A value that needs to be interpreted when formatting.\n    Specifier(Specifier),\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Padding":["/// The type of padding to use when formatting.\npub(crate) enum Padding {\n    /// No padding. Minimizes width.\n    None,\n    /// Pad to the requisite width using spaces.\n    Space,\n    /// Pad to the requisite width using zeros.\n    Zero,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Specifier":["/// Specifiers are similar to C's `strftime`, with some omissions and changes.\n///\n/// See the table in `lib.rs` for a description of each specifier (and\n/// equivalences for combination specifiers).\n#[allow(\n    non_snake_case,\n    non_camel_case_types,\n    clippy::missing_docs_in_private_items\n)]\npub(crate) enum Specifier {\n    a,\n    A,\n    b,\n    B,\n    c,\n    C { padding: Padding },\n    d { padding: Padding },\n    D,\n    F,\n    g { padding: Padding },\n    G { padding: Padding },\n    H { padding: Padding },\n    I { padding: Padding },\n    j { padding: Padding },\n    m { padding: Padding },\n    M { padding: Padding },\n    N,\n    p,\n    P,\n    r,\n    R,\n    S { padding: Padding },\n    T,\n    u,\n    U { padding: Padding },\n    V { padding: Padding },\n    w,\n    W { padding: Padding },\n    y { padding: Padding },\n    Y { padding: Padding },\n    z,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::date::fmt_A":["/// Day of the week\npub(crate) fn fmt_A(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    f.write_str(WEEKDAYS_FULL[date.weekday().number_days_from_monday() as usize])\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_B":["/// Month name\npub(crate) fn fmt_B(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    f.write_str(MONTHS_FULL[date.month() as usize - 1])\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_C":["/// Year divided by 100 and truncated to integer (`00`-`999`)\npub(crate) fn fmt_C(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.year() / 100)\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_G":["/// Week-based year\npub(crate) fn fmt_G(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    let year = date.iso_year_week().0;\n\n    if year >= 10_000 {\n        f.write_str(\"+\")?;\n    }\n\n    pad!(f, padding, 4, year)\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_U":["/// Sunday-based week number (`00`-`53`)\npub(crate) fn fmt_U(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.sunday_based_week())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_V":["/// ISO week number, zero-padded (`01`-`53`)\npub(crate) fn fmt_V(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.week())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_W":["/// Monday-based week number (`00`-`53`)\npub(crate) fn fmt_W(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.monday_based_week())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_Y":["/// Full year\npub(crate) fn fmt_Y(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    let year = date.year();\n\n    if year >= 10_000 {\n        f.write_str(\"+\")?;\n    }\n\n    pad!(f, padding, 4, year)\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_a":["/// Short day of the week\npub(crate) fn fmt_a(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    f.write_str(WEEKDAYS_ABBR[date.weekday().number_days_from_monday() as usize])\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_b":["/// Short month name\npub(crate) fn fmt_b(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    f.write_str(MONTHS_ABBR[date.month() as usize - 1])\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_d":["/// Day of the month, zero-padded (`01`-`31`)\npub(crate) fn fmt_d(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.day())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_g":["/// Week-based year, last two digits (`00`-`99`)\npub(crate) fn fmt_g(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.iso_year_week().0.rem_euclid(100))\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_j":["/// Day of the year, zero-padded to width 3 (`001`-`366`)\npub(crate) fn fmt_j(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 3, date.ordinal())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_m":["/// Month of the year, zero-padded (`01`-`12`)\npub(crate) fn fmt_m(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.month())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_u":["/// ISO weekday (Monday = `1`, Sunday = `7`)\npub(crate) fn fmt_u(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    write!(f, \"{}\", date.weekday().iso_weekday_number())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_w":["/// Weekday number (Sunday = `0`, Saturday = `6`)\npub(crate) fn fmt_w(f: &mut Formatter<'_>, date: Date) -> fmt::Result{\n    write!(f, \"{}\", date.weekday().number_days_from_sunday())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::fmt_y":["/// Last two digits of year (`00`-`99`)\npub(crate) fn fmt_y(f: &mut Formatter<'_>, date: Date, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, date.year().rem_euclid(100))\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_A":["/// Day of the week\npub(crate) fn parse_A(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.weekday = Some(\n        try_consume_first_match(s, WEEKDAYS_FULL.iter().zip(WEEKDAYS.iter().cloned()))\n            .ok_or(error::Parse::InvalidDayOfWeek)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_B":["/// Month name\npub(crate) fn parse_B(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.month = Some(\n        try_consume_first_match(s, MONTHS_FULL.iter().cloned().zip(1..))\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidMonth)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_C":["/// Year divided by 100 and truncated to integer (`00`-`999`)\npub(crate) fn parse_C(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    let padding_length = consume_padding(s, padding, 1);\n    items.year = Some(\n        try_consume_digits::<i32>(s, 2 - padding_length, 3 - padding_length)\n            .ok_or(error::Parse::InvalidYear)?\n            * 100\n            + items.year.unwrap_or(0).rem_euclid(100),\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_G":["/// Week-based year\npub(crate) fn parse_G(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    let sign = try_consume_first_match(s, [(\"+\", 1), (\"-\", -1)].iter().cloned()).unwrap_or(1);\n\n    consume_padding(s, padding, 4);\n\n    items.week_based_year = Some(\n        try_consume_digits(s, 1, 6)\n            .map(|v: i32| sign * v)\n            .ok_or(error::Parse::InvalidYear)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_U":["/// Sunday-based week number (`00`-`53`)\npub(crate) fn parse_U(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.sunday_week =\n        Some(try_consume_exact_digits(s, 2, padding).ok_or(error::Parse::InvalidWeek)?);\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_V":["/// ISO week number, zero-padded (`01`-`53`)\npub(crate) fn parse_V(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.iso_week = Some(\n        try_consume_exact_digits(s, 2, padding)\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidWeek)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_W":["/// Monday-based week number (`00`-`53`)\npub(crate) fn parse_W(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.monday_week =\n        Some(try_consume_exact_digits(s, 2, padding).ok_or(error::Parse::InvalidWeek)?);\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_Y":["/// Full year\npub(crate) fn parse_Y(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    let (sign, max_digits) =\n        try_consume_first_match(s, [(\"+\", (1, 6)), (\"-\", (-1, 6))].iter().cloned())\n            .unwrap_or((1, 4));\n\n    consume_padding(s, padding, 3);\n\n    items.year = Some(\n        try_consume_digits(s, 1, max_digits)\n            .map(|v: i32| sign * v)\n            .ok_or(error::Parse::InvalidYear)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_a":["/// Short day of the week\npub(crate) fn parse_a(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.weekday = Some(\n        try_consume_first_match(s, WEEKDAYS_ABBR.iter().zip(WEEKDAYS.iter().cloned()))\n            .ok_or(error::Parse::InvalidDayOfWeek)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_b":["/// Short month name\npub(crate) fn parse_b(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.month = Some(\n        try_consume_first_match(s, MONTHS_ABBR.iter().cloned().zip(1..))\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidMonth)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_d":["/// Day of the month, zero-padded (`01`-`31`)\npub(crate) fn parse_d(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.day = Some(\n        try_consume_exact_digits(s, 2, padding)\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidDayOfMonth)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_g":["/// Week-based year, last two digits (`00`-`99`)\npub(crate) fn parse_g(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.week_based_year = Some(\n        items.week_based_year.unwrap_or(0) / 100 * 100\n            + try_consume_exact_digits::<i32>(s, 2, padding).ok_or(error::Parse::InvalidYear)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_j":["/// Day of the year, zero-padded to width 3 (`001`-`366`)\npub(crate) fn parse_j(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.ordinal_day = Some(\n        try_consume_exact_digits(s, 3, padding)\n            .and_then(NonZeroU16::new)\n            .ok_or(error::Parse::InvalidDayOfYear)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_m":["/// Month of the year, zero-padded (`01`-`12`)\npub(crate) fn parse_m(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.month = Some(\n        try_consume_exact_digits(s, 2, padding)\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidMonth)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_u":["/// ISO weekday (Monday = `1`, Sunday = `7`)\npub(crate) fn parse_u(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.weekday = Some(\n        try_consume_first_match(\n            s,\n            (1..).map(|d| d.to_string()).zip(WEEKDAYS.iter().cloned()),\n        )\n        .ok_or(error::Parse::InvalidDayOfWeek)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_w":["/// Weekday number (Sunday = `0`, Saturday = `6`)\npub(crate) fn parse_w(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    let mut weekdays = WEEKDAYS;\n    weekdays.rotate_left(1);\n\n    items.weekday = Some(\n        try_consume_first_match(\n            s,\n            (0..)\n                .map(|d: u8| d.to_string())\n                .zip(weekdays.iter().cloned()),\n        )\n        .ok_or(error::Parse::InvalidDayOfWeek)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::date::parse_y":["/// Last two digits of year (`00`-`99`)\npub(crate) fn parse_y(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.year = Some(\n        items.year.unwrap_or(0) / 100 * 100\n            + try_consume_exact_digits::<i32>(s, 2, padding).ok_or(error::Parse::InvalidYear)?,\n    );\n\n    Ok(())\n}","Real(LocalPath(\"src/format/date.rs\"))"],"format::deferred_format::DeferredFormat":["/// A struct containing all the necessary information to display the inner type.\npub(crate) struct DeferredFormat {\n    /// The `Date` to use for formatting.\n    date: Option<Date>,\n    /// The `Time` to use for formatting.\n    time: Option<Time>,\n    /// The `UtcOffset` to use for formatting.\n    offset: Option<UtcOffset>,\n    /// The list of items used to display the item.\n    format: Format,\n}","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::date":["/// Obtain the `Date` component.\npub(crate) const fn date(&self) -> Option<Date>{\n        self.date\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::new":["/// Create a new `DeferredFormat` with the provided formatting string.\npub(crate) fn new(format: impl Into<Format>) -> Self{\n        Self {\n            date: None,\n            time: None,\n            offset: None,\n            format: format.into(),\n        }\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::offset":["/// Obtain the `UtcOffset` component.\npub(crate) const fn offset(&self) -> Option<UtcOffset>{\n        self.offset\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::time":["/// Obtain the `Time` component.\npub(crate) const fn time(&self) -> Option<Time>{\n        self.time\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::with_date":["/// Provide the `Date` component.\npub(crate) fn with_date(&mut self, date: Date) -> &mut Self{\n        self.date = Some(date);\n        self\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::with_offset":["/// Provide the `UtcOffset` component.\npub(crate) fn with_offset(&mut self, offset: UtcOffset) -> &mut Self{\n        self.offset = Some(offset);\n        self\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::deferred_format::DeferredFormat::with_time":["/// Provide the `Time` component.\npub(crate) fn with_time(&mut self, time: Time) -> &mut Self{\n        self.time = Some(time);\n        self\n    }","Real(LocalPath(\"src/format/deferred_format.rs\"))"],"format::format::Format":["/// Various well-known formats, along with the possibility for a custom format\n/// (provided either at compile-time or runtime).\n#[allow(clippy::missing_docs_in_private_items)]\nnon_exhaustive\npub enum Format {\n    #[cfg_attr(__time_02_docs, doc(alias = \"ISO8601\"))]\n    Rfc3339,\n    Custom(String),\n    #[cfg(not(__time_02_supports_non_exhaustive))]\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/format/format.rs\"))"],"format::format_specifier":["/// Given all the information necessary, write the provided specifier to the\n/// formatter.\nfn format_specifier(\n    f: &mut Formatter<'_>,\n    date: Option<Date>,\n    time: Option<Time>,\n    offset: Option<UtcOffset>,\n    specifier: Specifier,\n) -> Result<(), error::Format>{\n    /// Push the provided specifier to the list of items.\n    macro_rules! specifier {\n        ($type:ident :: $specifier_fn:ident ( $specifier:ident $(, $param:expr)? )) => {\n            $type::$specifier_fn(\n                f,\n                match $type {\n                    Some(v) => v,\n                    None => return Err(error::Format::InsufficientTypeInformation),\n                },\n                $($param)?\n            )?\n        };\n    }\n\n    macro_rules! literal {\n        ($string:literal) => {\n            f.write_str($string)?\n        };\n    }\n\n    use Specifier::*;\n    match specifier {\n        a => specifier!(date::fmt_a(a)),\n        A => specifier!(date::fmt_A(A)),\n        b => specifier!(date::fmt_b(b)),\n        B => specifier!(date::fmt_B(B)),\n        c => {\n            specifier!(date::fmt_a(a));\n            literal!(\" \");\n            specifier!(date::fmt_b(b));\n            literal!(\" \");\n            specifier!(date::fmt_d(d, Padding::None));\n            literal!(\" \");\n            specifier!(time::fmt_H(H, Padding::None));\n            literal!(\":\");\n            specifier!(time::fmt_M(M, Padding::Zero));\n            literal!(\":\");\n            specifier!(time::fmt_S(S, Padding::Zero));\n            literal!(\" \");\n            specifier!(date::fmt_Y(Y, Padding::None));\n        }\n        C { padding } => specifier!(date::fmt_C(C, padding)),\n        d { padding } => specifier!(date::fmt_d(d, padding)),\n        D => {\n            specifier!(date::fmt_m(m, Padding::None));\n            literal!(\"/\");\n            specifier!(date::fmt_d(d, Padding::Zero));\n            literal!(\"/\");\n            specifier!(date::fmt_y(y, Padding::Zero));\n        }\n        F => {\n            specifier!(date::fmt_Y(Y, Padding::None));\n            literal!(\"-\");\n            specifier!(date::fmt_m(m, Padding::Zero));\n            literal!(\"-\");\n            specifier!(date::fmt_d(d, Padding::Zero));\n        }\n        g { padding } => specifier!(date::fmt_g(g, padding)),\n        G { padding } => specifier!(date::fmt_G(G, padding)),\n        H { padding } => specifier!(time::fmt_H(H, padding)),\n        I { padding } => specifier!(time::fmt_I(I, padding)),\n        j { padding } => specifier!(date::fmt_j(j, padding)),\n        m { padding } => specifier!(date::fmt_m(m, padding)),\n        M { padding } => specifier!(time::fmt_M(M, padding)),\n        N => specifier!(time::fmt_N(N)),\n        p => specifier!(time::fmt_p(p)),\n        P => specifier!(time::fmt_P(P)),\n        r => {\n            specifier!(time::fmt_I(I, Padding::None));\n            literal!(\":\");\n            specifier!(time::fmt_M(M, Padding::Zero));\n            literal!(\":\");\n            specifier!(time::fmt_S(S, Padding::Zero));\n            literal!(\" \");\n            specifier!(time::fmt_p(p));\n        }\n        R => {\n            specifier!(time::fmt_H(H, Padding::None));\n            literal!(\":\");\n            specifier!(time::fmt_M(M, Padding::Zero));\n        }\n        S { padding } => specifier!(time::fmt_S(S, padding)),\n        T => {\n            specifier!(time::fmt_H(H, Padding::None));\n            literal!(\":\");\n            specifier!(time::fmt_M(M, Padding::Zero));\n            literal!(\":\");\n            specifier!(time::fmt_S(S, Padding::Zero));\n        }\n        u => specifier!(date::fmt_u(u)),\n        U { padding } => specifier!(date::fmt_U(U, padding)),\n        V { padding } => specifier!(date::fmt_V(V, padding)),\n        w => specifier!(date::fmt_w(w)),\n        W { padding } => specifier!(date::fmt_W(W, padding)),\n        y { padding } => specifier!(date::fmt_y(y, padding)),\n        Y { padding } => specifier!(date::fmt_Y(Y, padding)),\n        z => specifier!(offset::fmt_z(z)),\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::offset::fmt_z":["/// UTC offset\npub(crate) fn fmt_z(f: &mut Formatter<'_>, offset: UtcOffset) -> fmt::Result{\n    let offset = offset.as_duration();\n\n    write!(\n        f,\n        \"{}{:02}{:02}\",\n        if offset.is_negative() { '-' } else { '+' },\n        offset.whole_hours().abs(),\n        (offset.whole_minutes() - 60 * offset.whole_hours()).abs()\n    )\n}","Real(LocalPath(\"src/format/offset.rs\"))"],"format::offset::parse_z":["/// UTC offset\npub(crate) fn parse_z(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    let sign = try_consume_first_match(s, [(\"+\", 1), (\"-\", -1)].iter().cloned())\n        .ok_or(error::Parse::InvalidOffset)?;\n\n    let hours: i16 =\n        try_consume_exact_digits(s, 2, Padding::Zero).ok_or(error::Parse::InvalidOffset)?;\n\n    let minutes: i16 =\n        try_consume_exact_digits(s, 2, Padding::Zero).ok_or(error::Parse::InvalidOffset)?;\n\n    items.offset = UtcOffset::minutes(sign * (hours * 60 + minutes)).into();\n    Ok(())\n}","Real(LocalPath(\"src/format/offset.rs\"))"],"format::parse::AmPm":["/// A value representing a time that is either \"AM\" or \"PM\".\npub(crate) enum AmPm {\n    /// A time before noon.\n    AM,\n    /// A time at or after noon.\n    PM,\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::Error":["/// An error occurred while parsing.\nnon_exhaustive\npub enum Error {\n    /// The nanosecond present was not valid.\n    InvalidNanosecond,\n    /// The second present was not valid.\n    InvalidSecond,\n    /// The minute present was not valid.\n    InvalidMinute,\n    /// The hour present was not valid.\n    InvalidHour,\n    /// The AM/PM was not valid.\n    InvalidAmPm,\n    /// The month present was not valid.\n    InvalidMonth,\n    /// The year present was not valid.\n    InvalidYear,\n    /// The week present was not valid.\n    InvalidWeek,\n    /// The day of week present was not valid.\n    InvalidDayOfWeek,\n    /// The day of month present was not valid.\n    InvalidDayOfMonth,\n    /// The day of year present was not valid.\n    InvalidDayOfYear,\n    /// The UTC offset present was not valid.\n    InvalidOffset,\n    /// There was no character following a `%`.\n    MissingFormatSpecifier,\n    /// The character following `%` is not valid.\n    InvalidFormatSpecifier(char),\n    /// A character literal was expected to be present but was not.\n    UnexpectedCharacter {\n        /// The character that was expected to be present.\n        expected: char,\n        /// The character that was present in the string.\n        actual: char,\n    },\n    /// The string ended, but there should be more content.\n    UnexpectedEndOfString,\n    /// There was not enough information provided to create the requested type.\n    InsufficientInformation,\n    /// A component was out of range.\n    ComponentOutOfRange(Box<error::ComponentRange>),\n    #[cfg(not(__time_02_supports_non_exhaustive))]\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::ParsedItems":["/// All information gathered from parsing a provided string.\npub(crate) struct ParsedItems {\n    /// Year the ISO week belongs to.\n    pub(crate) week_based_year: Option<i32>,\n    /// The year the month, day, and ordinal day belong to.\n    pub(crate) year: Option<i32>,\n    /// One-indexed month number.\n    pub(crate) month: Option<NonZeroU8>,\n    /// Day of the month.\n    pub(crate) day: Option<NonZeroU8>,\n    /// Day of the week.\n    pub(crate) weekday: Option<Weekday>,\n    /// Day of the year.\n    pub(crate) ordinal_day: Option<NonZeroU16>,\n    /// ISO week within the year. Week 1 contains the year's first Thursday.\n    pub(crate) iso_week: Option<NonZeroU8>,\n    /// Week number, counted from the first Sunday. May be zero.\n    pub(crate) sunday_week: Option<u8>,\n    /// Week number, counted from the first Monday. May be zero.\n    pub(crate) monday_week: Option<u8>,\n    /// Hour in the 12-hour clock.\n    pub(crate) hour_12: Option<NonZeroU8>,\n    /// Hour in the 24-hour clock.\n    pub(crate) hour_24: Option<u8>,\n    /// Minute within the hour.\n    pub(crate) minute: Option<u8>,\n    /// Second within the minute.\n    pub(crate) second: Option<u8>,\n    /// Nanosecond within the second.\n    pub(crate) nanosecond: Option<u32>,\n    /// The UTC offset of the datetime.\n    pub(crate) offset: Option<UtcOffset>,\n    /// Whether the hour indicated is AM or PM.\n    pub(crate) am_pm: Option<AmPm>,\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::ParsedItems::new":["/// Create a new `ParsedItems` with nothing known.\npub(crate) const fn new() -> Self{\n        Self {\n            week_based_year: None,\n            year: None,\n            month: None,\n            day: None,\n            weekday: None,\n            ordinal_day: None,\n            iso_week: None,\n            sunday_week: None,\n            monday_week: None,\n            hour_12: None,\n            hour_24: None,\n            minute: None,\n            second: None,\n            nanosecond: None,\n            offset: None,\n            am_pm: None,\n        }\n    }","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::consume_padding":["/// Consume all leading padding up to the number of characters.\n///\n/// Returns the number of characters trimmed.\npub(crate) fn consume_padding(s: &mut &str, padding: Padding, max_chars: usize) -> usize{\n    let pad_char = match padding {\n        Padding::Space => ' ',\n        Padding::Zero => '0',\n        Padding::None => return 0,\n    };\n\n    let pad_width = s\n        .chars()\n        .take(max_chars)\n        .take_while(|&c| c == pad_char)\n        .count();\n    *s = &s[pad_width..];\n    pad_width\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse":["/// Attempt to parse the string with the provided format, returning a struct\n/// containing all information found.\n#[allow(clippy::too_many_lines)]\npub(crate) fn parse(s: &str, format: &Format) -> ParseResult<ParsedItems>{\n    use super::{date, offset, time};\n\n    // Make a copy of the provided string, letting us mutate as necessary.\n    let mut s = <&str>::clone(&s);\n\n    let mut items = ParsedItems::new();\n\n    /// Parse the provided specifier with the given parameters.\n    macro_rules! parse {\n        ($module:ident :: $specifier_fn:ident $( ( $($params:expr),* ) )?) => {\n            $module::$specifier_fn(&mut items, &mut s, $( $($params),* )?)?\n        };\n    }\n\n    macro_rules! parse_char {\n        ($c:literal) => {\n            try_consume_char(&mut s, $c)?\n        };\n    }\n\n    match &format {\n        Format::Rfc3339 => well_known::rfc3339::parse(&mut items, &mut s)?,\n        Format::Custom(format) => {\n            for item in parse_fmt_string(format) {\n                match item {\n                    FormatItem::Literal(expected) => try_consume_str(&mut s, expected)?,\n                    FormatItem::Specifier(specifier) => {\n                        use Specifier::*;\n                        match specifier {\n                            a => parse!(date::parse_a),\n                            A => parse!(date::parse_A),\n                            b => parse!(date::parse_b),\n                            B => parse!(date::parse_B),\n                            c => {\n                                parse!(date::parse_a);\n                                parse_char!(' ');\n                                parse!(date::parse_b);\n                                parse_char!(' ');\n                                parse!(date::parse_d(Padding::None));\n                                parse_char!(' ');\n                                parse!(time::parse_H(Padding::None));\n                                parse_char!(':');\n                                parse!(time::parse_M(Padding::Zero));\n                                parse_char!(':');\n                                parse!(time::parse_S(Padding::Zero));\n                                parse_char!(' ');\n                                parse!(date::parse_Y(Padding::None));\n                            }\n                            C { padding } => parse!(date::parse_C(padding)),\n                            d { padding } => parse!(date::parse_d(padding)),\n                            D => {\n                                parse!(date::parse_m(Padding::None));\n                                parse_char!('/');\n                                parse!(date::parse_d(Padding::Zero));\n                                parse_char!('/');\n                                parse!(date::parse_y(Padding::Zero));\n                            }\n                            F => {\n                                parse!(date::parse_Y(Padding::None));\n                                parse_char!('-');\n                                parse!(date::parse_m(Padding::Zero));\n                                parse_char!('-');\n                                parse!(date::parse_d(Padding::Zero));\n                            }\n                            g { padding } => parse!(date::parse_g(padding)),\n                            G { padding } => parse!(date::parse_G(padding)),\n                            H { padding } => parse!(time::parse_H(padding)),\n                            I { padding } => parse!(time::parse_I(padding)),\n                            j { padding } => parse!(date::parse_j(padding)),\n                            M { padding } => parse!(time::parse_M(padding)),\n                            m { padding } => parse!(date::parse_m(padding)),\n                            N => parse!(time::parse_N),\n                            p => parse!(time::parse_p),\n                            P => parse!(time::parse_P),\n                            r => {\n                                parse!(time::parse_I(Padding::None));\n                                parse_char!(':');\n                                parse!(time::parse_M(Padding::Zero));\n                                parse_char!(':');\n                                parse!(time::parse_S(Padding::Zero));\n                                parse_char!(' ');\n                                parse!(time::parse_p);\n                            }\n                            R => {\n                                parse!(time::parse_H(Padding::None));\n                                parse_char!(':');\n                                parse!(time::parse_M(Padding::Zero));\n                            }\n                            S { padding } => parse!(time::parse_S(padding)),\n                            T => {\n                                parse!(time::parse_H(Padding::None));\n                                parse_char!(':');\n                                parse!(time::parse_M(Padding::Zero));\n                                parse_char!(':');\n                                parse!(time::parse_S(Padding::Zero));\n                            }\n                            u => parse!(date::parse_u),\n                            U { padding } => parse!(date::parse_U(padding)),\n                            V { padding } => parse!(date::parse_V(padding)),\n                            w => parse!(date::parse_w),\n                            W { padding } => parse!(date::parse_W(padding)),\n                            y { padding } => parse!(date::parse_y(padding)),\n                            z => parse!(offset::parse_z),\n                            Y { padding } => parse!(date::parse_Y(padding)),\n                        }\n                    }\n                }\n            }\n        }\n        #[cfg(not(__time_02_supports_non_exhaustive))]\n        Format::__NonExhaustive => unreachable!(),\n    }\n\n    Ok(items)\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_char":["/// Attempt to consume the provided character.\npub(crate) fn try_consume_char(s: &mut &str, expected: char) -> ParseResult<()>{\n    match s.char_indices().next() {\n        Some((index, actual_char)) if actual_char == expected => {\n            *s = &s[(index + actual_char.len_utf8())..];\n            Ok(())\n        }\n        Some((_, actual)) => Err(Error::UnexpectedCharacter { expected, actual }),\n        None => Err(Error::UnexpectedEndOfString),\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_char_case_insensitive":["/// Attempt to consume the provided character, ignoring case.\npub(crate) fn try_consume_char_case_insensitive(s: &mut &str, expected: char) -> ParseResult<()>{\n    match s.char_indices().next() {\n        Some((index, actual_char)) if actual_char.eq_ignore_ascii_case(&expected) => {\n            *s = &s[(index + actual_char.len_utf8())..];\n            Ok(())\n        }\n        Some((_, actual)) => Err(Error::UnexpectedCharacter { expected, actual }),\n        None => Err(Error::UnexpectedEndOfString),\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_digits":["/// Attempt to consume a number of digits. Consumes the maximum amount possible\n/// within the range provided.\npub(crate) fn try_consume_digits<T: FromStr>(\n    s: &mut &str,\n    min_digits: usize,\n    max_digits: usize,\n) -> Option<T>{\n    // Determine how many digits the string starts with, up to the upper limit\n    // of the range.\n    let len = s\n        .chars()\n        .take(max_digits)\n        .take_while(char::is_ascii_digit)\n        .count();\n\n    // We don't have enough digits.\n    if len < min_digits {\n        return None;\n    }\n\n    // Because we're only dealing with ASCII digits here, we know that the\n    // length is equal to the number of bytes, as ASCII values are always one\n    // byte in Unicode.\n    let digits = &s[..len];\n    *s = &s[len..];\n    digits.parse::<T>().ok()\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_exact_digits":["/// Attempt to consume an exact number of digits.\npub(crate) fn try_consume_exact_digits<T: FromStr>(\n    s: &mut &str,\n    num_digits: usize,\n    padding: Padding,\n) -> Option<T>{\n    let pad_size = match padding {\n        Padding::Space => consume_padding(s, padding, num_digits - 1),\n        _ => 0,\n    };\n\n    if padding == Padding::None {\n        try_consume_digits(s, 1, num_digits - pad_size)\n    } else {\n        // Ensure all the necessary characters are ASCII digits.\n        if !s\n            .chars()\n            .take(num_digits - pad_size)\n            .all(|c| c.is_ascii_digit())\n        {\n            return None;\n        }\n\n        // Ensure the string is long enough to perform the slicing.\n        if (num_digits - pad_size) > s.len() {\n            return None;\n        }\n\n        // Because we're only dealing with ASCII digits here, we know that the\n        // length is equal to the number of bytes, as ASCII values are always one\n        // byte in Unicode.\n        let digits = &s[..(num_digits - pad_size)];\n        *s = &s[(num_digits - pad_size)..];\n        digits.parse::<T>().ok()\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_first_match":["/// Attempt to find one of the strings provided, returning the first value.\npub(crate) fn try_consume_first_match<T: Copy>(\n    s: &mut &str,\n    opts: impl IntoIterator<Item = (impl AsRef<str>, T)>,\n) -> Option<T>{\n    opts.into_iter().find_map(|(expected, value)| {\n        if s.starts_with(expected.as_ref()) {\n            *s = &s[expected.as_ref().len()..];\n            Some(value)\n        } else {\n            None\n        }\n    })\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::try_consume_str":["/// Attempt to consume the provided string.\npub(crate) fn try_consume_str(s: &mut &str, expected: &str) -> ParseResult<()>{\n    if s.starts_with(expected) {\n        *s = &s[expected.len()..];\n        Ok(())\n    } else {\n        // Iterate through the characters, returning the error where differing.\n        for c in expected.chars() {\n            try_consume_char(s, c)?;\n        }\n        // TODO Find a way to allow the compiler to prove the following is not\n        // necessary.\n        unreachable!(\"The previous loop should always cause the function to return.\");\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse_items::parse_fmt_string":["/// Parse the formatting string. Panics if not valid.\npub(crate) fn parse_fmt_string<'a>(s: &'a str) -> Vec<FormatItem<'a>>{\n    match try_parse_fmt_string(s) {\n        Ok(items) => items,\n        Err(err) => panic!(\"{}\", err),\n    }\n}","Real(LocalPath(\"src/format/parse_items.rs\"))"],"format::parse_items::try_parse_fmt_string":["/// Attempt to parse the formatting string.\n#[allow(clippy::too_many_lines)]\npub(crate) fn try_parse_fmt_string<'a>(s: &'a str) -> Result<Vec<FormatItem<'a>>, String>{\n    let mut items = Vec::new();\n    let mut literal_start = 0;\n    let mut chars = s.char_indices().peekable();\n\n    while let Some((i, c)) = chars.next() {\n        /// Push the provided specifier to the list of items.\n        macro_rules! push_specifier {\n            ($i:ident, $specifier:expr) => {{\n                literal_start = $i + 1;\n                items.push(FormatItem::Specifier($specifier))\n            }};\n        }\n\n        if c == '%' {\n            // Avoid adding unnecessary empty strings.\n            if literal_start != i {\n                items.push(FormatItem::Literal(&s[literal_start..i]));\n            }\n\n            // Call `chars.next()` if a modifier is present, moving the iterator\n            // past the character. `None` is equivalent to the default value.\n            let padding = match chars.peek().map(|v| v.1) {\n                Some('-') => {\n                    let _ = chars.next();\n                    Some(Padding::None)\n                }\n                Some('_') => {\n                    let _ = chars.next();\n                    Some(Padding::Space)\n                }\n                Some('0') => {\n                    let _ = chars.next();\n                    Some(Padding::Zero)\n                }\n                _ => None,\n            };\n\n            match chars.next() {\n                Some((i, 'a')) => push_specifier!(i, Specifier::a),\n                Some((i, 'A')) => push_specifier!(i, Specifier::A),\n                Some((i, 'b')) => push_specifier!(i, Specifier::b),\n                Some((i, 'B')) => push_specifier!(i, Specifier::B),\n                Some((i, 'c')) => push_specifier!(i, Specifier::c),\n                Some((i, 'C')) => push_specifier!(\n                    i,\n                    Specifier::C {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'd')) => push_specifier!(\n                    i,\n                    Specifier::d {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'D')) => push_specifier!(i, Specifier::D),\n                Some((i, 'F')) => push_specifier!(i, Specifier::F),\n                Some((i, 'g')) => push_specifier!(\n                    i,\n                    Specifier::g {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'G')) => push_specifier!(\n                    i,\n                    Specifier::G {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'H')) => push_specifier!(\n                    i,\n                    Specifier::H {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'I')) => push_specifier!(\n                    i,\n                    Specifier::I {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'j')) => push_specifier!(\n                    i,\n                    Specifier::j {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'm')) => push_specifier!(\n                    i,\n                    Specifier::m {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'M')) => push_specifier!(\n                    i,\n                    Specifier::M {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'N')) => push_specifier!(i, Specifier::N),\n                Some((i, 'p')) => push_specifier!(i, Specifier::p),\n                Some((i, 'P')) => push_specifier!(i, Specifier::P),\n                Some((i, 'r')) => push_specifier!(i, Specifier::r),\n                Some((i, 'R')) => push_specifier!(i, Specifier::R),\n                Some((i, 'S')) => push_specifier!(\n                    i,\n                    Specifier::S {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'T')) => push_specifier!(i, Specifier::T),\n                Some((i, 'u')) => push_specifier!(i, Specifier::u),\n                Some((i, 'U')) => push_specifier!(\n                    i,\n                    Specifier::U {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'V')) => push_specifier!(\n                    i,\n                    Specifier::V {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'w')) => push_specifier!(i, Specifier::w),\n                Some((i, 'W')) => push_specifier!(\n                    i,\n                    Specifier::W {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'y')) => push_specifier!(\n                    i,\n                    Specifier::y {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'Y')) => push_specifier!(\n                    i,\n                    Specifier::Y {\n                        padding: padding.unwrap_or(Padding::Zero)\n                    }\n                ),\n                Some((i, 'z')) => push_specifier!(i, Specifier::z),\n                Some((i, '%')) => literal_start = i,\n                Some((_, c)) => return Err(format!(\"Invalid specifier `{}`\", c)),\n                None => {\n                    return Err(String::from(\n                        \"Cannot end formatting with `%`. If you want a literal `%`, you must use \\\n                         `%%`.\",\n                    ))\n                }\n            }\n        }\n    }\n\n    if literal_start < s.len() {\n        items.push(FormatItem::Literal(&s[literal_start..]));\n    }\n\n    Ok(items)\n}","Real(LocalPath(\"src/format/parse_items.rs\"))"],"format::time::fmt_H":["/// Hour in 24h format (`00`-`23`)\npub(crate) fn fmt_H(f: &mut Formatter<'_>, time: Time, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, time.hour())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_I":["/// Hour in 12h format (`01`-`12`)\npub(crate) fn fmt_I(f: &mut Formatter<'_>, time: Time, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, (time.hour() as i8 - 1).rem_euclid(12) + 1)\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_M":["/// Minutes, zero-padded (`00`-`59`)\npub(crate) fn fmt_M(f: &mut Formatter<'_>, time: Time, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, time.minute())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_N":["/// Subsecond nanoseconds. Always 9 digits\npub(crate) fn fmt_N(f: &mut Formatter<'_>, time: Time) -> fmt::Result{\n    write!(f, \"{:09}\", time.nanosecond)\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_P":["/// AM/PM\npub(crate) fn fmt_P(f: &mut Formatter<'_>, time: Time) -> fmt::Result{\n    if time.hour() < 12 {\n        f.write_str(\"AM\")\n    } else {\n        f.write_str(\"PM\")\n    }\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_S":["/// Seconds, zero-padded (`00`-`59`)\npub(crate) fn fmt_S(f: &mut Formatter<'_>, time: Time, padding: Padding) -> fmt::Result{\n    pad!(f, padding, 2, time.second())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::fmt_p":["/// am/pm\npub(crate) fn fmt_p(f: &mut Formatter<'_>, time: Time) -> fmt::Result{\n    if time.hour() < 12 {\n        f.write_str(\"am\")\n    } else {\n        f.write_str(\"pm\")\n    }\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_H":["/// Hour in 24h format (`00`-`23`)\npub(crate) fn parse_H(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.hour_24 = Some(try_consume_exact_digits(s, 2, padding).ok_or(error::Parse::InvalidHour)?);\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_I":["/// Hour in 12h format (`01`-`12`)\npub(crate) fn parse_I(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.hour_12 = Some(\n        try_consume_exact_digits(s, 2, padding)\n            .and_then(NonZeroU8::new)\n            .ok_or(error::Parse::InvalidHour)?,\n    );\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_M":["/// Minutes, zero-added (`00`-`59`)\npub(crate) fn parse_M(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.minute =\n        Some(try_consume_exact_digits(s, 2, padding).ok_or(error::Parse::InvalidMinute)?);\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_N":["/// Subsecond nanoseconds. Always 9 digits\npub(crate) fn parse_N(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.nanosecond =\n        Some(try_consume_exact_digits(s, 9, Padding::None).ok_or(error::Parse::InvalidNanosecond)?);\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_P":["/// AM/PM\npub(crate) fn parse_P(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.am_pm = Some(\n        try_consume_first_match(s, [(\"AM\", AM), (\"PM\", PM)].iter().cloned())\n            .ok_or(error::Parse::InvalidAmPm)?,\n    );\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_S":["/// Seconds, zero-added (`00`-`59`)\npub(crate) fn parse_S(items: &mut ParsedItems, s: &mut &str, padding: Padding) -> ParseResult<()>{\n    items.second =\n        Some(try_consume_exact_digits(s, 2, padding).ok_or(error::Parse::InvalidSecond)?);\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::time::parse_p":["/// am/pm\npub(crate) fn parse_p(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n    items.am_pm = Some(\n        try_consume_first_match(s, [(\"am\", AM), (\"pm\", PM)].iter().cloned())\n            .ok_or(error::Parse::InvalidAmPm)?,\n    );\n    Ok(())\n}","Real(LocalPath(\"src/format/time.rs\"))"],"format::well_known::rfc3339::fmt":["/// Format `df` according to the RFC3339 specification.\npub(crate) fn fmt(df: &DeferredFormat, f: &mut Formatter<'_>) -> Result<(), error::Format>{\n        let (date, time, offset) = match (df.date(), df.time(), df.offset()) {\n            (Some(date), Some(time), Some(offset)) => (date, time, offset),\n            _ => return Err(error::Format::InsufficientTypeInformation),\n        };\n\n        date::fmt_Y(f, date, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_m(f, date, Padding::Zero)?;\n        f.write_str(\"-\")?;\n        date::fmt_d(f, date, Padding::Zero)?;\n        f.write_str(\"T\")?;\n        time::fmt_H(f, time, Padding::Zero)?;\n        f.write_str(\":\")?;\n        time::fmt_M(f, time, Padding::Zero)?;\n        f.write_str(\":\")?;\n        time::fmt_S(f, time, Padding::Zero)?;\n        write!(\n            f,\n            \"{:+03}:{:02}\",\n            offset.as_hours(),\n            offset.as_minutes().rem_euclid(60)\n        )?;\n\n        Ok(())\n    }","Real(LocalPath(\"src/format/well_known.rs\"))"],"format::well_known::rfc3339::parse":["/// Parse `s` as specified by RFC3339.\npub(crate) fn parse(items: &mut ParsedItems, s: &mut &str) -> ParseResult<()>{\n        items.year = try_consume_exact_digits::<i32>(s, 4, Padding::None)\n            .ok_or(error::Parse::InvalidYear)?\n            .into();\n        try_consume_char(s, '-')?;\n        date::parse_m(items, s, Padding::Zero)?;\n        try_consume_char(s, '-')?;\n        date::parse_d(items, s, Padding::Zero)?;\n        try_consume_char_case_insensitive(s, 'T')?;\n        time::parse_H(items, s, Padding::Zero)?;\n        try_consume_char(s, ':')?;\n        time::parse_M(items, s, Padding::Zero)?;\n        try_consume_char(s, ':')?;\n        time::parse_S(items, s, Padding::Zero)?;\n\n        if try_consume_char(s, '.').is_ok() {\n            let num_digits = s.chars().take_while(char::is_ascii_digit).count();\n            if num_digits == 0 {\n                return Err(error::Parse::InvalidNanosecond);\n            }\n            let num_digits_used = core::cmp::min(num_digits, 9);\n\n            let nanos_raw: String = s.chars().take(num_digits_used).collect();\n            // At most 9 decimal digits will always fit in a u32.\n            // `num_digits_used` is at most 9, which can safely be cast.\n            #[allow(clippy::unwrap_used)]\n            let nanos = nanos_raw.parse::<u32>().unwrap() * 10_u32.pow(9 - num_digits_used as u32);\n            items.nanosecond = Some(nanos);\n            *s = &s[num_digits..];\n        }\n\n        if try_consume_char_case_insensitive(s, 'Z').is_ok() {\n            items.offset = Some(UtcOffset::UTC);\n        } else {\n            let offset_sign =\n                match try_consume_first_match(s, [(\"+\", 1), (\"-\", -1)].iter().cloned()) {\n                    Some(sign) => sign,\n                    None => {\n                        return Err(match s.chars().next() {\n                            Some(actual) => error::Parse::UnexpectedCharacter {\n                                actual,\n                                expected: '+',\n                            },\n                            None => error::Parse::UnexpectedEndOfString,\n                        })\n                    }\n                };\n            let offset_hour: i16 =\n                try_consume_exact_digits(s, 2, Padding::Zero).ok_or(error::Parse::InvalidOffset)?;\n            try_consume_char(s, ':')?;\n            let offset_minute: i16 =\n                try_consume_exact_digits(s, 2, Padding::Zero).ok_or(error::Parse::InvalidOffset)?;\n            items.offset = Some(UtcOffset::minutes(\n                offset_sign * (offset_hour * 60 + offset_minute),\n            ));\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/format/well_known.rs\"))"],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["fn eq(&self, rhs: &Instant) -> bool{\n        self.eq(&rhs.inner)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["fn partial_cmp(&self, rhs: &Instant) -> Option<Ordering>{\n        self.partial_cmp(&rhs.inner)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["fn from(instant: Instant) -> Self{\n        instant.inner\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["fn add(self, duration: Duration) -> Self::Output{\n        (Instant::from(self) + duration).into()\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        (Instant::from(self) - duration).into()\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["fn sub(self, other: Instant) -> Self::Output{\n        Instant::from(self) - other\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant":["/// A measurement of a monotonically non-decreasing clock. Opaque and useful\n/// only with [`Duration`].\n///\n/// Instants are always guaranteed to be no less than any previously measured\n/// instant when created, and are often useful for tasks such as measuring\n/// benchmarks or timing how long an operation takes.\n///\n/// Note, however, that instants are not guaranteed to be **steady**. In other\n/// words, each tick of the underlying clock may not be the same length (e.g.\n/// some seconds may be longer than others). An instant may jump forwards or\n/// experience time dilation (slow down or speed up), but it will never go\n/// backwards.\n///\n/// Instants are opaque types that can only be compared to one another. There is\n/// no method to get \"the number of seconds\" from an instant. Instead, it only\n/// allows measuring the duration between two instants (or comparing two\n/// instants).\n///\n/// This implementation allows for operations with signed [`Duration`]s, but is\n/// otherwise identical to [`std::time::Instant`].\npub struct Instant {\n    /// Inner representation, using `std::time::Instant`.\n    inner: StdInstant,\n}","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::checked_add":["/// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be\n/// represented as `Instant` (which means it's inside the bounds of the\n/// underlying data structure), `None` otherwise.\n///\n/// ```rust\n/// # use time::{Instant, prelude::*};\n/// let now = Instant::now();\n/// assert_eq!(\n///     now.checked_add(5.seconds()),\n///     Some(now + 5.seconds())\n/// );\n/// assert_eq!(\n///     now.checked_add((-5).seconds()),\n///     Some(now + (-5).seconds())\n/// );\n/// ```\n///\n/// This function is only present when using rustc >= 1.34.0.\n#[cfg(__time_02_instant_checked_ops)]\npub fn checked_add(self, duration: Duration) -> Option<Self>{\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.inner.checked_add(duration.abs_std()).map(From::from)\n        } else {\n            // duration.is_negative()\n            self.inner.checked_sub(duration.abs_std()).map(From::from)\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::checked_sub":["/// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be\n/// represented as `Instant` (which means it's inside the bounds of the\n/// underlying data structure), `None` otherwise.\n///\n/// ```rust\n/// # use time::{Instant, prelude::*};\n/// let now = Instant::now();\n/// assert_eq!(\n///     now.checked_sub(5.seconds()),\n///     Some(now - 5.seconds())\n/// );\n/// assert_eq!(\n///     now.checked_sub((-5).seconds()),\n///     Some(now - (-5).seconds())\n/// );\n/// ```\n///\n/// This function is only present when using rustc >= 1.34.0.\n#[cfg(__time_02_instant_checked_ops)]\npub fn checked_sub(self, duration: Duration) -> Option<Self>{\n        self.checked_add(-duration)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::elapsed":["/// Returns the amount of time elapsed since this instant was created. The\n/// duration will always be nonnegative if the instant is not synthetically\n/// created.\n///\n/// ```rust\n/// # use time::{Instant, prelude::*};\n/// # use std::thread;\n/// let instant = Instant::now();\n/// thread::sleep(1.std_milliseconds());\n/// assert!(instant.elapsed() >= 1.milliseconds());\n/// ```\npub fn elapsed(self) -> Duration{\n        Self::now() - self\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::now":["/// Returns an `Instant` corresponding to \"now\".\n///\n/// ```rust\n/// # use time::Instant;\n/// println!(\"{:?}\", Instant::now());\n/// ```\npub fn now() -> Self{\n        Self {\n            inner: StdInstant::now(),\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::to":["#[cfg(feature = \"deprecated\")]\n#[deprecated(since = \"0.2.0\", note = \"Use `rhs - lhs`\")]\npub fn to(&self, later: Self) -> Duration{\n        later - *self\n    }","Real(LocalPath(\"src/instant.rs\"))"],"internals::Date":["pub struct Date;","Real(LocalPath(\"src/internals.rs\"))"],"internals::Date::from_iso_ywd_unchecked":["pub(crate) const fn from_iso_ywd_unchecked(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> crate::Date{\n        let (ordinal, overflow) = (week as u16 * 7 + weekday.iso_weekday_number() as u16)\n            .overflowing_sub(jan_weekday(year, 4) as u16 + 4);\n\n        if overflow || ordinal == 0 {\n            return Self::from_yo_unchecked(year - 1, ordinal.wrapping_add(days_in_year(year - 1)));\n        }\n\n        let days_in_cur_year = days_in_year(year);\n        if ordinal > days_in_cur_year {\n            Self::from_yo_unchecked(year + 1, ordinal - days_in_cur_year)\n        } else {\n            Self::from_yo_unchecked(year, ordinal)\n        }\n    }","Real(LocalPath(\"src/internals.rs\"))"],"internals::Date::from_ymd_unchecked":["pub(crate) const fn from_ymd_unchecked(year: i32, month: u8, day: u8) -> crate::Date{\n        /// Cumulative days through the beginning of a month in both common and\n        /// leap years.\n        const DAYS_CUMULATIVE_COMMON_LEAP: [[u16; 12]; 2] = [\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        Date::from_yo_unchecked(\n            year,\n            DAYS_CUMULATIVE_COMMON_LEAP[is_leap_year(year) as usize][month as usize - 1]\n                + day as u16,\n        )\n    }","Real(LocalPath(\"src/internals.rs\"))"],"internals::Date::from_yo_unchecked":["pub const fn from_yo_unchecked(year: i32, ordinal: u16) -> crate::Date{\n        crate::Date {\n            value: (year << 9) | ordinal as i32,\n        }\n    }","Real(LocalPath(\"src/internals.rs\"))"],"internals::Time":["pub struct Time;","Real(LocalPath(\"src/internals.rs\"))"],"internals::Time::from_hms_nanos_unchecked":["/// Create a `Time` from its components.\npub const fn from_hms_nanos_unchecked(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> crate::Time{\n        crate::Time {\n            hour,\n            minute,\n            second,\n            nanosecond,\n        }\n    }","Real(LocalPath(\"src/internals.rs\"))"],"internals::jan_weekday":["/// Obtain the ISO weekday number of a day in January.\npub(crate) const fn jan_weekday(year: i32, ordinal: i32) -> u8{\n    let adj_year = year - 1;\n    let rem = (ordinal + adj_year + adj_year / 4 - adj_year / 100 + adj_year / 400 + 6) % 7;\n    if rem < 0 {\n        (rem + 7) as u8\n    } else {\n        rem as u8\n    }\n}","Real(LocalPath(\"src/internals.rs\"))"],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["fn eq(&self, rhs: &OffsetDateTime) -> bool{\n        &OffsetDateTime::from(*self) == rhs\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["fn partial_cmp(&self, other: &OffsetDateTime) -> Option<Ordering>{\n        OffsetDateTime::from(*self).partial_cmp(other)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["fn from(datetime: OffsetDateTime) -> Self{\n        let duration = datetime - OffsetDateTime::unix_epoch();\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["fn add(self, duration: Duration) -> Self::Output{\n        if duration.is_zero() {\n            self\n        } else if duration.is_positive() {\n            self + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            self - duration.abs_std()\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["fn add_assign(&mut self, duration: Duration){\n        *self = *self + duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        (OffsetDateTime::from(self) - duration).into()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["fn sub(self, rhs: OffsetDateTime) -> Self::Output{\n        OffsetDateTime::from(self) - rhs\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["fn sub_assign(&mut self, duration: Duration){\n        *self = *self - duration;\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime":["/// A [`PrimitiveDateTime`] with a [`UtcOffset`].\n///\n/// All comparisons are performed using the UTC time.\npub struct OffsetDateTime {\n    /// The `PrimitiveDateTime`, which is _always_ UTC.\n    utc_datetime: PrimitiveDateTime,\n    /// The `UtcOffset`, which will be added to the `PrimitiveDateTime` as necessary.\n    offset: UtcOffset,\n}","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::date":["/// Get the `Date` in the stored offset.\n///\n/// ```rust\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .date(),\n///     date!(2019-01-01),\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .date(),\n///     date!(2018-12-31),\n/// );\n/// ```\npub fn date(self) -> Date{\n        (self.utc_datetime + self.offset.as_duration()).date()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::day":["/// Get the day of the date in the stored offset. If fetching both the month\n/// and day, it is more efficient to use [`OffsetDateTime::month_day`].\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .day(),\n///     1,\n/// );\n/// assert_eq!(\n///     date!(2019-12-31)\n///         .with_time(time!(23:00))\n///         .assume_utc()\n///         .to_offset(offset!(+1))\n///         .day(),\n///     1,\n/// );\n/// ```\npub fn day(self) -> u8{\n        self.date().day()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::format":["/// Format the `OffsetDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::{date};\n/// assert_eq!(\n///     date!(2019-01-02)\n///         .midnight()\n///         .assume_utc()\n///         .format(\"%F %r %z\"),\n///     \"2019-01-02 12:00:00 am +0000\",\n/// );\n/// ```\npub fn format(self, format: impl Into<Format>) -> String{\n        self.lazy_format(format).to_string()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::from_unix_timestamp":["/// Create an `OffsetDateTime` from the provided [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n///\n/// ```rust\n/// # use time::{date, OffsetDateTime};\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(0),\n///     OffsetDateTime::unix_epoch(),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(1_546_300_800),\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc(),\n/// );\n/// ```\n///\n/// If you have a timestamp-nanosecond pair, you can use something along the\n/// lines of the following:\n///\n/// ```rust\n/// # use time::{Duration, OffsetDateTime, ext::NumericalDuration};\n/// let (timestamp, nanos) = (1, 500_000_000);\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(timestamp) + Duration::nanoseconds(nanos),\n///     OffsetDateTime::unix_epoch() + 1.5.seconds()\n/// );\n/// ```\npub fn from_unix_timestamp(timestamp: i64) -> Self{\n        OffsetDateTime::unix_epoch() + Duration::seconds(timestamp)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["/// Construct an `OffsetDateTime` from the provided Unix timestamp (in\n/// nanoseconds).\n///\n/// ```rust\n/// # use time::{date, OffsetDateTime};\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp_nanos(0),\n///     OffsetDateTime::unix_epoch(),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp_nanos(1_546_300_800_000_000_000),\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc(),\n/// );\n/// ```\n///\n/// Note that the range of timestamps possible here is far larger than the\n/// valid range of dates storable in this crate. It is the _user's\n/// responsibility_ to ensure the timestamp provided as a parameter is\n/// valid. No behavior is guaranteed if this parameter would not result in a\n/// valid value.\npub fn from_unix_timestamp_nanos(timestamp: i128) -> Self{\n        OffsetDateTime::unix_epoch() + Duration::nanoseconds_i128(timestamp)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::hour":["/// Get the clock hour in the stored offset.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::{date, time, offset};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .hour(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59))\n///         .assume_utc()\n///         .to_offset(offset!(-2))\n///         .hour(),\n///     21,\n/// );\n/// ```\npub fn hour(self) -> u8{\n        self.time().hour()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::iso_year_week":["/// Get the ISO 8601 year and week number in the stored offset.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .iso_year_week(),\n///     (2019, 1),\n/// );\n/// assert_eq!(\n///     date!(2019-10-04)\n///         .midnight()\n///         .assume_utc()\n///         .iso_year_week(),\n///     (2019, 40),\n/// );\n/// assert_eq!(\n///     date!(2020-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .iso_year_week(),\n///     (2020, 1),\n/// );\n/// assert_eq!(\n///     date!(2020-12-31)\n///         .midnight()\n///         .assume_utc()\n///         .iso_year_week(),\n///     (2020, 53),\n/// );\n/// assert_eq!(\n///     date!(2021-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .iso_year_week(),\n///     (2020, 53),\n/// );\n/// ```\npub fn iso_year_week(self) -> (i32, u8){\n        self.date().iso_year_week()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::lazy_format":["/// Format the `OffsetDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-02)\n///         .midnight()\n///         .assume_utc()\n///         .lazy_format(\"%F %r %z\")\n///         .to_string(),\n///     \"2019-01-02 12:00:00 am +0000\",\n/// );\n/// ```\npub fn lazy_format(self, format: impl Into<Format>) -> impl Display{\n        DeferredFormat::new(format)\n            .with_date(self.date())\n            .with_time(self.time())\n            .with_offset(self.offset())\n            .to_owned()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::microsecond":["/// Get the microseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .microsecond(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59.999_999))\n///         .assume_utc()\n///         .microsecond(),\n///     999_999,\n/// );\n/// ```\npub fn microsecond(self) -> u32{\n        self.time().microsecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::millisecond":["/// Get the milliseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .millisecond(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59.999))\n///         .assume_utc()\n///         .millisecond(),\n///     999,\n/// );\n/// ```\npub fn millisecond(self) -> u16{\n        self.time().millisecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::minute":["/// Get the minute within the hour in the stored offset.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .minute(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59))\n///         .assume_utc()\n///         .to_offset(offset!(+0:30))\n///         .minute(),\n///     29,\n/// );\n/// ```\npub fn minute(self) -> u8{\n        self.time().minute()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::month":["/// Get the month of the date in the stored offset. If fetching both the\n/// month and day, it is more efficient to use\n/// [`OffsetDateTime::month_day`].\n///\n/// The returned value will always be in the range `1..=12`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .month(),\n///     1,\n/// );\n/// assert_eq!(\n///     date!(2019-12-31)\n///         .with_time(time!(23:00))\n///         .assume_utc()\n///         .to_offset(offset!(+1))\n///         .month(),\n///     1,\n/// );\n/// ```\npub fn month(self) -> u8{\n        self.date().month()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::month_day":["/// Get the month and day of the date in the stored offset.\n///\n/// The month component will always be in the range `1..=12`;\n/// the day component in `1..=31`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .month_day(),\n///     (1, 1),\n/// );\n/// assert_eq!(\n///     date!(2019-12-31)\n///         .with_time(time!(23:00))\n///         .assume_utc()\n///         .to_offset(offset!(+1))\n///         .month_day(),\n///     (1, 1),\n/// );\n/// ```\npub fn month_day(self) -> (u8, u8){\n        self.date().month_day()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::nanosecond":["/// Get the nanoseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .nanosecond(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59.999_999_999))\n///         .assume_utc()\n///         .nanosecond(),\n///     999_999_999,\n/// );\n/// ```\npub fn nanosecond(self) -> u32{\n        self.time().nanosecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::new_assuming_offset":["/// Create a new `OffsetDateTime` from the provided `PrimitiveDateTime` and\n/// `UtcOffset`. The `PrimitiveDateTime` is assumed to be in the provided\n/// offset.\npub(crate) fn new_assuming_offset(utc_datetime: PrimitiveDateTime, offset: UtcOffset) -> Self{\n        Self {\n            utc_datetime: utc_datetime - offset.as_duration(),\n            offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::new_assuming_utc":["/// Create a new `OffsetDateTime` from the provided `PrimitiveDateTime` and\n/// `UtcOffset`. The `PrimitiveDateTime` is assumed to be in UTC.\npub(crate) const fn new_assuming_utc(utc_datetime: PrimitiveDateTime) -> Self{\n        Self {\n            utc_datetime,\n            offset: UtcOffset::UTC,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::now":["/// Create a new `OffsetDateTime` with the current date and time in UTC.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{OffsetDateTime, offset};\n/// assert!(OffsetDateTime::now().year() >= 2019);\n/// assert_eq!(OffsetDateTime::now().offset(), offset!(UTC));\n/// ```\n#[deprecated(\n        since = \"0.2.11\",\n        note = \"This function returns a value with an offset of UTC, which is not apparent from \\\n                its name alone. You should use `OffsetDateTime::now_utc()` instead.\"\n    )]\n#[cfg(feature = \"std\")]\npub fn now() -> Self{\n        SystemTime::now().into()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::now_local":["/// Create a new `OffsetDateTime` with the current date and time in the\n/// local offset.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::OffsetDateTime;\n/// assert!(OffsetDateTime::now_local().year() >= 2019);\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\n#[allow(deprecated)]\npub fn now_local() -> Self{\n        let t = Self::now_utc();\n        t.to_offset(UtcOffset::local_offset_at(t))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::now_utc":["/// Create a new `OffsetDateTime` with the current date and time in UTC.\n///\n/// ```rust\n/// # use time::{OffsetDateTime, offset};\n/// assert!(OffsetDateTime::now_utc().year() >= 2019);\n/// assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));\n/// ```\n#[cfg(feature = \"std\")]\npub fn now_utc() -> Self{\n        SystemTime::now().into()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::offset":["/// Get the `UtcOffset`.\n///\n/// ```rust\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .offset(),\n///     offset!(UTC),\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_offset(offset!(+1))\n///         .offset(),\n///     offset!(+1),\n/// );\n/// ```\npub const fn offset(self) -> UtcOffset{\n        self.offset\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::ordinal":["/// Get the day of the year of the date in the stored offset.\n///\n/// The returned value will always be in the range `1..=366`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .ordinal(),\n///     1,\n/// );\n/// assert_eq!(\n///     date!(2019-12-31)\n///         .with_time(time!(23:00))\n///         .assume_utc()\n///         .to_offset(offset!(+1))\n///         .ordinal(),\n///     1,\n/// );\n/// ```\npub fn ordinal(self) -> u16{\n        self.date().ordinal()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::parse":["/// Attempt to parse an `OffsetDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::{date, OffsetDateTime, time};\n/// assert_eq!(\n///     OffsetDateTime::parse(\"2019-01-02 00:00:00 +0000\", \"%F %T %z\"),\n///     Ok(date!(2019-01-02).midnight().assume_utc()),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::parse(\"2019-002 23:59:59 +0000\", \"%Y-%j %T %z\"),\n///     Ok(date!(2019-002).with_time(time!(23:59:59)).assume_utc()),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::parse(\"2019-W01-3 12:00:00 pm +0000\", \"%G-W%V-%u %r %z\"),\n///     Ok(date!(2019-W01-3).with_time(time!(12:00)).assume_utc()),\n/// );\n/// ```\npub fn parse(s: impl AsRef<str>, format: impl Into<Format>) -> ParseResult<Self>{\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::second":["/// Get the second within the minute in the stored offset.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .second(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .with_time(time!(23:59:59))\n///         .assume_utc()\n///         .to_offset(offset!(+0:00:30))\n///         .second(),\n///     29,\n/// );\n/// ```\npub fn second(self) -> u8{\n        self.time().second()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::time":["/// Get the `Time` in the stored offset.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .time(),\n///     time!(0:00)\n/// );\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .time(),\n///     time!(23:00)\n/// );\n/// ```\npub fn time(self) -> Time{\n        (self.utc_datetime + self.offset.as_duration()).time()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::timestamp":["/// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .timestamp(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .timestamp(),\n///     0,\n/// );\n/// ```\n#[deprecated(\n        since = \"0.2.23\",\n        note = \"Use `OffsetDateTime::unix_timestamp` instead\"\n    )]\npub fn timestamp(self) -> i64{\n        self.unix_timestamp()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::timestamp_nanos":["/// Get the Unix timestamp in nanoseconds.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// use time::{date, offset, time};\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .unix_timestamp_nanos(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .with_time(time!(1:00))\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .unix_timestamp_nanos(),\n///     3_600_000_000_000,\n/// );\n/// ```\n#[deprecated(\n        since = \"0.2.23\",\n        note = \"Use `OffsetDateTime::unix_timestamp_nanos` instead\"\n    )]\npub fn timestamp_nanos(self) -> i128{\n        self.unix_timestamp_nanos()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_offset":["/// Convert the `OffsetDateTime` from the current `UtcOffset` to the\n/// provided `UtcOffset`.\n///\n/// ```rust\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(2000-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .year(),\n///     1999,\n/// );\n///\n/// // Let's see what time Sydney's new year's celebration is in New York\n/// // and Los Angeles.\n///\n/// // Construct midnight on new year's in Sydney. This is equivalent to\n/// // 13:00 UTC.\n/// let sydney = date!(2000-01-01).midnight().assume_offset(offset!(+11));\n/// let new_york = sydney.to_offset(offset!(-5));\n/// let los_angeles = sydney.to_offset(offset!(-8));\n/// assert_eq!(sydney.hour(), 0);\n/// assert_eq!(new_york.hour(), 8);\n/// assert_eq!(los_angeles.hour(), 5);\n/// ```\npub const fn to_offset(self, offset: UtcOffset) -> Self{\n        Self {\n            utc_datetime: self.utc_datetime,\n            offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::try_from_parsed_items":["/// Given the items already parsed, attempt to create an `OffsetDateTime`.\npub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self>{\n        let offset = UtcOffset::try_from_parsed_items(items)?;\n        Ok(PrimitiveDateTime::try_from_parsed_items(items)?.assume_offset(offset))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::try_now_local":["/// Attempt to create a new `OffsetDateTime` with the current date and time\n/// in the local offset. If the offset cannot be determined, an error is\n/// returned.\n///\n/// ```rust\n/// # use time::OffsetDateTime;\n/// let now = OffsetDateTime::try_now_local();\n/// # if false {\n/// assert!(now.is_ok());\n/// # }\n/// ```\n#[cfg(feature = \"std\")]\npub fn try_now_local() -> Result<Self, error::IndeterminateOffset>{\n        let t = Self::now_utc();\n        Ok(t.to_offset(UtcOffset::try_local_offset_at(t)?))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::unix_epoch":["/// Midnight, 1 January, 1970 (UTC).\n///\n/// ```rust\n/// # use time::{date, OffsetDateTime};\n/// assert_eq!(\n///     OffsetDateTime::unix_epoch(),\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc(),\n/// );\n/// ```\npub const fn unix_epoch() -> Self{\n        internals::Date::from_yo_unchecked(1970, 1)\n            .midnight()\n            .assume_utc()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::unix_timestamp":["/// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n///\n/// ```rust\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .unix_timestamp(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .unix_timestamp(),\n///     0,\n/// );\n/// ```\npub fn unix_timestamp(self) -> i64{\n        let days = (self.utc_datetime.date.julian_day()\n            - internals::Date::from_yo_unchecked(1970, 1).julian_day())\n            * 86_400;\n        let hours = self.utc_datetime.hour() as i64 * 3_600;\n        let minutes = self.utc_datetime.minute() as i64 * 60;\n        let seconds = self.utc_datetime.second() as i64;\n        days + hours + minutes + seconds\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["/// Get the Unix timestamp in nanoseconds.\n///\n/// ```rust\n/// use time::{date, offset, time};\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .unix_timestamp_nanos(),\n///     0,\n/// );\n/// assert_eq!(\n///     date!(1970-01-01)\n///         .with_time(time!(1:00))\n///         .assume_utc()\n///         .to_offset(offset!(-1))\n///         .unix_timestamp_nanos(),\n///     3_600_000_000_000,\n/// );\n/// ```\npub fn unix_timestamp_nanos(self) -> i128{\n        (self - Self::unix_epoch()).whole_nanoseconds()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::week":["/// Get the ISO week number of the date in the stored offset.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .week(),\n///     1,\n/// );\n/// assert_eq!(\n///     date!(2020-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .week(),\n///     1,\n/// );\n/// assert_eq!(\n///     date!(2020-12-31)\n///         .midnight()\n///         .assume_utc()\n///         .week(),\n///     53,\n/// );\n/// assert_eq!(\n///     date!(2021-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .week(),\n///     53,\n/// );\n/// ```\npub fn week(self) -> u8{\n        self.date().week()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::weekday":["/// Get the weekday of the date in the stored offset.\n///\n/// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n/// internally.\n///\n/// ```rust\n/// # use time::{date, Weekday::*};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .weekday(),\n///     Tuesday,\n/// );\n/// assert_eq!(\n///     date!(2019-02-01)\n///         .midnight()\n///         .assume_utc()\n///         .weekday(),\n///     Friday,\n/// );\n/// assert_eq!(\n///     date!(2019-03-01)\n///         .midnight()\n///         .assume_utc()\n///         .weekday(),\n///     Friday,\n/// );\n/// ```\npub fn weekday(self) -> Weekday{\n        self.date().weekday()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::year":["/// Get the year of the date in the stored offset.\n///\n/// ```rust\n/// # use time::{date, offset, time};\n/// assert_eq!(\n///     date!(2019-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .year(),\n///     2019,\n/// );\n/// assert_eq!(\n///     date!(2019-12-31)\n///         .with_time(time!(23:00))\n///         .assume_utc()\n///         .to_offset(offset!(+1))\n///         .year(),\n///     2020,\n/// );\n/// assert_eq!(\n///     date!(2020-01-01)\n///         .midnight()\n///         .assume_utc()\n///         .year(),\n///     2020,\n/// );\n/// ```\npub fn year(self) -> i32{\n        self.date().year()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"parse":["/// Parse any parsable type from the time crate.\n///\n/// This is identical to calling `T::parse(s, format)`, but allows the use of\n/// type inference where possible.\n///\n/// ```rust\n/// use time::Time;\n///\n/// #[derive(Debug)]\n/// struct Foo(Time);\n///\n/// fn main() -> time::Result<()> {\n///     // We don't need to tell the compiler what type we need!\n///     let foo = Foo(time::parse(\"14:55:02\", \"%T\")?);\n///     println!(\"{:?}\", foo);\n///     Ok(())\n/// }\n/// ```\npub fn parse<T: private::Parsable>(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<T>{\n    private::Parsable::parse(s, format)\n}","Real(LocalPath(\"src/lib.rs\"))"],"precise_time_ns":["#[cfg(all(feature = \"std\", feature = \"deprecated\"))]\n#[allow(clippy::missing_docs_in_private_items)]\n#[deprecated(\n    since = \"0.2.0\",\n    note = \"Use `OffsetDateTime::now() - OffsetDateTime::unix_epoch()` to get a `Duration` since \\\n            a known epoch.\"\n)]\npub fn precise_time_ns() -> u64{\n    use standback::convert::TryInto;\n    use std::time::SystemTime;\n\n    (SystemTime::now().duration_since(SystemTime::UNIX_EPOCH))\n        .expect(\"System clock was before 1970.\")\n        .as_nanos()\n        .try_into()\n        .expect(\"This function will be removed long before this is an issue.\")\n}","Real(LocalPath(\"src/lib.rs\"))"],"precise_time_s":["#[cfg(all(feature = \"std\", feature = \"deprecated\"))]\n#[allow(clippy::missing_docs_in_private_items)]\n#[deprecated(\n    since = \"0.2.0\",\n    note = \"Use `OffsetDateTime::now() - OffsetDateTime::unix_epoch()` to get a `Duration` since \\\n            a known epoch.\"\n)]\npub fn precise_time_s() -> f64{\n    use std::time::SystemTime;\n\n    (SystemTime::now().duration_since(SystemTime::UNIX_EPOCH))\n        .expect(\"System clock was before 1970.\")\n        .as_secs_f64()\n}","Real(LocalPath(\"src/lib.rs\"))"],"primitive_date_time::<impl std::cmp::PartialEq<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::eq":["fn eq(&self, rhs: &PrimitiveDateTime) -> bool{\n        &PrimitiveDateTime::from(*self) == rhs\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::<impl std::cmp::PartialOrd<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::partial_cmp":["fn partial_cmp(&self, other: &PrimitiveDateTime) -> Option<Ordering>{\n        PrimitiveDateTime::from(*self).partial_cmp(other)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::<impl std::convert::From<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::from":["fn from(datetime: PrimitiveDateTime) -> Self{\n        let duration = datetime - PrimitiveDateTime::unix_epoch();\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            // duration.is_negative()\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::<impl std::ops::Sub<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::sub":["fn sub(self, rhs: PrimitiveDateTime) -> Self::Output{\n        PrimitiveDateTime::from(self) - rhs\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime":["/// Combined date and time.\npub struct PrimitiveDateTime {\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) date: Date,\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) time: Time,\n}","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::assume_offset":["/// Assuming that the existing `PrimitiveDateTime` represents a moment in\n/// the provided `UtcOffset`, return an `OffsetDateTime`.\n///\n/// ```rust\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(2019-01-01).midnight().assume_offset(offset!(UTC)).unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01).midnight().assume_offset(offset!(-1)).unix_timestamp(),\n///     1_546_304_400,\n/// );\n/// ```\npub fn assume_offset(self, offset: UtcOffset) -> OffsetDateTime{\n        OffsetDateTime::new_assuming_offset(self, offset)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::assume_utc":["/// Assuming that the existing `PrimitiveDateTime` represents a moment in\n/// the UTC, return an `OffsetDateTime`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-01).midnight().assume_utc().unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// ```\n///\n/// This function is the same as calling `.assume_offset(offset!(UTC))`,\n/// except it is usable in `const` contexts.\npub const fn assume_utc(self) -> OffsetDateTime{\n        OffsetDateTime::new_assuming_utc(self)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::date":["/// Get the `Date` component of the `PrimitiveDateTime`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-01).midnight().date(),\n///     date!(2019-01-01)\n/// );\n/// ```\npub const fn date(self) -> Date{\n        self.date\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::day":["/// Get the day of the date.  If fetching both the month and day, it is\n/// more efficient to use [`PrimitiveDateTime::month_day`].\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-1-1).midnight().day(), 1);\n/// assert_eq!(date!(2019-12-31).midnight().day(), 31);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn day(self) -> u8{\n        self.date().day()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::format":["/// Format the `PrimitiveDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-02).midnight().format(\"%F %r\"),\n///     \"2019-01-02 12:00:00 am\"\n/// );\n/// ```\npub fn format(self, format: impl AsRef<str>) -> String{\n        self.lazy_format(format).to_string()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::from_unix_timestamp":["/// Create a `PrimitiveDateTime` from the provided [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{date, PrimitiveDateTime};\n/// assert_eq!(\n///     PrimitiveDateTime::from_unix_timestamp(0),\n///     PrimitiveDateTime::unix_epoch()\n/// );\n/// assert_eq!(\n///     PrimitiveDateTime::from_unix_timestamp(1_546_300_800),\n///     date!(2019-01-01).midnight(),\n/// );\n/// ```\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n#[allow(deprecated)]\npub fn from_unix_timestamp(timestamp: i64) -> Self{\n        Self::unix_epoch() + Duration::seconds(timestamp)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::hour":["/// Get the clock hour.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().hour(), 0);\n/// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).hour(), 23);\n/// ```\npub const fn hour(self) -> u8{\n        self.time().hour()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::iso_year_week":["/// Get the ISO 8601 year and week number.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().iso_year_week(), (2019, 1));\n/// assert_eq!(date!(2019-10-04).midnight().iso_year_week(), (2019, 40));\n/// assert_eq!(date!(2020-01-01).midnight().iso_year_week(), (2020, 1));\n/// assert_eq!(date!(2020-12-31).midnight().iso_year_week(), (2020, 53));\n/// assert_eq!(date!(2021-01-01).midnight().iso_year_week(), (2020, 53));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn iso_year_week(self) -> (i32, u8){\n        self.date().iso_year_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::lazy_format":["/// Format the `PrimitiveDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(\n///     date!(2019-01-02).midnight().lazy_format(\"%F %r\").to_string(),\n///     \"2019-01-02 12:00:00 am\"\n/// );\n/// ```\npub fn lazy_format(self, format: impl AsRef<str>) -> impl Display{\n        DeferredFormat::new(format.as_ref())\n            .with_date(self.date())\n            .with_time(self.time())\n            .to_owned()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::microsecond":["/// Get the microseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().microsecond(), 0);\n/// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59.999_999)).microsecond(), 999_999);\n/// ```\npub const fn microsecond(self) -> u32{\n        self.time().microsecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::millisecond":["/// Get the milliseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().millisecond(), 0);\n/// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59.999)).millisecond(), 999);\n/// ```\npub const fn millisecond(self) -> u16{\n        self.time().millisecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::minute":["/// Get the minute within the hour.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().minute(), 0);\n/// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).minute(), 59);\n/// ```\npub const fn minute(self) -> u8{\n        self.time().minute()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::monday_based_week":["/// Get the week number where week 1 begins on the first Monday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().monday_based_week(), 0);\n/// assert_eq!(date!(2020-01-01).midnight().monday_based_week(), 0);\n/// assert_eq!(date!(2020-12-31).midnight().monday_based_week(), 52);\n/// assert_eq!(date!(2021-01-01).midnight().monday_based_week(), 0);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn monday_based_week(self) -> u8{\n        self.date().monday_based_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::month":["/// Get the month of the date. If fetching both the month and day, it is\n/// more efficient to use [`PrimitiveDateTime::month_day`].\n///\n/// The returned value will always be in the range `1..=12`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().month(), 1);\n/// assert_eq!(date!(2019-12-31).midnight().month(), 12);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn month(self) -> u8{\n        self.date().month()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::month_day":["/// Get the month and day of the date. This is more efficient than fetching\n/// the components individually.\n///\n/// The month component will always be in the range `1..=12`;\n/// the day component in `1..=31`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().month_day(), (1, 1));\n/// assert_eq!(date!(2019-12-31).midnight().month_day(), (12, 31));\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn month_day(self) -> (u8, u8){\n        self.date().month_day()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::nanosecond":["/// Get the nanoseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().nanosecond(), 0);\n/// assert_eq!(\n///     date!(2019-01-01).with_time(time!(23:59:59.999_999_999)).nanosecond(),\n///     999_999_999,\n/// );\n/// ```\npub const fn nanosecond(self) -> u32{\n        self.time().nanosecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::new":["/// Create a new `PrimitiveDateTime` from the provided `Date` and `Time`.\n///\n/// ```rust\n/// # use time::{PrimitiveDateTime, time, date};\n/// assert_eq!(\n///     PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)),\n///     date!(2019-01-01).midnight(),\n/// );\n/// ```\npub const fn new(date: Date, time: Time) -> Self{\n        Self { date, time }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::now":["/// Create a new `PrimitiveDateTime` with the current date and time (UTC).\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::PrimitiveDateTime;\n/// assert!(PrimitiveDateTime::now().year() >= 2019);\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\npub fn now() -> Self{\n        SystemTime::now().into()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::ordinal":["/// Get the day of the year.\n///\n/// The returned value will always be in the range `1..=366` (`1..=365` for\n/// common years).\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().ordinal(), 1);\n/// assert_eq!(date!(2019-12-31).midnight().ordinal(), 365);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn ordinal(self) -> u16{\n        self.date().ordinal()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::parse":["/// Attempt to parse a `PrimitiveDateTime` using the provided string.\n///\n/// ```rust\n/// # use time::{date, PrimitiveDateTime, time};\n/// assert_eq!(\n///     PrimitiveDateTime::parse(\"2019-01-02 00:00:00\", \"%F %T\"),\n///     Ok(date!(2019-01-02).midnight()),\n/// );\n/// assert_eq!(\n///     PrimitiveDateTime::parse(\"2019-002 23:59:59\", \"%Y-%j %T\"),\n///     Ok(date!(2019-002).with_time(time!(23:59:59)))\n/// );\n/// assert_eq!(\n///     PrimitiveDateTime::parse(\"2019-W01-3 12:00:00 pm\", \"%G-W%V-%u %r\"),\n///     Ok(date!(2019-W01-3).with_time(time!(12:00))),\n/// );\n/// ```\npub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::second":["/// Get the second within the minute.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().second(), 0);\n/// assert_eq!(date!(2019-01-01).with_time(time!(23:59:59)).second(), 59);\n/// ```\npub const fn second(self) -> u8{\n        self.time().second()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["/// Get the week number where week 1 begins on the first Sunday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().sunday_based_week(), 0);\n/// assert_eq!(date!(2020-01-01).midnight().sunday_based_week(), 0);\n/// assert_eq!(date!(2020-12-31).midnight().sunday_based_week(), 52);\n/// assert_eq!(date!(2021-01-01).midnight().sunday_based_week(), 0);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn sunday_based_week(self) -> u8{\n        self.date().sunday_based_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::time":["/// Get the `Time` component of the `PrimitiveDateTime`.\n///\n/// ```rust\n/// # use time::{date, time};\n/// assert_eq!(date!(2019-01-01).midnight().time(), time!(0:00));\npub const fn time(self) -> Time{\n        self.time\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::timestamp":["/// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time)\n/// representing the `PrimitiveDateTime`.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{date, PrimitiveDateTime};\n/// assert_eq!(PrimitiveDateTime::unix_epoch().timestamp(), 0);\n/// assert_eq!(date!(2019-01-01).midnight().timestamp(), 1_546_300_800);\n/// ```\n#[allow(deprecated)]\n#[deprecated(since = \"0.2.7\", note = \"This method assumes an offset of UTC.\")]\npub fn timestamp(self) -> i64{\n        let days = (self.date.julian_day()\n            - internals::Date::from_yo_unchecked(1970, 1).julian_day())\n            * 86_400;\n        let hours = self.hour() as i64 * 3_600;\n        let minutes = self.minute() as i64 * 60;\n        let seconds = self.second() as i64;\n        days + hours + minutes + seconds\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::try_from_parsed_items":["/// Given the items already parsed, attempt to create a `PrimitiveDateTime`.\npub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self>{\n        Ok(Self {\n            date: Date::try_from_parsed_items(items)?,\n            time: Time::try_from_parsed_items(items)?,\n        })\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::unix_epoch":["/// Midnight, 1 January, 1970 (UTC).\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{PrimitiveDateTime, date};\n/// assert_eq!(\n///     PrimitiveDateTime::unix_epoch(),\n///     date!(1970-01-01).midnight()\n/// );\n/// ```\n#[deprecated(since = \"0.2.7\", note = \"This method assumes an offset of UTC.\")]\npub const fn unix_epoch() -> Self{\n        Self {\n            date: internals::Date::from_yo_unchecked(1970, 1),\n            time: Time::midnight(),\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::using_offset":["/// Assuming that the existing `PrimitiveDateTime` represents a moment in\n/// the UTC, return an `OffsetDateTime` with the provided `UtcOffset`.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{date, offset};\n/// assert_eq!(\n///     date!(2019-01-01).midnight().using_offset(offset!(UTC)).unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// assert_eq!(\n///     date!(2019-01-01).midnight().using_offset(offset!(-1)).unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// ```\n///\n/// This function is the same as calling `.assume_utc().to_offset(offset)`.\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"Due to behavior not clear by its name alone, it is preferred to use \\\n                `.assume_utc().to_offset(offset)`. This has the same behavior and can be used in \\\n                `const` contexts.\"\n    )]\npub const fn using_offset(self, offset: UtcOffset) -> OffsetDateTime{\n        self.assume_utc().to_offset(offset)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::week":["/// Get the ISO week number.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().week(), 1);\n/// assert_eq!(date!(2019-10-04).midnight().week(), 40);\n/// assert_eq!(date!(2020-01-01).midnight().week(), 1);\n/// assert_eq!(date!(2020-12-31).midnight().week(), 53);\n/// assert_eq!(date!(2021-01-01).midnight().week(), 53);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn week(self) -> u8{\n        self.date().week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::weekday":["/// Get the weekday.\n///\n/// This current uses [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence)\n/// internally.\n///\n/// ```rust\n/// # use time::{date, Weekday::*};\n/// assert_eq!(date!(2019-01-01).midnight().weekday(), Tuesday);\n/// assert_eq!(date!(2019-02-01).midnight().weekday(), Friday);\n/// assert_eq!(date!(2019-03-01).midnight().weekday(), Friday);\n/// assert_eq!(date!(2019-04-01).midnight().weekday(), Monday);\n/// assert_eq!(date!(2019-05-01).midnight().weekday(), Wednesday);\n/// assert_eq!(date!(2019-06-01).midnight().weekday(), Saturday);\n/// assert_eq!(date!(2019-07-01).midnight().weekday(), Monday);\n/// assert_eq!(date!(2019-08-01).midnight().weekday(), Thursday);\n/// assert_eq!(date!(2019-09-01).midnight().weekday(), Sunday);\n/// assert_eq!(date!(2019-10-01).midnight().weekday(), Tuesday);\n/// assert_eq!(date!(2019-11-01).midnight().weekday(), Friday);\n/// assert_eq!(date!(2019-12-01).midnight().weekday(), Sunday);\n/// ```\npub fn weekday(self) -> Weekday{\n        self.date().weekday()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::year":["/// Get the year of the date.\n///\n/// ```rust\n/// # use time::date;\n/// assert_eq!(date!(2019-01-01).midnight().year(), 2019);\n/// assert_eq!(date!(2019-12-31).midnight().year(), 2019);\n/// assert_eq!(date!(2020-01-01).midnight().year(), 2020);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn year(self) -> i32{\n        self.date().year()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"private::Parsable":["pub trait Parsable: Sized {\n        fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for f32>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for f64>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for i128>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for i16>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for i32>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for i64>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Div<sign::Sign> for i8>::div":["fn div(self, rhs: Sign) -> Self::Output{\n                    self * rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for f32>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for f64>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for i128>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for i16>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for i32>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for i64>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::DivAssign<sign::Sign> for i8>::div_assign":["fn div_assign(&mut self, rhs: Sign){\n                    *self *= rhs\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for f32>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for f64>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for i128>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for i16>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for i32>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for i64>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::Mul<sign::Sign> for i8>::mul":["fn mul(self, rhs: Sign) -> Self::Output{\n                    rhs * self\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for f32>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for f64>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for i128>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for i16>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for i32>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for i64>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::<impl std::ops::MulAssign<sign::Sign> for i8>::mul_assign":["#[allow(trivial_numeric_casts)]\nfn mul_assign(&mut self, rhs: Sign){\n                    *self *= rhs as i8 as $type;\n                }","Real(LocalPath(\"src/sign.rs\"))"],"sign::Sign":["/// Contains the sign of a value: positive, negative, or zero.\n///\n/// For ease of use, `Sign` implements [`Mul`] and [`Div`] on all signed numeric\n/// types. `Sign`s can also be multiplied and divided by another `Sign`, which\n/// follows the same rules as real numbers.\n#[repr(i8)]\n#[deprecated(\n    since = \"0.2.7\",\n    note = \"The only use for this (obtaining the sign of a `Duration`) can be replaced with \\\n            `Duration::is_{positive|negative|zero}`\"\n)]\npub enum Sign {\n    /// A positive value.\n    Positive = 1,\n\n    /// A negative value.\n    Negative = -1,\n\n    /// A value that is exactly zero.\n    Zero = 0,\n}","Real(LocalPath(\"src/sign.rs\"))"],"sign::Sign::is_negative":["/// Is the sign negative?\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Sign;\n/// assert!(!Sign::Positive.is_negative());\n/// assert!(Sign::Negative.is_negative());\n/// assert!(!Sign::Zero.is_negative());\n/// ```\npub const fn is_negative(self) -> bool{\n        self as u8 == Negative as u8\n    }","Real(LocalPath(\"src/sign.rs\"))"],"sign::Sign::is_positive":["/// Is the sign positive?\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Sign;\n/// assert!(Sign::Positive.is_positive());\n/// assert!(!Sign::Negative.is_positive());\n/// assert!(!Sign::Zero.is_positive());\n/// ```\npub const fn is_positive(self) -> bool{\n        self as u8 == Positive as u8\n    }","Real(LocalPath(\"src/sign.rs\"))"],"sign::Sign::is_zero":["/// Is the value exactly zero?\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Sign;\n/// assert!(!Sign::Positive.is_zero());\n/// assert!(!Sign::Negative.is_zero());\n/// assert!(Sign::Zero.is_zero());\n/// ```\npub const fn is_zero(self) -> bool{\n        self as u8 == Zero as u8\n    }","Real(LocalPath(\"src/sign.rs\"))"],"sign::Sign::negate":["/// Return the opposite of the current sign.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Sign;\n/// assert_eq!(Sign::Positive.negate(), Sign::Negative);\n/// assert_eq!(Sign::Negative.negate(), Sign::Positive);\n/// assert_eq!(Sign::Zero.negate(), Sign::Zero);\n/// ```\npub fn negate(self) -> Self{\n        match self {\n            Positive => Negative,\n            Negative => Positive,\n            Zero => Zero,\n        }\n    }","Real(LocalPath(\"src/sign.rs\"))"],"time_mod::Time":["/// The clock time within a given date. Nanosecond precision.\n///\n/// All minutes are assumed to have exactly 60 seconds; no attempt is made to\n/// handle leap seconds (either positive or negative).\n///\n/// When comparing two `Time`s, they are assumed to be in the same calendar\n/// date.\npub struct Time {\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) hour: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) minute: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) second: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) nanosecond: u32,\n}","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::format":["/// Format the `Time` using the provided string.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00).format(\"%r\"), \"12:00:00 am\");\n/// ```\npub fn format(self, format: impl AsRef<str>) -> String{\n        self.lazy_format(format).to_string()\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::from_nanoseconds_since_midnight":["/// Create a `Time` from the number of nanoseconds since midnight.\npub(crate) const fn from_nanoseconds_since_midnight(nanosecond: u64) -> Self{\n        Self {\n            hour: (nanosecond / 1_000_000_000 / 60 / 60 % 24) as u8,\n            minute: (nanosecond / 1_000_000_000 / 60 % 60) as u8,\n            second: (nanosecond / 1_000_000_000 % 60) as u8,\n            nanosecond: (nanosecond % 1_000_000_000) as u32,\n        }\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::hour":["/// Get the clock hour.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00:00).hour(), 0);\n/// assert_eq!(time!(23:59:59).hour(), 23);\n/// ```\npub const fn hour(self) -> u8{\n        self.hour\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::lazy_format":["/// Format the `Time` using the provided string.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00).lazy_format(\"%r\").to_string(), \"12:00:00 am\");\n/// ```\npub fn lazy_format(self, format: impl AsRef<str>) -> impl Display{\n        DeferredFormat::new(format.as_ref())\n            .with_time(self)\n            .to_owned()\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::microsecond":["/// Get the microseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00).microsecond(), 0);\n/// assert_eq!(time!(23:59:59.999_999).microsecond(), 999_999);\n/// ```\npub const fn microsecond(self) -> u32{\n        self.nanosecond() / 1_000\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::midnight":["/// Create a `Time` that is exactly midnight.\n///\n/// ```rust\n/// # use time::{Time, time};\n/// assert_eq!(Time::midnight(), time!(0:00));\n/// ```\npub const fn midnight() -> Self{\n        Time {\n            hour: 0,\n            minute: 0,\n            second: 0,\n            nanosecond: 0,\n        }\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::millisecond":["/// Get the milliseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00).millisecond(), 0);\n/// assert_eq!(time!(23:59:59.999).millisecond(), 999);\n/// ```\npub const fn millisecond(self) -> u16{\n        (self.nanosecond() / 1_000_000) as u16\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::minute":["/// Get the minute within the hour.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00:00).minute(), 0);\n/// assert_eq!(time!(23:59:59).minute(), 59);\n/// ```\npub const fn minute(self) -> u8{\n        self.minute\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::nanosecond":["/// Get the nanoseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00).nanosecond(), 0);\n/// assert_eq!(time!(23:59:59.999_999_999).nanosecond(), 999_999_999);\n/// ```\npub const fn nanosecond(self) -> u32{\n        self.nanosecond\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::nanoseconds_since_midnight":["/// Get the number of nanoseconds since midnight.\npub(crate) const fn nanoseconds_since_midnight(self) -> u64{\n        self.hour() as u64 * 60 * 60 * 1_000_000_000\n            + self.minute() as u64 * 60 * 1_000_000_000\n            + self.second() as u64 * 1_000_000_000\n            + self.nanosecond() as u64\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::now":["/// Create a `Time` representing the current time (UTC).\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::Time;\n/// println!(\"{:?}\", Time::now());\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.7\",\n        note = \"This method returns a value that assumes an offset of UTC.\"\n    )]\n#[allow(deprecated)]\npub fn now() -> Self{\n        PrimitiveDateTime::now().time()\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::parse":["/// Attempt to parse a `Time` using the provided string.\n///\n/// ```rust\n/// # use time::{Time, time};\n/// assert_eq!(\n///     Time::parse(\"0:00:00\", \"%T\"),\n///     Ok(time!(0:00))\n/// );\n/// assert_eq!(\n///     Time::parse(\"23:59:59\", \"%T\"),\n///     Ok(time!(23:59:59))\n/// );\n/// assert_eq!(\n///     Time::parse(\"12:00:00 am\", \"%r\"),\n///     Ok(time!(0:00))\n/// );\n/// assert_eq!(\n///     Time::parse(\"12:00:00 pm\", \"%r\"),\n///     Ok(time!(12:00))\n/// );\n/// assert_eq!(\n///     Time::parse(\"11:59:59 pm\", \"%r\"),\n///     Ok(time!(23:59:59))\n/// );\n/// ```\npub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::second":["/// Get the second within the minute.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::time;\n/// assert_eq!(time!(0:00:00).second(), 0);\n/// assert_eq!(time!(23:59:59).second(), 59);\n/// ```\npub const fn second(self) -> u8{\n        self.second\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_hms":["/// Attempt to create a `Time` from the hour, minute, and second.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms(1, 2, 3).is_ok());\n/// ```\n///\n/// Returns `None` if any component is not valid.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms(24, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::try_from_hms(0, 60, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::try_from_hms(0, 0, 60).is_err()); // 60 isn't a valid second.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_hms(\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: 0,\n        })\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_hms_micro":["/// Attempt to create a `Time` from the hour, minute, second, and microsecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_micro(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// Returns `None` if any component is not valid.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_micro(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::try_from_hms_micro(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::try_from_hms_micro(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::try_from_hms_micro(0, 0, 0, 1_000_000).is_err()); // 1_000_000 isn't a valid microsecond.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_hms_micro(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(microsecond in 0 => 999_999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: microsecond * 1_000,\n        })\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_hms_milli":["/// Attempt to create a `Time` from the hour, minute, second, and millisecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_milli(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// Returns `None` if any component is not valid.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_milli(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::try_from_hms_milli(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::try_from_hms_milli(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::try_from_hms_milli(0, 0, 0, 1_000).is_err()); // 1_000 isn't a valid millisecond.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_hms_milli(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(millisecond in 0 => 999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond: millisecond as u32 * 1_000_000,\n        })\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_hms_nano":["/// Attempt to create a `Time` from the hour, minute, second, and nanosecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_nano(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// Returns `None` if any component is not valid.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::try_from_hms_nano(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::try_from_hms_nano(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::try_from_hms_nano(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::try_from_hms_nano(0, 0, 0, 1_000_000_000).is_err()); // 1_000_000_000 isn't a valid nanosecond.\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn try_from_hms_nano(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(nanosecond in 0 => 999_999_999);\n        Ok(Self {\n            hour,\n            minute,\n            second,\n            nanosecond,\n        })\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_parsed_items":["/// Given the items already parsed, attempt to create a `Time`.\npub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self>{\n        macro_rules! items {\n            ($($item:ident),* $(,)?) => {\n                ParsedItems { $($item: Some($item)),*, .. }\n            };\n        }\n\n        /// Convert a 12-hour time to a 24-hour time.\n        #[allow(clippy::missing_const_for_fn)] // internal fn in non-const outer fn\n        fn hour_12_to_24(hour: NonZeroU8, am_pm: AmPm) -> u8 {\n            use AmPm::{AM, PM};\n            match (hour.get(), am_pm) {\n                (12, AM) => 0,\n                (12, PM) => 12,\n                (h, AM) => h,\n                (h, PM) => h + 12,\n            }\n        }\n\n        match items {\n            items!(hour_24, minute, second, nanosecond) => {\n                Self::try_from_hms_nano(hour_24, minute, second, nanosecond).map_err(Into::into)\n            }\n            items!(hour_12, minute, second, nanosecond, am_pm) => {\n                Self::try_from_hms_nano(hour_12_to_24(hour_12, am_pm), minute, second, nanosecond)\n                    .map_err(Into::into)\n            }\n            items!(hour_24, minute, second) => {\n                Self::try_from_hms(hour_24, minute, second).map_err(Into::into)\n            }\n            items!(hour_12, minute, second, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), minute, second)\n                    .map_err(Into::into)\n            }\n            items!(hour_24, minute) => Self::try_from_hms(hour_24, minute, 0).map_err(Into::into),\n            items!(hour_12, minute, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), minute, 0).map_err(Into::into)\n            }\n            items!(hour_24) => Self::try_from_hms(hour_24, 0, 0).map_err(Into::into),\n            items!(hour_12, am_pm) => {\n                Self::try_from_hms(hour_12_to_24(hour_12, am_pm), 0, 0).map_err(Into::into)\n            }\n            _ => Err(error::Parse::InsufficientInformation),\n        }\n    }","Real(LocalPath(\"src/time_mod.rs\"))"],"time_mod::Time::try_from_parsed_items::hour_12_to_24":["/// Convert a 12-hour time to a 24-hour time.\n#[allow(clippy::missing_const_for_fn)]\nfn hour_12_to_24(hour: NonZeroU8, am_pm: AmPm) -> u8{\n            use AmPm::{AM, PM};\n            match (hour.get(), am_pm) {\n                (12, AM) => 0,\n                (12, PM) => 12,\n                (h, AM) => h,\n                (h, PM) => h + 12,\n            }\n        }","Real(LocalPath(\"src/time_mod.rs\"))"],"utc_offset::UtcOffset":["/// An offset from UTC.\n///\n/// Guaranteed to store values up to 23:59:59. Any values outside this range\n/// may have incidental support that can change at any time without notice. If\n/// you need support outside this range, please file an issue with your use\n/// case.\npub struct UtcOffset {\n    /// The number of seconds offset from UTC. Positive is east, negative is\n    /// west.\n    pub(crate) seconds: i32,\n}","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::as_duration":["/// Convert a `UtcOffset` to ` Duration`. Useful for implementing operators.\npub(crate) const fn as_duration(self) -> Duration{\n        Duration::seconds(self.seconds as i64)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::as_hours":["/// Get the number of hours from UTC the value is. Positive is east,\n/// negative is west.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::UTC.as_hours(), 0);\n/// assert_eq!(UtcOffset::hours(12).as_hours(), 12);\n/// assert_eq!(UtcOffset::hours(-12).as_hours(), -12);\n/// ```\npub const fn as_hours(self) -> i8{\n        (self.as_seconds() / 3_600) as i8\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::as_minutes":["/// Get the number of minutes from UTC the value is. Positive is east,\n/// negative is west.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::UTC.as_minutes(), 0);\n/// assert_eq!(UtcOffset::hours(12).as_minutes(), 720);\n/// assert_eq!(UtcOffset::hours(-12).as_minutes(), -720);\n/// ```\npub const fn as_minutes(self) -> i16{\n        (self.as_seconds() / 60) as i16\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::as_seconds":["/// Get the number of seconds from UTC the value is. Positive is east,\n/// negative is west.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::UTC.as_seconds(), 0);\n/// assert_eq!(UtcOffset::hours(12).as_seconds(), 43_200);\n/// assert_eq!(UtcOffset::hours(-12).as_seconds(), -43_200);\n/// ```\npub const fn as_seconds(self) -> i32{\n        self.seconds\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::current_local_offset":["/// Obtain the system's current UTC offset. If the offset cannot be\n/// determined, UTC is returned.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::UtcOffset;\n/// let local_offset = UtcOffset::current_local_offset();\n/// println!(\"{}\", local_offset.format(\"%z\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\npub fn current_local_offset() -> Self{\n        let now = OffsetDateTime::now_utc();\n        try_local_offset_at(now).unwrap_or(Self::UTC)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::east_hours":["/// Create a `UtcOffset` representing an easterly offset by the number of\n/// hours provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::east_hours(1).as_hours(), 1);\n/// assert_eq!(UtcOffset::east_hours(2).as_minutes(), 120);\n/// ```\npub const fn east_hours(hours: u8) -> Self{\n        Self::hours(hours as i8)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::east_minutes":["/// Create a `UtcOffset` representing an easterly offset by the number of\n/// minutes provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::east_minutes(60).as_hours(), 1);\n/// ```\npub const fn east_minutes(minutes: u16) -> Self{\n        Self::minutes(minutes as i16)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::east_seconds":["/// Create a `UtcOffset` representing an easterly offset by the number of\n/// seconds provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::east_seconds(3_600).as_hours(), 1);\n/// assert_eq!(UtcOffset::east_seconds(1_800).as_minutes(), 30);\n/// ```\npub const fn east_seconds(seconds: u32) -> Self{\n        Self::seconds(seconds as i32)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::format":["/// Format the `UtcOffset` using the provided string.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::hours(2).format(\"%z\"), \"+0200\");\n/// assert_eq!(UtcOffset::hours(-2).format(\"%z\"), \"-0200\");\n/// ```\npub fn format(self, format: impl AsRef<str>) -> String{\n        self.lazy_format(format).to_string()\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::hours":["/// Create a `UtcOffset` representing an offset by the number of hours\n/// provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::hours(2).as_minutes(), 120);\n/// assert_eq!(UtcOffset::hours(-2).as_minutes(), -120);\n/// ```\npub const fn hours(hours: i8) -> Self{\n        Self::seconds(hours as i32 * 3_600)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::lazy_format":["/// Format the `UtcOffset` using the provided string.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::hours(2).lazy_format(\"%z\").to_string(), \"+0200\");\n/// assert_eq!(UtcOffset::hours(-2).lazy_format(\"%z\").to_string(), \"-0200\");\n/// ```\npub fn lazy_format(self, format: impl AsRef<str>) -> impl Display{\n        DeferredFormat::new(format.as_ref())\n            .with_offset(self)\n            .to_owned()\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::local_offset_at":["/// Obtain the system's UTC offset at a known moment in time. If the offset\n/// cannot be determined, UTC is returned.\n///\n/// ```rust\n/// # #![allow(deprecated)]\n/// # use time::{UtcOffset, OffsetDateTime};\n/// let unix_epoch = OffsetDateTime::unix_epoch();\n/// let local_offset = UtcOffset::local_offset_at(unix_epoch);\n/// println!(\"{}\", local_offset.format(\"%z\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[deprecated(\n        since = \"0.2.23\",\n        note = \"UTC is returned if the local offset cannot be determined\"\n    )]\npub fn local_offset_at(datetime: OffsetDateTime) -> Self{\n        try_local_offset_at(datetime).unwrap_or(Self::UTC)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::minutes":["/// Create a `UtcOffset` representing a offset by the number of minutes\n/// provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::minutes(60).as_hours(), 1);\n/// assert_eq!(UtcOffset::minutes(-60).as_hours(), -1);\n/// ```\npub const fn minutes(minutes: i16) -> Self{\n        Self::seconds(minutes as i32 * 60)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::parse":["/// Attempt to parse the `UtcOffset` using the provided string.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::parse(\"+0200\", \"%z\"), Ok(UtcOffset::hours(2)));\n/// assert_eq!(UtcOffset::parse(\"-0200\", \"%z\"), Ok(UtcOffset::hours(-2)));\n/// ```\npub fn parse(s: impl AsRef<str>, format: impl AsRef<str>) -> ParseResult<Self>{\n        Self::try_from_parsed_items(parse(s.as_ref(), &format.into())?)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::seconds":["/// Create a `UtcOffset` representing an offset by the number of seconds\n/// provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::seconds(3_600).as_hours(), 1);\n/// assert_eq!(UtcOffset::seconds(-3_600).as_hours(), -1);\n/// ```\npub const fn seconds(seconds: i32) -> Self{\n        Self { seconds }\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::try_current_local_offset":["/// Attempt to obtain the system's current UTC offset. If the offset cannot\n/// be determined, an error is returned.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// let local_offset = UtcOffset::try_current_local_offset();\n/// # if false {\n/// assert!(local_offset.is_ok());\n/// # }\n/// ```\n#[cfg(feature = \"std\")]\npub fn try_current_local_offset() -> Result<Self, error::IndeterminateOffset>{\n        let now = OffsetDateTime::now_utc();\n        try_local_offset_at(now).ok_or(error::IndeterminateOffset)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::try_from_parsed_items":["/// Given the items already parsed, attempt to create a `UtcOffset`.\npub(crate) fn try_from_parsed_items(items: ParsedItems) -> ParseResult<Self>{\n        items.offset.ok_or(error::Parse::InsufficientInformation)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::try_local_offset_at":["/// Attempt to obtain the system's UTC offset at a known moment in time. If\n/// the offset cannot be determined, an error is returned.\n///\n/// ```rust\n/// # use time::{UtcOffset, OffsetDateTime};\n/// let unix_epoch = OffsetDateTime::unix_epoch();\n/// let local_offset = UtcOffset::try_local_offset_at(unix_epoch);\n/// # if false {\n/// assert!(local_offset.is_ok());\n/// # }\n/// ```\n#[cfg(feature = \"std\")]\npub fn try_local_offset_at(\n        datetime: OffsetDateTime,\n    ) -> Result<Self, error::IndeterminateOffset>{\n        try_local_offset_at(datetime).ok_or(error::IndeterminateOffset)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::west_hours":["/// Create a `UtcOffset` representing a westerly offset by the number of\n/// hours provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::west_hours(1).as_hours(), -1);\n/// assert_eq!(UtcOffset::west_hours(2).as_minutes(), -120);\n/// ```\npub const fn west_hours(hours: u8) -> Self{\n        Self::hours(-(hours as i8))\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::west_minutes":["/// Create a `UtcOffset` representing a westerly offset by the number of\n/// minutes provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::west_minutes(60).as_hours(), -1);\n/// ```\npub const fn west_minutes(minutes: u16) -> Self{\n        Self::minutes(-(minutes as i16))\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::west_seconds":["/// Create a `UtcOffset` representing a westerly offset by the number of\n/// seconds provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::west_seconds(3_600).as_hours(), -1);\n/// assert_eq!(UtcOffset::west_seconds(1_800).as_minutes(), -30);\n/// ```\npub const fn west_seconds(seconds: u32) -> Self{\n        Self::seconds(-(seconds as i32))\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::try_local_offset_at":["/// Attempt to obtain the system's UTC offset. If the offset cannot be\n/// determined, `None` is returned.\n#[cfg(feature = \"std\")]\n#[allow(clippy::too_many_lines, clippy::missing_const_for_fn)]\nfn try_local_offset_at(datetime: OffsetDateTime) -> Option<UtcOffset>{\n    #[cfg(target_family = \"unix\")]\n    {\n        // See #293 for details.\n        let _ = datetime;\n        None\n        // use standback::{convert::TryInto, mem::MaybeUninit};\n        //\n        // /// Convert the given Unix timestamp to a `libc::tm`. Returns `None` on\n        // /// any error.\n        // fn timestamp_to_tm(timestamp: i64) -> Option<libc::tm> {\n        //     extern \"C\" {\n        //         #[cfg_attr(target_os = \"netbsd\", link_name = \"__tzset50\")]\n        //         fn tzset();\n        //     }\n        //\n        //     // The exact type of `timestamp` beforehand can vary, so this\n        //     // conversion is necessary.\n        //     #[allow(clippy::useless_conversion)]\n        //     let timestamp = timestamp.try_into().ok()?;\n        //\n        //     let mut tm = MaybeUninit::uninit();\n        //\n        //     // Update timezone information from system. `localtime_r` does not\n        //     // do this for us.\n        //     //\n        //     // Safety: tzset is thread-safe.\n        //     #[allow(unsafe_code)]\n        //     unsafe {\n        //         tzset();\n        //     }\n        //\n        //     // Safety: We are calling a system API, which mutates the `tm`\n        //     // variable. If a null pointer is returned, an error occurred.\n        //     #[allow(unsafe_code)]\n        //     let tm_ptr = unsafe { libc::localtime_r(&timestamp, tm.as_mut_ptr()) };\n        //\n        //     if tm_ptr.is_null() {\n        //         None\n        //     } else {\n        //         // Safety: The value was initialized, as we no longer have a\n        //         // null pointer.\n        //         #[allow(unsafe_code)]\n        //         {\n        //             Some(unsafe { tm.assume_init() })\n        //         }\n        //     }\n        // }\n        //\n        // let tm = timestamp_to_tm(datetime.unix_timestamp())?;\n        //\n        // // `tm_gmtoff` extension\n        // #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n        // {\n        //     tm.tm_gmtoff.try_into().ok().map(UtcOffset::seconds)\n        // }\n        //\n        // // No `tm_gmtoff` extension\n        // #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n        // {\n        //     use crate::Date;\n        //     use standback::convert::TryFrom;\n        //\n        //     let mut tm = tm;\n        //     if tm.tm_sec == 60 {\n        //         // Leap seconds are not currently supported.\n        //         tm.tm_sec = 59;\n        //     }\n        //\n        //     let local_timestamp =\n        //         Date::try_from_yo(1900 + tm.tm_year, u16::try_from(tm.tm_yday).ok()? + 1)\n        //             .ok()?\n        //             .try_with_hms(\n        //                 tm.tm_hour.try_into().ok()?,\n        //                 tm.tm_min.try_into().ok()?,\n        //                 tm.tm_sec.try_into().ok()?,\n        //             )\n        //             .ok()?\n        //             .assume_utc()\n        //             .unix_timestamp();\n        //\n        //     (local_timestamp - datetime.unix_timestamp())\n        //         .try_into()\n        //         .ok()\n        //         .map(UtcOffset::seconds)\n        // }\n    }\n    #[cfg(target_family = \"windows\")]\n    {\n        use standback::{convert::TryInto, mem::MaybeUninit};\n        use winapi::{\n            shared::minwindef::FILETIME,\n            um::{\n                minwinbase::SYSTEMTIME,\n                timezoneapi::{SystemTimeToFileTime, SystemTimeToTzSpecificLocalTime},\n            },\n        };\n\n        /// Convert a `SYSTEMTIME` to a `FILETIME`. Returns `None` if any error\n        /// occurred.\n        fn systemtime_to_filetime(systime: &SYSTEMTIME) -> Option<FILETIME> {\n            let mut ft = MaybeUninit::uninit();\n\n            // Safety: `SystemTimeToFileTime` is thread-safe. We are only\n            // assuming initialization if the call succeeded.\n            #[allow(unsafe_code)]\n            {\n                if 0 == unsafe { SystemTimeToFileTime(systime, ft.as_mut_ptr()) } {\n                    // failed\n                    None\n                } else {\n                    Some(unsafe { ft.assume_init() })\n                }\n            }\n        }\n\n        /// Convert a `FILETIME` to an `i64`, representing a number of seconds.\n        fn filetime_to_secs(filetime: &FILETIME) -> i64 {\n            /// FILETIME represents 100-nanosecond intervals\n            const FT_TO_SECS: i64 = 10_000_000;\n            ((filetime.dwHighDateTime as i64) << 32 | filetime.dwLowDateTime as i64) / FT_TO_SECS\n        }\n\n        /// Convert an `OffsetDateTime` to a `SYSTEMTIME`.\n        fn offset_to_systemtime(datetime: OffsetDateTime) -> SYSTEMTIME {\n            let (month, day_of_month) = datetime.to_offset(UtcOffset::UTC).month_day();\n            SYSTEMTIME {\n                wYear: datetime.year() as u16,\n                wMonth: month as u16,\n                wDay: day_of_month as u16,\n                wDayOfWeek: 0, // ignored\n                wHour: datetime.hour() as u16,\n                wMinute: datetime.minute() as u16,\n                wSecond: datetime.second() as u16,\n                wMilliseconds: datetime.millisecond(),\n            }\n        }\n\n        // This function falls back to UTC if any system call fails.\n        let systime_utc = offset_to_systemtime(datetime.to_offset(UtcOffset::UTC));\n\n        // Safety: `local_time` is only read if it is properly initialized, and\n        // `SystemTimeToTzSpecificLocalTime` is thread-safe.\n        #[allow(unsafe_code)]\n        let systime_local = unsafe {\n            let mut local_time = MaybeUninit::uninit();\n\n            if 0 == SystemTimeToTzSpecificLocalTime(\n                core::ptr::null(), // use system's current timezone\n                &systime_utc,\n                local_time.as_mut_ptr(),\n            ) {\n                // call failed\n                return None;\n            } else {\n                local_time.assume_init()\n            }\n        };\n\n        // Convert SYSTEMTIMEs to FILETIMEs so we can perform arithmetic on\n        // them.\n        let ft_system = systemtime_to_filetime(&systime_utc)?;\n        let ft_local = systemtime_to_filetime(&systime_local)?;\n\n        let diff_secs = filetime_to_secs(&ft_local) - filetime_to_secs(&ft_system);\n\n        diff_secs.try_into().ok().map(UtcOffset::seconds)\n    }\n    #[cfg(__time_02_cargo_web)]\n    {\n        use stdweb::{js, unstable::TryInto};\n\n        let timestamp_utc = datetime.unix_timestamp();\n        let low_bits = (timestamp_utc & 0xFF_FF_FF_FF) as i32;\n        let high_bits = (timestamp_utc >> 32) as i32;\n\n        let timezone_offset = js! {\n            return\n                new Date(((@{high_bits} << 32) + @{low_bits}) * 1000)\n                    .getTimezoneOffset() * -60;\n        };\n\n        timezone_offset.try_into().ok().map(UtcOffset::seconds)\n    }\n    #[cfg(not(any(target_family = \"unix\", target_family = \"windows\", __time_02_cargo_web)))]\n    {\n        // Silence the unused variable warning when appropriate.\n        let _ = datetime;\n        None\n    }\n}","Real(LocalPath(\"src/utc_offset.rs\"))"],"util::days_in_year":["/// Get the number of calendar days in a given year.\n///\n/// The returned value will always be either 365 or 366.\n///\n/// ```rust\n/// # use time::days_in_year;\n/// assert_eq!(days_in_year(1900), 365);\n/// assert_eq!(days_in_year(2000), 366);\n/// assert_eq!(days_in_year(2004), 366);\n/// assert_eq!(days_in_year(2005), 365);\n/// assert_eq!(days_in_year(2100), 365);\n/// ```\npub const fn days_in_year(year: i32) -> u16{\n    365 + is_leap_year(year) as u16\n}","Real(LocalPath(\"src/util.rs\"))"],"util::days_in_year_month":["/// Get the number of days in the month of a given year.\npub(crate) const fn days_in_year_month(year: i32, month: u8) -> u8{\n    DAYS_IN_MONTH_COMMON_LEAP[is_leap_year(year) as usize][month as usize - 1] as u8\n}","Real(LocalPath(\"src/util.rs\"))"],"util::is_leap_year":["/// Returns if the provided year is a leap year in the proleptic Gregorian\n/// calendar. Uses [astronomical year numbering](https://en.wikipedia.org/wiki/Astronomical_year_numbering).\n///\n/// ```rust\n/// # use time::is_leap_year;\n/// assert!(!is_leap_year(1900));\n/// assert!(is_leap_year(2000));\n/// assert!(is_leap_year(2004));\n/// assert!(!is_leap_year(2005));\n/// assert!(!is_leap_year(2100));\n/// ```\npub const fn is_leap_year(year: i32) -> bool{\n    (year % 4 == 0) & ((year % 100 != 0) | (year % 400 == 0))\n}","Real(LocalPath(\"src/util.rs\"))"],"util::validate_format_string":["/// Checks if a user-provided formatting string is valid. If it isn't, a\n/// description of the error is returned.\npub fn validate_format_string(s: impl AsRef<str>) -> Result<(), String>{\n    try_parse_fmt_string(s.as_ref()).map(|_| ())\n}","Real(LocalPath(\"src/util.rs\"))"],"util::weeks_in_year":["/// Get the number of weeks in the ISO year.\n///\n/// The returned value will always be either 52 or 53.\n///\n/// ```rust\n/// # use time::weeks_in_year;\n/// assert_eq!(weeks_in_year(2019), 52);\n/// assert_eq!(weeks_in_year(2020), 53);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn weeks_in_year(year: i32) -> u8{\n    let weekday = internals::Date::from_yo_unchecked(year, 1).iso_weekday_number();\n\n    if weekday == 4 || weekday == 3 && is_leap_year(year) {\n        53\n    } else {\n        52\n    }\n}","Real(LocalPath(\"src/util.rs\"))"],"weekday::Weekday":["/// Days of the week.\n///\n/// As order is dependent on context (Sunday could be either\n/// two days after or five days before Friday), this type does not implement\n/// `PartialOrd` or `Ord`.\npub enum Weekday {\n    #[allow(clippy::missing_docs_in_private_items)]\n    Monday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Tuesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Wednesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Thursday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Friday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Saturday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Sunday,\n}","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::iso_weekday_number":["/// Get the ISO 8601 weekday number. Equivalent to\n/// [`Weekday::number_from_monday`].\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.iso_weekday_number(), 1);\n/// ```\npub const fn iso_weekday_number(self) -> u8{\n        self.number_from_monday()\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::next":["/// Get the next weekday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn next(self) -> Self{\n        match self {\n            Monday => Tuesday,\n            Tuesday => Wednesday,\n            Wednesday => Thursday,\n            Thursday => Friday,\n            Friday => Saturday,\n            Saturday => Sunday,\n            Sunday => Monday,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_days_from_monday":["/// Get the zero-indexed number of days from Monday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_days_from_monday(), 0);\n/// ```\npub const fn number_days_from_monday(self) -> u8{\n        self as u8\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_days_from_sunday":["/// Get the zero-indexed number of days from Sunday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_days_from_sunday(), 1);\n/// ```\npub const fn number_days_from_sunday(self) -> u8{\n        (self as u8 + 1) % 7\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_monday":["/// Get the one-indexed number of days from Monday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_from_monday(), 1);\n/// ```\npub const fn number_from_monday(self) -> u8{\n        self.number_days_from_monday() + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_sunday":["/// Get the one-indexed number of days from Sunday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_from_sunday(), 2);\n/// ```\npub const fn number_from_sunday(self) -> u8{\n        self.number_days_from_sunday() + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::previous":["/// Get the previous weekday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Tuesday.previous(), Weekday::Monday);\n/// ```\n///\n/// This function is `const fn` when using rustc >= 1.46.\npub const fn previous(self) -> Self{\n        match self {\n            Monday => Sunday,\n            Tuesday => Monday,\n            Wednesday => Tuesday,\n            Thursday => Wednesday,\n            Friday => Thursday,\n            Saturday => Friday,\n            Sunday => Saturday,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"]},"struct_constructor":{"&(dyn std::error::Error + 'static)":["source"],"(duration::Duration, T)":["time_fn"],"(i32, u16)":["as_yo"],"(i32, u8)":["iso_year_week"],"(i32, u8, u8)":["as_ymd"],"(u8, u8)":["month_day"],"<date::Date as std::ops::Add<duration::Duration>>::Output":["add"],"<date::Date as std::ops::Add<std::time::Duration>>::Output":["add"],"<date::Date as std::ops::Sub<duration::Duration>>::Output":["sub"],"<date::Date as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<date::Date as std::ops::Sub>::Output":["sub"],"<duration::Duration as std::ops::Add<std::time::Duration>>::Output":["add"],"<duration::Duration as std::ops::Add>::Output":["add"],"<duration::Duration as std::ops::Div<f32>>::Output":["div"],"<duration::Duration as std::ops::Div<f64>>::Output":["div"],"<duration::Duration as std::ops::Div<i16>>::Output":["div"],"<duration::Duration as std::ops::Div<i32>>::Output":["div"],"<duration::Duration as std::ops::Div<i8>>::Output":["div"],"<duration::Duration as std::ops::Div<std::time::Duration>>::Output":["div"],"<duration::Duration as std::ops::Div<u16>>::Output":["div"],"<duration::Duration as std::ops::Div<u32>>::Output":["div"],"<duration::Duration as std::ops::Div<u8>>::Output":["div"],"<duration::Duration as std::ops::Div>::Output":["div"],"<duration::Duration as std::ops::Mul<f32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<f64>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i16>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i8>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u16>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u8>>::Output":["mul"],"<duration::Duration as std::ops::Neg>::Output":["neg"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<duration::Duration as std::ops::Sub>::Output":["sub"],"<f32 as std::ops::Div<sign::Sign>>::Output":["div"],"<f32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<f32 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<f64 as std::ops::Div<sign::Sign>>::Output":["div"],"<f64 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<f64 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<i128 as std::ops::Div<sign::Sign>>::Output":["div"],"<i128 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<i16 as std::ops::Div<sign::Sign>>::Output":["div"],"<i16 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i16 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<i32 as std::ops::Div<sign::Sign>>::Output":["div"],"<i32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i32 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<i64 as std::ops::Div<sign::Sign>>::Output":["div"],"<i64 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<i8 as std::ops::Div<sign::Sign>>::Output":["div"],"<i8 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i8 as std::ops::Mul<sign::Sign>>::Output":["mul"],"<instant::Instant as std::ops::Add<duration::Duration>>::Output":["add"],"<instant::Instant as std::ops::Add<std::time::Duration>>::Output":["add"],"<instant::Instant as std::ops::Sub<duration::Duration>>::Output":["sub"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::Output":["sub"],"<instant::Instant as std::ops::Sub>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Add<duration::Duration>>::Output":["add"],"<offset_date_time::OffsetDateTime as std::ops::Add<std::time::Duration>>::Output":["add"],"<offset_date_time::OffsetDateTime as std::ops::Sub<duration::Duration>>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::Output":["add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::Output":["add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::SystemTime>>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::Output":["sub"],"<sign::Sign as std::ops::Div>::Output":["div"],"<sign::Sign as std::ops::Mul<f32>>::Output":["mul"],"<sign::Sign as std::ops::Mul<f64>>::Output":["mul"],"<sign::Sign as std::ops::Mul<i128>>::Output":["mul"],"<sign::Sign as std::ops::Mul<i16>>::Output":["mul"],"<sign::Sign as std::ops::Mul<i32>>::Output":["mul"],"<sign::Sign as std::ops::Mul<i64>>::Output":["mul"],"<sign::Sign as std::ops::Mul<i8>>::Output":["mul"],"<sign::Sign as std::ops::Mul>::Output":["mul"],"<sign::Sign as std::ops::Neg>::Output":["neg"],"<sign::Sign as std::ops::Not>::Output":["not"],"<std::time::Duration as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::Duration as std::ops::Div<duration::Duration>>::Output":["div"],"<std::time::Duration as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::Instant as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::Instant as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::Instant as std::ops::Sub<instant::Instant>>::Output":["sub"],"<std::time::SystemTime as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::SystemTime as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::SystemTime as std::ops::Sub<offset_date_time::OffsetDateTime>>::Output":["sub"],"<std::time::SystemTime as std::ops::Sub<primitive_date_time::PrimitiveDateTime>>::Output":["sub"],"<time_mod::Time as std::ops::Add<duration::Duration>>::Output":["add"],"<time_mod::Time as std::ops::Add<std::time::Duration>>::Output":["add"],"<time_mod::Time as std::ops::Sub<duration::Duration>>::Output":["sub"],"<time_mod::Time as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<time_mod::Time as std::ops::Sub>::Output":["sub"],"<u16 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<u32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<u8 as std::ops::Mul<duration::Duration>>::Output":["mul"],"bool":["eq","is_leap_year","is_negative","is_positive","is_zero"],"date::Date":["clone","date","from_iso_ywd_unchecked","from_julian_day","from_ymd_unchecked","from_yo_unchecked","parse","today","try_from_iso_ywd","try_from_parsed_items","try_from_ymd","try_from_yo"],"duration::Duration":["as_duration","clone","day","days","default","elapsed","from_std","hour","hours","max_value","microsecond","microseconds","millisecond","milliseconds","min_value","minute","minutes","nanosecond","nanoseconds","nanoseconds_i128","new","second","seconds","seconds_f32","seconds_f64","span","to","try_from","week","weeks","zero"],"error::ComponentRange":["clone"],"error::ConversionRange":["clone"],"error::Error":["clone","from"],"error::Format":["clone","from"],"error::IndeterminateOffset":["clone"],"f32":["as_seconds_f32"],"f64":["as_seconds_f64","precise_time_s"],"format::FormatItem":["clone"],"format::Padding":["clone"],"format::Specifier":["clone"],"format::deferred_format::DeferredFormat":["clone","new"],"format::format::Format":["clone","from"],"format::parse::AmPm":["clone"],"format::parse::Error":["clone","from"],"format::parse::ParsedItems":["clone","new","parse"],"i128":["timestamp_nanos","unix_timestamp_nanos","whole_microseconds","whole_milliseconds","whole_nanoseconds"],"i16":["adjustment","as_minutes","subsec_milliseconds"],"i32":["as_seconds","subsec_microseconds","subsec_nanoseconds","year"],"i64":["julian_day","num_days","num_hours","num_microseconds","num_milliseconds","num_minutes","num_nanoseconds","num_seconds","num_weeks","timestamp","unix_timestamp","whole_days","whole_hours","whole_minutes","whole_seconds","whole_weeks"],"i8":["as_hours"],"impl std::fmt::Display":["lazy_format"],"instant::Instant":["clone","from","now"],"offset_date_time::OffsetDateTime":["assume_offset","assume_utc","clone","from","from_unix_timestamp","from_unix_timestamp_nanos","new_assuming_offset","new_assuming_utc","now","now_local","now_utc","parse","try_from_parsed_items","try_now_local","unix_epoch","using_offset"],"primitive_date_time::PrimitiveDateTime":["clone","from","from_unix_timestamp","midnight","new","now","parse","try_from_parsed_items","try_with_hms","try_with_hms_micro","try_with_hms_milli","try_with_hms_nano","unix_epoch","with_time"],"sign::Sign":["clone","default","sign"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["format"],"std::time::Duration":["abs_std","days","hours","microseconds","milliseconds","minutes","nanoseconds","seconds","std_days","std_hours","std_microseconds","std_milliseconds","std_minutes","std_nanoseconds","std_seconds","std_weeks","to_std","try_from","weeks"],"std::time::Instant":["from"],"std::time::SystemTime":["from"],"std::vec::Vec":["parse_fmt_string","try_parse_fmt_string"],"time_mod::Time":["clone","from_hms_nanos_unchecked","from_nanoseconds_since_midnight","midnight","now","parse","time","try_from_hms","try_from_hms_micro","try_from_hms_milli","try_from_hms_nano","try_from_parsed_items"],"u16":["days_in_year","millisecond","ordinal"],"u32":["microsecond","nanosecond"],"u64":["nanoseconds_since_midnight","precise_time_ns"],"u8":["day","hour","hour_12_to_24","iso_weekday_number","jan_weekday","minute","monday_based_week","month","number_days_from_monday","number_days_from_sunday","number_from_monday","number_from_sunday","second","sunday_based_week","week","weeks_in_year"],"utc_offset::UtcOffset":["clone","current_local_offset","east_hours","east_minutes","east_seconds","hours","local_offset_at","minutes","offset","parse","seconds","try_current_local_offset","try_from_parsed_items","try_local_offset_at","west_hours","west_minutes","west_seconds"],"weekday::Weekday":["clone","weekday"]},"struct_to_trait":{"<T as ext::NumericalStdDurationShort>::T":["ext::NumericalStdDurationShort"],"date::Date":["private::Parsable","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"duration::Duration":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::TryFrom","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Div","std::ops::DivAssign","std::ops::Mul","std::ops::MulAssign","std::ops::Neg","std::ops::Sub","std::ops::SubAssign"],"error::ComponentRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::ConversionRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Format":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::IndeterminateOffset":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::FormatItem":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Padding":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Specifier":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::deferred_format::DeferredFormat":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::format::Format":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::parse::AmPm":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::parse::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::parse::ParsedItems":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"instant::Instant":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"offset_date_time::OffsetDateTime":["private::Parsable","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"primitive_date_time::PrimitiveDateTime":["private::Parsable","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"sign::Sign":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Div","std::ops::DivAssign","std::ops::Mul","std::ops::MulAssign","std::ops::Neg","std::ops::Not"],"std::num::NonZeroI16":["ext::NumericalDuration"],"std::num::NonZeroI32":["ext::NumericalDuration"],"std::num::NonZeroI64":["ext::NumericalDuration"],"std::num::NonZeroI8":["ext::NumericalDuration"],"std::num::NonZeroU16":["ext::NumericalDuration","ext::NumericalStdDuration"],"std::num::NonZeroU32":["ext::NumericalDuration","ext::NumericalStdDuration"],"std::num::NonZeroU64":["ext::NumericalStdDuration"],"std::num::NonZeroU8":["ext::NumericalDuration","ext::NumericalStdDuration"],"std::time::Duration":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::TryFrom","std::ops::Add","std::ops::Div","std::ops::Sub","std::ops::SubAssign"],"std::time::Instant":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"std::time::SystemTime":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"time_mod::Time":["private::Parsable","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"utc_offset::UtcOffset":["private::Parsable","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"weekday::Weekday":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<T as ext::NumericalStdDurationShort>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<T as ext::NumericalStdDurationShort>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDurationShort"],"<date::Date as private::Parsable>::parse":["parse","Real(LocalPath(\"src/lib.rs\"))","private::Parsable"],"<date::Date as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/date.rs\"))","std::cmp::Ord"],"<date::Date as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/date.rs\"))","std::cmp::PartialOrd"],"<date::Date as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Debug"],"<date::Date as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<date::Date as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/date.rs\"))","std::ops::Add"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/date.rs\"))","std::ops::Add"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::AddAssign"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::AddAssign"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::SubAssign"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::SubAssign"],"<duration::Duration as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::Ord"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["eq","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialEq"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialOrd"],"<duration::Duration as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialOrd"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["try_from","Real(LocalPath(\"src/duration.rs\"))","std::convert::TryFrom"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"<duration::Duration as std::ops::Add>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::AddAssign"],"<duration::Duration as std::ops::AddAssign>::add_assign":["add_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::AddAssign"],"<duration::Duration as std::ops::Div<f32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<f64>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i16>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i8>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u16>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u8>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["div_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::Mul<f32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<f64>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i16>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i8>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u16>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u8>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["mul_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::Neg>::neg":["neg","Real(LocalPath(\"src/duration.rs\"))","std::ops::Neg"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"<duration::Duration as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::SubAssign"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::SubAssign"],"<error::ComponentRange as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::ConversionRange as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Error as std::convert::From<error::ComponentRange>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<error::ConversionRange>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<error::Format>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<error::IndeterminateOffset>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<format::parse::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Format as std::convert::From<std::fmt::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Format as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Format as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::IndeterminateOffset as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<f32 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f32 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<format::deferred_format::DeferredFormat as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/format/deferred_format.rs\"))","std::fmt::Display"],"<format::format::Format as std::convert::From<T>>::from":["from","Real(LocalPath(\"src/format/format.rs\"))","std::convert::From"],"<format::parse::Error as std::convert::From<error::ComponentRange>>::from":["from","Real(LocalPath(\"src/format/parse.rs\"))","std::convert::From"],"<format::parse::Error as std::error::Error>::source":["source","Real(LocalPath(\"src/format/parse.rs\"))","std::error::Error"],"<format::parse::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/format/parse.rs\"))","std::fmt::Display"],"<i16 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i16 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i32 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i32 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i64 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i8 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["eq","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialEq"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialOrd"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["from","Real(LocalPath(\"src/instant.rs\"))","std::convert::From"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::AddAssign"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::AddAssign"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::SubAssign"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::SubAssign"],"<offset_date_time::OffsetDateTime as private::Parsable>::parse":["parse","Real(LocalPath(\"src/lib.rs\"))","private::Parsable"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::Ord"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/offset_date_time.rs\"))","std::convert::From"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/offset_date_time.rs\"))","std::fmt::Display"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/offset_date_time.rs\"))","std::hash::Hash"],"<offset_date_time::OffsetDateTime as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Add"],"<offset_date_time::OffsetDateTime as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Add"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::AddAssign"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::AddAssign"],"<offset_date_time::OffsetDateTime as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::SubAssign"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::SubAssign"],"<primitive_date_time::PrimitiveDateTime as private::Parsable>::parse":["parse","Real(LocalPath(\"src/lib.rs\"))","private::Parsable"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::Ord"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["eq","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::PartialEq"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::PartialOrd"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::PartialOrd"],"<primitive_date_time::PrimitiveDateTime as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::convert::From"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::fmt::Display"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Add"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::AddAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::AddAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::SubAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::SubAssign"],"<sign::Sign as std::default::Default>::default":["default","Real(LocalPath(\"src/sign.rs\"))","std::default::Default"],"<sign::Sign as std::ops::Div>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"<sign::Sign as std::ops::DivAssign>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"<sign::Sign as std::ops::Mul<f32>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<f64>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<i128>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<i16>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<i32>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<i64>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul<i8>>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"<sign::Sign as std::ops::MulAssign>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"<sign::Sign as std::ops::Neg>::neg":["neg","Real(LocalPath(\"src/sign.rs\"))","std::ops::Neg"],"<sign::Sign as std::ops::Not>::not":["not","Real(LocalPath(\"src/sign.rs\"))","std::ops::Not"],"<std::num::NonZeroI16 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI16 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI32 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI64 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroI8 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU16 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU32 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU64 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<std::num::NonZeroU8 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<time_mod::Time as private::Parsable>::parse":["parse","Real(LocalPath(\"src/lib.rs\"))","private::Parsable"],"<time_mod::Time as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/time_mod.rs\"))","std::cmp::Ord"],"<time_mod::Time as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/time_mod.rs\"))","std::cmp::PartialOrd"],"<time_mod::Time as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/time_mod.rs\"))","std::fmt::Display"],"<time_mod::Time as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::Add"],"<time_mod::Time as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::Add"],"<time_mod::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::AddAssign"],"<time_mod::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::AddAssign"],"<time_mod::Time as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::Sub"],"<time_mod::Time as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::Sub"],"<time_mod::Time as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::Sub"],"<time_mod::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::SubAssign"],"<time_mod::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/time_mod.rs\"))","std::ops::SubAssign"],"<u16 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u16 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u16 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u32 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u32 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<u8 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u8 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<utc_offset::UtcOffset as private::Parsable>::parse":["parse","Real(LocalPath(\"src/lib.rs\"))","private::Parsable"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/utc_offset.rs\"))","std::fmt::Display"],"<weekday::Weekday as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/weekday.rs\"))","std::fmt::Display"],"date::Date::as_ymd":["as_ymd","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::as_yo":["as_yo","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::day":["day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::format":["format","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_julian_day":["from_julian_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::iso_weekday_number":["iso_weekday_number","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::iso_year_week":["iso_year_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::julian_day":["julian_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::lazy_format":["lazy_format","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::midnight":["midnight","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::monday_based_week":["monday_based_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::month":["month","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::month_day":["month_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::next_day":["next_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::number_days_from_monday":["number_days_from_monday","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::number_days_from_sunday":["number_days_from_sunday","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::ordinal":["ordinal","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::parse":["parse","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::previous_day":["previous_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::sunday_based_week":["sunday_based_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::today":["today","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_from_iso_ywd":["try_from_iso_ywd","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_from_parsed_items":["try_from_parsed_items","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_from_parsed_items::adjustment":["adjustment","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_from_ymd":["try_from_ymd","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_from_yo":["try_from_yo","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_with_hms":["try_with_hms","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_with_hms_micro":["try_with_hms_micro","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_with_hms_milli":["try_with_hms_milli","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::try_with_hms_nano":["try_with_hms_nano","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::week":["week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::weekday":["weekday","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_time":["with_time","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::year":["year","Real(LocalPath(\"src/date.rs\"))",""],"date::div_floor":["div_floor","Real(LocalPath(\"src/date.rs\"))",""],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["eq","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialEq"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialOrd"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["try_from","Real(LocalPath(\"src/duration.rs\"))","std::convert::TryFrom"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["sub_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::SubAssign"],"duration::Duration::abs":["abs","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::abs_std":["abs_std","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::as_seconds_f32":["as_seconds_f32","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::as_seconds_f64":["as_seconds_f64","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_add":["checked_add","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_div":["checked_div","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_mul":["checked_mul","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_sub":["checked_sub","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::day":["day","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::days":["days","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::from_std":["from_std","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::hour":["hour","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::hours":["hours","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_negative":["is_negative","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_positive":["is_positive","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_zero":["is_zero","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::max_value":["max_value","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::microsecond":["microsecond","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::microseconds":["microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::millisecond":["millisecond","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::milliseconds":["milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::min_value":["min_value","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::minute":["minute","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::minutes":["minutes","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::nanosecond":["nanosecond","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::nanoseconds":["nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::nanoseconds_i128":["nanoseconds_i128","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::new":["new","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_days":["num_days","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_hours":["num_hours","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_microseconds":["num_microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_milliseconds":["num_milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_minutes":["num_minutes","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_nanoseconds":["num_nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_seconds":["num_seconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::num_weeks":["num_weeks","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::second":["second","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds":["seconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds_f32":["seconds_f32","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds_f64":["seconds_f64","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::sign":["sign","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::span":["span","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_microseconds":["subsec_microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_milliseconds":["subsec_milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_nanoseconds":["subsec_nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::time_fn":["time_fn","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::to_std":["to_std","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::week":["week","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::weeks":["weeks","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_days":["whole_days","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_hours":["whole_hours","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_microseconds":["whole_microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_milliseconds":["whole_milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_minutes":["whole_minutes","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_nanoseconds":["whole_nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_seconds":["whole_seconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_weeks":["whole_weeks","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::zero":["zero","Real(LocalPath(\"src/duration.rs\"))",""],"format::date::fmt_A":["fmt_A","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_B":["fmt_B","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_C":["fmt_C","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_G":["fmt_G","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_U":["fmt_U","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_V":["fmt_V","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_W":["fmt_W","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_Y":["fmt_Y","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_a":["fmt_a","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_b":["fmt_b","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_d":["fmt_d","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_g":["fmt_g","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_j":["fmt_j","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_m":["fmt_m","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_u":["fmt_u","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_w":["fmt_w","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::fmt_y":["fmt_y","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_A":["parse_A","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_B":["parse_B","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_C":["parse_C","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_G":["parse_G","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_U":["parse_U","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_V":["parse_V","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_W":["parse_W","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_Y":["parse_Y","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_a":["parse_a","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_b":["parse_b","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_d":["parse_d","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_g":["parse_g","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_j":["parse_j","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_m":["parse_m","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_u":["parse_u","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_w":["parse_w","Real(LocalPath(\"src/format/date.rs\"))",""],"format::date::parse_y":["parse_y","Real(LocalPath(\"src/format/date.rs\"))",""],"format::deferred_format::DeferredFormat::date":["date","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::new":["new","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::offset":["offset","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::time":["time","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::with_date":["with_date","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::with_offset":["with_offset","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::deferred_format::DeferredFormat::with_time":["with_time","Real(LocalPath(\"src/format/deferred_format.rs\"))",""],"format::format_specifier":["format_specifier","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::offset::fmt_z":["fmt_z","Real(LocalPath(\"src/format/offset.rs\"))",""],"format::offset::parse_z":["parse_z","Real(LocalPath(\"src/format/offset.rs\"))",""],"format::parse::ParsedItems::new":["new","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::consume_padding":["consume_padding","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::parse":["parse","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_char":["try_consume_char","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_char_case_insensitive":["try_consume_char_case_insensitive","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_digits":["try_consume_digits","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_exact_digits":["try_consume_exact_digits","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_first_match":["try_consume_first_match","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::try_consume_str":["try_consume_str","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse_items::parse_fmt_string":["parse_fmt_string","Real(LocalPath(\"src/format/parse_items.rs\"))",""],"format::parse_items::try_parse_fmt_string":["try_parse_fmt_string","Real(LocalPath(\"src/format/parse_items.rs\"))",""],"format::time::fmt_H":["fmt_H","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_I":["fmt_I","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_M":["fmt_M","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_N":["fmt_N","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_P":["fmt_P","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_S":["fmt_S","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::fmt_p":["fmt_p","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_H":["parse_H","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_I":["parse_I","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_M":["parse_M","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_N":["parse_N","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_P":["parse_P","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_S":["parse_S","Real(LocalPath(\"src/format/time.rs\"))",""],"format::time::parse_p":["parse_p","Real(LocalPath(\"src/format/time.rs\"))",""],"format::well_known::rfc3339::fmt":["fmt","Real(LocalPath(\"src/format/well_known.rs\"))",""],"format::well_known::rfc3339::parse":["parse","Real(LocalPath(\"src/format/well_known.rs\"))",""],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["eq","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialEq"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialOrd"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["from","Real(LocalPath(\"src/instant.rs\"))","std::convert::From"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["add_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::AddAssign"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["sub_assign","Real(LocalPath(\"src/instant.rs\"))","std::ops::SubAssign"],"instant::Instant::checked_add":["checked_add","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::checked_sub":["checked_sub","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::elapsed":["elapsed","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::now":["now","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::to":["to","Real(LocalPath(\"src/instant.rs\"))",""],"internals::Date::from_iso_ywd_unchecked":["from_iso_ywd_unchecked","Real(LocalPath(\"src/internals.rs\"))",""],"internals::Date::from_ymd_unchecked":["from_ymd_unchecked","Real(LocalPath(\"src/internals.rs\"))",""],"internals::Date::from_yo_unchecked":["from_yo_unchecked","Real(LocalPath(\"src/internals.rs\"))",""],"internals::Time::from_hms_nanos_unchecked":["from_hms_nanos_unchecked","Real(LocalPath(\"src/internals.rs\"))",""],"internals::jan_weekday":["jan_weekday","Real(LocalPath(\"src/internals.rs\"))",""],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["from","Real(LocalPath(\"src/offset_date_time.rs\"))","std::convert::From"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["add","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Add"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["add_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::AddAssign"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["sub_assign","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::SubAssign"],"offset_date_time::OffsetDateTime::date":["date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::day":["day","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::format":["format","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::from_unix_timestamp":["from_unix_timestamp","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["from_unix_timestamp_nanos","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::hour":["hour","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::iso_year_week":["iso_year_week","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::lazy_format":["lazy_format","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::microsecond":["microsecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::millisecond":["millisecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::minute":["minute","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::month":["month","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::month_day":["month_day","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::nanosecond":["nanosecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::new_assuming_offset":["new_assuming_offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::new_assuming_utc":["new_assuming_utc","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::now":["now","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::now_local":["now_local","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::now_utc":["now_utc","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::offset":["offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::ordinal":["ordinal","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::parse":["parse","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::second":["second","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::time":["time","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::timestamp":["timestamp","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::timestamp_nanos":["timestamp_nanos","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_offset":["to_offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::try_from_parsed_items":["try_from_parsed_items","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::try_now_local":["try_now_local","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::unix_epoch":["unix_epoch","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::unix_timestamp":["unix_timestamp","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["unix_timestamp_nanos","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::week":["week","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::weekday":["weekday","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::year":["year","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"parse":["parse","Real(LocalPath(\"src/lib.rs\"))",""],"precise_time_ns":["precise_time_ns","Real(LocalPath(\"src/lib.rs\"))",""],"precise_time_s":["precise_time_s","Real(LocalPath(\"src/lib.rs\"))",""],"primitive_date_time::<impl std::cmp::PartialEq<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::eq":["eq","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::PartialEq"],"primitive_date_time::<impl std::cmp::PartialOrd<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::cmp::PartialOrd"],"primitive_date_time::<impl std::convert::From<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::from":["from","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::convert::From"],"primitive_date_time::<impl std::ops::Sub<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"primitive_date_time::PrimitiveDateTime::assume_offset":["assume_offset","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::assume_utc":["assume_utc","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::date":["date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::day":["day","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::format":["format","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::from_unix_timestamp":["from_unix_timestamp","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::hour":["hour","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::iso_year_week":["iso_year_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::lazy_format":["lazy_format","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::microsecond":["microsecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::millisecond":["millisecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::minute":["minute","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::monday_based_week":["monday_based_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::month":["month","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::month_day":["month_day","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::nanosecond":["nanosecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::new":["new","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::now":["now","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::ordinal":["ordinal","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::parse":["parse","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::second":["second","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["sunday_based_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::time":["time","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::timestamp":["timestamp","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::try_from_parsed_items":["try_from_parsed_items","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::unix_epoch":["unix_epoch","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::using_offset":["using_offset","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::week":["week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::weekday":["weekday","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::year":["year","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"sign::<impl std::ops::Div<sign::Sign> for f32>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for f64>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for i128>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for i16>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for i32>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for i64>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::Div<sign::Sign> for i8>::div":["div","Real(LocalPath(\"src/sign.rs\"))","std::ops::Div"],"sign::<impl std::ops::DivAssign<sign::Sign> for f32>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for f64>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i128>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i16>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i32>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i64>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::DivAssign<sign::Sign> for i8>::div_assign":["div_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::DivAssign"],"sign::<impl std::ops::Mul<sign::Sign> for f32>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for f64>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for i128>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for i16>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for i32>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for i64>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::Mul<sign::Sign> for i8>::mul":["mul","Real(LocalPath(\"src/sign.rs\"))","std::ops::Mul"],"sign::<impl std::ops::MulAssign<sign::Sign> for f32>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for f64>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i128>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i16>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i32>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i64>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::<impl std::ops::MulAssign<sign::Sign> for i8>::mul_assign":["mul_assign","Real(LocalPath(\"src/sign.rs\"))","std::ops::MulAssign"],"sign::Sign::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))",""],"sign::Sign::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))",""],"sign::Sign::is_zero":["is_zero","Real(LocalPath(\"src/sign.rs\"))",""],"sign::Sign::negate":["negate","Real(LocalPath(\"src/sign.rs\"))",""],"time_mod::Time::format":["format","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::from_nanoseconds_since_midnight":["from_nanoseconds_since_midnight","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::hour":["hour","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::lazy_format":["lazy_format","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::microsecond":["microsecond","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::midnight":["midnight","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::millisecond":["millisecond","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::minute":["minute","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::nanosecond":["nanosecond","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::nanoseconds_since_midnight":["nanoseconds_since_midnight","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::now":["now","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::parse":["parse","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::second":["second","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_hms":["try_from_hms","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_hms_micro":["try_from_hms_micro","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_hms_milli":["try_from_hms_milli","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_hms_nano":["try_from_hms_nano","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_parsed_items":["try_from_parsed_items","Real(LocalPath(\"src/time_mod.rs\"))",""],"time_mod::Time::try_from_parsed_items::hour_12_to_24":["hour_12_to_24","Real(LocalPath(\"src/time_mod.rs\"))",""],"utc_offset::UtcOffset::as_duration":["as_duration","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::as_hours":["as_hours","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::as_minutes":["as_minutes","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::as_seconds":["as_seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::current_local_offset":["current_local_offset","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::east_hours":["east_hours","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::east_minutes":["east_minutes","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::east_seconds":["east_seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::format":["format","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::hours":["hours","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::lazy_format":["lazy_format","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::local_offset_at":["local_offset_at","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::minutes":["minutes","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::parse":["parse","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::seconds":["seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::try_current_local_offset":["try_current_local_offset","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::try_from_parsed_items":["try_from_parsed_items","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::try_local_offset_at":["try_local_offset_at","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::west_hours":["west_hours","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::west_minutes":["west_minutes","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::west_seconds":["west_seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::try_local_offset_at":["try_local_offset_at","Real(LocalPath(\"src/utc_offset.rs\"))",""],"util::days_in_year":["days_in_year","Real(LocalPath(\"src/util.rs\"))",""],"util::days_in_year_month":["days_in_year_month","Real(LocalPath(\"src/util.rs\"))",""],"util::is_leap_year":["is_leap_year","Real(LocalPath(\"src/util.rs\"))",""],"util::validate_format_string":["validate_format_string","Real(LocalPath(\"src/util.rs\"))",""],"util::weeks_in_year":["weeks_in_year","Real(LocalPath(\"src/util.rs\"))",""],"weekday::Weekday::iso_weekday_number":["iso_weekday_number","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::next":["next","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_days_from_monday":["number_days_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_days_from_sunday":["number_days_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_monday":["number_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_sunday":["number_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::previous":["previous","Real(LocalPath(\"src/weekday.rs\"))",""]},"trait_to_struct":{"ext::NumericalDuration":["std::num::NonZeroI16","std::num::NonZeroI32","std::num::NonZeroI64","std::num::NonZeroI8","std::num::NonZeroU16","std::num::NonZeroU32","std::num::NonZeroU8"],"ext::NumericalStdDuration":["std::num::NonZeroU16","std::num::NonZeroU32","std::num::NonZeroU64","std::num::NonZeroU8"],"ext::NumericalStdDurationShort":["<T as ext::NumericalStdDurationShort>::T"],"private::Parsable":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"std::clone::Clone":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","format::parse::ParsedItems","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::Eq":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::Ord":["date::Date","duration::Duration","error::Format","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset"],"std::cmp::PartialEq":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","std::time::Duration","std::time::Instant","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::PartialOrd":["date::Date","duration::Duration","error::Format","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time_mod::Time","utc_offset::UtcOffset"],"std::convert::From":["error::Error","error::Format","format::format::Format","format::parse::Error","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Instant","std::time::SystemTime"],"std::convert::TryFrom":["duration::Duration","std::time::Duration"],"std::default::Default":["duration::Duration","sign::Sign"],"std::error::Error":["error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::parse::Error"],"std::fmt::Debug":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","format::parse::ParsedItems","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::fmt::Display":["date::Date","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::deferred_format::DeferredFormat","format::parse::Error","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::hash::Hash":["date::Date","duration::Duration","error::ComponentRange","error::Format","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::Error","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::marker::Copy":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Format","error::IndeterminateOffset","format::Padding","format::Specifier","format::parse::AmPm","format::parse::ParsedItems","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::marker::StructuralEq":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::marker::StructuralPartialEq":["date::Date","duration::Duration","error::ComponentRange","error::ConversionRange","error::Error","error::Format","error::IndeterminateOffset","format::FormatItem","format::Padding","format::Specifier","format::deferred_format::DeferredFormat","format::format::Format","format::parse::AmPm","format::parse::Error","instant::Instant","primitive_date_time::PrimitiveDateTime","sign::Sign","time_mod::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::ops::Add":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time_mod::Time"],"std::ops::AddAssign":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Instant","std::time::SystemTime","time_mod::Time"],"std::ops::Div":["duration::Duration","sign::Sign","std::time::Duration"],"std::ops::DivAssign":["duration::Duration","sign::Sign"],"std::ops::Mul":["duration::Duration","sign::Sign"],"std::ops::MulAssign":["duration::Duration","sign::Sign"],"std::ops::Neg":["duration::Duration","sign::Sign"],"std::ops::Not":["sign::Sign"],"std::ops::Sub":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time_mod::Time"],"std::ops::SubAssign":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time_mod::Time"]},"type_to_def_path":{"date::Date":"date::Date","duration::Duration":"duration::Duration","error::ComponentRange":"error::ComponentRange","error::ConversionRange":"error::ConversionRange","error::Error":"error::Error","error::Format":"error::Format","error::IndeterminateOffset":"error::IndeterminateOffset","format::FormatItem<'a>":"format::FormatItem","format::Padding":"format::Padding","format::Specifier":"format::Specifier","format::deferred_format::DeferredFormat":"format::deferred_format::DeferredFormat","format::format::Format":"format::format::Format","format::parse::AmPm":"format::parse::AmPm","format::parse::Error":"format::parse::Error","format::parse::ParsedItems":"format::parse::ParsedItems","instant::Instant":"instant::Instant","internals::Date":"internals::Date","internals::Time":"internals::Time","offset_date_time::OffsetDateTime":"offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime":"primitive_date_time::PrimitiveDateTime","sign::Sign":"sign::Sign","time_mod::Time":"time_mod::Time","utc_offset::UtcOffset":"utc_offset::UtcOffset","weekday::Weekday":"weekday::Weekday"}}