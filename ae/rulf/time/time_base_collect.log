========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_days() {
        let duration = Duration::new(86400, 0);
        let expected = duration;
        let actual = duration.days();
        assert_eq!(actual, expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::{TryFrom, TryInto};
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::Duration as StdDuration;
    use crate::error;
    use crate::ext::{NumericalStdDuration, NumericalStdDurationShort};
    use crate::ext::ExtDuration;
    use crate::Duration;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(2);
        let std_duration: StdDuration = duration.into();
        let std_hours = std_duration.hours();
        let duration_hours: Duration = std_hours.try_into().expect("Failed to convert to Duration");
        assert_eq!(duration_hours, duration);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::{NumericalStdDuration, NumericalStdDurationShort};
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::{NumericalDuration, StdDuration};

    #[test]
    fn test_microseconds() {
        let duration = StdDuration::from_secs(5);
        let microseconds = duration.microseconds();
        assert_eq!(microseconds.as_micros(), 5_000_000);
    }
}
False
========================================
    use crate::ext::{NumericalStdDurationShort, NumericalStdDuration};
    use std::convert::TryFrom;
    use std::crate::Duration;
    use std::ops::TryInto;
    use std::cmp::Ordering;
    
    #[test]
    fn test_milliseconds() {
        let duration = Duration::new(1, 500_000_000);
        let duration_milliseconds = duration.milliseconds();
        let expected_milliseconds = 1_500;
        assert_eq!(duration_milliseconds.as_milliseconds(), expected_milliseconds);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_minutes() {
        use crate::ext::NumericalStdDuration;
        let dur1 = Duration::new(180, 0); // 3 minutes
        let dur2 = Duration::new(120, 0); // 2 minutes
        let dur3 = Duration::new(240, 0); // 4 minutes
        
        assert_eq!(<Duration as NumericalStdDuration>::std_minutes(dur1), dur2);
        assert_eq!(<Duration as NumericalStdDuration>::std_minutes(dur3), dur1);
        }
    }
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::crate::Duration;
    use crate::NumericalStdDuration;
    use crate::NumericalStdDurationShort;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::new(5, 500_000_000);
        let expected = 5_500_000_000;
        let result = Duration::nanoseconds(duration);
        assert_eq!(result, expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration as StdDuration;

    use crate::ext::{NumericalStdDuration, NumericalStdDurationShort};
    use crate::ext::NumericalStdDurationShort;

    #[test]
    fn test_seconds() {
        // Test case 1
        let duration1 = StdDuration::new(5, 0);
        let result1 = duration1.seconds();
        let expected1 = 5;
        assert_eq!(result1, expected1);

        // Test case 2
        let duration2 = StdDuration::new(2, 500_000_000);
        let result2 = duration2.seconds();
        let expected2 = 2;
        assert_eq!(result2, expected2);

        // Test case 3
        let duration3 = StdDuration::new(0, 1_000_000_000);
        let result3 = duration3.seconds();
        let expected3 = 1;
        assert_eq!(result3, expected3);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};

    use crate::{ext::{NumericalStdDurationShort, NumericalStdDuration}, Duration};

    #[test]
    fn test_weeks() {
        let duration = Duration::weeks(2);
        assert_eq!(NumericalStdDurationShort::weeks(duration), duration);
    }

    #[test]
    fn test_add() {
        let duration = Duration::weeks(2);
        let other = Duration::minutes(30);
        assert_eq!(NumericalStdDuration::std_add(duration, other), Duration::weeks(2) + Duration::minutes(30));
    }

    #[test]
    fn test_div() {
        let duration = Duration::weeks(2);
        let other = Duration::minutes(30);
        assert_eq!(NumericalStdDuration::std_div(duration, other), duration.as_std().as_secs_f64() / other.as_std().as_secs_f64());
    }

    #[test]
    fn test_eq() {
        let duration = Duration::weeks(2);
        let other = Duration::weeks(2);
        assert_eq!(duration, other);
    }

    #[test]
    fn test_partial_cmp() {
        let duration = Duration::weeks(2);
        let other = Duration::days(14);
        assert_eq!(duration.partial_cmp(&other), Some(Ordering::Equal));
    }

    #[test]
    fn test_sub() {
        let duration = Duration::weeks(2);
        let other = Duration::weeks(1);
        assert_eq!(NumericalStdDuration::std_sub(duration, other), Duration::weeks(2) - Duration::weeks(1));
    }

    #[test]
    fn test_sub_assign() {
        let mut duration = Duration::weeks(2);
        let other = Duration::weeks(1);
        NumericalStdDuration::std_sub_assign(&mut duration, other);
        assert_eq!(duration, Duration::weeks(1));
    }

    #[test]
    fn test_try_from() {
        let duration = Duration::weeks(2);
        let std_duration = duration.as_std();
        assert_eq!(Duration::try_from(std_duration), Ok(duration));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::private::Parsable;

    #[test]
    fn test_parse() {
        let s = "2022-01-01";
        let format = "%Y-%m-%d";
        let result = Date::parse(s, format);
        assert_eq!(result.is_ok(), true);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_cmp() {
        let date1 = Date::try_from_ymd(2021, 12, 31).unwrap();
        let date2 = Date::try_from_ymd(2021, 12, 31).unwrap();
        let date3 = Date::try_from_ymd(2022, 1, 1).unwrap();
        
        assert_eq!(date1.cmp(&date2), Ordering::Equal);
        assert_eq!(date1.cmp(&date3), Ordering::Less);
        assert_eq!(date3.cmp(&date1), Ordering::Greater);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_partial_cmp() {
        let date1 = Date::try_from_ymd(2021, 8, 1).unwrap();
        let date2 = Date::try_from_ymd(2021, 8, 10).unwrap();
        let date3 = Date::try_from_ymd(2021, 8, 5).unwrap();
        let date4 = Date::try_from_ymd(2022, 1, 1).unwrap();

        assert_eq!(date1.partial_cmp(&date2), Some(Ordering::Less));
        assert_eq!(date2.partial_cmp(&date1), Some(Ordering::Greater));
        assert_eq!(date2.partial_cmp(&date3), Some(Ordering::Greater));
        assert_eq!(date3.partial_cmp(&date2), Some(Ordering::Less));
        assert_eq!(date1.partial_cmp(&date3), Some(Ordering::Less));
        assert_eq!(date3.partial_cmp(&date1), Some(Ordering::Greater));
        assert_eq!(date1.partial_cmp(&date1), Some(Ordering::Equal));
        assert_eq!(date4.partial_cmp(&date1), Some(Ordering::Greater));
        assert_eq!(date1.partial_cmp(&date4), Some(Ordering::Less));
    }
}
True
<date::Date as std::ops::Add<duration::Duration>>::add exceed
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_duration() {
        let date = Date::try_from_ymd(2021, 1, 1).unwrap();
        let duration = Duration::days(1);
        let expected = Date::try_from_ymd(2021, 1, 2).unwrap();
        assert_eq!(date.add(duration), expected);
    }

    #[test]
    fn test_add_std_duration() {
        let date = Date::try_from_ymd(2021, 1, 1).unwrap();
        let duration = StdDuration::new(86_400, 0);
        let expected = Date::try_from_ymd(2021, 1, 2).unwrap();
        assert_eq!(date.add(duration), expected);
    }
}
False
<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign exceed
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_assign_duration() {
        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::days(1);
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::weeks(1);
        assert_eq!(date, Date::from_ymd(2021, 1, 8));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::days(1).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::minutes(1440).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::days(1).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::seconds(86_400).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::nanoseconds(86_400_000_000_000).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));

        let mut date = Date::from_ymd(2021, 1, 1);
        date += Duration::days(1).to_std().unwrap();
        assert_eq!(date, Date::from_ymd(2021, 1, 2));
    }
}
False
<date::Date as std::ops::Sub<duration::Duration>>::sub exceed
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub() {
        let date1 = Date::try_from_ymd(2021, 1, 1).unwrap();
        let duration = Duration::days(10);
        let expected = Date::try_from_ymd(2020, 12, 22).unwrap();
        assert_eq!(date1 - duration, expected);

        let date2 = Date::try_from_ymd(2021, 1, 1).unwrap();
        let std_duration = StdDuration::from_secs(864_000);
        let expected = Date::try_from_ymd(2020, 12, 22).unwrap();
        assert_eq!(date2 - std_duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    use duration::Duration;

    #[test]
    fn test_sub() {
        assert_eq!(
            Date {
                value: 2458485,
            }
            .sub(Date {
                value: 2458482,
            }),
            Duration::days(3),
        );
    }
}
True
<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign exceed
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub_assign() {
        let mut date = Date::from_ymd(2021, 1, 1);
        let duration = StdDuration::from_secs(86400);
        date.sub_assign(duration);
        assert_eq!(date, Date::from_ymd(2020, 12, 31));
    }

    #[test]
    fn test_sub_assign_boundary() {
        let mut date = Date::from_ymd(0, 1, 1);
        let duration = StdDuration::from_secs(86400);
        date.sub_assign(duration);
        assert_eq!(date, Date::from_ymd(-1, 12, 31));
    }

    #[test]
    fn test_sub_assign_overflow() {
        let mut date = Date::from_ymd(-100_000, 1, 1);
        let duration = StdDuration::from_secs(86400);
        date.sub_assign(duration);
        assert_eq!(date, Date::from_ymd(-100_000, 12, 31));
    }

    #[test]
    fn test_sub() {
        let date = Date::from_ymd(2021, 1, 1);
        let duration = StdDuration::from_secs(86400);
        let result: Date = date - duration;
        assert_eq!(result, Date::from_ymd(2020, 12, 31));
    }

    #[test]
    fn test_sub_boundary() {
        let date = Date::from_ymd(0, 1, 1);
        let duration = StdDuration::from_secs(86400);
        let result: Date = date - duration;
        assert_eq!(result, Date::from_ymd(-1, 12, 31));
    }

    #[test]
    fn test_sub_overflow() {
        let date = Date::from_ymd(-100_000, 1, 1);
        let duration = StdDuration::from_secs(86400);
        let result: Date = date - duration;
        assert_eq!(result, Date::from_ymd(-100_000, 12, 31));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use crate::prelude::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_cmp() {
        let duration1 = Duration::new(1, 0);
        let duration2 = Duration::new(2, 0);
        let duration3 = Duration::new(1, 500_000_000);
        let duration4 = Duration::new(-1, 0);

        assert_eq!(duration1.cmp(&duration1), Ordering::Equal);
        assert_eq!(duration1.cmp(&duration2), Ordering::Less);
        assert_eq!(duration1.cmp(&duration3), Ordering::Less);
        assert_eq!(duration3.cmp(&duration2), Ordering::Less);
        assert_eq!(duration4.cmp(&duration1), Ordering::Less);
    }

    #[test]
    fn test_cmp_with_std_duration() {
        let duration1 = Duration::new(1, 0);
        let duration2 = Duration::new(2, 0);
        let std_duration1 = StdDuration::from_secs(1);
        let std_duration2 = StdDuration::from_secs(2);

        assert_eq!(
            duration1.cmp(&Duration::try_from(std_duration1).unwrap()),
            Ordering::Equal
        );
        assert_eq!(
            duration1.cmp(&Duration::try_from(std_duration2).unwrap()),
            Ordering::Less
        );
        assert_eq!(
            duration2.cmp(&Duration::try_from(std_duration1).unwrap()),
            Ordering::Greater
        );
    }
}
False
========================================
    use crate::duration::{Duration, StdDuration};
    use std::convert::TryFrom;

    #[test]
    fn test_eq() {
        let duration1 = Duration::seconds(1);
        let duration2 = Duration::seconds(2);
        let std_duration = StdDuration::new(1, 0);

        assert_eq!(duration1.eq(&std_duration), true);
        assert_eq!(duration2.eq(&std_duration), false);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::cmp::Ordering;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_partial_cmp() {
        let duration = Duration::new(1, 0);
        let std_duration = StdDuration::new(1, 0);
        assert_eq!(duration.partial_cmp(&std_duration), Some(Ordering::Equal));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_partial_cmp() {
        let duration1 = Duration::new(5, 500_000_000);
        let duration2 = Duration::new(5, 100_000_000);
        let duration3 = Duration::new(5, 900_000_000);

        assert_eq!(duration1.partial_cmp(&duration2), Some(Ordering::Greater));
        assert_eq!(duration2.partial_cmp(&duration3), Some(Ordering::Less));
        assert_eq!(duration1.partial_cmp(&duration3), Some(Ordering::Greater));
        assert_eq!(duration2.partial_cmp(&duration2), Some(Ordering::Equal));
    }

    #[test]
    fn test_partial_cmp_with_std_duration() {
        let duration = Duration::new(10, 500_000_000);
        let std_duration = StdDuration::new(10, 500_000_000);

        assert_eq!(duration.partial_cmp(&std_duration), Some(Ordering::Equal));
    }
}
False
========================================
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::error::ConversionRange;

    #[test]
    fn test_try_from() {
        // Test case 1
        let original1 = StdDuration::new(10, 500000000);
        let result1 = Duration::try_from(original1).unwrap();
        assert_eq!(result1, Duration::new(10, 500000000));

        // Test case 2
        let original2 = StdDuration::new(0, 999999999);
        let result2 = Duration::try_from(original2).unwrap();
        assert_eq!(result2, Duration::new(0, 999999999));

        // Test case 3
        let original3 = StdDuration::new(86400, 0);
        let result3 = Duration::try_from(original3).unwrap();
        assert_eq!(result3, Duration::new(86400, 0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::Add;

    #[test]
    fn test_add() {
        let duration = Duration::new(1, 0);
        let std_duration = StdDuration::from_secs(1);
        let result = duration.add(std_duration);
        assert_eq!(result, Duration::new(2, 0));
    }
}
True
========================================
use crate::duration::Duration as MyDuration;
use std::ops::Add as AddTrait;

#[test]
fn test_add() {
    let dur1 = MyDuration {
        seconds: 10,
        nanoseconds: 100,
    };
    let dur2 = MyDuration {
        seconds: 5,
        nanoseconds: 200,
    };
    let expected = MyDuration {
        seconds: 15,
        nanoseconds: 300,
    };
    assert_eq!(dur1.add(dur2), expected);
}
True
========================================
    use std::crate::Duration as StdDuration;
    use crate::duration::Duration;

    #[test]
    fn add_assign() {
        let mut duration = Duration::seconds(5);
        let std_duration = StdDuration::from_secs(2);

        duration += std_duration;

        assert_eq!(duration, Duration::seconds(7));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_assign() {
        let mut duration = crate::Duration::seconds(5);
        duration.add_assign(crate::Duration::seconds(3));
        assert_eq!(duration, crate::Duration::seconds(8));
    }

    #[test]
    fn test_add_assign_std() {
        let mut duration = crate::Duration::seconds(5);
        let std_duration: StdDuration = StdDuration::from_secs(3);
        duration.add_assign(std_duration.try_into().unwrap());
        assert_eq!(duration, crate::Duration::seconds(8));
    }

    #[test]
    fn test_add_assign_overflow() {
        let mut duration = crate::Duration::max_value();
        duration.add_assign(crate::Duration::seconds(1));
        assert_eq!(duration, crate::Duration::max_value());
    }

    #[test]
    fn test_add_assign_std_overflow() {
        let mut duration = crate::Duration::max_value();
        let std_duration: StdDuration = StdDuration::from_secs(1);
        duration.add_assign(std_duration.try_into().unwrap());
        assert_eq!(duration, crate::Duration::max_value());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div() {
        let duration = Duration::new(5, 500_000_000);
        let rhs = 1.5;
        let expected = Duration::new(3, 333_333_333);
        assert_eq!(<Duration as std::ops::Div<f32>>::div(duration, rhs), expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_div() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.div(2.0), duration::Duration::seconds_f64(5.0));
        assert_eq!(duration.div(0.5), duration::Duration::seconds_f64(20.0));
        assert_eq!(duration.div(3), duration::Duration::seconds_f64(3.3333333333333335));
    }
}
True
========================================
    use std::ops::Div;
    use std::convert::TryFrom;
    use crate::duration::Duration;

    #[test]
    fn test_div() {
        // Test cases
        let duration1 = Duration::seconds(10);
        let duration2 = Duration::seconds(2);
        let duration3 = Duration::seconds(5);
        let duration4 = Duration::zero();
        let duration5 = Duration::seconds(10);

        // Test the div() function
        assert_eq!(Duration::div(duration1, 2), duration2);
        assert_eq!(Duration::div(duration1, 3), duration3);
        assert_eq!(Duration::div(duration1, 0), duration4);
        assert_eq!(Duration::div(duration1, 1), duration5);

        // Test the try_div() function
        let duration6 = Duration::zero();
        let duration7 = Duration::seconds(10);
        let duration8 = Duration::zero();

        assert_eq!(duration6.checked_div(2), Some(duration6));
        assert_eq!(duration7.checked_div(5), Some(duration8));
        assert_eq!(duration7.checked_div(0), None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_div() {
        let duration = Duration::new(5, 0);
        let result = duration.div(2);
        let expected = Duration::new(2, 500_000_000);
        assert_eq!(result, expected);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_div() {
        let duration1 = Duration::new(10, 0);
        let duration2 = Duration::new(2, 0);
        let result = duration1.div(2);
        assert_eq!(result, Duration::new(5, 0));
        
        let duration3 = Duration::new(10, 0);
        let duration4 = Duration::new(3, 0);
        let result = duration3.div(3);
        assert_eq!(result, Duration::new(3, 333_333_333));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_div() {
        let duration = Duration::new(10, 0);
        let std_duration = StdDuration::new(5, 0);
        let expected = 2.0;

        let result = duration.div(std_duration);

        assert_eq!(result, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_div() {
        let duration = Duration::new(10, 0);
        let rhs: u16 = 2;
        let result = duration.div(rhs);
        assert_eq!(result, Duration::new(5, 0));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_div() {
        let duration = Duration::new(500, 0);
        let result: Duration = duration.div(2);
        assert_eq!(result.whole_seconds(), 250);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div() {
        let duration = Duration::new(10, 0);
        let rhs: u8 = 2;
        let expected = Duration::new(5, 0);
        assert_eq!(<Duration as std::ops::Div<u8>>::div(duration, rhs), expected);

        let duration = Duration::new(10, 0);
        let rhs: Duration = Duration::new(2, 0);
        let expected = 5.0;
        assert_eq!(<Duration as std::ops::Div<Duration>>::div(duration, rhs), expected);

        let duration = Duration::new(10, 0);
        let rhs: StdDuration = StdDuration::new(2, 0);
        let expected = 5.0;
        assert_eq!(<Duration as std::ops::Div<StdDuration>>::div(duration, rhs), expected);

        let duration = Duration::new(10, 0);
        let rhs: f32 = 2.0;
        let expected = Duration::new(5, 0);
        assert_eq!(<Duration as std::ops::Div<f32>>::div(duration, rhs), expected);

        let duration = Duration::new(10, 0);
        let rhs: f64 = 2.0;
        let expected = Duration::new(5, 0);
        assert_eq!(<Duration as std::ops::Div<f64>>::div(duration, rhs), expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div() {
        // Create test cases
        let test_cases = [
            (Duration::seconds(10), Duration::seconds(2), 5.0),
            (Duration::seconds(0), Duration::seconds(5), 0.0),
            (Duration::hours(1), Duration::minutes(30), 2.0),
        ];

        // Iterate through test cases
        for (duration, divisor, expected) in test_cases {
            let result = <Duration as std::ops::Div<Duration>>::div(duration, divisor);
            assert_eq!(result, expected);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div_assign() {
        let mut duration = duration::Duration::new(10, 500_000_000);
        duration.div_assign(2.5);
        assert_eq!(duration, duration::Duration::new(4, 400_000_000));

        let mut duration = duration::Duration::new(100, 0);
        duration.div_assign(0.5);
        assert_eq!(duration, duration::Duration::new(200, 0));

        let mut duration = duration::Duration::new(-10, 0);
        duration.div_assign(-2.5);
        assert_eq!(duration, duration::Duration::new(4, 0));

        let mut duration = duration::Duration::new(0, 0);
        duration.div_assign(2.5);
        assert_eq!(duration, duration::Duration::new(0, 0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div_assign() {
        let mut duration = Duration::seconds(10);
        duration /= 2.0;
        assert_eq!(duration, Duration::seconds(5));
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::Duration as TimeDuration;

    #[test]
    fn test_div_assign_i16() {
        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(2);
        assert_eq!(duration, TimeDuration::seconds(5));

        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(0);
        assert_eq!(duration, TimeDuration::seconds(10));
    }

    #[test]
    fn test_div_assign_f32() {
        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(2.0);
        assert_eq!(duration, TimeDuration::seconds(5));

        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(0.0);
        assert_eq!(duration, TimeDuration::seconds(10));
    }

    #[test]
    fn test_div_assign_f64() {
        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(2.0);
        assert_eq!(duration, TimeDuration::seconds(5));

        let mut duration = TimeDuration::seconds(10);
        duration.div_assign(0.0);
        assert_eq!(duration, TimeDuration::seconds(10));
    }
}
True
========================================
    use std::convert::TryFrom;
    use crate::duration::Duration;
    use std::ops::DivAssign;
    use std::crate::Duration as StdDuration;
    use std::cmp::Ordering;

    #[test]
    fn test_div_assign() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(2);
        let expected = Duration::seconds(5);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::prelude::*;
    use crate::Duration;

    #[test]
    fn test_div_assign() {
        let mut duration: Duration = 10.seconds();

        duration /= 2;
        assert_eq!(duration, 5.seconds());

        duration /= 0;
        assert_eq!(duration, Duration::zero());

        duration = 1000.milliseconds();
        duration /= 10;
        assert_eq!(duration, 100.milliseconds());

        duration = 3.seconds();
        duration /= 0.5;
        assert_eq!(duration, 6.seconds());
    }
}
False
========================================
    use super::*;

use crate::*;
    // use std::crate::Duration as StdDuration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn div_assign_test() {
        // Test case 1
        let mut duration_1 = Duration::seconds(10);
        duration_1.div_assign(2);
        assert_eq!(duration_1, Duration::seconds(5));

        // Test case 2
        let mut duration_2 = Duration::minutes(5);
        duration_2.div_assign(2);
        assert_eq!(duration_2, Duration::minutes(2));

        // Test case 3
        let mut duration_3 = Duration::milliseconds(500);
        duration_3.div_assign(2);
        assert_eq!(duration_3, Duration::milliseconds(250));

        // Test case 4
        let mut duration_4 = Duration::seconds(10);
        duration_4.div_assign(0);
        assert_eq!(duration_4, Duration::seconds(10));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div_assign() {
        let mut duration = crate::Duration::seconds(10);
        duration /= 2;
        assert_eq!(duration, crate::Duration::seconds(5));

        let mut duration = crate::Duration::seconds(10);
        duration /= 1.5;
        assert_eq!(duration, crate::Duration::seconds(6));

        let mut duration = crate::Duration::seconds(10);
        duration /= 0.5;
        assert_eq!(duration, crate::Duration::seconds(20));
    }
}
False
========================================
    use std::convert::TryFrom;
    use crate::duration::Duration;
    use std::ops::DivAssign;
    
    #[test]
    fn test_div_assign() {
        let mut duration = Duration::new(5, 0);
        duration /= 2;
        assert_eq!(duration, Duration::new(2, 500_000_000));
        
        let mut duration = Duration::new(-5, 0);
        duration /= 2;
        assert_eq!(duration, Duration::new(-2, -500_000_000));
        
        let mut duration = Duration::new(5, 0);
        duration /= 0;
        assert_eq!(duration, Duration::new(5, 0));
        
        let mut duration = Duration::new(0, 500_000_000);
        duration /= 2;
        assert_eq!(duration, Duration::new(0, 250_000_000));
        
        let mut duration = Duration::new(0, 500_000_000);
        duration /= -2;
        assert_eq!(duration, Duration::new(0, -250_000_000));
        
        let mut duration = Duration::new(0, 0);
        duration /= 2;
        assert_eq!(duration, Duration::new(0, 0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul() {
        let duration = Duration::new(5, 0);
        let result = duration.mul(2.0);
        let expected = Duration::new(10, 0);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul() {
        let duration = Duration::new(1, 0);
        let result = <Duration as std::ops::Mul<f64>>::mul(duration, 2.0);
        let expected = Duration::new(2, 0);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul() {
        let duration = Duration::new(2, 500_000_000);
        let result = duration.mul(3);
        assert_eq!(2_000_000_000, result.seconds);
        assert_eq!(1_500_000_000, result.nanoseconds);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;

    #[test]
    fn test_duration_mul() {
        let duration1 = Duration::seconds(5);
        let duration2 = duration1 * 2;
        assert_eq!(duration2, Duration::seconds(10));

        let duration3 = Duration::seconds(5);
        let duration4 = duration3 * (-2);
        assert_eq!(duration4, Duration::seconds(-10));

        let duration5 = Duration::seconds(5);
        let duration6 = duration5 * 0;
        assert_eq!(duration6, Duration::seconds(0));

        let max_duration = Duration::max_value();
        let duration7 = max_duration * 2;
        assert_eq!(duration7, None);

        let min_duration = Duration::min_value();
        let duration8 = min_duration * 2;
        assert_eq!(duration8, None);
    }
}
False
========================================
    use std::convert::TryFrom;

    use crate::duration::{Duration, StdDuration, Mul};

    #[test]
    fn test_mul() {
        let duration = Duration::new(1, 0);
        let result = duration.mul(2i8);

        assert_eq!(result, Duration::new(2, 0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul() {
        let duration = Duration::new(10, 0);
        let result = duration.mul(2);
        assert_eq!(result, Duration::new(20, 0));

        let duration = Duration::new(10, 0);
        let result = duration.mul(0);
        assert_eq!(result, Duration::zero());

        let duration = Duration::new(10, 0);
        let result = duration.mul(-2);
        assert_eq!(result, Duration::new(-20, 0));

        let duration = Duration::new(10, 0);
        let result = duration.mul(0.5);
        assert_eq!(result, Duration::new(5, 0));

        let duration = Duration::new(10, 0);
        let result = duration.mul(2.5);
        assert_eq!(result, Duration::new(25, 0));
    }
}
False
========================================
    use std::convert::TryFrom;
    use crate::duration::Duration;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_mul() {
        // Test case 1
        let dur1 = Duration::new(1, 0);
        let dur2 = Duration::try_from(StdDuration::from_secs(2)).unwrap();
        let result = dur1.mul(2);
        let expected = Duration::new(2, 0);
        assert_eq!(result, expected);

        // Test case 2
        let dur1 = Duration::new(1, 0);
        let dur2 = Duration::try_from(StdDuration::from_secs(0)).unwrap();
        let result = dur1.mul(0);
        let expected = Duration::new(0, 0);
        assert_eq!(result, expected);

        // Test case 3
        let dur1 = Duration::new(1, 0);
        let dur2 = Duration::try_from(StdDuration::from_secs(-2)).unwrap();
        let result = dur1.mul(-2);
        let expected = Duration::new(-2, 0);
        assert_eq!(result, expected);

        // Test case 4
        let dur1 = Duration::new(1, 0);
        let dur2 = Duration::try_from(StdDuration::from_secs(-2)).unwrap();
        let result = dur1.mul(-2);
        let expected = Duration::new(-2, 0);
        assert_eq!(result, expected);

        // Test case 5
        let dur1 = Duration::new(1, 0);
        let dur2 = Duration::try_from(StdDuration::from_secs(2)).unwrap();
        let result = dur1.mul(2);
        let expected = Duration::new(2, 0);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul() {
        let duration1 = Duration::seconds(5);
        let duration2 = duration1 * 2;
        assert_eq!(duration2, Duration::seconds(10));

        let duration3 = duration1 * -2;
        assert_eq!(duration3, Duration::seconds(-10));

        let duration4 = duration1 * 0;
        assert_eq!(duration4, Duration::seconds(0));

        let duration5 = Duration::max_value();
        let result1 = duration5.checked_mul(2);
        assert!(result1.is_none());

        let duration6 = Duration::min_value();
        let result2 = duration6.checked_mul(2);
        assert!(result2.is_none());
    }
}
True
========================================
    use crate::duration::Duration;

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(5);
        duration *= 2;

        assert_eq!(duration, Duration::seconds(10));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));

        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::seconds(-10));

        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));

        let mut duration = Duration::max_value();
        assert_eq!(duration.checked_mul_assign(2), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_mul_assign() {
        // Test case 1
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));
        
        // Test case 2
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::seconds(-10));
        
        // Test case 3
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));
        
        // Test case 4
        let mut duration = Duration::max_value();
        duration.mul_assign(2);
        assert_eq!(duration, Duration::max_value());
        
        // Test case 5
        let mut duration = Duration::min_value();
        duration.mul_assign(2);
        assert_eq!(duration, Duration::min_value());
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));
    }
    
    // Add more unit tests here...
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(2);
        duration *= 3;
        assert_eq!(duration, Duration::seconds(6));

        let mut duration = Duration::seconds(2);
        duration *= -3;
        assert_eq!(duration, Duration::seconds(-6));

        let mut duration = Duration::seconds(2);
        duration *= 0;
        assert_eq!(duration, Duration::seconds(0));

        let mut duration = Duration::max_value();
        duration *= 2;
        assert_eq!(duration, Duration::max_value());

        let mut duration = Duration::min_value();
        duration *= 2;
        assert_eq!(duration, Duration::min_value());

        let mut duration = Duration::milliseconds(500);
        duration *= 2.5;
        assert_eq!(duration, Duration::milliseconds(1250));

        let mut duration = Duration::milliseconds(500);
        duration *= -2.5;
        assert_eq!(duration, Duration::milliseconds(-1250));

        let mut duration = Duration::milliseconds(500);
        duration *= 0.5;
        assert_eq!(duration, Duration::milliseconds(250));

        let mut duration = Duration::milliseconds(500);
        duration *= 0.0;
        assert_eq!(duration, Duration::milliseconds(0));

        let mut duration = Duration::milliseconds(500);
        duration *= -0.0;
        assert_eq!(duration, Duration::milliseconds(0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(1);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(2));
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));

        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::seconds(-10));

        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));

        let mut duration = Duration::max_value();
        duration.mul_assign(2);
        assert_eq!(duration, Duration::max_value());

        let mut duration = Duration::min_value();
        duration.mul_assign(2);
        assert_eq!(duration, Duration::min_value());

        let mut duration = Duration::hours(2);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::hours(4));

        let mut duration = Duration::hours(2);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));

        let mut duration = Duration::hours(2);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::hours(-4));

        let mut duration = Duration::zero();
        duration.mul_assign(i32::max_value());
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::zero();
        duration.mul_assign(i32::min_value());
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::zero();
        duration.mul_assign(2);
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::zero();
        duration.mul_assign(0);
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::hours(2);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::hours(2);
        duration.mul_assign(i32::min_value());
        assert_eq!(duration, Duration::zero());

        let mut duration = Duration::hours(2);
        duration.mul_assign(i32::max_value());
        assert_eq!(duration, Duration::hours(i64::from(i32::max_value())));

        let mut duration = Duration::hours(2);
        duration.mul_assign(i32::min_value() + 1);
        assert_eq!(duration, Duration::hours(i64::from(i32::min_value()) + 1));

        let mut duration = Duration::hours(2);
        duration.mul_assign(i32::min_value());
        assert_eq!(duration, Duration::hours(i64::from(i32::min_value())));

        let mut duration = Duration::hours(i64::from(i32::max_value()));
        duration.mul_assign(2);
        assert_eq!(duration, Duration::hours(i64::from(i32::max_value()) * 2));

        let mut duration = Duration::hours(i64::from(i32::min_value()));
        duration.mul_assign(2);
        assert_eq!(duration, Duration::hours(i64::from(i32::min_value()) * 2));

        let mut duration = Duration::hours(i64::from(i32::min_value()));
        duration.mul_assign(1);
        assert_eq!(duration, Duration::hours(i64::from(i32::min_value())));

        let mut duration = Duration::hours(0);
        duration.mul_assign(i32::max_value());
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(i32::min_value());
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(i32::min_value() + 1);
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(i32::min_value());
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(i32::max_value());
        assert_eq!(duration, Duration::hours(0));

        let mut duration = Duration::hours(0);
        duration.mul_assign(1);
        assert_eq!(duration, Duration::hours(0));
    }
}
False
========================================
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;
    use crate::duration::Duration;

    #[test]
    fn test_mul_assign() {
        let mut duration: Duration = Duration::seconds(5);
        let rhs: u8 = 3;
        duration.mul_assign(rhs);
        let expected: Duration = Duration::seconds(5).mul(rhs);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_neg() {
        let duration = Duration::seconds(10);
        let neg = -duration;

        assert_eq!(neg.seconds, -10);
        assert_eq!(neg.nanoseconds, 0);
    }

    #[test]
    fn test_neg_with_nanoseconds() {
        let duration = Duration::new(0, 1);
        let neg = -duration;

        assert_eq!(neg.seconds, 0);
        assert_eq!(neg.nanoseconds, -1);
    }

    #[test]
    fn test_neg_with_negative_duration() {
        let duration = Duration::seconds(-10);
        let neg = -duration;

        assert_eq!(neg.seconds, 10);
        assert_eq!(neg.nanoseconds, 0);
    }

    #[test]
    fn test_neg_with_negative_duration_nanoseconds() {
        let duration = Duration::new(-1, 1);
        let neg = -duration;

        assert_eq!(neg.seconds, 0);
        assert_eq!(neg.nanoseconds, -1);
    }

    #[test]
    fn test_neg_with_max_value() {
        let duration = Duration::max_value();
        let neg = -duration;

        assert_eq!(neg.seconds, i64::min_value());
        assert_eq!(neg.nanoseconds, -999_999_999);
    }

    #[test]
    fn test_neg_with_min_value() {
        let duration = Duration::min_value();
        let neg = -duration;

        assert_eq!(neg.seconds, i64::max_value());
        assert_eq!(neg.nanoseconds, 999_999_999);
    }

    #[test]
    fn test_neg_with_std_duration() {
        let duration = Duration::try_from(StdDuration::from_secs(10)).unwrap();
        let neg = -duration;

        assert_eq!(neg.seconds, -10);
        assert_eq!(neg.nanoseconds, 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub() {
        let duration1 = Duration::new(5, 0);
        let duration2 = StdDuration::new(4, 0);

        let result = duration1 - duration2;

        assert_eq!(result, Duration::new(1, 0));
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub() {
        let dur1 = Duration::new(10, 500_000_000);
        let dur2 = Duration::new(2, 1_000_000_000);
        let expected = Duration::new(8, 500_000_000);
        let result = dur1.sub(dur2);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_sub_std() {
        let dur1 = Duration::new(10, 500_000_000);
        let dur2 = StdDuration::new(2, 0);
        let expected = Duration::new(8, 500_000_000);
        let result = dur1.sub(dur2);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_sub_assign() {
        let mut dur1 = Duration::new(10, 500_000_000);
        let dur2 = Duration::new(2, 1_000_000_000);
        let expected = Duration::new(8, 500_000_000);
        dur1 -= dur2;
        assert_eq!(dur1, expected);
    }

    #[test]
    fn test_sub_assign_std() {
        let mut dur1 = Duration::new(10, 500_000_000);
        let dur2 = StdDuration::new(2, 0);
        let expected = Duration::new(8, 500_000_000);
        dur1 -= dur2;
        assert_eq!(dur1, expected);
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::duration::Duration;

    #[test]
    fn sub_assign_test() {
        let mut duration = Duration::new(10, 0);
        let rhs = StdDuration::new(5, 0);
        duration -= rhs;
        assert_eq!(duration, Duration::new(5, 0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_sub_assign() {
        let mut duration = Duration::seconds(10);
        let rhs = Duration::seconds(5);
        duration.sub_assign(rhs);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn test_sub_assign_std_duration() {
        let mut duration = Duration::seconds(10);
        let rhs = StdDuration::from_secs(5);
        duration.sub_assign(Duration::try_from(rhs).unwrap());
        assert_eq!(duration, Duration::seconds(5));
    }
}
False
========================================
    use crate::error::{ComponentRange, ConversionRange, Error, Format, IndeterminateOffset, Parse};
    use std::error::Error as StdError;

    #[test]
    fn test_from() {
        let original = ComponentRange {
            name: "test",
            minimum: 0,
            maximum: 10,
            value: 15,
            conditional_range: false,
            #[cfg(not(__time_02_supports_non_exhaustive))]
            __non_exhaustive: (),
        };

        let result: Error = original.into();

        // Ensure result is ComponentRange error
        match result {
            Error::ComponentRange(_) => (),
            _ => panic!("Expected ComponentRange error, but got different error variant"),
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::{ConversionRange, Error};
    #[test]
    fn test_from() {
        let original = ConversionRange;
        let result = <error::Error as std::convert::From<error::ConversionRange>>::from(original);
        assert_eq!(result, Error::ConversionRange(original));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::error::Error;

    #[test]
    fn test_from() {
        let error = error::Format::InsufficientTypeInformation;

        let result = error::Error::from(error);

        match result {
            error::Error::Format(e) => assert_eq!(e, error::Format::InsufficientTypeInformation),
            _ => panic!("Expected error::Error::Format, found {:?}", result),
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::error::ConversionRange;
    use crate::error::Error;
    use crate::error::Format;
    use crate::error::IndeterminateOffset;
    use crate::format::parse::Error;

    #[test]
    fn test_from() {
        let original = IndeterminateOffset;
        let result: Error = Error::from(original);
    }
}
False
========================================
    use super::*;

use crate::*;
    use format::parse::Error;
    
    #[test]
    fn test_from() {
        let original = Error::InvalidNanosecond;
        let result = <Error as std::convert::From<format::parse::Error>>::from(original);
        assert_eq!(result, Error::ComponentOutOfRange(Box::new(error::ComponentRange { 
            name: "",
            minimum: 0,
            maximum: 0,
            value: 0,
            conditional_range: None
        })));
        // Add more test cases here
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::parse::Error as ParseError;

    #[derive(Debug)]
    struct MockConversionRange;

    impl std::fmt::Display for MockConversionRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "Mock conversion range error")
        }
    }

    impl std::error::Error for MockConversionRange {}

    #[derive(Debug)]
    struct MockComponentRange;

    impl std::fmt::Display for MockComponentRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "Mock component range error")
        }
    }

    impl std::error::Error for MockComponentRange {}

    #[derive(Debug)]
    struct MockParse;

    impl std::fmt::Display for MockParse {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "Mock parse error")
        }
    }

    impl std::error::Error for MockParse {}

    #[derive(Debug)]
    struct MockIndeterminateOffset;

    impl std::fmt::Display for MockIndeterminateOffset {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "Mock indeterminate offset error")
        }
    }

    impl std::error::Error for MockIndeterminateOffset {}

    #[derive(Debug)]
    struct MockFormat;

    impl std::fmt::Display for MockFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "Mock format error")
        }
    }

    impl std::error::Error for MockFormat {}

    #[test]
    fn test_source_conversion_range_error() {
        let error: Error = Error::ConversionRange(MockConversionRange);
        assert!(error.source().is_some());
        assert_eq!(error.source().unwrap().to_string(), "Mock conversion range error");
    }

    #[test]
    fn test_source_component_range_error() {
        let error: Error = Error::ComponentRange(Box::new(MockComponentRange));
        assert!(error.source().is_some());
        assert_eq!(error.source().unwrap().to_string(), "Mock component range error");
    }

    #[test]
    fn test_source_parse_error() {
        let error: Error = Error::Parse(ParseError::InvalidMonth);
        assert!(error.source().is_none());
    }

    #[test]
    fn test_source_indeterminate_offset_error() {
        let error: Error = Error::IndeterminateOffset(MockIndeterminateOffset);
        assert!(error.source().is_some());
        assert_eq!(error.source().unwrap().to_string(), "Mock indeterminate offset error");
    }

    #[test]
    fn test_source_format_error() {
        let error: Error = Error::Format(MockFormat);
        assert!(error.source().is_none());
    }

    #[test]
    #[should_panic(expected = "unreachable")]
    fn test_source_non_exhaustive_error() {
        let error: Error = Error::__NonExhaustive;
        error.source().unwrap();
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::fmt;
    
    #[test]
    fn test_from() {
        let err = fmt::Error;
        let result: error::Format = error::Format::from(err);
        assert_eq!(result, error::Format::StdFmtError);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::Format;
    // Add import for the trait
    use std::error::Error;

    #[test]
    fn test_source() {
        let err = Format::StdFmtError;
        // Add type annotation for source
        let source: Option<&(dyn Error + 'static)> = err.source();
        assert!(matches!(source, Some(_)));
        assert!(source.unwrap().is::<fmt::Error>());
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_days() {
        assert_eq!(<f32 as super::NumericalDuration>::days(1.5), Duration::nanoseconds(1_296_000_000_000));
        assert_eq!(<f32 as super::NumericalDuration>::days(0.5), Duration::nanoseconds(432_000_000_000));
        assert_eq!(<f32 as super::NumericalDuration>::days(0.25), Duration::nanoseconds(216_000_000_000));
        assert_eq!(<f32 as super::NumericalDuration>::days(-1.5), Duration::nanoseconds(-1_296_000_000_000));
        assert_eq!(<f32 as super::NumericalDuration>::days(-0.5), Duration::nanoseconds(-432_000_000_000));
        assert_eq!(<f32 as super::NumericalDuration>::days(-0.25), Duration::nanoseconds(-216_000_000_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(1);
        let std_duration = duration::StdDuration::from_secs(3600);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let hours = 2.5;
        let seconds = hours * 3600.;
        let duration = Duration::hours(hours);
        let std_duration = duration::StdDuration::from_secs_f64(seconds);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let hours = 0.5;
        let seconds = hours * 3600.;
        let duration = Duration::hours(hours);
        let std_duration = duration::StdDuration::from_secs_f64(seconds);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_microseconds() {
        let duration = Duration::nanoseconds(1_000);
        let expected = Duration::nanoseconds(1_000);
        assert_eq!(<Duration as ext::NumericalDuration>::microseconds(duration), expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(500);
        let expected = Duration::nanoseconds(500_000_000);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_minutes() {
        assert_eq!(
            <f32 as ext::NumericalDuration>::minutes(1.5),
            StdDuration::from_secs(90)
        );
        assert_eq!(
            <f32 as ext::NumericalDuration>::minutes(0.0),
            StdDuration::from_secs(0)
        );
        assert_eq!(
            <f32 as ext::NumericalDuration>::minutes(-2.5),
            StdDuration::from_secs(0) - StdDuration::from_secs(150)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_nanoseconds() {
        assert_eq!(
            <f32 as crate::ext::NumericalDuration>::nanoseconds(/*f32*/),
            Duration::nanoseconds(0)
        );
        assert_eq!(
            <f32 as crate::ext::NumericalDuration>::nanoseconds(/*f32*/).whole_nanoseconds(),
            0
        );
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_seconds() {
        let duration = Duration::seconds(5);
        let expected = Duration::nanoseconds(5_000_000_000);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_weeks() {
        let duration = StdDuration::from_secs(604800);
        let expected = Duration::new(1, 0);
        let result = Duration::try_from(duration).unwrap();
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDurationShort;

    #[test]
    fn test_days() {
        assert_eq!(ext::NumericalStdDurationShort::days(1_f64), Duration::nanoseconds(86_400_000_000_000));
        assert_eq!(ext::NumericalStdDurationShort::days(0_f64), Duration::nanoseconds(0));
        assert_eq!(ext::NumericalStdDurationShort::days(0.5), Duration::nanoseconds(43_200_000_000_000));
        assert_eq!(ext::NumericalStdDurationShort::days((-1_f64)), Duration::nanoseconds(-86_400_000_000_000));
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(2);
        assert_eq!(duration, Duration::nanoseconds(7_200_000_000_000));

        let duration = Duration::hours(-2);
        assert_eq!(duration, Duration::nanoseconds(-7_200_000_000_000));

        let duration = Duration::hours(0);
        assert_eq!(duration, Duration::nanoseconds(0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;
    use duration::Duration;
    use std::convert::TryInto;
    
    #[test]
    fn test_microseconds() {
        let duration: Duration = 1.5.seconds();
        let expected = Duration::nanoseconds(1_500_000_000);
        assert_eq!(duration, expected);
    }
    
    #[test]
    fn test_microseconds_negative() {
        let duration: Duration = (-1.5).seconds();
        let expected = Duration::nanoseconds(-1_500_000_000);
        assert_eq!(duration, expected);
    }
    
    #[test]
    fn test_microseconds_zero() {
        let duration: Duration = 0.seconds();
        let expected = Duration::nanoseconds(0);
        assert_eq!(duration, expected);
    }
    
    #[test]
    fn test_microseconds_overflow() {
        let duration: Duration = 1_000_000_000.seconds() + 0.5.seconds();
        let expected = Duration::nanoseconds(1_000_000_000_i128).unwrap();
        assert_eq!(duration, expected);
    }
    
    #[test]
    fn test_microseconds_std_duration() {
        let std_duration: std::crate::Duration = std::crate::Duration::from_secs(1);
        let duration: Duration = std_duration.try_into().unwrap();
        let expected = Duration::seconds(1);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(1000);
        let std_duration = StdDuration::from_secs(1);
        assert_eq!(<Duration as std::convert::TryFrom<StdDuration>>::try_from(std_duration).unwrap(), duration);
    }
}
False
========================================
    use crate::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_minutes() {
        let duration = Duration::seconds(60);
        let minutes = duration.minutes();
        assert_eq!(minutes, Duration::nanoseconds(60_000_000_000));

        let duration = Duration::seconds(-60);
        let minutes = duration.minutes();
        assert_eq!(minutes, Duration::nanoseconds(-60_000_000_000));

        let duration = Duration::seconds(0);
        let minutes = duration.minutes();
        assert_eq!(minutes, Duration::nanoseconds(0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use ext::NumericalDuration;
    use ext::NumericalStdDurationShort;

    #[test]
    fn test_nanoseconds() {
        let duration = NumericalDuration::nanoseconds(10.5);
        assert_eq!(duration.whole_nanoseconds(), 10_500_000_000);
    }
}
True
========================================
    use super::*;

use crate::*;

    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_seconds() {
        let duration = ext::NumericalDuration::seconds(5.5);
        assert_eq!(duration.seconds(), 5);
        assert_eq!(duration.nanoseconds(), 500_000_000);
        let duration = ext::NumericalDuration::seconds(5.5);
        assert_eq!(duration.seconds(), 5);
        assert_eq!(duration.nanoseconds(), 500_000_000);
    }
    
    #[test]
    fn test_checked_add() {
        let duration1 = ext::NumericalDuration::seconds(5.5);
        let duration2 = ext::NumericalDuration::seconds(2.3);
        let result = duration1.checked_add(duration2).unwrap();
        assert_eq!(result.seconds(), 7);
        assert_eq!(result.nanoseconds(), 800_000_000);
    }
    
    #[test]
    fn test_checked_sub() {
        let duration1 = ext::NumericalDuration::seconds(5.5);
        let duration2 = ext::NumericalDuration::seconds(2.3);
        let result = duration1.checked_sub(duration2).unwrap();
        assert_eq!(result.seconds(), 3);
        assert_eq!(result.nanoseconds(), 200_000_000);
    }
    
    #[test]
    fn test_checked_mul() {
        let duration = ext::NumericalDuration::seconds(5.5);
        let result = duration.checked_mul(2).unwrap();
        assert_eq!(result.seconds(), 11);
        assert_eq!(result.nanoseconds(), 0);
    }
    
    #[test]
    fn test_checked_div() {
        let duration = ext::NumericalDuration::seconds(5.5);
        let result = duration.checked_div(2).unwrap();
        assert_eq!(result.seconds(), 2);
        assert_eq!(result.nanoseconds(), 750_000_000);
    }
    
    #[test]
    fn test_neg() {
        let duration = ext::NumericalDuration::seconds(5.5);
        let result = duration.neg();
        assert_eq!(result.seconds(), -5);
        assert_eq!(result.nanoseconds(), -500_000_000);
    }
    
    #[test]
    fn test_partial_eq() {
        let duration = ext::NumericalDuration::seconds(5.5);
        let std_duration = StdDuration::from_secs(5);
        assert_eq!(duration, std_duration);
    }
    
    #[test]
    fn test_partial_ord() {
        let duration1 = ext::NumericalDuration::seconds(5.5);
        let duration2 = ext::NumericalDuration::seconds(2.5);
        assert!(duration1 > duration2);
        assert!(duration2 < duration1);
    }
    
    #[test]
    fn test_try_from() {
        let std_duration = StdDuration::from_secs(5);
        let duration: ext::NumericalDuration = std_duration.try_into().unwrap();
        assert_eq!(duration.seconds(), 5);
        assert_eq!(duration.nanoseconds(), 0);
    }
    
    #[test]
    fn test_sub() {
        let duration1 = ext::NumericalDuration::seconds(5.5);
        let duration2 = ext::NumericalDuration::seconds(2.5);
        let result = duration1 - duration2;
        assert_eq!(result.seconds(), 3);
        assert_eq!(result.nanoseconds(), 0);
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_weeks() {
        let duration = 1.weeks();
        assert_eq!(duration.whole_seconds(), 604800);
        assert_eq!(duration.whole_nanoseconds() % 1_000_000_000, 0);
    }
}
True
========================================
    use std::crate::Duration;
    use std::convert::TryInto;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::cmp::{PartialEq, PartialOrd, Ordering};
    use std::convert::TryFrom;
    use crate::ext::NumericalStdDuration;
    use crate::StdDuration;
    use crate::error::ConversionRange;

    #[test]
    fn test_std_days() {
        let duration: f64 = 1.0;
        let std_duration = StdDuration::from_nanos((duration * 86_400_000_000_000.) as u64);
        let assert_duration: StdDuration = duration.std_days();

        assert_eq!(std_duration, assert_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_hours() {
        let duration = Duration::from_secs(3600);
        let result = duration.std_hours();
        let expected = Duration::from_secs(3600);
        assert_eq!(result, expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryInto;
    use std::crate::{Duration as StdDuration, Instant};

    #[test]
    fn test_std_microseconds() {
        let duration = StdDuration::from_secs(1);
        let microseconds = duration.std_microseconds();
        assert_eq!(microseconds, 1_000_000);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;

    use crate::error::ConversionRange;
    use crate::ext::NumericalStdDuration;
    use crate::StdDuration;

    #[test]
    fn test_std_milliseconds() {
        let duration = StdDuration::try_from(Duration::new(10, 500_000_000)).unwrap();
        let result = duration.std_milliseconds();
        assert_eq!(result.as_secs(), 10);
        assert_eq!(result.subsec_millis(), 500);
        assert!(result.mul_f64(1000.) == duration);
        assert!(result.is_zero() == duration.is_zero());
        assert!(result.is_positive() == duration.is_positive());
        assert!(result.is_negative() == duration.is_negative());
        assert!(result > Duration::new(10, 0));
        assert!(result.partial_cmp(&Duration::new(10, 0)) == Some(Ordering::Greater));
        assert!(result.partial_cmp(&Duration::new(11, 0)) == Some(Ordering::Less));
        assert!(result.partial_cmp(&Duration::new(10, 500_000_000)) == Some(Ordering::Equal));
        assert!(result.partial_cmp(&Duration::new(10, 500_000_001)) == Some(Ordering::Less));
        assert_eq!(result / duration, 1.);
        assert_eq!(result.sub(duration), Duration::new(0, 0));
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    use crate::StdDuration;

    #[test]
    fn test_std_minutes() {
        let d: StdDuration = Duration::new(180, 0).into();
        assert_eq!(d.std_minutes(), Duration::new(3, 0));
        let d: StdDuration = Duration::new(301, 0).into();
        assert_eq!(d.std_minutes(), Duration::new(5, 1));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::Duration as TimeDuration;
    use crate::ext::NumericalStdDuration;
    use crate::ext::NumericalDuration;
    use crate::ext::StdDuration;
    use crate::ext::TryIntoStdDuration;
    use crate::ext::TryFromStdDuration;

    #[test]
    fn test_std_nanoseconds() {
        let duration = TimeDuration::new(3, 500000000);
        let std_duration = TimeDuration::new(3.5, 0);
        let std_nanoseconds = std_duration.std_nanoseconds();
        let expected = duration.std;

        assert_eq!(std_nanoseconds, expected);
        assert!(std_nanoseconds >= 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::crate::Duration;

    #[test]
    #[should_panic]
    fn std_seconds_assertion() {
        let duration = -1.0;
        duration.std_seconds();
    }

    #[test]
    fn std_seconds_valid() {
        let duration = 1.5;
        let std_duration = duration.std_seconds();
        let expected = Duration::from_nanos((1.5 * 1_000_000_000.) as u64);
  
        assert_eq!(std_duration, expected);
    }

    #[test]
    fn std_seconds_zero() {
        let duration = 0.0;
        let std_duration = duration.std_seconds();
        let expected = Duration::from_nanos((0.0 * 1_000_000_000.) as u64);
  
        assert_eq!(std_duration, expected);
    }
}
False
========================================
    use std::crate::{Duration, SystemTime};

    #[test]
    fn test_std_weeks() {
        let std_duration = Duration::new(120, 0);
        let std_weeks = std_duration.std_weeks();
        assert_eq!(std_weeks, Duration::new(120 * 7 * 24 * 60 * 60, 0));
    }
}
False
========================================
    use std::convert::From;
    use crate::format::format::Format;

    #[test]
    fn test_from() {
        let s = "custom_format";
        let format = Format::from(s);
        assert_eq!(format, Format::Custom(s.to_string()));
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[derive(Debug)]
    struct ComponentRange {
        name: &'static str,
        minimum: i64,
        maximum: i64,
        value: i64,
        conditional_range: bool,
    }
    
    impl std::error::Error for ComponentRange {}
    
    impl std::fmt::Display for ComponentRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(
                f,
                "{} must be in the range {}..={}",
                self.name, self.minimum, self.maximum
            )?;
    
            if self.conditional_range {
                write!(f, ", given values of other parameters")?;
            }
    
            Ok(())
        }
    }
    
    #[test]
    fn test_from() {
        let error = ComponentRange {
            name: "test",
            minimum: 0,
            maximum: 10,
            value: 15,
            conditional_range: false,
        };
        
        let result = <format::parse::Error as std::convert::From<ComponentRange>>::from(error);
        
        assert_eq!(format!("{:?}", result), "ComponentOutOfRange(\"test must be in the range 0..=10\")");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::parse::Error;
    use std::error::Error as _;

    #[test]
    fn test_source() {
        let error = Error::InvalidNanosecond;
        assert!(error.source().is_none());

        let component = crate::format::parse::error::ComponentRange {
            name: "",
            minimum: 0,
            maximum: 0,
            value: 0,
            conditional_range: None,
        };
        let error = Error::ComponentOutOfRange(Box::new(component));
        assert!(error.source().is_some());

        let source = error.source().unwrap();
        let error_source: &(dyn std::error::Error + 'static) = source;
        assert_eq!(error_source.source(), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_days() {
        let d = Duration::days(5);
        assert_eq!(d, 5_i64.days());
        
        let d = Duration::days(-5);
        assert_eq!(d, (-5_i64).days());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_hours() {
        // Test cases here
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    
    #[test]
    fn test_microseconds() {
        let duration = Duration::microseconds(100);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.whole_milliseconds(), 100);
        assert_eq!(duration.whole_microseconds(), 100);
        assert_eq!(duration.whole_nanoseconds(), 100_000);

        let duration = Duration::microseconds(-100);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.whole_milliseconds(), -100);
        assert_eq!(duration.whole_microseconds(), -100);
        assert_eq!(duration.whole_nanoseconds(), -100_000);
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::seconds(1);
        let result = Duration::milliseconds(duration.whole_seconds() * 1_000);
        let expected = Duration::milliseconds(1_000);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    
    #[test]
    fn test_minutes() {
        let duration = <i16 as NumericalDuration>::minutes(5);
        let expected = Duration::seconds(300);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_nanoseconds() {
        let d = StdDuration::from_secs(1);
        let result = Duration::try_from(d).unwrap();
        
        assert_eq!(result.seconds, 1);
        assert_eq!(result.nanoseconds, 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_seconds() {
        let duration: StdDuration = StdDuration::from_secs(5);
        let result: Duration = Duration::try_from(duration).unwrap();
        let expected: Duration = Duration::seconds(5);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_weeks() {
        let duration: Duration = 2.weeks();
        let expected: Duration = Duration::new(1_209_600, 0);
        assert_eq!(duration, expected);
    }
}

False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_days() {
        let duration = Duration::days(7);
        assert_eq!(duration.whole_days(), 7);

        let duration = Duration::days(0);
        assert_eq!(duration.whole_days(), 0);

        let duration = Duration::days(-7);
        assert_eq!(duration.whole_days(), -7);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_hours() {
        let duration = NumericalDuration::hours(1);
        assert_eq!(duration, Duration::new(1, 0));

        let negative_duration = NumericalDuration::hours(-1);
        assert_eq!(negative_duration, Duration::new(-1, 0));
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_microseconds() {
        let duration = Duration::try_from(StdDuration::from_secs(1)).unwrap();
        let microseconds = duration.whole_microseconds();
        assert_eq!(microseconds, 1_000_000);

        let duration = Duration::try_from(StdDuration::from_secs(0)).unwrap();
        let microseconds = duration.whole_microseconds();
        assert_eq!(microseconds, 0);

        let duration = Duration::try_from(StdDuration::from_millis(500)).unwrap();
        let microseconds = duration.whole_microseconds();
        assert_eq!(microseconds, 500_000);

        let duration = Duration::try_from(StdDuration::from_nanos(50)).unwrap();
        let microseconds = duration.whole_microseconds();
        assert_eq!(microseconds, 0);
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_milliseconds() {
        assert_eq!(1_i32.milliseconds().as_duration(), Duration::milliseconds(1));
        assert_eq!(2_i32.milliseconds().as_duration(), Duration::milliseconds(2));
        assert_eq!(0_i32.milliseconds().as_duration(), Duration::milliseconds(0));
        assert_eq!((-1_i32).milliseconds().as_duration(), Duration::milliseconds(-1));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDuration; // Add this import

    #[test]
    fn test_minutes() {
        let duration = Duration::new(120, 0);
        assert_eq!(duration.as_minutes(), 2); // Replace duration.minutes() with duration.as_minutes()

        let duration = Duration::new(1830, 0);
        assert_eq!(duration.as_minutes(), 30); // Replace duration.minutes() with duration.as_minutes()

        let duration = Duration::new(-120, 0);
        assert_eq!(duration.as_minutes(), -2); // Replace duration.minutes() with duration.as_minutes()

        let duration = Duration::new(0, 0);
        assert_eq!(duration.as_minutes(), 0); // Replace duration.minutes() with duration.as_minutes()
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::nanoseconds(1000);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_nanoseconds(), 1000);
    }

    #[test]
    fn test_nanoseconds_conversion() {
        let duration = Duration::nanoseconds(1000);
        let std_duration = StdDuration::from(duration);
        let converted_duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(converted_duration, duration);
    }
}
False
========================================
    use crate::duration::duration::Duration;
    use crate::ext::NumericalDuration;
    use crate::ext::seconds;
    use std::convert::TryFrom;

    #[test]
    fn test_seconds() {
        let duration1 = Duration::seconds(5);
        let duration2 = duration1.seconds();
        assert_eq!(duration1, duration2);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_weeks() {
        let result = Duration::weeks(2);
        assert_eq!(result.whole_seconds(), 1_209_600);
        assert_eq!(result.nanoseconds, 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::crate::Duration;
    
    #[test]
    fn test_std_days() {
        // Test case 1
        let duration = Duration::from_secs(86400);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 2
        let duration = Duration::from_secs(604800);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 3
        let duration = Duration::from_secs(172800);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 4
        let duration = Duration::from_secs(259200);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 5
        let duration = Duration::from_secs(1);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 6
        let duration = Duration::from_secs(0);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
        
        // Test case 7
        let duration = Duration::from_secs(std::u64::MAX);
        let std_duration = duration.std_days();
        assert_eq!(std_duration, duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration;

    #[test]
    fn test_std_hours() {
        let duration = Duration::from_secs(3600);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_hours(), Duration::from_secs(3600));

        let duration = Duration::from_secs(0);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_hours(), Duration::from_secs(0));

        let duration = Duration::from_secs(7200);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_hours(), Duration::from_secs(7200));

        let duration = Duration::from_secs(3600);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_hours(), Duration::from_secs(3600));

        let duration = Duration::from_secs(3600);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_hours(), Duration::from_secs(3600));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    use crate::ext::std_microseconds;
    use crate::crate::ext::StdDuration;

    #[test]
    fn test_std_microseconds() {
        let input: i32 = 100;
        let expected: Duration = Duration::from_micros(100);
        let actual: StdDuration = input.std_microseconds();
        assert_eq!(actual, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDuration;
    use std::crate::Duration;
    use std::convert::TryFrom;

    #[test]
    fn test_std_milliseconds() {
        let duration = Duration::new(2, 500000000);
        let std_duration = StdDuration::try_from(duration).unwrap();
        assert_eq!(std_duration.std_milliseconds(), 2500);
    }
}
False
========================================
    use std::crate::Duration;
    use std::cmp::Ordering;
    use std::convert::{TryFrom, TryInto};
    use crate::ext::StdDuration;

    #[test]
    fn test_std_minutes() {
        let duration = Duration::from_secs(300);
        let std_duration: StdDuration = duration.try_into().unwrap();
        assert_eq!(std_duration.std_minutes(), 5);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::cmp::Ordering;
    use std::convert::{TryFrom, TryInto};
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, error};

    #[test]
    fn test_std_nanoseconds() {
        let duration: StdDuration = SomeDuration::nanoseconds(1000);
        let std_duration = duration.std_nanoseconds();
        assert_eq!(duration.as_nanos() as i32, std_duration.as_nanos() as i32);

        let duration: StdDuration = SomeDuration::nanoseconds(-5000);
        let std_duration = duration.std_nanoseconds();
        assert_eq!(duration.as_nanos() as i32, std_duration.as_nanos() as i32);
    }

    // Mocking Duration for testing the std_nanoseconds function
    #[derive(Copy, Clone)]
    struct SomeDuration {
        nanoseconds: i32,
    }

    impl SomeDuration {
        fn nanoseconds(nanoseconds: i32) -> Self {
            Self { nanoseconds }
        }
    }

    impl Add<Self> for SomeDuration {
        type Output = Self;

        fn add(self, rhs: Self) -> Self::Output {
            SomeDuration::nanoseconds(self.nanoseconds + rhs.nanoseconds)
        }
    }

    impl Div<Self> for SomeDuration {
        type Output = f64;

        fn div(self, rhs: Self) -> Self::Output {
            self.nanoseconds as f64 / rhs.nanoseconds as f64
        }
    }

    impl PartialEq<Self> for SomeDuration {
        fn eq(&self, rhs: &Self) -> bool {
            self.nanoseconds == rhs.nanoseconds
        }
    }

    impl PartialOrd<Self> for SomeDuration {
        fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
            Some(self.nanoseconds.cmp(&rhs.nanoseconds))
        }
    }

    impl Sub<Self> for SomeDuration {
        type Output = Self;

        fn sub(self, rhs: Self) -> Self::Output {
            SomeDuration::nanoseconds(self.nanoseconds - rhs.nanoseconds)
        }
    }

    impl SubAssign<Self> for SomeDuration {
        fn sub_assign(&mut self, rhs: Self) {
            self.nanoseconds -= rhs.nanoseconds;
        }
    }

    impl TryFrom<SomeDuration> for StdDuration {
        type Error = error::ConversionRange;

        fn try_from(duration: SomeDuration) -> Result<Self, error::ConversionRange> {
            if duration.nanoseconds >= 0 {
                Ok(StdDuration::from_nanos(duration.nanoseconds as u64))
            } else {
                Err(error::ConversionRange)
            }
        }
    }
}
False
========================================
    use std::crate::Duration;
    use crate::Duration as TimeDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::ext::{self, NumericalStdDuration};

    #[test]
    fn test_std_seconds() {
        let duration: TimeDuration = TimeDuration::new(5, 0);

        let std_duration: Duration = duration.std_seconds();

        assert_eq!(std_duration.as_secs(), 5);
    }
}
False
========================================
    use std::crate::{Duration, Instant};
    use crate::{ext::NumericalStdDuration, error::ConversionRange};

    #[test]
    fn test_std_weeks() {
        let duration: i32 = 5;
        let std_duration: Duration = duration.std_weeks();
        let expected_duration: Duration = Duration::from_secs(duration as u64 * 604_800);

        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use std::convert::TryFrom;
    use crate::ext;

    #[test]
    fn test_days() {
        let duration = ext::Duration::days(5);
        assert_eq!(duration.whole_days(), 5);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{Duration, NumericalDuration, NumericalStdDurationShort};

    #[test]
    fn test_hours() {
        assert_eq!(Duration::hours(1), NumericalDuration::seconds(3_600));
        assert_eq!(Duration::hours(-1), NumericalDuration::seconds(-3_600));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_microseconds() {
        let duration = <i64 as ext::NumericalDuration>::microseconds(10);
        let result = duration.microseconds();
        assert_eq!(result, Duration::microseconds(10));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;
    use crate::Duration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(100);
        let std_duration = StdDuration::from_millis(100);
        assert_eq!(duration, std_duration.try_into().unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(10);
        let expected = StdDuration::from_secs(10 * 60);
        let result: StdDuration = duration.try_into().unwrap();
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use duration::Duration;

    #[test]
    fn test_nanoseconds() {
        let duration: Duration = Duration::seconds(1000);
        assert_eq!(duration.nanoseconds(), 1000_000_000_000);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_seconds() {
        let duration = Duration::seconds(10);
        let std_duration = StdDuration::new(10, 0);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use duration::*;
    
    #[test]
    fn test_weeks() {
        assert_eq!(
            <i64 as NumericalDuration>::weeks(1),
            Duration::weeks(1),
        );
        assert_eq!(
            <i64 as NumericalDuration>::weeks(0),
            Duration::weeks(0),
        );
        assert_eq!(
            <i64 as NumericalDuration>::weeks(-1),
            Duration::weeks(-1),
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_days() {
        assert_eq!(Duration::days(5).whole_seconds(), 5 * 24 * 60 * 60);
        assert_eq!(Duration::days(-5).whole_seconds(), -5 * 24 * 60 * 60);
        assert_eq!(Duration::days(0).whole_seconds(), 0);
    }
}
True
========================================
    use super::*;

use crate::*;

    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_hours() {
        let duration = duration::Duration::hours(5);
        assert_eq!(
            duration::NumericalStdDuration::hours(&duration),
            duration::Duration::hours(5)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_microseconds() {
        let duration = Duration::seconds(1);
        let microseconds = Duration::microseconds(duration);
        assert_eq!(microseconds, StdDuration::from_micros(1_000_000));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_milliseconds() {
        assert_eq!(<i16 as ext::NumericalDuration>::milliseconds(0), Duration::zero());
        assert_eq!(<i16 as ext::NumericalDuration>::milliseconds(1), Duration::milliseconds(1));
        assert_eq!(<i16 as ext::NumericalDuration>::milliseconds(-1), Duration::milliseconds(-1));
        assert_eq!(<i16 as ext::NumericalDuration>::milliseconds(1000), Duration::seconds(1));
        assert_eq!(<i16 as ext::NumericalDuration>::milliseconds(-1000), Duration::seconds(-1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(5);
        let expected = Duration::seconds(300);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_nanoseconds() {
        let duration = <i8 as ext::NumericalDuration>::nanoseconds(-100);
        assert_eq!(duration, Duration::nanoseconds(-100));
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use std::crate::Duration as StdDuration;
    use super::*;

use crate::*;

    #[test]
    fn test_seconds() {
        let duration = 10.seconds();
        let std_duration = StdDuration::from_secs(10);
        assert_eq!(i8::seconds(duration), std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_weeks() {
        let duration = Duration::weeks(2);
        assert_eq!(duration, Duration::seconds(1_209_600));
    }
}
True
========================================
    use std::cmp::Ordering;
    use std::crate::Instant as StdInstant;
    use crate::instant::Instant;
    use crate::Duration;

    #[test]
    fn test_eq() {
        let std_instant_1 = StdInstant::now();
        let std_instant_2 = std_instant_1 + Duration::from_std(std::crate::Duration::from_secs(1));
        let instant_1 = Instant::from(std_instant_1);
        let instant_2 = Instant::from(std_instant_2);

        assert_eq!(instant_1.eq(&std_instant_1), true);
        assert_eq!(instant_1.eq(&std_instant_2), false);
        assert_eq!(instant_2.eq(&std_instant_1), false);
        assert_eq!(instant_2.eq(&std_instant_2), true);
    }
}
False
========================================
    use crate::super::*;

    #[test]
    fn test_partial_cmp() {
        let time1 = Instant::now();
        let time2 = Instant::now();

        assert_eq!(time1.partial_cmp(&time2), time1.inner.partial_cmp(&time2.inner));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Instant;
    use std::crate::Instant as StdInstant;

    #[test]
    fn test_from() {
        let std_instant = StdInstant::now();
        let instant: Instant = Instant::from(std_instant);
        assert_eq!(std_instant, instant.inner);
    }
}
False
========================================
use crate::Duration;
use crate::Instant as CrateInstant;

#[test]
fn test_add() {
    let instant = CrateInstant::now();
    let duration = Duration::seconds(5);
    let sum = instant + duration;
    assert_eq!(sum, CrateInstant::now());
}

#[test]
fn test_add_assign() {
    let mut instant = CrateInstant::now();
    let duration = Duration::seconds(5);
    instant += duration;
    assert_eq!(instant, CrateInstant::now());
}

#[test]
fn test_sub() {
    let instant = CrateInstant::now();
    let duration = Duration::seconds(5);
    let diff = instant - duration;
    assert_eq!(diff, CrateInstant::now());
}

#[test]
fn test_sub_assign() {
    let mut instant = CrateInstant::now();
    let duration = Duration::seconds(5);
    instant -= duration;
    assert_eq!(instant, CrateInstant::now());
}

#[test]
fn test_eq() {
    let instant1 = CrateInstant::now();
    let instant2 = CrateInstant::now();
    assert_eq!(instant1, instant2);
}

#[test]
fn test_partial_ord() {
    let instant1 = CrateInstant::now();
    let instant2 = CrateInstant::now();
    assert!(instant1 <= instant2);
    assert!(instant1 >= instant2);
}

#[test]
fn test_sub_duration() {
    let instant = CrateInstant::now();
    let duration = Duration::seconds(1);
    let diff = instant - duration;
    assert!(diff.elapsed() >= duration);
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add() {
        let instant = Instant::now();
        let duration = StdDuration::from_secs(10);
        let result = instant.add(duration);
        assert_eq!(result.inner, instant.inner + duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_assign() {
        let mut instant = Instant::now();
        let duration = Duration::seconds(1);
        instant.add_assign(duration);

        let expected = Instant::now() + Duration::seconds(1);
        assert_eq!(instant, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::crate::Instant as StdInstant;
    
    #[test]
    fn test_add_assign() {
        let mut instant = crate::Instant::now();
        let duration = StdDuration::from_secs(5);
        instant.add_assign(duration);
        assert_eq!(instant, crate::Instant::now() + duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub() {
        let instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant + -duration;

        let result = instant::Instant::sub(instant.inner, duration);
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_checked_sub() {
        let instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant - duration;

        let result = instant::Instant::sub(instant.inner, duration.abs_std());
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_add() {
        let instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant + duration;

        let result = instant::Instant::add(instant.inner, duration.abs_std());
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_checked_add() {
        let instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant + duration;

        let result = instant::Instant::add(instant.inner, duration.abs_std());
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_add_assign() {
        let mut instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant + duration;

        instant::Instant::add_assign(&mut instant.inner, duration.abs_std());
        assert_eq!(instant.inner, expected.inner);
    }

    #[test]
    fn test_sub_assign() {
        let mut instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant - duration;

        instant::Instant::sub_assign(&mut instant.inner, duration.abs_std());
        assert_eq!(instant.inner, expected.inner);
    }

    #[test]
    fn test_eq() {
        let instant1 = Instant::now();
        let instant2 = Instant::now();

        assert_eq!(instant1.inner, instant2.inner);
        assert_eq!(instant1, instant2);
    }

    #[test]
    fn test_ne() {
        let instant1 = Instant::now();
        let instant2 = Instant::now() + Duration::seconds(1);

        assert_ne!(instant1.inner, instant2.inner);
        assert_ne!(instant1, instant2);
    }

    #[test]
    fn test_ord() {
        let instant1 = Instant::now();
        let instant2 = Instant::now() + Duration::seconds(1);
        let instant3 = Instant::now() - Duration::seconds(1);

        assert!(instant1.inner < instant2.inner);
        assert!(instant1 < instant2);

        assert!(instant2.inner > instant3.inner);
        assert!(instant2 > instant3);
    }

    #[test]
    fn test_partial_ord() {
        let instant1 = Instant::now();
        let instant2 = Instant::now() + Duration::seconds(1);
        let instant3 = Instant::now() - Duration::seconds(1);

        assert!(instant1.inner.partial_cmp(&instant2.inner).is_some());
        assert!(instant1.partial_cmp(&instant2).is_some());

        assert!(instant2.inner.partial_cmp(&instant3.inner).is_some());
        assert!(instant2.partial_cmp(&instant3).is_some());
    }

    #[test]
    fn test_sub_duration() {
        let instant = Instant::now();
        let duration = Duration::seconds(1);
        let expected = instant - duration;

        let result = instant::Instant::sub(instant.inner, duration.abs_std());
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_add_duration() {
        let instant = Instant::now();
        let duration = Duration::seconds(1);
        let expected = instant + duration;

        let result = instant::Instant::add(instant.inner, duration.abs_std());
        assert_eq!(result, expected.inner);
    }

    #[test]
    fn test_duration_eq_std_duration() {
        let duration = Duration::seconds(1);
        let std_duration = StdDuration::from_secs(1);

        assert_eq!(duration.inner, std_duration);
        assert_eq!(duration, std_duration);
    }

    #[test]
    fn test_duration_ne_std_duration() {
        let duration = Duration::seconds(1);
        let std_duration = StdDuration::from_secs(2);

        assert_ne!(duration.inner, std_duration);
        assert_ne!(duration, std_duration);
    }

    #[test]
    fn test_duration_partial_ord_std_duration() {
        let duration = Duration::seconds(1);
        let std_duration = StdDuration::from_secs(2);

        assert!(duration.inner.partial_cmp(&std_duration).is_some());
        assert!(duration.partial_cmp(&std_duration).is_some());

        assert!(std_duration.partial_cmp(&duration.inner).is_some());
        assert!(std_duration.partial_cmp(&duration).is_some());
    }

    #[test]
    fn test_try_from_std_duration() {
        let std_duration = StdDuration::from_secs(1);

        let result = Duration::try_from(std_duration);
        assert_eq!(result, Ok(Duration::seconds(1)));
    }

    #[test]
    fn test_try_from_std_duration_overflow() {
        let std_duration = StdDuration::from_secs(u64::MAX);

        let result = Duration::try_from(std_duration);
        assert_eq!(result, Err(error::ConversionRange));
    }

    #[test]
    fn test_try_from_std_duration_overflow_subsec() {
        let std_duration = StdDuration::from_secs(1) - StdDuration::from_nanos(1);

        let result = Duration::try_from(std_duration);
        assert_eq!(result, Err(error::ConversionRange));
    }
}
False
========================================
    use crate::instant::Instant;
    use std::crate::Duration;

    #[test]
    fn test_sub() {
        let instant1 = Instant::now();
        let instant2 = Instant::now();
        let duration = Duration::new(5, 0);

        let result = instant1 - duration;

        // Check the result here
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Instant as StdInstant;

    #[test]
    fn test_sub() {
        let instant1 = instant::Instant::now();
        let instant2 = instant::Instant::now();
        let std_instant1: StdInstant = StdInstant::now();
        let std_instant2: StdInstant = StdInstant::now();

        let result1: instant::Duration = instant1.sub(std_instant2);
        let result2: instant::Duration = std_instant1 - instant2;

        assert_eq!(result1, result2);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryInto;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::super::Instant;
    use crate::super::super::Instant as StdInstant;
    
    #[test]
    fn test_sub() {
        let inner1 = StdInstant::now();
        let inner2 = StdInstant::now();
        let self_instant = Instant {
            inner: inner1,
        };
        let other_instant = Instant {
            inner: inner2,
        };
        let expected = match self_instant.inner.cmp(&other_instant.inner) {
            Ordering::Equal => Duration::zero(),
            Ordering::Greater => (self_instant.inner - other_instant.inner).try_into().expect("overflow converting `std::crate::Duration` to `crate::Duration`"),
            Ordering::Less => -Duration::try_from(other_instant.inner - self_instant.inner).expect("overflow converting `std::crate::Duration` to `crate::Duration`"),
        };
        let result = self_instant.sub(other_instant);
        assert_eq!(result, expected);
    }
}
False
========================================
use super::*;

use crate::*;

#[test]
fn test_sub_assign() {
    let mut instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    instant.sub_assign(duration);

    assert_eq!(instant, Instant::from(StdInstant::now() - duration));
}

#[test]
fn test_sub_assign_std() {
    let mut instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = StdDuration::from_secs(2);

    instant.sub_assign(duration);

    assert_eq!(instant, Instant::from(StdInstant::now() - duration));
}

#[test]
fn test_checked_sub() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    let result = instant.checked_sub(duration);

    assert_eq!(result, Some(Instant::from(StdInstant::now() - duration)));
}

#[test]
fn test_checked_sub_std() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = StdDuration::from_secs(2);

    let result = instant.checked_sub(duration);

    assert_eq!(result, Some(Instant::from(StdInstant::now() - duration)));
}

#[test]
fn test_sub() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    let result = instant - duration;

    assert_eq!(result, Instant::from(StdInstant::now() - duration));
}

#[test]
fn test_sub_std() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = StdDuration::from_secs(2);

    let result = instant - duration;

    assert_eq!(result, Instant::from(StdInstant::now() - duration));
}

#[test]
fn test_sub_assign() {
    let mut instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    instant.sub_assign(duration);

    assert_eq!(instant, Instant::from(StdInstant::now() - duration));
}

#[test]
fn test_checked_add() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    let result = instant.checked_add(duration);

    assert_eq!(result, Some(Instant::from(StdInstant::now() + duration)));
}

#[test]
fn test_checked_add_std() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = StdDuration::from_secs(2);

    let result = instant.checked_add(duration);

    assert_eq!(result, Some(Instant::from(StdInstant::now() + duration)));
}

#[test]
fn test_add() {
    let instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    let result = instant + duration;

    assert_eq!(result, Instant::from(StdInstant::now() + duration));
}

#[test]
fn test_add_assign() {
    let mut instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = Duration::seconds(2);

    instant.add_assign(duration);

    assert_eq!(instant, Instant::from(StdInstant::now() + duration));
}

#[test]
fn test_add_assign_std() {
    let mut instant = Instant {
        inner: StdInstant::now(),
    };
    let duration = StdDuration::from_secs(2);

    instant.add_assign(duration);

    assert_eq!(instant, Instant::from(StdInstant::now() + duration));
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub_assign() {
        let mut instant = Instant::now();
        let duration = StdDuration::from_secs(5);
        instant.sub_assign(duration);
        assert_eq!(instant.elapsed(), StdDuration::from_secs(5));
    }
}
False
========================================
    use super::*;

use crate::*;
    use offset_date_crate::{OffsetDateTime, Date, Time, UtcOffset, ParseResult};
    
    #[test]
    fn test_parse() {
        let s: &str = "2022-01-01 12:00:00";
        let format: &str = "%Y-%m-%d %H:%M:%S";
        let result: ParseResult<OffsetDateTime> = parse(s, format);
        assert_eq!(result, Ok(OffsetDateTime::try_new(Date::from_calendar_date(2022, 1, 1), Time::try_new(12, 0, 0, 0).unwrap(), UtcOffset::UTC).unwrap()));
    }
}
False
<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp exceed
<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq exceed
<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq exceed
<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp exceed
<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp exceed
<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from exceed
<offset_date_time::OffsetDateTime as std::hash::Hash>::hash exceed
<offset_date_time::OffsetDateTime as std::ops::Add<duration::Duration>>::add exceed
<offset_date_time::OffsetDateTime as std::ops::Add<std::time::Duration>>::add exceed
<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign exceed
<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign exceed
<offset_date_time::OffsetDateTime as std::ops::Sub<duration::Duration>>::sub exceed
<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::Duration>>::sub exceed
<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub exceed
<offset_date_time::OffsetDateTime as std::ops::Sub>::sub exceed
<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign exceed
<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign exceed
========================================
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::private::Parsable;
    use crate::parse;
    use crate::ParseResult;

    #[test]
    fn test_parse() {
        let s = "2021-01-01T00:00:00";
        let format = "%Y-%m-%dT%H:%M:%S";
        let expected_result = PrimitiveDateTime {
            year: 2021,
            month: 1,
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        
        let result = parse::<PrimitiveDateTime>(s, format);
        assert_eq!(result, Ok(expected_result));
    }
}
False
<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp exceed
<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq exceed
<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp exceed
<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp exceed
<primitive_date_time::PrimitiveDateTime as std::convert::From<std::time::SystemTime>>::from exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add exceed
<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign exceed
<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::SystemTime>>::sub exceed
<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub exceed
<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign exceed
<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign exceed
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_default() {
        assert_eq!(<sign::Sign as std::default::Default>::default(), sign::Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Div;

    #[test]
    fn test_div() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Negative;
        let sign3 = Sign::Zero;

        let result1 = sign1.div(sign2);
        let result2 = sign2.div(sign3);
        let result3 = sign3.div(sign1);

        assert_eq!(result1, Sign::Negative);
        assert_eq!(result2, Sign::Zero);
        assert_eq!(result3, Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::DivAssign;

    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use crate::Sign; // Import the Sign enum from the same module

    #[test]
    fn test_mul() {
        let sign_positive = Sign::Positive;
        let sign_negative = Sign::Negative;
        let sign_zero = Sign::Zero;

        let result = sign_positive.mul(5.0);
        assert_eq!(result, 5.0);
        
        let result = sign_negative.mul(5.0);
        assert_eq!(result, -5.0);
        
        let result = sign_zero.mul(5.0);
        assert_eq!(result, 0.0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::clone::Clone;
    use std::cmp::{Eq, PartialEq};
    use std::default::Default;
    use std::fmt::Debug;
    use std::hash::Hash;
    use std::marker::{Copy, PartialEq, Eq, StructuralEq, StructuralPartialEq};
    use std::ops::{Div, DivAssign, Mul, MulAssign, Neg, Not};

    #[test]
    fn test_mul() {
        let sign = Sign::Positive;
        let rhs = 5.0;
        let result = sign.mul(rhs);
        assert_eq!(result, 5.0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn test_mul() {
        let sign_pos = Sign::Positive;
        let sign_neg = Sign::Negative;
        let sign_zero = Sign::Zero;

        let result_pos = sign_pos.mul(10);
        let result_neg = sign_neg.mul(10);
        let result_zero = sign_zero.mul(10);

        assert_eq!(result_pos, 10);
        assert_eq!(result_neg, -10);
        assert_eq!(result_zero, 0);

        let result_pos_float = sign_pos.mul(10.5);
        let result_neg_float = sign_neg.mul(10.5);
        let result_zero_float = sign_zero.mul(10.5);

        assert_eq!(result_pos_float, 10.5);
        assert_eq!(result_neg_float, -10.5);
        assert_eq!(result_zero_float, 0.0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use sign::Sign;

    #[test]
    fn test_mul_positive_positive() {
        let sign = Sign::Positive;
        let rhs = 10;
        let expected = 10;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_positive_negative() {
        let sign = Sign::Positive;
        let rhs = -10;
        let expected = -10;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_positive_zero() {
        let sign = Sign::Positive;
        let rhs = 0;
        let expected = 0;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_negative_positive() {
        let sign = Sign::Negative;
        let rhs = 10;
        let expected = -10;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_negative_negative() {
        let sign = Sign::Negative;
        let rhs = -10;
        let expected = 10;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_negative_zero() {
        let sign = Sign::Negative;
        let rhs = 0;
        let expected = 0;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_zero_positive() {
        let sign = Sign::Zero;
        let rhs = 10;
        let expected = 0;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_zero_negative() {
        let sign = Sign::Zero;
        let rhs = -10;
        let expected = 0;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_mul_zero_zero() {
        let sign = Sign::Zero;
        let rhs = 0;
        let expected = 0;
        let result = sign.mul(rhs);
        assert_eq!(result, expected);
    }
}
True
========================================
#[allow(trivial_numeric_casts)]
#[test]
fn test_mul() {
    use crate::Sign;
    
    assert_eq!(Sign::Positive.mul(5), 5);
    assert_eq!(Sign::Negative.mul(5), -5);
    assert_eq!(Sign::Zero.mul(5), 0);
    assert_eq!(Sign::Positive * Sign::Positive, Sign::Positive);
    assert_eq!(Sign::Positive * Sign::Negative, Sign::Negative);
    assert_eq!(Sign::Negative * Sign::Positive, Sign::Negative);
    assert_eq!(Sign::Negative * Sign::Negative, Sign::Positive);
    assert_eq!(Sign::Positive / Sign::Positive, Sign::Positive);
    assert_eq!(Sign::Positive / Sign::Negative, Sign::Negative);
    assert_eq!(Sign::Negative / Sign::Positive, Sign::Negative);
    assert_eq!(Sign::Negative / Sign::Negative, Sign::Positive);
    assert_eq!(-Sign::Positive, Sign::Negative);
    assert_eq!(-Sign::Negative, Sign::Positive);
    assert_eq!(-Sign::Zero, Sign::Zero);
    assert_eq!(!Sign::Positive, Sign::Negative);
    assert_eq!(!Sign::Negative, Sign::Positive);
    assert_eq!(!Sign::Zero, Sign::Zero);
    assert!(Sign::Positive.is_positive());
    assert!(!Sign::Negative.is_positive());
    assert!(!Sign::Zero.is_positive());
    assert!(!Sign::Positive.is_negative());
    assert!(Sign::Negative.is_negative());
    assert!(!Sign::Zero.is_negative());
    assert!(!Sign::Positive.is_zero());
    assert!(!Sign::Negative.is_zero());
    assert!(Sign::Zero.is_zero());
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Mul;

    #[test]
    fn test_mul() {
        let sign_1 = Sign::Positive;
        let sign_2 = Sign::Negative;
        let sign_3 = Sign::Zero;

        let result_1 = sign_1.mul(5);
        let result_2 = sign_2.mul(5);
        let result_3 = sign_3.mul(5);
        assert_eq!(result_1, 5);
        assert_eq!(result_2, -5);
        assert_eq!(result_3, 0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Sign;
    #[test]
    fn test_mul() {
        let sign_positive = Sign::Positive;
        let sign_negative = Sign::Negative;
        let sign_zero = Sign::Zero;
        let rhs: i8 = /* initialize rhs value */;

        let result_positive = sign_positive.mul(rhs);
        let result_negative = sign_negative.mul(rhs);
        let result_zero = sign_zero.mul(rhs);

        assert_eq!(result_positive, /* expected result for sign_positive */);
        assert_eq!(result_negative, /* expected result for sign_negative */);
        assert_eq!(result_zero, /* expected result for sign_zero */);
    }
}
False
========================================
    use crate::sign::Sign;
    use std::ops::Mul;

    #[test]
    fn test_mul() {
        assert_eq!(Sign::Zero.mul(Sign::Positive), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Negative), Sign::Zero);
        assert_eq!(Sign::Positive.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Negative.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Positive.mul(Sign::Positive), Sign::Positive);
        assert_eq!(Sign::Negative.mul(Sign::Negative), Sign::Positive);
        assert_eq!(Sign::Positive.mul(Sign::Negative), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Positive), Sign::Negative);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Sign;

    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    #[test]
    fn test_neg() {
        assert_eq!(Sign::Positive.neg(), Sign::Negative);
        assert_eq!(Sign::Negative.neg(), Sign::Positive);
        assert_eq!(Sign::Zero.neg(), Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_not_positive() {
        let sign = sign::Sign::Positive;
        let result = <sign::Sign as std::ops::Not>::not(sign);
        assert_eq!(result, sign::Sign::Negative);
    }
    
    #[test]
    fn test_not_negative() {
        let sign = sign::Sign::Negative;
        let result = <sign::Sign as std::ops::Not>::not(sign);
        assert_eq!(result, sign::Sign::Positive);
    }
    
    #[test]
    fn test_not_zero() {
        let sign = sign::Sign::Zero;
        let result = <sign::Sign as std::ops::Not>::not(sign);
        assert_eq!(result, sign::Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::NumericalDuration;

    #[test]
    fn test_days() {
        let duration = std::num::NonZeroI16::new(5).unwrap();
        let result: crate::Duration =
            <std::num::NonZeroI16 as crate::ext::NumericalDuration>::days(duration).into();
        let expected = crate::Duration::days(5);

        assert_eq!(result, expected);
    }
}
True
========================================
    use std::num::NonZeroI16;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_hours() {
        fn hours(duration: NonZeroI16) -> Duration {
            Duration::hours(duration.get() as i64)
        }
        
        let hours_fn = hours as fn(NonZeroI16) -> Duration;

        let duration = NonZeroI16::new(2).unwrap();
        assert_eq!(hours_fn(duration), Duration::hours(2));
    }
}
True
========================================
    use crate::{Duration, NumericalDuration};

    #[test]
    fn test_microseconds() {
        let value: std::num::NonZeroI16 = std::num::NonZeroI16::new(10).unwrap();
        assert_eq!(value.microseconds(), Duration::microseconds(10));
    }
}
True
========================================
    use std::convert::TryFrom;
    use std::num::NonZeroI16;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(100);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_milliseconds(), 100);
    }

    #[test]
    fn test_milliseconds_with_nonzero_duration() {
        let nonzero_duration = NonZeroI16::new(100).unwrap();
        let duration = NonZeroI16::milliseconds(nonzero_duration);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_milliseconds(), 100);
    }

    #[test]
    fn test_milliseconds_with_nonzero_duration_try_into() {
        let nonzero_duration = NonZeroI16::new(100).unwrap();
        let duration = Duration::try_from(nonzero_duration).unwrap();
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_milliseconds(), 100);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::num::NonZeroI16;

    #[test]
    fn test_minutes() {
        let duration = NonZeroI16::new(10).unwrap();
        let result = <NonZeroI16 as ext::NumericalDuration>::minutes(duration).as_seconds_f64();
        assert_eq!(result, 600.0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI16;

    #[test]
    fn test_nanoseconds() {
        let duration = NonZeroI16::new(5).unwrap().nanoseconds();
        let expected = Duration::nanoseconds(5);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;
    use std::num::NonZeroI16;

    #[test]
    fn test_seconds() {
        let duration = <NonZeroI16 as ext::NumericalDuration>::seconds(NonZeroI16::new(5).unwrap());
        let expected = Duration::seconds(5);
        assert_eq!(duration, expected);
    }

    #[test]
    fn test_try_from_std_duration() {
        let std_duration = StdDuration::from_secs(10);
        let duration = Duration::try_from(std_duration).unwrap();
        let expected = Duration::seconds(10);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    use core::num::NonZeroI16;
    use crate::{Duration, NumericalDuration};

    #[test]
    fn test_weeks() {
        let duration = NonZeroI16::new(2).unwrap().weeks();
        let expected = Duration::weeks(2);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use std::convert::TryFrom;
    use std::num::NonZeroI32;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_days() {
        let duration: Duration = NonZeroI32::new(5)
            .map(|n| n.days())
            .unwrap();
        assert_eq!(duration, Duration::days(5));
    }
}
True
========================================
    use super::*;

use crate::*;
    use core::num::NonZeroI32;
    use crate::*;
    
    #[test]
    fn test_hours() {
        let duration = NonZeroI32::new(2).unwrap().hours();
        let expected = Duration::hours(2);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use std::convert::TryFrom;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::num::NonZeroI32;

    #[test]
    fn test_microseconds() {
        let duration: Duration = NonZeroI32::new(10)
            .map(|num| num.microseconds())
            .unwrap();
        
        let expected: Duration = Duration::new(0, 10 * 1000);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI32;

    #[test]
    fn test_milliseconds() {
        let duration: Duration = NonZeroI32::new(5).unwrap().milliseconds();
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.whole_nanoseconds(), 5_000_000);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI32;

    #[test]
    fn test_minutes() {
        let duration = NonZeroI32::new(5).unwrap();
        let result = duration.minutes();
        assert_eq!(result, Duration::minutes(5));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::nanoseconds(100);
        let std_duration = StdDuration::from_nanos(100);
        assert_eq!(Duration::try_from(std_duration), Ok(duration));
    }
}
False
========================================
    use std::num::NonZeroI32;
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_seconds() {
        let non_zero_seconds = NonZeroI32::new(10).unwrap();
        let duration = non_zero_seconds.seconds();
        assert_eq!(duration, Duration::seconds(10));

        let non_zero_seconds = NonZeroI32::new(-10).unwrap();
        let duration = non_zero_seconds.seconds();
        assert_eq!(duration, Duration::seconds(-10));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI32;

    #[test]
    fn test_weeks() {
        let duration = NonZeroI32::new(2).unwrap().weeks();
        let expected = Duration::weeks(2);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use std::num::NonZeroI64;
    use super::*;

use crate::*;

    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;
    use crate::NumericalDuration;

    #[test]
    fn test_days() {
        let duration: Duration = NonZeroI64::new(5).unwrap().days().try_into().unwrap();
        assert_eq!(duration, Duration::days(5));
        
        let duration: Duration = NonZeroI64::new(0).unwrap().days().try_into().unwrap();
        assert_eq!(duration, Duration::zero());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::{NonZeroI8, NonZeroI16, NonZeroI32, NonZeroU8, NonZeroU16, NonZeroU32};

    #[test]
    fn test_hours() {
        let duration = Duration::hours(5);
        assert_eq!(hours(duration), Duration::hours(5));
    }

    fn hours<T>(hours: T) -> Duration
    where
        T: Into<NonZeroI8>
            + Into<NonZeroI16>
            + Into<NonZeroI32>
            + Into<NonZeroU8>
            + Into<NonZeroU16>
            + Into<NonZeroU32>
    {
        hours.into().hours()
    }
}
False
========================================
    use std::num::NonZeroI64;
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_microseconds() {
        let duration: Duration = NonZeroI64::new(100).unwrap().microseconds();
        let expected_duration = Duration::microseconds(100);
        assert_eq!(duration, expected_duration);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(1000);
        let std_duration = StdDuration::from_millis(1000);
        assert_eq!(duration, std_duration.into());

        let duration = Duration::milliseconds(-1000);
        let std_duration = StdDuration::from_millis(-1000);
        assert_eq!(duration, std_duration.into());
    }
}
False
========================================
    use std::num::NonZeroI64;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_minutes() {
        let duration = NonZeroI64::new(5).unwrap().minutes();
        assert_eq!(duration, Duration::minutes(5));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::nanoseconds(1000);
        assert_eq!(duration.seconds, 0);
        assert_eq!(duration.nanoseconds, 1000);
    }

    #[test]
    fn test_nanoseconds_i128() {
        let duration = Duration::nanoseconds_i128(1000000000000);
        assert_eq!(duration.seconds, 1000);
        assert_eq!(duration.nanoseconds, 0);
    }

    #[test]
    fn test_try_from() {
        let duration = Duration::from_secs(10);
        let std_duration = std::crate::Duration::from_secs(10);
        assert_eq!(Duration::try_from(std_duration).unwrap(), duration);
    }

    #[test]
    fn test_checked_add() {
        let duration = Duration::from_secs(10);
        let result = duration.checked_add(Duration::from_secs(5)).unwrap();
        assert_eq!(result.seconds, 15);
        assert_eq!(result.nanoseconds, 0);
    }

    #[test]
    fn test_checked_sub() {
        let duration = Duration::from_secs(10);
        let result = duration.checked_sub(Duration::from_secs(5)).unwrap();
        assert_eq!(result.seconds, 5);
        assert_eq!(result.nanoseconds, 0);
    }

    #[test]
    fn test_checked_mul() {
        let duration = Duration::from_secs(10);
        let result = duration.checked_mul(2).unwrap();
        assert_eq!(result.seconds, 20);
        assert_eq!(result.nanoseconds, 0);
    }

    #[test]
    fn test_checked_div() {
        let duration = Duration::from_secs(10);
        let result = duration.checked_div(2).unwrap();
        assert_eq!(result.seconds, 5);
        assert_eq!(result.nanoseconds, 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_seconds() {
        let non_zero_i64: std::num::NonZeroI64 = std::num::NonZeroI64::new(5).unwrap();
        let duration: Duration = non_zero_i64.seconds();
        let expected: Duration = Duration::seconds(5);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_weeks() {
        fn equal(duration1: Duration, duration2: Duration) {
            assert_eq!(duration1, duration2);
        }
        
        fn non_zero(duration: Duration) {
            assert_ne!(duration, Duration::zero());
        }
        
        equal(Duration::weeks(1), Duration::seconds(604800));
        equal(Duration::weeks(2), Duration::seconds(1209600));
        equal(Duration::weeks(3), Duration::seconds(1814400));
        equal(Duration::weeks(4), Duration::seconds(2419200));
        
        non_zero(Duration::weeks(1));
        non_zero(Duration::weeks(2));
        non_zero(Duration::weeks(3));
        non_zero(Duration::weeks(4));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use crate::duration::Duration;
    
    #[test]
    fn test_days() {
        let duration = Duration::days(5);
        assert_eq!(duration.whole_days(), 5);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(5);
        let std_duration = StdDuration::from_secs(5 * 3600);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        assert_eq!(duration.whole_hours(), 5);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI8;

    #[test]
    fn test_microseconds() {
        let non_zero_i8 = NonZeroI8::new(1).unwrap();
        let duration = non_zero_i8.microseconds();
        assert_eq!(duration.whole_microseconds(), 1);
    }
}
True
========================================
    use std::convert::TryFrom;
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_milliseconds() {
        let non_zero_i8: std::num::NonZeroI8 = std::num::NonZeroI8::new(10).unwrap();
        let duration = Duration::try_from(non_zero_i8).unwrap();
        let milliseconds = duration.whole_milliseconds();
        assert_eq!(milliseconds, 10);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroI8;

    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(10);
        assert_eq!(duration, Duration::seconds(10 * 60));
    }
}
True
========================================
    use std::num::NonZeroI8;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::default::Default;
    use std::fmt::Debug;
    use std::hash::Hash;
    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};
    use std::crate::{Duration as StdDuration};

    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_nanoseconds() {
        let nzi8 = NonZeroI8::new(1).unwrap();
        let duration = nzi8.nanoseconds();
        assert_eq!(duration, Duration::nanoseconds(1));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_seconds() {
        let non_zero_i8 = std::num::NonZeroI8::new(5).unwrap();
        let duration: Duration = non_zero_i8.seconds();
        let expected = Duration::seconds(5);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use duration::Duration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_weeks() {
        let duration: Duration = std::num::NonZeroI8::new(2).unwrap().weeks();
        assert_eq!(duration, Duration::weeks(2));

        let duration: Duration = std::num::NonZeroI8::new(0).unwrap().weeks();
        assert_eq!(duration, Duration::weeks(0));

        let duration: Duration = ext::NumericalDuration::weeks((-2));
        assert_eq!(duration, Duration::weeks(-2));

        let duration: Duration = ext::NumericalDuration::weeks(i8::max_value());
        assert_eq!(duration, Duration::weeks(i8::max_value() as i64));

        let duration: Duration = ext::NumericalDuration::weeks(i8::min_value());
        assert_eq!(duration, Duration::weeks(i8::min_value() as i64));

        let std_duration: StdDuration = 2.weeks().try_into().unwrap();
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::*;
    use std::convert::TryFrom;
    use std::num::NonZeroU16;
    use std::crate::Duration as StdDuration;

    impl ext::NumericalStdDurationShort for NonZeroU16 {
        fn days(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 86_400)
        }
    }

    #[test]
    fn test_days() {
        let duration = NonZeroU16::new(5).unwrap().days();
        assert_eq!(duration.as_secs(), 432_000);
        assert_eq!(duration.subsec_nanos(), 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_hours() {
        let duration = Duration::hours(1);
        assert_eq!(duration, Duration::new(1, 0));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_microseconds() {
        let duration = NonZeroU16::new(100).unwrap().microseconds();
        let expected = StdDuration::from_micros(100 as u64);

        assert_eq!(duration, expected);
    }

    #[test]
    fn test_microseconds_zero() {
        let duration = NonZeroU16::new(0).unwrap().microseconds();
        let expected = StdDuration::from_micros(0 as u64);

        assert_eq!(duration, expected);
    }
}
False
========================================
    use std::num::NonZeroU16;
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_milliseconds() {
        let duration: Duration = NonZeroU16::new(100).expect("Valid duration").milliseconds();
        let expected: Duration = Duration::milliseconds(100);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::num::NonZeroU16;

    #[test]
    fn test_minutes() {
        let duration = <NonZeroU16 as NumericalDuration>::minutes(5);

        let expected = StdDuration::from_secs(5 * 60);
        let actual = duration.std_minutes();

        assert_eq!(expected, actual);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::nanoseconds(1000);
        assert_eq!(duration, Duration::microseconds(1));
    }
    
    #[test]
    fn test_microseconds() {
        let duration = Duration::microseconds(1000);
        assert_eq!(duration, Duration::milliseconds(1));
    }
    
    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(1000);
        assert_eq!(duration, Duration::seconds(1));
    }
    
    #[test]
    fn test_seconds() {
        let duration = Duration::seconds(60);
        assert_eq!(duration, Duration::minutes(1));
    }
    
    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(60);
        assert_eq!(duration, Duration::hours(1));
    }
    
    #[test]
    fn test_hours() {
        let duration = Duration::hours(24);
        assert_eq!(duration, Duration::days(1));
    }
    
    #[test]
    fn test_days() {
        let duration = Duration::days(7);
        assert_eq!(duration, Duration::weeks(1));
    }

    #[test]
    fn test_try_from_std_duration() {
        let std_duration = StdDuration::from_secs(10);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(duration, Duration::seconds(10));
    }
    
    #[test]
    fn test_checked_add() {
        let duration1 = Duration::seconds(10);
        let duration2 = Duration::seconds(5);
        let duration3 = Duration::max_value();
        assert_eq!(duration1.checked_add(duration2), Some(Duration::seconds(15)));
        assert_eq!(duration1.checked_add(duration3), None);
    }
    
    #[test]
    fn test_checked_sub() {
        let duration1 = Duration::seconds(10);
        let duration2 = Duration::seconds(5);
        let duration3 = Duration::min_value();
        assert_eq!(duration1.checked_sub(duration2), Some(Duration::seconds(5)));
        assert_eq!(duration1.checked_sub(duration3), None);
    }
    
    #[test]
    fn test_checked_mul() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.checked_mul(2), Some(Duration::seconds(20)));
        assert_eq!(duration.checked_mul(0), Some(Duration::zero()));
        assert_eq!(duration.checked_mul(10000000000), None);
    }
    
    #[test]
    fn test_checked_div() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.checked_div(2), Some(Duration::seconds(5)));
        assert_eq!(duration.checked_div(0), None);
    }
    
    #[test]
    fn test_sub_add() {
        let duration1 = Duration::seconds(10);
        let duration2 = Duration::seconds(5);
        let duration3 = duration1 - duration2;
        assert_eq!(duration3 + duration2, duration1);
    }
    
}
False
========================================
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::ext::{NumericalDuration, NumericalStdDuration};
    use crate::Duration;

    #[test]
    fn test_seconds() {
        let duration = Duration::new(2, 0);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(2));
    }

    #[test]
    fn test_seconds_neg() {
        let duration = Duration::new(-2, 0);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(-2));
    }

    #[test]
    fn test_seconds_with_nanoseconds() {
        let duration = Duration::new(2, 999_999_999);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(2));
    }

    #[test]
    fn test_seconds_with_nanoseconds_neg() {
        let duration = Duration::new(-2, 999_999_999);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(-2));
    }

    #[test]
    fn test_seconds_with_nanoseconds_rounded() {
        let duration = Duration::new(2, 1_000_000_000);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(3));
    }

    #[test]
    fn test_seconds_with_nanoseconds_rounded_neg() {
        let duration = Duration::new(-2, -1_000_000_000);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(-3));
    }

    #[test]
    fn test_seconds_with_nanoseconds_rounded_neg2() {
        let duration = Duration::new(-2, 1_000_000_000);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(-1));
    }

    #[test]
    fn test_seconds_with_nanoseconds_rounded_both() {
        let duration = Duration::new(2, -1_000_000_000);
        let result = duration::Duration::seconds(duration);
        assert_eq!(result, Duration::seconds(1));
    }
}
False
========================================
    use crate::NumericalDuration;
    use std::num::NonZeroU16;
    use std::crate::Duration;
    
    #[test]
    fn test_weeks() {
        let weeks: NonZeroU16 = NonZeroU16::new(2).unwrap();
        let duration = weeks.weeks();
        assert_eq!(duration, Duration::new(1_209_600, 0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDuration;
    use crate::Duration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Sub, SubAssign};
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn std_days_test() {
        let duration = Duration::days(2);
        let std_duration = StdDuration::try_from(duration).unwrap();
        let expected = StdDuration::from_secs(2 * 86_400);
        assert_eq!(std_duration.std_days(), expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::num::NonZeroU16;
    use std::crate::{Duration as StdDuration};
    use crate::ext::{NumericalDuration, NumericalStdDuration};

    #[test]
    fn test_std_hours() {
        let duration = NonZeroU16::new(2).unwrap();
        let std_duration = duration.std_hours();
        let expected = StdDuration::from_secs(duration.get() as u64 * 3_600);
        assert_eq!(std_duration, expected);
    }
}
False
========================================
    use crate::ext::{NumericalStdDuration, NumericalStdDurationShort};
    use std::crate::{Duration as StdDuration};

    fn std_microseconds(self) -> StdDuration {
        StdDuration::from_micros(self.get() as u64)
    }

    #[test]
    fn test_std_microseconds() {
        let duration = NumericalStdDuration::new(100).unwrap();
        let result = std_microseconds(duration);
        let expected = StdDuration::from_micros(100);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_std_milliseconds() {
        let duration = core::num::NonZeroU16::new(123).unwrap();
        let std_duration = StdDuration::from_millis(u64::from(duration.get()));
        assert_eq!(std_duration.as_millis(), 123);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    fn compare_durations(lhs: Duration, rhs: Duration) -> bool {
        lhs.as_secs() == rhs.as_secs() && lhs.subsec_nanos() == rhs.subsec_nanos()
    }
    
    #[test]
    fn test_std_minutes() {
        let input: std::num::NonZeroU16 = std::num::NonZeroU16::new(10).unwrap();
        let expected_output: Duration = Duration::from_secs(10 * 60);
        let result: Duration = input.std_minutes();
        assert!(compare_durations(result, expected_output));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, Instant};

    trait NumericalDuration {
        fn nanoseconds(self) -> StdDuration;
        fn microseconds(self) -> StdDuration;
        fn milliseconds(self) -> StdDuration;
        fn seconds(self) -> StdDuration;
        fn minutes(self) -> StdDuration;
        fn hours(self) -> StdDuration;
        fn days(self) -> StdDuration;
        fn weeks(self) -> StdDuration;
    }

    trait NumericalStdDuration {
        fn std_nanoseconds(self) -> StdDuration;
        fn std_microseconds(self) -> StdDuration;
        fn std_milliseconds(self) -> StdDuration;
        fn std_seconds(self) -> StdDuration;
        fn std_minutes(self) -> StdDuration;
        fn std_hours(self) -> StdDuration;
        fn std_days(self) -> StdDuration;
        fn std_weeks(self) -> StdDuration;
    }

    trait ConversionRange {
    }

    fn std_nanoseconds(self) -> StdDuration {
        StdDuration::from_nanos(self.get() as u64)
    }

    impl NumericalDuration for std::num::NonZeroU16 {
        fn nanoseconds(self) -> StdDuration {
            StdDuration::nanoseconds(self.get() as i64)
        }

        fn microseconds(self) -> StdDuration {
            StdDuration::microseconds(self.get() as i64)
        }

        fn milliseconds(self) -> StdDuration {
            StdDuration::milliseconds(self.get() as i64)
        }

        fn seconds(self) -> StdDuration {
            StdDuration::seconds(self.get() as i64)
        }

        fn minutes(self) -> StdDuration {
            StdDuration::minutes(self.get() as i64)
        }

        fn hours(self) -> StdDuration {
            StdDuration::hours(self.get() as i64)
        }

        fn days(self) -> StdDuration {
            StdDuration::days(self.get() as i64)
        }

        fn weeks(self) -> StdDuration {
            StdDuration::weeks(self.get() as i64)
        }
    }

    impl NumericalStdDuration for std::num::NonZeroU16 {
        fn std_nanoseconds(self) -> StdDuration {
            StdDuration::from_nanos(self.get() as u64)
        }

        fn std_microseconds(self) -> StdDuration {
            StdDuration::from_micros(self.get() as u64)
        }

        fn std_milliseconds(self) -> StdDuration {
            StdDuration::from_millis(self.get() as u64)
        }

        fn std_seconds(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64)
        }

        fn std_minutes(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 60)
        }

        fn std_hours(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 3_600)
        }

        fn std_days(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 86_400)
        }

        fn std_weeks(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 604_800)
        }
    }

    impl Add<StdDuration> for StdDuration {
        type Output = StdDuration;

        fn add(self, rhs: StdDuration) -> StdDuration {
            rhs + self
        }
    }

    impl Div<StdDuration> for StdDuration {
        type Output = f64;

        fn div(self, rhs: StdDuration) -> f64 {
            self.as_secs_f64() / rhs.as_secs_f64()
        }
    }

    impl PartialEq<StdDuration> for StdDuration {
        fn eq(&self, rhs: &StdDuration) -> bool {
            rhs == self
        }
    }

    impl PartialOrd<StdDuration> for StdDuration {
        fn partial_cmp(&self, rhs: &StdDuration) -> Option<Ordering> {
            rhs.partial_cmp(self).map(Ordering::reverse)
        }
    }

    impl Sub<StdDuration> for StdDuration {
        type Output = StdDuration;

        fn sub(self, rhs: StdDuration) -> StdDuration {
            self.checked_sub(rhs)
                .expect("overflow converting `std::crate::Duration` to `crate::Duration`")
        }
    }

    impl SubAssign<StdDuration> for StdDuration {
        fn sub_assign(&mut self, rhs: StdDuration) {
            *self = (*self - rhs).try_into().expect("Cannot represent a resulting duration in std");
        }
    }

    impl TryFrom<StdDuration> for StdDuration {
        type Error = ConversionRange;

        fn try_from(duration: StdDuration) -> Result<StdDuration, ConversionRange> {
            Ok(Self::new(
                duration
                    .as_secs()
                    .try_into()
                    .map_err(|_| ConversionRange)?,
                duration
                    .subsec_nanos()
                    .try_into()
                    .map_err(|_| ConversionRange)?,
            ))
        }
    }

    #[test]
    fn test_std_nanoseconds() {
        let duration = std::crate::Duration::new(2, 500_000_000);
        let result = duration.std_nanoseconds();
        let expected = std::crate::Duration::from_nanos(2_500_000_000);
        assert_eq!(result, expected);
    }
}
False
========================================
    use core::cmp::PartialEq;
    use core::convert::TryFrom;
    use core::ops::Sub;
    use core::ops::SubAssign;
    use std::num::NonZeroU16;
    use std::crate::{Duration as StdDuration, error};

    #[test]
    fn test_std_seconds() {
        let duration = NonZeroU16::new(12).unwrap();
        let std_duration = duration.std_seconds();
        assert_eq!(u64::from(std_duration), 12);
    }
}
False
========================================
    use std::crate::{Duration, SystemTime};
    use std::num::NonZeroU16;
    use crate::ext::{NumericalStdDuration, Duration as StdDuration};


    #[test]
    fn test_std_weeks() {
        let duration: NonZeroU16 = NonZeroU16::new(2).unwrap();
        let std_duration: StdDuration = duration.std_weeks();
        let expected_duration: StdDuration = StdDuration::from_secs(2 * 604_800);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroU32;
    use ext::NumericalDuration;

    #[test]
    fn test_days() {
        let duration = NonZeroU32::new(5).unwrap().days();
        let expected = Duration::days(5);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(2);
        let std_duration = StdDuration::from_secs(2 * 60 * 60);
        assert_eq!(Duration::try_from(std_duration).unwrap(), duration);
        assert_eq!(duration.whole_hours(), 2);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_microseconds() {
        let non_zero_u32 = std::num::NonZeroU32::new(100).unwrap();
        let duration = ext::NumericalDuration::microseconds(non_zero_u32);
        assert_eq!(duration.seconds, 0);
        assert_eq!(duration.nanoseconds, 100_000);
    }
}
False
========================================
    use crate::*;
    use std::num::NonZeroU32;

    #[test]
    fn test_milliseconds() {
        let duration = std::num::NonZeroU32::milliseconds(); // Call the target function here
        assert_eq!(duration, Duration::milliseconds(123));
    }
}
False
========================================
    use super::*;

use crate::*;
    use core::num::NonZeroU32;

    #[test]
    fn test_minutes() {
        let minutes = NonZeroU32::new(10).unwrap();
        let expected = crate::Duration::minutes(10);
        let result = minutes.minutes();
        assert_eq!(expected, result);
    }
}
False
========================================
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    use crate::NumericalDuration;
    use crate::Duration;
    use std::num::NonZeroU32;

    #[test]
    fn test_nanoseconds() {
        let non_zero_value = NonZeroU32::new(10).unwrap();
        let duration = non_zero_value.nanoseconds();
        let std_duration = StdDuration::from_nanos(10);
        let expected = Duration::try_from(std_duration).unwrap();

        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_seconds() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.whole_seconds(), 10);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroU32;

    #[test]
    fn test_weeks() {
        let duration = Duration::weeks(2);
        assert_eq!(duration.whole_seconds(), 1_209_600);
    }
}
True
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, error};
    use crate::ext::{NumericalDuration, NumericalStdDuration};
    use crate::Duration;

    #[test]
    fn test_std_days() {
        let duration = Duration::days(7);
        let std_duration = duration.std_days();
        let expected = StdDuration::from_secs(604_800);
        assert_eq!(std_duration, expected);
    }
}
False
========================================
    use std::crate::{Duration, self};
    use std::num::NonZeroU32;
    use crate::ext::{NumericalDuration, NumericalStdDuration};
    use std::cmp::Ordering;

    #[test]
    fn test_std_hours() {
        let duration: NonZeroU32 = NonZeroU32::new(2).unwrap();
        let std_duration = duration.std_hours();
        let expected_duration = Duration::from_secs(2u64 * 3_600u64);

        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::num::NonZeroU32;
    use std::convert::TryFrom;
    use std::cmp::Ordering;

    #[test]
    fn test_std_microseconds() {
        // Test case 1
        let nzu32: NonZeroU32 = NonZeroU32::new(1).unwrap();
        let result1 = nzu32.std_microseconds();
        assert_eq!(result1, StdDuration::from_micros(1));

        // Test case 2
        let nzu32: NonZeroU32 = NonZeroU32::new(500).unwrap();
        let result2 = nzu32.std_microseconds();
        assert_eq!(result2, StdDuration::from_micros(500));

        // Test case 3
        let nzu32: NonZeroU32 = NonZeroU32::new(1000).unwrap();
        let result3 = nzu32.std_microseconds();
        assert_eq!(result3, StdDuration::from_micros(1000));

        // Test case 4
        let nzu32: NonZeroU32 = NonZeroU32::new(1000000).unwrap();
        let result4 = nzu32.std_microseconds();
        assert_eq!(result4, StdDuration::from_micros(1000000));

        // Test case 5
        let nzu32: NonZeroU32 = NonZeroU32::new(86400000000).unwrap();
        let result5 = nzu32.std_microseconds();
        assert_eq!(result5, StdDuration::from_micros(86400000000));
    }
}
False
========================================
    use std::cmp::PartialEq;
    use std::convert::TryFrom;
    use std::num::NonZeroU32;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, Ordering};
    use crate::Duration;
    use crate::error;
    use crate::ext::{NumericalDuration, NumericalStdDuration};

    impl NumericalDuration for NonZeroU32 {
        fn nanoseconds(self) -> Duration {
            Duration::nanoseconds(self.get() as i64)
        }

        fn microseconds(self) -> Duration {
            Duration::microseconds(self.get() as i64)
        }

        fn milliseconds(self) -> Duration {
            Duration::milliseconds(self.get() as i64)
        }

        fn seconds(self) -> Duration {
            Duration::seconds(self.get() as i64)
        }

        fn minutes(self) -> Duration {
            Duration::minutes(self.get() as i64)
        }

        fn hours(self) -> Duration {
            Duration::hours(self.get() as i64)
        }

        fn days(self) -> Duration {
            Duration::days(self.get() as i64)
        }

        fn weeks(self) -> Duration {
            Duration::weeks(self.get() as i64)
        }
    }

    impl NumericalStdDuration for NonZeroU32 {
        fn std_nanoseconds(self) -> StdDuration {
            StdDuration::from_nanos(self.get() as u64)
        }

        fn std_microseconds(self) -> StdDuration {
            StdDuration::from_micros(self.get() as u64)
        }

        fn std_milliseconds(self) -> StdDuration {
            StdDuration::from_millis(self.get() as u64)
        }

        fn std_seconds(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64)
        }

        fn std_minutes(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 60)
        }

        fn std_hours(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 3_600)
        }

        fn std_days(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 86_400)
        }

        fn std_weeks(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 604_800)
        }
    }

    #[test]
    fn test_std_milliseconds() {
        let duration: NonZeroU32 = NonZeroU32::new(100).unwrap();
        let std_duration: StdDuration = duration.std_milliseconds();
        assert_eq!(std_duration.as_millis(), 100);
    }
}
False
========================================
    use std::crate::Duration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::NumericalDuration;
    use crate::NumericalStdDuration;
    use core::num::NonZeroU32;

    #[test]
    fn test_std_minutes() {
        let duration = NonZeroU32::new(10).unwrap();
        let std_minutes = duration.std_minutes();
        let expected = Duration::from_secs(10 * 60);
        assert_eq!(std_minutes, expected);
    }
}
False
========================================
    use crate::ext::{NumericalStdDuration, NumericalDuration};
    use std::num::NonZeroU32;
    use std::crate::{Duration as StdDuration};

    #[test]
    fn test_std_nanoseconds() {
        let duration: NonZeroU32 = NonZeroU32::new(100).unwrap();
        let std_duration = duration.std_nanoseconds();
        assert_eq!(std_duration, StdDuration::from_nanos(100 as u64));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, SystemTime};

    use crate::ext::{NumericalDuration, NumericalStdDuration};

    #[test]
    fn test_std_seconds() {
        let duration = StdDuration::new(10, 0);
        let non_zero = std::num::NonZeroU32::new(10).unwrap();

        let expected = StdDuration::from_secs(10);
        let result = non_zero.std_seconds();

        assert_eq!(result, expected);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::{NumericalDuration, NumericalStdDuration};

    #[test]
    fn test_std_weeks() {
        let duration = NonZeroU32::new(2).unwrap();
        let std_duration = duration.std_weeks();
        let expected = Duration::from_secs(2 * 604_800);
        assert_eq!(std_duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;

    #[test]
    fn test_std_days() {
        let duration = std::num::NonZeroU64::new(2).unwrap();
        let std_duration = duration.std_days();
        let expected_std_duration = Duration::from_secs(2 * 86_400);
        assert_eq!(std_duration, expected_std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::crate::ext::NumericalStdDuration;
    use std::convert::TryFrom;
    use std::cmp::Ordering;
    use std::ops::{Add, Div, Sub, SubAssign};

    #[test]
    fn test_std_hours() {
        let std_hours: StdDuration = 2.std_hours();
        let expected: StdDuration = StdDuration::from_secs(2 * 3_600);
        assert_eq!(std_hours, expected);
    }

    // Add additional tests here
}
False
========================================
    use std::crate::{Duration, SystemTime};
    use crate::ext::{NumericalStdDuration, std_microseconds};
    use std::num::NonZeroU64;

    #[test]
    fn test_std_microseconds() {
        let duration = NonZeroU64::new(1000).unwrap();
        let std_duration = duration.std_microseconds();
        assert_eq!(std_duration, Duration::from_micros(1000));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;
    use std::num::NonZeroU64;

    #[test]
    fn test_std_milliseconds() {
        let value: NonZeroU64 = NonZeroU64::new(100).unwrap();
        let duration = value.std_milliseconds();
        assert_eq!(duration, Duration::from_millis(100));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_minutes() {
        let duration = Duration::new(120, 0); // 2 minutes
        let result = duration.as_secs() * 60;
        let expected = 120 * 60; // 2 hours in seconds
        assert_eq!(result, expected);
    }
}
False
========================================
    use std::crate::{Duration, SystemTime};
    use crate::{ext::{NumericalStdDuration, StdDuration}};

    #[test]
    fn test_std_nanoseconds() {
        let duration = Duration::nanoseconds(123456);
        let std_duration = StdDuration::from_nanos(123456);
        assert_eq!(duration.num_nanoseconds(), std_duration);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, TryInto};

    pub trait NumericalStdDuration {
        fn std_nanoseconds(self) -> StdDuration;
        fn std_microseconds(self) -> StdDuration;
        fn std_milliseconds(self) -> StdDuration;
        fn std_seconds(self) -> StdDuration;
        fn std_minutes(self) -> StdDuration;
        fn std_hours(self) -> StdDuration;
        fn std_days(self) -> StdDuration;
        fn std_weeks(self) -> StdDuration;
    }

    pub struct NonZeroU64 {
        value: u64,
    }

    impl NonZeroU64 {
        fn new(value: u64) -> Option<Self> {
            if value != 0 {
                Some(Self { value })
            } else {
                None
            }
        }

        fn get(&self) -> u64 {
            self.value
        }
    }

    impl NumericalStdDuration for NonZeroU64 {
        fn std_nanoseconds(self) -> StdDuration {
            StdDuration::from_nanos(self.get() as u64)
        }

        fn std_microseconds(self) -> StdDuration {
            StdDuration::from_micros(self.get() as u64)
        }

        fn std_milliseconds(self) -> StdDuration {
            StdDuration::from_millis(self.get() as u64)
        }

        fn std_seconds(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64)
        }

        fn std_minutes(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 60)
        }

        fn std_hours(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 3_600)
        }

        fn std_days(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 86_400)
        }

        fn std_weeks(self) -> StdDuration {
            StdDuration::from_secs(self.get() as u64 * 604_800)
        }
    }

    impl Add<StdDuration> for NonZeroU64 {
        type Output = StdDuration;

        fn add(self, rhs: StdDuration) -> Self::Output {
            StdDuration::from_secs(self.get() as u64) + rhs
        }
    }

    impl Div<StdDuration> for NonZeroU64 {
        type Output = f64;

        fn div(self, rhs: StdDuration) -> Self::Output {
            StdDuration::from_secs(self.get() as u64).as_secs_f64() / rhs.as_secs_f64()
        }
    }

    impl Sub<StdDuration> for NonZeroU64 {
        type Output = StdDuration;

        fn sub(self, rhs: StdDuration) -> Self::Output {
            let self_duration: std::crate::Duration = std::crate::Duration::from_secs(self.get() as u64);
            let self_duration: StdDuration = self_duration.try_into().expect("Failed to convert to Duration");
            let rhs_duration: StdDuration = rhs.try_into().expect("Failed to convert to Duration");
            let result: StdDuration = self_duration - rhs_duration;
            result
        }
    }

    impl SubAssign<StdDuration> for NonZeroU64 {
        fn sub_assign(&mut self, rhs: StdDuration) {
            let self_duration: std::crate::Duration = std::crate::Duration::from_secs(self.get() as u64);
            let self_duration: StdDuration = self_duration.try_into().expect("Failed to convert to Duration");
            let rhs_duration: StdDuration = rhs.try_into().expect("Failed to convert to Duration");
            let result: StdDuration = self_duration - rhs_duration;
            *self = NonZeroU64::new(result.as_secs()).expect("Cannot represent a resulting duration in NonZeroU64");
        }
    }

    impl TryFrom<StdDuration> for NonZeroU64 {
        type Error = std::num::TryFromIntError;

        fn try_from(duration: StdDuration) -> Result<Self, std::num::TryFromIntError> {
            let seconds = duration.as_secs().try_into();
            let nanoseconds = duration.subsec_nanos().try_into();
            match (seconds, nanoseconds) {
                (Ok(secs), Ok(nanos)) => NonZeroU64::new(secs + nanos).ok_or(std::num::TryFromIntError),
                _ => Err(std::num::TryFromIntError),
            }
        }
    }

    #[test]
    fn test_std_seconds() {
        let duration: StdDuration = StdDuration::from_secs(123456);
        let non_zero: NonZeroU64 = NonZeroU64::new(123456).expect("123456 is not zero");
        assert_eq!(non_zero.std_seconds(), duration);
    }
}
False
========================================
    use std::crate::{Duration as StdDuration, SystemTime};
    use std::num::NonZeroU64;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_weeks() {
        let non_zero_weeks = NonZeroU64::new(2).unwrap(); // choose any non-zero value
        let duration = non_zero_weeks.std_weeks();
        let expected_duration = StdDuration::from_secs(2 * 604_800);
        assert_eq!(duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_days() {
        let d = std::num::NonZeroU8::new(2).unwrap();
        let duration = ext::NumericalDuration::days(d);
        let std_duration = StdDuration::from_secs(2 * 86400);
        assert_eq!(duration, std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroU8;

    #[test]
    fn test_hours() {
        let hours = NonZeroU8::new(2).unwrap();
        let duration = hours.hours();
        assert_eq!(duration, Duration::hours(2));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_microseconds() {
        let duration = StdDuration::from_secs(1);
        let expected = Duration::microseconds(1_000_000);
        assert_eq!(
            <StdDuration as TryFrom<Duration>>::try_from(expected),
            Ok(duration)
        );
    }
}
True
========================================
    use std::num::NonZeroU8;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_milliseconds() {
        let duration = NonZeroU8::new(5).unwrap().milliseconds();
        let expected_duration = Duration::milliseconds(5);
        assert_eq!(duration, expected_duration);
    }

    #[test]
    fn test_milliseconds_conversion() {
        let std_duration = StdDuration::from_millis(5);
        let duration = Duration::try_from(std_duration).unwrap();
        let expected_duration = NonZeroU8::new(5).unwrap().milliseconds();
        assert_eq!(duration, expected_duration);
    }
}
False
========================================
    use std::num::NonZeroU8;
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_minutes() {
        let minutes: NonZeroU8 = unsafe { NonZeroU8::new_unchecked(1) };
        let duration = minutes.minutes();
        assert_eq!(duration, Duration::minutes(1));
    }
}
True
========================================
    use std::crate::{Duration as StdDuration};

    use crate::{Duration};

    #[test]
    fn test_nanoseconds() {
        let nanoseconds = Duration::nanoseconds(1);

        assert_eq!(nanoseconds, Duration::microseconds(1) / 1000);
        assert_eq!(nanoseconds, Duration::milliseconds(1) / 1_000_000);
        assert_eq!(nanoseconds, Duration::seconds(1) / 1_000_000_000);
        assert_eq!(nanoseconds, Duration::minutes(1) / 60 / 1_000_000_000);
        assert_eq!(nanoseconds, Duration::hours(1) / 60 / 60 / 1_000_000_000);
        assert_eq!(nanoseconds, Duration::days(1) / 24 / 60 / 60 / 1_000_000_000);
        assert_eq!(nanoseconds, Duration::weeks(1) / 7 / 24 / 60 / 60 / 1_000_000_000);

        let std_nanoseconds = StdDuration::from_nanos(1);
        assert_eq!(nanoseconds, std_nanoseconds.try_into().unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;

    #[test]
    fn test_seconds() {
        let duration: Duration = NonZeroU8::new(5).unwrap().nanoseconds();
        assert_eq!(duration.whole_seconds(), 5);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDurationShort;
    use crate::Duration;
    use std::num::NonZeroU8;

    #[test]
    fn test_weeks() {
        assert_eq!(
            NumericalDuration::weeks(NonZeroU8::new(1u8)
                .unwrap())
                .as_seconds_f64(),
            604_800.0
        );
        assert_eq!(
            NumericalDuration::weeks(NonZeroU8::new(2u8)
                .unwrap())
                .as_seconds_f64(),
            1_209_600.0
        );
        assert_eq!(
            NumericalDuration::weeks(NonZeroU8::new(0u8)
                .unwrap())
                .as_seconds_f64(),
            0.0
        );
    }
}
True
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::{Duration as StdDuration, Instant};
    use std::num::NonZeroU8;

    trait NumericalDuration {
        fn nanoseconds(self) -> StdDuration;
        fn microseconds(self) -> StdDuration;
        fn milliseconds(self) -> StdDuration;
        fn seconds(self) -> StdDuration;
        fn minutes(self) -> StdDuration;
        fn hours(self) -> StdDuration;
        fn days(self) -> StdDuration;
        fn weeks(self) -> StdDuration;
    }

    trait NumericalStdDuration {
        fn std_nanoseconds(self) -> StdDuration;
        fn std_microseconds(self) -> StdDuration;
        fn std_milliseconds(self) -> StdDuration;
        fn std_seconds(self) -> StdDuration;
        fn std_minutes(self) -> StdDuration;
        fn std_hours(self) -> StdDuration;
        fn std_days(self) -> StdDuration;
        fn std_weeks(self) -> StdDuration;
    }

    fn std_days(self) -> StdDuration {
        StdDuration::from_secs(self.get() as u64 * 86_400)
    }

    #[test]
    fn test_std_days() {
        let duration: StdDuration = StdDuration::from_secs(86400);
        let non_zero_u8 = NonZeroU8::new(1).unwrap();
        let std_duration = duration.std_days();
        let expected_duration: StdDuration = StdDuration::from_secs(86400);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::Duration;

    #[test]
    fn test_std_hours() {
        let hours = crate::ext::NumericalStdDuration::std_hours(4u8.into());
        let expected = StdDuration::from_secs(4 * 3_600);
        assert_eq!(hours, expected);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::{NumericalDuration, NumericalStdDuration};

    #[test]
    fn test_std_microseconds() {
        let value: u8 = 42;
        let nonzero_value = std::num::NonZeroU8::new(value).unwrap();
        let duration = nonzero_value.std_microseconds();
        assert_eq!(duration, Duration::from_micros(value as u64));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::crate::Duration;
    use std::convert::TryFrom;
    use crate::{Duration as TimeDuration, NumericalDuration, NumericalStdDuration};
    
    #[test]
    fn test_std_milliseconds() {
        let duration: TimeDuration = TimeDuration::milliseconds(100);
        let std_duration: Duration = <TimeDuration as NumericalStdDuration>::std_milliseconds(duration);
        let expected_duration: Duration = Duration::from_millis(100);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use std::crate::Duration;
    use std::num::NonZeroU8;
    use crate::ext::{NumericalDuration, NumericalStdDuration};

    #[test]
    fn test_std_minutes() {
        let value: NonZeroU8 = NonZeroU8::new(5).unwrap();
        let result = value.std_minutes();
        let expected = Duration::from_secs(5u64 * 60u64);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_std_nanoseconds() {
        let duration: std::num::NonZeroU8 = std::num::NonZeroU8::new(5).unwrap();
        let std_duration: std::crate::Duration = duration.std_nanoseconds();
        assert_eq!(std_duration.as_nanos(), 5);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration, Instant};

    #[test]
    fn test_std_seconds() {
        let duration = std::crate::Duration::from_secs(5);
        let std_duration = duration.std_seconds();
        assert_eq!(std_duration, std::crate::Duration::from_secs(5));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration as StdDuration;
    use crate::ext::{NumericalDuration, NumericalStdDuration};
    use crate::Duration;

    #[test]
    fn test_std_weeks() {
        let weeks = 2;
        let non_zero_weeks = std::num::NonZeroU8::new(weeks).unwrap();

        let expected = StdDuration::from_secs(weeks as u64 * 604_800);
        let actual = non_zero_weeks.std_weeks();

        assert_eq!(actual, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_parse() {
        let s = "2022-01-01 12:00:00";
        let format = "%Y-%m-%d %H:%M:%S";
        let result = <time_mod::Time as private::Parsable>::parse(s, format);
        assert!(result.is_ok());
        // add more tests here
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_cmp() {
        let time1 = Time {
            hour: 12,
            minute: 30,
            second: 45,
            nanosecond: 0,
        };
        let time2 = Time {
            hour: 12,
            minute: 30,
            second: 45,
            nanosecond: 0,
        };
        let time3 = Time {
            hour: 12,
            minute: 30,
            second: 30,
            nanosecond: 0,
        };
        let time4 = Time {
            hour: 12,
            minute: 45,
            second: 0,
            nanosecond: 0,
        };
        let time5 = Time {
            hour: 13,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };

        assert_eq!(time1.cmp(&time2), Ordering::Equal);
        assert_eq!(time1.cmp(&time3), Ordering::Greater);
        assert_eq!(time1.cmp(&time4), Ordering::Less);
        assert_eq!(time1.cmp(&time5), Ordering::Less);
        assert_eq!(time3.cmp(&time4), Ordering::Less);
        assert_eq!(time4.cmp(&time5), Ordering::Less);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_partial_cmp() {
        let time1 = Time {
            hour: 1,
            minute: 30,
            second: 0,
            nanosecond: 0,
        };
        let time2 = Time {
            hour: 2,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        let time3 = Time {
            hour: 1,
            minute: 30,
            second: 0,
            nanosecond: 0,
        };
        let time4 = Time {
            hour: 0,
            minute: 59,
            second: 0,
            nanosecond: 0,
        };
        let time5 = Time {
            hour: 2,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };

        assert_eq!(time1.partial_cmp(&time2), Some(Ordering::Less));
        assert_eq!(time2.partial_cmp(&time1), Some(Ordering::Greater));
        assert_eq!(time1.partial_cmp(&time3), Some(Ordering::Equal));
        assert_eq!(time4.partial_cmp(&time5), Some(Ordering::Less));
    }
}
True
<time_mod::Time as std::ops::Add<duration::Duration>>::add exceed
========================================
    use super::*;

use crate::*;
    use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_add_duration() {
        assert_eq!(Time::from_hms(12, 0, 0) + 2.std_hours(), Time::from_hms(14, 0, 0));
        assert_eq!(
            Time::from_hms(23, 59, 59) + 2.std_seconds(),
            Time::from_hms(0, 0, 1)
        );
    }
}
False
<time_mod::Time as std::ops::AddAssign<duration::Duration>>::add_assign exceed
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn test_add_assign_duration() {
        let mut time = Time {
            hour: 12,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(Duration::minutes(30));
        assert_eq!(time, Time {
            hour: 12,
            minute: 30,
            second: 0,
            nanosecond: 0,
        });
    }

    #[test]
    fn test_add_assign_std_duration() {
        let mut time = Time {
            hour: 12,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(StdDuration::from_secs(1800));
        assert_eq!(time, Time {
            hour: 12,
            minute: 30,
            second: 0,
            nanosecond: 0,
        });
    }

    #[test]
    fn test_add_assign_duration_overflow() {
        let mut time = Time {
            hour: 23,
            minute: 30,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(Duration::hours(2));
        assert_eq!(time, Time {
            hour: 1,
            minute: 30,
            second: 0,
            nanosecond: 0,
        });
    }

    #[test]
    fn test_add_assign_std_duration_overflow() {
        let mut time = Time {
            hour: 23,
            minute: 30,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(StdDuration::from_secs(7200));
        assert_eq!(time, Time {
            hour: 1,
            minute: 30,
            second: 0,
            nanosecond: 0,
        });
    }

    #[test]
    fn test_add_assign_duration_microsecond_precision() {
        let mut time = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(Duration::microseconds(1));
        assert_eq!(time, Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 1_000,
        });
    }

    #[test]
    fn test_add_assign_std_duration_microsecond_precision() {
        let mut time = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(StdDuration::from_micros(1));
        assert_eq!(time, Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 1_000,
        });
    }

    #[test]
    fn test_add_assign_duration_nanosecond_precision() {
        let mut time = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(Duration::nanoseconds(1));
        assert_eq!(time, Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 1,
        });
    }

    #[test]
    fn test_add_assign_std_duration_nanosecond_precision() {
        let mut time = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        time.add_assign(StdDuration::from_nanos(1));
        assert_eq!(time, Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 1,
        });
    }
}
False
<time_mod::Time as std::ops::Sub<duration::Duration>>::sub exceed
========================================
    use crate::time_mod::*;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_sub() {
        let time1 = Time {
            hour: 14,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        let duration1 = StdDuration::from_secs(2 * 60 * 60);
        let expected1 = Time {
            hour: 12,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        assert_eq!(time1.sub(duration1), expected1);
        
        let time2 = Time {
            hour: 0,
            minute: 0,
            second: 1,
            nanosecond: 0,
        };
        let duration2 = StdDuration::from_secs(2);
        let expected2 = Time {
            hour: 23,
            minute: 59,
            second: 59,
            nanosecond: 0,
        };
        assert_eq!(time2.sub(duration2), expected2);
    }
}
False
========================================
    use crate::duration::Duration;
    use crate::macros::time;
    use crate::crate::Time;
    use crate::prelude::*;

    #[test]
    fn test_sub() {
        assert_eq!(Time::from_hms(0, 0, 0) - Time::from_hms(0, 0, 0), Duration::zero());
        assert_eq!(Time::from_hms(1, 0, 0) - Time::from_hms(0, 0, 0), Duration::hours(1));
        assert_eq!(Time::from_hms(0, 0, 0) - Time::from_hms(1, 0, 0), Duration::hours(-1));
        assert_eq!(Time::from_hms(0, 0, 0) - Time::from_hms(23, 0, 0), Duration::hours(-23));
    }
}
False
<time_mod::Time as std::ops::SubAssign<duration::Duration>>::sub_assign exceed
========================================
    use std::crate::Duration as StdDuration;
    use crate::{Time, time};
    use time_macros::time;

    #[test]
    fn test_sub_assign() {
        let mut time = time!(14:00);
        time.sub_assign(2.std_hours());
        assert_eq!(time, time!(12:00));

        let mut time = time!(0:00:01);
        time.sub_assign(2.std_seconds());
        assert_eq!(time, time!(23:59:59));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_days() {
        let duration = Duration::days(5);

        assert_eq!(<Duration as NumericalDuration>::days(&duration), Duration::days(5));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_hours() {
        let duration = <u16 as ext::NumericalDuration>::hours(3);
        let expected = Duration::hours(3);

        assert_eq!(duration, expected);

        let std_duration = StdDuration::new(3 * 3_600, 0);
        let converted = Duration::try_from(std_duration).unwrap();

        assert_eq!(duration, converted);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_microseconds() {
        let duration = <u16 as ext::NumericalDuration>::microseconds(123);
        let expected = Duration::microseconds(123);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;
    use crate::error::ConversionRange;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_milliseconds() {
        let duration = duration::Duration::seconds(1);
        let ms_duration = NumericalDuration::milliseconds(&duration);
        let expected = StdDuration::from_secs(1).try_into().unwrap();
        assert_eq!(ms_duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_minutes() {
        let duration = <u16 as crate::ext::NumericalDuration>::minutes(10);
        let expected = StdDuration::from_secs(600);
        assert_eq!(Duration::try_from(expected).unwrap(), duration);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::nanoseconds(1000);
        let expected = StdDuration::new(0, 1000);
        assert_eq!(duration, Duration::try_from(expected).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;

    #[test]
    fn test_seconds() {
        let duration = 10.seconds();
        assert_eq!(duration, Duration::new(10, 0));
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;
    
    #[test]
    fn test_weeks() {
        let duration: Duration = 2.weeks();
        assert_eq!(duration, Duration::seconds(1209600));
    }
}
True
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration;
    use crate::ext::{self, NumericalStdDuration};
    use crate::Duration as StdDuration;
    
    #[test]
    fn std_days_test() {
        let duration = StdDuration::new(1, 0);
        let std_duration = duration.std_days();
        let expected_duration = Duration::from_secs(86400);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;

    #[test]
    fn std_hours_test() {
        let duration: u16 = 5;
        let expected_result = Duration::from_secs(duration as u64 * 3_600);
        let actual_result = duration.std_hours();
        assert_eq!(actual_result, expected_result);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;
    use std::convert::TryInto;
    use crate::NumericalStdDuration; // Add this line

    #[test]
    fn test_std_microseconds() {
        let v: u16 = 1000;
        let expected = Duration::from_micros(v as u64);
        let result = v.std_microseconds();
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_milliseconds() {
        let duration = Duration::from_millis(500);
        let std_duration = duration.std_milliseconds();
        assert_eq!(std_duration, std::crate::Duration::from_millis(500));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_minutes() {
        let duration = Duration::from_secs(120);
        let std_duration = duration.std_minutes();
        assert_eq!(std_duration, Duration::from_secs(2 * 60));
    }
}
False
========================================
    use std::crate::Duration;
    use crate::{Duration as custom_Duration, ext::NumericalStdDuration};

    #[test]
    fn test_std_nanoseconds() {
        let dur: custom_Duration = custom_Duration::new(5, 123456789);
        let std_dur: Duration = dur.std_nanoseconds();

        assert_eq!(std_dur.as_secs(), 5);
        assert_eq!(std_dur.subsec_nanos(), 123456789);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::Duration;

    #[test]
    fn test_std_seconds() {
        let duration: u16 = 10;
        let std_duration: StdDuration = duration.std_seconds();
        assert_eq!(std_duration.as_secs(), duration as u64);
        assert_eq!(std_duration.as_secs_f32(), duration as f32);
        assert_eq!(std_duration.as_secs_f64(), duration as f64);
        assert_eq!(std_duration, StdDuration::from_secs(duration as u64));
        assert_eq!(std_duration.partial_cmp(&StdDuration::from_secs(5)), Some(Ordering::Greater));
        assert_eq!(std_duration.partial_cmp(&StdDuration::from_secs(15)), Some(Ordering::Less));
        assert_eq!(std_duration + StdDuration::from_secs(5), StdDuration::from_secs(15));
        assert_eq!(std_duration - StdDuration::from_secs(5), StdDuration::from_secs(5));
        assert_eq!(std_duration / Duration::from_std(StdDuration::from_secs(2)), 5.0);
        let mut mutable_std_duration = std_duration;
        mutable_std_duration -= StdDuration::from_secs(5);
        assert_eq!(mutable_std_duration, StdDuration::from_secs(5));
        let duration: Duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(duration.seconds(), 10);
        assert_eq!(duration.nanoseconds(), 0);
    }
}
False
========================================
    use std::crate::{Duration, Instant};
    use crate::ext::{NumericalStdDuration, std_weeks};
    
    #[test]
    fn test_std_weeks() {
        let duration: u16 = 1;
        let std_duration = duration.std_weeks();
        let expected_duration = Duration::from_secs(604_800);
        
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    // Update the import path
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::convert::TryFrom;

    #[test]
    fn test_days() {
        let duration = Duration::days(5);
        let std_duration = StdDuration::from_secs(5 * 24 * 60 * 60);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let duration = Duration::days(-5);
        let std_duration = StdDuration::from_secs(-5 * 24 * 60 * 60);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(5);
        let expected = StdDuration::new(5 * 3_600, 0);
        assert_eq!(Duration::try_from(expected), Ok(duration));

        let duration = Duration::hours(0);
        let expected = StdDuration::new(0, 0);
        assert_eq!(Duration::try_from(expected), Ok(duration));

        let duration = Duration::hours(-5);
        let expected = StdDuration::new((-5) * 3_600, 0);
        assert_eq!(Duration::try_from(expected), Ok(duration));

    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use std::convert::TryFrom;

    #[test]
    fn test_microseconds() {
        let duration = Duration::seconds(1);
        let result = Duration::microseconds(duration.as_std().as_micros() as i64);
        let expected = Duration::microseconds(1_000_000);
        assert_eq!(result, expected);
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(1000);
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_milliseconds(), 0);

        let duration = Duration::milliseconds(1500);
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_milliseconds(), 500);

        let duration = Duration::milliseconds(-1000);
        assert_eq!(duration.whole_seconds(), -1);
        assert_eq!(duration.subsec_milliseconds(), 0);
    }

    #[test]
    fn test_milliseconds_with_std_duration() {
        let std_duration = StdDuration::from_secs(1);
        let duration = Duration::milliseconds(std_duration);
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_milliseconds(), 0);

        let std_duration = StdDuration::from_millis(1500);
        let duration = Duration::milliseconds(std_duration);
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_milliseconds(), 500);

        let std_duration = StdDuration::from_secs(1).checked_neg().unwrap();
        let duration = Duration::milliseconds(std_duration);
        assert_eq!(duration.whole_seconds(), -1);
        assert_eq!(duration.subsec_milliseconds(), 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(5);
        assert_eq!(duration, Duration::seconds(300));
    }
}
True
========================================
    use crate::{ext::NumericalDuration, duration::Duration};
    use std::convert::TryFrom;

    #[test]
    fn test_nanoseconds() {
        let duration = Duration::seconds(10);
        assert_eq!(
            Duration::nanoseconds(duration.whole_nanoseconds()),
            Duration::nanoseconds(10_000_000_000)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_seconds() {
        assert_eq!(<u32 as ext::NumericalDuration>::seconds(10), StdDuration::from_secs(10));
        assert_eq!(<u32 as ext::NumericalDuration>::seconds(u32::MAX), StdDuration::from_secs(u32::MAX as u64));
    }
}
False
========================================
    use super::*;

use crate::*;
    use duration::Duration;
    use ext::NumericalDuration;
    
    #[test]
    fn test_weeks() {
        assert_eq!(<u32 as ext::NumericalDuration>::weeks(1), Duration::weeks(1));
        assert_eq!(<u32 as ext::NumericalDuration>::weeks(0), Duration::weeks(0));
        assert_eq!(<u32 as ext::NumericalDuration>::weeks(100), Duration::weeks(100));
    }
}
True
========================================
    use std::crate::Duration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use crate::ext::{NumericalStdDuration, StdDuration};
    use crate::error::ConversionRange;

    #[test]
    fn test_std_days() {
        let duration: u32 = 2;
        let std_duration = duration.std_days();

        let expected_secs = 2 * 86_400;
        let expected_duration = Duration::from_secs(expected_secs as u64);

        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn test_duration_add() {
        let std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(86_400);

        let expected_duration = Duration::from_secs(3 * 86_400);

        assert_eq!(std_duration + duration, expected_duration);
    }

    #[test]
    fn test_duration_div() {
        let std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(86_400);

        let expected_result: f64 = 2.0;
        let result = std_duration / duration;

        assert_eq!(result, expected_result);
    }

    #[test]
    fn test_duration_eq() {
        let std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(2 * 86_400);

        assert_eq!(std_duration, duration);
    }

    #[test]
    fn test_duration_partial_cmp() {
        let std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(3 * 86_400);

        let expected_result = Some(Ordering::Less);
        let result = std_duration.partial_cmp(&duration);

        assert_eq!(result, expected_result);
    }

    #[test]
    fn test_duration_sub() {
        let std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(86_400);

        let expected_duration = Duration::from_secs(86_400);

        assert_eq!(std_duration - duration, expected_duration);
    }

    #[test]
    fn test_duration_sub_assign() {
        let mut std_duration: StdDuration = Duration::from_secs(2 * 86_400);
        let duration = Duration::from_secs(86_400);

        let expected_duration = Duration::from_secs(86_400);

        std_duration -= duration;

        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn test_try_from_duration() {
        let duration = Duration::from_secs(2 * 86_400);

        let expected_result: Result<StdDuration, ConversionRange> = Ok(StdDuration::from_secs(2 * 86_400));

        assert_eq!(StdDuration::try_from(duration), expected_result);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    
    #[test]
    fn test_std_hours() {
        let duration = Duration::from_secs(7200);
        let std_duration = duration.std_hours();
        let expected_duration = Duration::from_secs(7200);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_microseconds() {
        let std_microseconds_fn = |x: u32| -> Duration {
            Duration::from_micros(x as u64)
        };

        assert_eq!(std_microseconds_fn(0),  Duration::from_micros(0));
        assert_eq!(std_microseconds_fn(1),  Duration::from_micros(1));
        assert_eq!(std_microseconds_fn(123),  Duration::from_micros(123));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::ext::{NumericalStdDuration, StdDuration};

    #[test]
    fn test_std_milliseconds() {
        let duration = StdDuration::new(12345, 6789);
        let std_milliseconds = duration.std_milliseconds();
        let expected = Duration::from_millis(12345);
        assert_eq!(std_milliseconds, expected);
    }
}
False
========================================
    use std::crate::{Duration, SystemTime, UNIX_EPOCH};

    #[test]
    fn test_std_minutes() {
        // Create a `Duration` instance
        let duration = Duration::from_secs(120);

        // Calculate the standard minutes
        let std_minutes = duration.std_minutes();

        // Assert the standard minutes
        assert_eq!(std_minutes, Duration::from_secs(2 * 60));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::convert::{TryFrom, TryInto};
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration;

    #[test]
    fn test_std_nanoseconds() {
        let duration: u32 = 1000;
        let expected = Duration::from_nanos(duration as u64);
        let actual = duration.std_nanoseconds();

        assert_eq!(actual, expected);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    
    #[test]
    fn test_std_seconds() {
        let duration: u32 = 3600;
        let expected = Duration::from_secs(3600);
        let result = duration.std_seconds();
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_std_weeks() {
        let duration: u32 = 2;
        let expected = StdDuration::from_secs(duration as u64 * 604_800);
        let result = duration.std_weeks();
        assert_eq!(result, expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_days() {
        let duration: Duration = Duration::from_secs(86400);
        let std_duration: std::crate::Duration = std::crate::Duration::from_secs(1);
        
        assert_eq!(duration.std_days(), std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration as StdDuration;

    impl NumericalStdDuration for u64 {
        fn std_hours(self) -> StdDuration {
            StdDuration::from_secs(self * 3_600)
        }
    }

    #[test]
    fn test_std_hours() {
        let duration1 = StdDuration::from_secs(3600);
        let duration2 = StdDuration::from_secs(7200);

        assert_eq!(duration1.std_hours(), StdDuration::from_secs(1));
        assert_eq!(duration2.std_hours(), StdDuration::from_secs(2));
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_microseconds() {
        trait NumericalStdDuration {
            fn as_microseconds(self) -> u64;
        }
        
        impl NumericalStdDuration for u64 {
            fn as_microseconds(self) -> u64 {
                self
            }
        }
        
        impl NumericalStdDuration for i64 {
            fn as_microseconds(self) -> u64 {
                self as u64
            }
        }
        
        impl NumericalStdDuration for StdDuration {
            fn as_microseconds(self) -> u64 {
                self.as_micros() as u64
            }
        }
        
        fn std_microseconds<T: NumericalStdDuration>(self) -> StdDuration {
            StdDuration::from_micros(self.as_microseconds())
        }

        let duration: u64 = 100;
        let expected_result = StdDuration::from_micros(100);

        let result = duration.std_microseconds();

        assert_eq!(result, expected_result);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_std_milliseconds() {
        let duration = StdDuration::from_millis(500);
        let std_duration = duration.std_milliseconds();
        let expected = 500;
        assert_eq!(std_duration.as_millis(), expected);
    }

    #[test]
    fn test_std_milliseconds_add() {
        let duration = StdDuration::from_millis(500);
        let rhs = Duration::from_millis(200);
        let std_duration = duration + rhs;
        let expected = 700;
        assert_eq!(std_duration.as_millis(), expected);
    }

    #[test]
    fn test_std_milliseconds_div() {
        let duration = StdDuration::from_millis(1000);
        let rhs = Duration::from_millis(500);
        let result = duration.div(rhs);
        let expected = 2.0;
        assert_eq!(result, expected);
    }

    #[test]
    fn test_std_milliseconds_eq() {
        let duration = StdDuration::from_millis(500);
        let rhs = Duration::from_millis(500);
        assert_eq!(duration, rhs);
    }

    #[test]
    fn test_std_milliseconds_partial_cmp() {
        let duration = StdDuration::from_millis(1000);
        let rhs = Duration::from_millis(500);
        let result = duration.partial_cmp(&rhs);
        let expected = Some(Ordering::Greater);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_std_milliseconds_sub() {
        let duration = StdDuration::from_millis(1000);
        let rhs = Duration::from_millis(500);
        let std_duration = duration - rhs;
        let expected = Duration::from_millis(500);
        assert_eq!(std_duration, expected);
    }
    
    #[test]
    fn test_std_milliseconds_sub_assign() {
        let mut duration = StdDuration::from_millis(1000);
        let rhs = Duration::from_millis(500);
        duration -= rhs;
        let expected = Duration::from_millis(500);
        assert_eq!(duration, expected);
    }
    
    #[test]
    fn test_try_from_duration() {
        let duration = Duration::from_millis(1000);
        let std_duration = StdDuration::try_from(duration).unwrap();
        let expected = StdDuration::from_secs(1);
        assert_eq!(std_duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;

    #[test]
    fn test_std_minutes() {
        let duration = Duration::from_std(StdDuration::from_secs(180)).unwrap();
        let std_duration = <u64 as NumericalStdDuration>::std_minutes(3);
        assert_eq!(std_duration, duration);
    }
}
True
========================================
    use std::time;
    use std::crate::Duration;
    use std::convert::TryInto;
    use std::cmp::Ordering;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_nanoseconds() {
        let std_duration = crate::Duration::new(10, 0);
        let nanoseconds = std_duration.std_nanoseconds();
        let expected = Duration::from_nanos(10_000_000_000);
        assert_eq!(nanoseconds, expected);
    }
}
False
========================================
#[cfg(test)]
mod test {
    use std::crate::Duration;

    #[test]
    fn test_std_seconds() {
        let dur = Duration::new(10, 0);
        assert_eq!(dur.std_seconds(), 10);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    use crate::StdDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::ops::{Add, Div, Sub, SubAssign};
    
    #[test]
    fn test_std_weeks() {
        let duration = StdDuration::from_secs(86400);
        let weeks = duration.std_weeks();

        assert_eq!(weeks.as_secs(), 1);
        assert_eq!(weeks.sub(StdDuration::from_secs(1)).as_secs(), 0);

        let duration2 = StdDuration::from_secs(604_800);
        let weeks2 = duration2.std_weeks();

        assert_eq!(weeks2.as_secs(), 1);
        assert_eq!(weeks2.sub(StdDuration::from_secs(1)).as_secs(), 0);

        let duration3 = StdDuration::from_secs(900_000);
        let weeks3 = duration3.std_weeks();

        assert_eq!(weeks3.as_secs(), 1);
        assert_eq!(weeks3.sub(StdDuration::from_secs(1)).as_secs(), 0);

        let duration4 = StdDuration::from_secs(0);
        let weeks4 = duration4.std_weeks();

        assert_eq!(weeks4.as_secs(), 0);
        assert_eq!(weeks4.sub(StdDuration::from_secs(1)).as_secs(), 604_800);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;

    #[test]
    fn test_days() {
        let dur = NumericalDuration::days(5);
        assert_eq!(dur, Duration::days(5));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_hours() {
        let duration = Duration::hours(5);
        assert_eq!(duration.whole_seconds(), 5 * 3600);
        assert_eq!(duration.subsec_nanoseconds(), 0);

        let duration: Duration = ext::NumericalDuration::hours(5).try_into().unwrap();
        assert_eq!(duration.whole_seconds(), 5 * 3600);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_microseconds() {
        let duration = Duration::seconds(1);
        assert_eq!(<Duration as NumericalDuration>::microseconds(duration), Duration::microseconds(1));
    }
}

False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_milliseconds() {
        let duration = Duration::milliseconds(100);
        assert_eq!(duration, StdDuration::from_millis(100));
    }
}
False
========================================
    use crate::Duration;

    #[test]
    fn test_minutes() {
        let duration = Duration::minutes(1);
        assert_eq!(duration, Duration::seconds(60));
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_nanoseconds() {
        let d1 = Duration::nanoseconds(1);
        assert_eq!(d1.whole_nanoseconds(), 1);
        
        let d2 = Duration::nanoseconds(-1);
        assert_eq!(d2.whole_nanoseconds(), -1);
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn test_seconds() {
        let duration = 5.seconds();
        assert_eq!(duration, Duration::new(5, 0));
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_weeks() {
        let duration = <u8 as ext::NumericalDuration>::weeks(2);
        let expected = Duration::weeks(2);
        assert_eq!(duration, expected);
    }
}
True
========================================
    use std::crate::{Duration, Instant};
    use std::convert::TryFrom;
    use crate::ext::{NumericalStdDuration, StdDuration};

    #[test]
    fn test_std_days() {
        let days: u8 = 5;
        let std_duration = days.std_days();
        let expected_duration = StdDuration::from_secs(days as u64 * 86_400);

        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration;

    #[test]
    fn test_std_hours() {
        let duration = Duration::from_secs(3600);
        let std_duration: StdDuration = duration.try_into().unwrap();

        assert_eq!(std_duration.std_hours(), duration);
    }
}
False
========================================
    use std::crate::Duration;
    use crate::ext::NumericalStdDuration;
    use crate::ext::NumericalDuration;
    use crate::StdDuration;
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use crate::error::ConversionRange;

    #[test]
    fn test_std_microseconds() {
        let us: u8 = 10;
        let expected: StdDuration = Duration::from_micros(us as u64);
        assert_eq!(us.std_microseconds(), expected);
    }

    #[test]
    fn test_std_microseconds_ops_add() {
        let us: u8 = 10;
        let duration: Duration = Duration::from_micros(us as u64);
        let expected: Duration = duration + us as u64;
        assert_eq!(us.std_microseconds() + duration, expected);
    }

    #[test]
    fn test_std_microseconds_ops_div() {
        let us: u8 = 10;
        let duration: Duration = Duration::from_micros(us as u64);
        let expected: f64 = duration.as_secs_f64() / us as f64;
        assert_eq!(us.std_microseconds() / duration, expected);
    }

    #[test]
    fn test_std_microseconds_cmp_eq() {
        let us1: u8 = 10;
        let us2: u8 = 20;
        let duration1: Duration = Duration::from_micros(us1 as u64);
        let duration2: Duration = Duration::from_micros(us2 as u64);
        assert_eq!(us1.std_microseconds() == duration1, true);
        assert_eq!(us1.std_microseconds() == duration2, false);
    }

    #[test]
    fn test_std_microseconds_cmp_ord() {
        let us1: u8 = 10;
        let us2: u8 = 20;
        let duration1: Duration = Duration::from_micros(us1 as u64);
        let duration2: Duration = Duration::from_micros(us2 as u64);
        assert_eq!(us1.std_microseconds().partial_cmp(&duration1), Some(Ordering::Equal));
        assert_eq!(us1.std_microseconds().partial_cmp(&duration2), Some(Ordering::Less));
    }

    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn test_std_microseconds_ops_sub() {
        let us1: u8 = 10;
        let us2: u8 = 20;
        let duration1: Duration = Duration::from_micros(us1 as u64);
        let duration2: Duration = Duration::from_micros(us2 as u64);
        let _ = us1.std_microseconds() - duration1;
        let _ = us1.std_microseconds() - duration2;
    }

    #[test]
    #[should_panic(expected = "Cannot represent a resulting duration in std. Try `let x = x - rhs;`, which will \
             change the type.")]
    fn test_std_microseconds_ops_subassign() {
        let us1: u8 = 10;
        let us2: u8 = 20;
        let duration1: Duration = Duration::from_micros(us1 as u64);
        let duration2: Duration = Duration::from_micros(us2 as u64);
        let mut std_duration: StdDuration = us1.std_microseconds();
        std_duration -= duration1;
        std_duration -= duration2;
    }

    #[test]
    fn test_std_microseconds_try_from() {
        let us: u8 = 10;
        let duration: Duration = Duration::from_micros(us as u64);
        let expected: Result<StdDuration, ConversionRange> = Ok(duration);
        assert_eq!(StdDuration::try_from(duration), expected);
    }
}
False
========================================
    use std::crate::Duration;
    use std::cmp::Ordering;
    use std::convert::TryInto;
    use std::ops::{Add, Div, Sub, SubAssign};
    use crate::ext::{NumericalStdDuration, StdDuration};
    
    #[test]
    fn test_std_milliseconds() {
        let duration: StdDuration = 5_u8.std_milliseconds();
        let expected: StdDuration = StdDuration::from_millis(5_u64);

        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn std_minutes_test() {
        let duration = StdDuration::from_secs(120);
        let std_minutes = duration.std_minutes();
        let expected = StdDuration::from_secs(120 * 60);
        assert_eq!(std_minutes, expected);
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::Duration;
    use crate::StdDuration;
    
    #[test]
    fn test_std_nanoseconds() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration.std_nanoseconds(), duration);
    }
    
    #[test]
    fn test_std_nanoseconds_add() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration.std_nanoseconds() + duration, duration + std_duration);
    }
    
    #[test]
    fn test_std_nanoseconds_div() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration.std_nanoseconds() / duration, std_duration.as_secs_f64() / duration.as_secs_f64());
    }
    
    #[test]
    fn test_std_nanoseconds_eq() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration.std_nanoseconds(), duration);
        assert_eq!(std_duration, duration);
    }
    
    #[test]
    fn test_std_nanoseconds_ord() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration.std_nanoseconds().partial_cmp(&duration), Some(Ordering::Greater));
    }
    
    #[test]
    fn test_std_nanoseconds_sub() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        let sub = std_duration.std_nanoseconds() - duration;
        assert_eq!(sub, Duration::try_from(sub).unwrap());
    }
    
    #[test]
    fn test_std_nanoseconds_sub_assign() {
        let mut std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        *std_duration.std_nanoseconds() -= duration;
        assert_eq!(std_duration, Duration::try_from(std_duration).unwrap());
    }
    
    #[test]
    fn test_std_nanoseconds_try_from() {
        let std_duration = StdDuration::from_nanos(1000);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(std_duration, StdDuration::try_from(duration).unwrap());
    }
}
False
========================================
    use std::crate::{Duration, Instant};
    use crate::ext::NumericalStdDuration;
    use std::convert::TryFrom;
    use std::cmp::Ordering;

    #[test]
    fn test_std_seconds() {
        let duration_seconds = 5u8;
        let duration = duration_seconds.std_seconds();
        let expected_std_duration = Duration::from_secs(duration_seconds as u64);

        assert_eq!(duration, expected_std_duration);
    }
}
False
========================================
    use std::crate::Duration;
    use std::crate::Duration as StdDuration;
    use std::cmp::PartialEq;
    use std::cmp::PartialOrd;
    use std::convert::TryFrom;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Sub;
    use std::ops::SubAssign;
    use std::cmp::Ordering;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_weeks() {
        let duration: u8 = 2;
        let expected: StdDuration = Duration::from_secs(duration as u64 * 604_800);
        assert_eq!(duration.std_weeks(), expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_parse() {
        let s = "<string_value>"; // Replace with a valid string value
        let format = "<format_value>"; // Replace with a valid format value
        
        let result: std::result::Result<_, format::parse::Error> = parse(s, format);
        
        assert!(result.is_ok());
        // Add more assertions if needed
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_as_ymd() {
        assert_eq!(Date::try_from_ymd(2019, 1, 1).unwrap().as_ymd(), (2019, 1, 1));
        assert_eq!(Date::try_from_ymd(2020, 12, 31).unwrap().as_ymd(), (2020, 12, 31));
    }
}
True
========================================
    use crate::date;
    use crate::Date;

    #[test]
    fn test_as_yo() {
        assert_eq!(Date::try_from_ymd(2019, 1, 1).unwrap().as_yo(), (2019, 1));
        assert_eq!(Date::try_from_ymd(2019, 12, 31).unwrap().as_yo(), (2019, 365));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::Date;
    use crate::date;

    #[test]
    fn test_day() {
        assert_eq!(date!(2019-01-01).day(), 1);
        assert_eq!(date!(2019-12-31).day(), 31);
    }

    #[test]
    fn test_day_value_in_range() {
        fn test_fn(year: i32, month: u8, day: u8) -> Result<(), ComponentRange> {
            Date::try_from_ymd(year, month, day)?;
            Ok(())
        }

        assert_eq!(test_fn(2019, 1, 1), Ok(()));
        assert_eq!(test_fn(2019, 12, 31), Ok(()));
    }

    #[test]
    #[should_panic]
    fn test_day_value_in_range_panic() {
        Date::try_from_ymd(2019, 2, 30).unwrap();
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::date::Date;

    #[test]
    fn test_format() {
        assert_eq!(Date::from_ymd(2019, 1, 2).format("%Y-%m-%d"), "2019-01-02");
    }
}
False
========================================
    use crate::date;

    use super::*;

use crate::*;

    #[test]
    fn test_from_julian_day() {
        assert_eq!(Date::from_julian_day(0), date!(-4713-11-24));
        assert_eq!(Date::from_julian_day(2_451_545), date!(2000-01-01));
        assert_eq!(Date::from_julian_day(2_458_485), date!(2019-01-01));
        assert_eq!(Date::from_julian_day(2_458_849), date!(2019-12-31));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_iso_weekday_number() {
        let date = Date::from_ymd(2022, 6, 7);
        assert!(date.iso_weekday_number() == 2);
        let date = Date::from_ymd(2022, 6, 8);
        assert!(date.iso_weekday_number() == 3);
        let date = Date::from_ymd(2022, 6, 9);
        assert!(date.iso_weekday_number() == 4);
        let date = Date::from_ymd(2022, 6, 10);
        assert!(date.iso_weekday_number() == 5);
        let date = Date::from_ymd(2022, 6, 11);
        assert!(date.iso_weekday_number() == 6);
        let date = Date::from_ymd(2022, 6, 12);
        assert!(date.iso_weekday_number() == 7);
        let date = Date::from_ymd(2022, 6, 13);
        assert!(date.iso_weekday_number() == 1);

        let date = Date::from_ymd(2022, 1, 1);
        assert!(date.iso_weekday_number() == 6);
        let date = Date::from_ymd(2022, 1, 2);
        assert!(date.iso_weekday_number() == 7);
        let date = Date::from_ymd(2022, 1, 3);
        assert!(date.iso_weekday_number() == 1);
        let date = Date::from_ymd(2022, 1, 4);
        assert!(date.iso_weekday_number() == 2);
        let date = Date::from_ymd(2022, 1, 5);
        assert!(date.iso_weekday_number() == 3);
        let date = Date::from_ymd(2022, 1, 6);
        assert!(date.iso_weekday_number() == 4);
        let date = Date::from_ymd(2022, 1, 7);
        assert!(date.iso_weekday_number() == 5);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Weekday;

    #[test]
    fn test_iso_year_week() {
        assert_eq!(Date::from_ymd(2019, 01, 01).iso_year_week(), (2019, 1));
        assert_eq!(Date::from_ymd(2019, 10, 04).iso_year_week(), (2019, 40));
        assert_eq!(Date::from_ymd(2020, 01, 01).iso_year_week(), (2020, 1));
        assert_eq!(Date::from_ymd(2020, 12, 31).iso_year_week(), (2020, 53));
        assert_eq!(Date::from_ymd(2021, 01, 01).iso_year_week(), (2020, 53));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;

    #[test]
    fn test_julian_day() {
        assert_eq!(Date::from_julian_day(0).julian_day(), 0);
        assert_eq!(Date::from_julian_day(2_451_545).julian_day(), 2_451_545);
        assert_eq!(Date::from_julian_day(2_458_485).julian_day(), 2_458_485);
        assert_eq!(Date::from_julian_day(2_458_849).julian_day(), 2_458_849);
    }
}
True
========================================
    use crate::date::Date;
    use crate::format::DeferredFormat;
    use std::fmt::Display;

    #[test]
    fn test_lazy_format() {
        assert_eq!(
            Date::from_ymd(2019, 1, 2).lazy_format("%Y-%m-%d").to_string(),
            "2019-01-02"
        );
    }
}
False
date::Date::midnight exceed
========================================
    use super::*;

use crate::*;
    use crate::date::Date;

    #[test]
    fn test_monday_based_week() {
        assert_eq!(
            Date::try_from_ymd(2019, 1, 1).unwrap().monday_based_week(),
            0
        );
        assert_eq!(
            Date::try_from_ymd(2020, 1, 1).unwrap().monday_based_week(),
            0
        );
        assert_eq!(
            Date::try_from_ymd(2020, 12, 31).unwrap().monday_based_week(),
            52
        );
        assert_eq!(
            Date::try_from_ymd(2021, 1, 1).unwrap().monday_based_week(),
            0
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::internals::Date as InternalDate;

    #[test]
    fn test_month() {
        assert_eq!(InternalDate::from_ymd(2019, 1, 1).month(), 1);
        assert_eq!(InternalDate::from_ymd(2019, 12, 31).month(), 12);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::internals::Date as InternalDate;
    use crate::internals::date;
    use crate::internals::days_in_year_month;
    use crate::internals::is_leap_year;
    use crate::internals::MIN_YEAR;
    use crate::internals::MAX_YEAR;

    #[test]
    fn test_month_day() {
        assert_eq!(date!(2019-01-01).internals::month_day(), (1, 1));
        assert_eq!(date!(2019-12-31).internals::month_day(), (12, 31));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;

    #[test]
    fn test_next_day() {
        assert_eq!(Date::from_ymd(2019, 1, 1).next_day(), Date::from_ymd(2019, 1, 2));
        assert_eq!(Date::from_ymd(2019, 1, 31).next_day(), Date::from_ymd(2019, 2, 1));
        assert_eq!(Date::from_ymd(2019, 12, 31).next_day(), Date::from_ymd(2020, 1, 1));
    }
}
False
========================================
    use crate::date::Date;
    use crate::crate::{Weekday};
    use crate::{date, time, format_description};
    use chrono::NaiveDate;
    
    #[test]
    fn test_number_days_from_monday() {
        assert_eq!(date!(1970-01-01).number_days_from_monday(), 3);
        assert_eq!(date!(1970-01-02).number_days_from_monday(), 4);
        assert_eq!(date!(1970-01-03).number_days_from_monday(), 5);
        assert_eq!(date!(1970-01-04).number_days_from_monday(), 6);
        assert_eq!(date!(1970-01-05).number_days_from_monday(), 0);
        assert_eq!(date!(1970-01-06).number_days_from_monday(), 1);
        assert_eq!(date!(1970-01-07).number_days_from_monday(), 2);
    }
    
    #[test]
    fn test_number_days_from_sunday() {
        assert_eq!(date!(1970-01-01).number_days_from_sunday(), 4);
        assert_eq!(date!(1970-01-02).number_days_from_sunday(), 5);
        assert_eq!(date!(1970-01-03).number_days_from_sunday(), 6);
        assert_eq!(date!(1970-01-04).number_days_from_sunday(), 0);
        assert_eq!(date!(1970-01-05).number_days_from_sunday(), 1);
        assert_eq!(date!(1970-01-06).number_days_from_sunday(), 2);
        assert_eq!(date!(1970-01-07).number_days_from_sunday(), 3);
    }
    
    #[test]
    fn test_weekday() {
        assert_eq!(date!(1970-01-01).weekday(), Weekday::Thursday);
        assert_eq!(date!(1970-01-02).weekday(), Weekday::Friday);
        assert_eq!(date!(1970-01-03).weekday(), Weekday::Saturday);
        assert_eq!(date!(1970-01-04).weekday(), Weekday::Sunday);
        assert_eq!(date!(1970-01-05).weekday(), Weekday::Monday);
        assert_eq!(date!(1970-01-06).weekday(), Weekday::Tuesday);
        assert_eq!(date!(1970-01-07).weekday(), Weekday::Wednesday);
    }

    #[test]
    fn test_from_julian_day() {
        assert_eq!(Date::from_julian_day(0), date!(-4713-11-24));
        assert_eq!(Date::from_julian_day(2_451_545), date!(2000-01-01));
        assert_eq!(Date::from_julian_day(2_458_485), date!(2019-01-01));
        assert_eq!(Date::from_julian_day(2_458_849), date!(2019-12-31));
    }

    #[test]
    fn test_to_julian_day() {
        assert_eq!(date!(-4713-11-24).julian_day(), 0);
        assert_eq!(date!(2000-01-01).julian_day(), 2_451_545);
        assert_eq!(date!(2019-01-01).julian_day(), 2_458_485);
        assert_eq!(date!(2019-12-31).julian_day(), 2_458_849);
    }

    #[test]
    fn test_format() {
        assert_eq!(date!(2019-01-02).format("%Y-%m-%d"), "2019-01-02");
        assert_eq!(date!(2019-01-02).format("%F"), "2019-01-02");
        assert_eq!(date!(2012-12-21).format("%Y/%j"), "2012/356");
        assert_eq!(date!(2012-12-21).format("%Y-%m-%d"), "2012-12-21");
    }

    #[test]
    fn test_lazy_format() {
        assert_eq!(
            date!(2019-01-02).lazy_format("%Y-%m-%d").to_string(),
            "2019-01-02"
        );
        assert_eq!(
            date!(2019-01-02).lazy_format("%Y/%j").to_string(),
            "2019/002"
        );
    }

    #[test]
    fn test_parse() {
        assert_eq!(
            Date::parse("2019-01-02", "%F"),
            Ok(date!(2019-01-02))
        );
        assert_eq!(
            Date::parse("2019-002", "%Y-%j"),
            Ok(date!(2019-002))
        );
        assert_eq!(
            Date::parse("2012-356", "%Y-%j"),
            Ok(date!(2012-12-21))
        );
        assert_eq!(
            Date::parse("2019-12-01", "%Y-%m-%d"),
            Ok(date!(2019-12-01))
        );
        assert_eq!(
            Date::parse("2019-12-01", "%Y-%m-%d"),
            Ok(date!(2019-12-01))
        );
    }

    #[test]
    fn test_try_with_hms() {
        assert_eq!(
            date!(2019-01-01).try_with_hms(0, 0, 0).unwrap(),
            date!(2019-01-01).midnight(),
        );
        assert_eq!(
            date!(2019-01-01).try_with_hms(24, 0, 0),
            Err(crate::error::ComponentRange::ComponentOutOfRange { name: "hour", minimum: 0, maximum: 23, value: 24 }),
        );
    }

    #[test]
    fn test_try_with_hms_milli() {
        assert_eq!(
            date!(2019-01-01).try_with_hms_milli(0, 0, 0, 0).unwrap(),
            date!(2019-01-01).midnight(),
        );
        assert_eq!(
            date!(2019-01-01).try_with_hms_milli(24, 0, 0, 0),
            Err(crate::error::ComponentRange::ComponentOutOfRange { name: "hour", minimum: 0, maximum: 23, value: 24 }),
        );
    }

    #[test]
    fn test_try_with_hms_micro() {
        assert_eq!(
            date!(2019-01-01).try_with_hms_micro(0, 0, 0, 0).unwrap(),
            date!(2019-01-01).midnight(),
        );
        assert_eq!(
            date!(2019-01-01).try_with_hms_micro(24, 0, 0, 0),
            Err(crate::error::ComponentRange::ComponentOutOfRange { name: "hour", minimum: 0, maximum: 23, value: 24 }),
        );
    }

    #[test]
    fn test_try_with_hms_nano() {
        assert_eq!(
            date!(2019-01-01).try_with_hms_nano(0, 0, 0, 0).unwrap(),
            date!(2019-01-01).midnight(),
        );
        assert_eq!(
            date!(2019-01-01).try_with_hms_nano(24, 0, 0, 0),
            Err(crate::error::ComponentRange::ComponentOutOfRange { name: "hour", minimum: 0, maximum: 23, value: 24 }),
        );
    }
}

False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_number_days_from_sunday() {
        let date = Date::from_ymd(2000, 1, 2);
        assert_eq!(date.number_days_from_sunday(), 0);
        
        let date = Date::from_ymd(2000, 1, 8);
        assert_eq!(date.number_days_from_sunday(), 6);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::*;

    #[test]
    fn test_ordinal() {
        assert_eq!(Date::try_from_ymd(2019, 1, 1).unwrap().ordinal(), 1);
        assert_eq!(Date::try_from_ymd(2019, 12, 31).unwrap().ordinal(), 365);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::macros::date;

    #[test]
    fn test_parse() {
        assert_eq!(
            Date::parse("2019-01-02", "%F").unwrap(),
            date!(2019-01-02)
        );

        assert_eq!(
            Date::parse("2019-002", "%Y-%j").unwrap(),
            date!(2019-002)
        );

        assert_eq!(
            Date::parse("2019-W01-3", "%G-W%V-%u").unwrap(),
            date!(2019-W01-3)
        );
    }
}
False
========================================
    use crate::date::Date;

    #[test]
    fn test_previous_day() {
        assert_eq!(Date::from_ymd(2019, 01, 02).previous_day(), Date::from_ymd(2019, 01, 01));
        assert_eq!(Date::from_ymd(2019, 02, 01).previous_day(), Date::from_ymd(2019, 01, 31));
        assert_eq!(Date::from_ymd(2020, 01, 01).previous_day(), Date::from_ymd(2019, 12, 31));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_sunday_based_week() {
        // Valid cases
        assert_eq!(date!(2019-01-01).sunday_based_week(), 0);
        assert_eq!(date!(2020-01-01).sunday_based_week(), 0);
        assert_eq!(date!(2020-12-31).sunday_based_week(), 52);
        assert_eq!(date!(2021-01-01).sunday_based_week(), 0);

        // Edge cases
        assert_eq!(date!(-100_000-01-01).sunday_based_week(), 0);
        assert_eq!(date!(100_000-12-31).sunday_based_week(), 52);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_today() {
        assert!(Date::today().year() >= 2019);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;

    #[test]
    fn test_try_from_iso_ywd() {
        assert_eq!(
            Date::try_from_iso_ywd(2019, 1, Weekday::Monday),
            Ok(internals::Date::from_iso_ywd_unchecked(2019, 1, Weekday::Monday))
        );

        assert_eq!(
            Date::try_from_iso_ywd(2019, 1, Weekday::Tuesday),
            Ok(internals::Date::from_iso_ywd_unchecked(2019, 1, Weekday::Tuesday))
        );

        assert_eq!(
            Date::try_from_iso_ywd(2020, 53, Weekday::Friday),
            Ok(internals::Date::from_iso_ywd_unchecked(2020, 53, Weekday::Friday))
        );

        assert_eq!(
            Date::try_from_iso_ywd(2019, 53, Weekday::Monday),
            Err(ComponentRange)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::parse::ParsedItems;
    use crate::error::Parse;

    #[test]
    fn test_try_from_parsed_items() {
        let items = ParsedItems::new();
        assert_eq!(
            Date::try_from_parsed_items(items),
            Err(Parse::InsufficientInformation)
        );
    }
}
True
========================================
    use crate::super::date::adjustment;

    #[test]
    fn test_adjustment() {
        assert_eq!(adjustment(2020), 3);
        assert_eq!(adjustment(2021), 5);
        assert_eq!(adjustment(2022), 1);
        assert_eq!(adjustment(2023), 2);
        assert_eq!(adjustment(2024), 7);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::date::Date;
    use crate::date::MAX_YEAR;
    use crate::date::MIN_YEAR;

    #[test]
    fn test_try_from_ymd_valid_date() {
        assert_eq!(
            Date::try_from_ymd(2019, 1, 1),
            Ok(Date::try_from_ymd_unchecked(2019, 1, 1))
        );
        assert_eq!(
            Date::try_from_ymd(2019, 12, 31),
            Ok(Date::try_from_ymd_unchecked(2019, 12, 31))
        );
    }

    #[test]
    fn test_try_from_ymd_invalid_date() {
        assert_eq!(
            Date::try_from_ymd(2019, 2, 29),
            Err(ComponentRange::Year)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;

    #[test]
    fn test_try_from_yo_valid() {
        assert!(Date::try_from_yo(2019, 1).is_ok());
        assert!(Date::try_from_yo(2019, 365).is_ok());
    }
    
    #[test]
    fn test_try_from_yo_invalid() {
        assert!(Date::try_from_yo(2019, 366).is_err());
    }
}
True
========================================
#[test]
fn test_try_with_hms() {
    use crate::error::ComponentRange;
    use crate::Date;
    use crate::Temporal;
    use crate::Time;
    use crate::PrimitiveDateTime;
    assert_eq!(
        Date::from_ymd(1970, 1, 1)
            .try_with_hms(0, 0, 0)
            .unwrap(),
        PrimitiveDateTime::new(Date::from_ymd(1970, 1, 1), Time::from_hms(0, 0, 0))
    );
    assert_eq!(
        Date::from_ymd(1970, 1, 1)
            .try_with_hms(24, 0, 0)
            .unwrap_err(),
        ComponentRange
    );
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::date::{Date, Time};

    #[test]
    fn test_try_with_hms_micro() {
        assert_eq!(
            Date::from_ymd(1970, 1, 1)
                .try_with_hms_micro(0, 0, 0, 0)
                .unwrap(),
            PrimitiveDateTime::new(Date::from_ymd(1970, 1, 1), Time::from_hms_micro(0, 0, 0, 0))
        );
        assert!(Date::from_ymd(1970, 1, 1)
            .try_with_hms_micro(24, 0, 0, 0)
            .is_err());
    }
}
False
========================================
    use crate::date::Date;
    use crate::crate::Time;
    use crate::primitive::PrimitiveDateTime;
    use crate::error::ComponentRange;
    
    #[test]
    fn test_try_with_hms_milli() {
        assert_eq!(
            Date::try_with_hms_milli(Date::try_from_ymd(1970, 1, 1).unwrap(), 0, 0, 0, 0),
            Ok(PrimitiveDateTime::new(Date::try_from_ymd(1970, 1, 1).unwrap(), Time::try_from_hms_milli(0, 0, 0, 0).unwrap()))
        );
    }

    #[test]
    fn test_try_with_hms_milli_with_invalid_hour() {
        assert_eq!(
            Date::try_with_hms_milli(Date::try_from_ymd(1970, 1, 1).unwrap(), 24, 0, 0, 0),
            Err(ComponentRange::Hour),
        );
    }

    #[test]
    fn test_try_with_hms_milli_with_invalid_minute() {
        assert_eq!(
            Date::try_with_hms_milli(Date::try_from_ymd(1970, 1, 1).unwrap(), 0, 60, 0, 0),
            Err(ComponentRange::Minute),
        );
    }

    #[test]
    fn test_try_with_hms_milli_with_invalid_second() {
        assert_eq!(
            Date::try_with_hms_milli(Date::try_from_ymd(1970, 1, 1).unwrap(), 0, 0, 60, 0),
            Err(ComponentRange::Second),
        );
    }

    #[test]
    fn test_try_with_hms_milli_with_invalid_millisecond() {
        assert_eq!(
            Date::try_with_hms_milli(Date::try_from_ymd(1970, 1, 1).unwrap(), 0, 0, 0, 1000),
            Err(ComponentRange::Millisecond),
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{DateTime, ComponentRange};

    #[test]
    fn try_with_hms_nano_test() {
        assert_eq!(
            date!(1970-01-01).try_with_hms_nano(0, 0, 0, 0),
            Ok(DateTime::new(date!(1970-01-01), time!(0:00:00.0)))
        );
        assert_eq!(
            date!(1970-01-01).try_with_hms_nano(24, 0, 0, 0),
            Err(ComponentRange::Hour)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;

    #[test]
    fn test_date_week() {
        assert_eq!(Date::from_ymd(2019, 01, 01).week(), 1);
        assert_eq!(Date::from_ymd(2019, 10, 04).week(), 40);
        assert_eq!(Date::from_ymd(2020, 01, 01).week(), 1);
        assert_eq!(Date::from_ymd(2020, 12, 31).week(), 53);
        assert_eq!(Date::from_ymd(2021, 01, 01).week(), 53);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Weekday::*;
    
    #[test]
    fn test_weekday() {
        assert_eq!(date!(2019-01-01).weekday(), Tuesday);
        assert_eq!(date!(2019-02-01).weekday(), Friday);
        assert_eq!(date!(2019-03-01).weekday(), Friday);
        assert_eq!(date!(2019-04-01).weekday(), Monday);
        assert_eq!(date!(2019-05-01).weekday(), Wednesday);
        assert_eq!(date!(2019-06-01).weekday(), Saturday);
        assert_eq!(date!(2019-07-01).weekday(), Monday);
        assert_eq!(date!(2019-08-01).weekday(), Thursday);
        assert_eq!(date!(2019-09-01).weekday(), Sunday);
        assert_eq!(date!(2019-10-01).weekday(), Tuesday);
        assert_eq!(date!(2019-11-01).weekday(), Friday);
        assert_eq!(date!(2019-12-01).weekday(), Sunday);
    }
}
False
date::Date::with_time exceed
========================================
    use super::*;

use crate::*;
    use crate::date::Private;

    #[test]
    fn test_year() {
        assert_eq!(Date::try_from_ymd(2019, 1, 1).unwrap().year(), 2019);
        assert_eq!(Date::try_from_ymd(2019, 12, 31).unwrap().year(), 2019);
        assert_eq!(Date::try_from_ymd(2020, 1, 1).unwrap().year(), 2020);
    }
}
False
========================================
    use crate::date::div_floor;

    #[test]
    fn test_div_floor() {
        assert_eq!(div_floor(7, 3), 2);
        assert_eq!(div_floor(7, -3), -3);
        assert_eq!(div_floor(-7, 3), -3);
        assert_eq!(div_floor(-7, -3), 2);
        assert_eq!(div_floor(0, 3), 0);
        assert_eq!(div_floor(7, 1), 7);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_eq() {
        let dur1 = Duration::seconds(1);
        let dur2 = Duration::seconds(2);
        let std_dur1 = StdDuration::from_secs(1);
        let std_dur2 = StdDuration::from_secs(2);

        assert_eq!(dur1.eq(&dur1), dur1 == dur1);
        assert_eq!(dur1.eq(&dur2), dur1 == dur2);
        assert_eq!(dur1.eq(&std_dur1), dur1 == std::convert::TryFrom::<Duration>::try_from(std_dur1).unwrap());
        assert_eq!(dur1.eq(&std_dur2), dur1 == std::convert::TryFrom::<Duration>::try_from(std_dur2).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_partial_cmp() {
        let duration1 = Duration::new(1, 0);
        let duration2 = Duration::new(0, 0);
        let duration3 = Duration::new(0, 500_000_000);
        let duration4 = Duration::new(2, 0);

        assert_eq!(duration1.partial_cmp(&duration2), Some(Ordering::Greater));
        assert_eq!(duration2.partial_cmp(&duration1), Some(Ordering::Less));
        assert_eq!(duration2.partial_cmp(&duration2), Some(Ordering::Equal));
        assert_eq!(duration2.partial_cmp(&duration3), Some(Ordering::Less));
        assert_eq!(duration3.partial_cmp(&duration2), Some(Ordering::Greater));
        assert_eq!(duration1.partial_cmp(&duration4), Some(Ordering::Less));
        assert_eq!(duration4.partial_cmp(&duration1), Some(Ordering::Greater));
    }
}
True
========================================
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::{Duration, try_from, error::ConversionRange};
    
    #[test]
    fn test_try_from() {
        let duration = Duration::new(10, 500_000_000);
        let std_duration = StdDuration::new(10, 500_000_000);
        assert_eq!(try_from(duration), Ok(std_duration));
    }

    #[test]
    fn test_try_from_conversion_range() {
        let duration = Duration::new(10, 500_000_000_000);
        assert_eq!(try_from(duration), Err(ConversionRange));
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_add() {
        let duration_1 = Duration::new(1, 500_000_000);
        let duration_2 = Duration::new(2, 0);
        let expected_result = Duration::new(3, 500_000_000);
        assert_eq!(duration_1.add(duration_2), expected_result);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_div() {
        let dur1 = Duration::seconds(5);
        let dur2 = Duration::seconds(2);
        let result = dur1.div(dur2);
        assert_eq!(result, 2.5);
    }
}
True
========================================
use super::*;

use crate::*;
use std::crate::Duration as StdDuration;

#[test]
fn test_mul() {
    let d1 = duration::Duration::seconds(5);
    let d2 = duration::Duration::seconds(2);
    let expected = duration::Duration::seconds(10);
    assert_eq!(d1 * d2, expected);
}

#[test]
fn test_mul_assign() {
    let mut d1 = duration::Duration::seconds(5);
    let d2 = duration::Duration::seconds(2);
    let expected = duration::Duration::seconds(10);
    d1 *= d2;
    assert_eq!(d1, expected);
}

#[test]
fn test_mul_f32() {
    let d1 = duration::Duration::seconds(5);
    let d2 = 2.5;
    let expected = duration::Duration::seconds(12);
    assert_eq!(d1 * d2, expected);
}

#[test]
fn test_mul_f64() {
    let d1 = duration::Duration::seconds(5);
    let d2 = 2.5;
    let expected = duration::Duration::seconds(12);
    assert_eq!(d1 * d2, expected);
}

#[test]
fn test_div() {
    let d1 = duration::Duration::seconds(10);
    let d2 = 2;
    let expected = duration::Duration::seconds(5);
    assert_eq!(d1 / d2, expected);
}

#[test]
fn test_div_assign() {
    let mut d1 = duration::Duration::seconds(10);
    let d2 = 2;
    let expected = duration::Duration::seconds(5);
    d1 /= d2;
    assert_eq!(d1, expected);
}

#[test]
fn test_sub() {
    let d1 = duration::Duration::seconds(8);
    let d2 = duration::Duration::seconds(5);
    let expected = duration::Duration::seconds(3);
    assert_eq!(d1 - d2, expected);
}

#[test]
fn test_sub_assign() {
    let mut d1 = duration::Duration::seconds(8);
    let d2 = duration::Duration::seconds(5);
    let expected = duration::Duration::seconds(3);
    d1 -= d2;
    assert_eq!(d1, expected);
}

#[test]
fn test_try_from() {
    let d = StdDuration::from_secs(5);
    let expected = duration::Duration::seconds(5);
    assert_eq!(duration::Duration::try_from(d).unwrap(), expected);
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_mul() {
        let duration = Duration::seconds(5);
        let rhs = Duration::seconds(2);
        let expected = Duration::seconds(10);
        assert_eq!(duration * rhs, expected);
    }

    #[test]
    fn test_mul_std_duration() {
        let duration = Duration::seconds(5);
        let rhs = StdDuration::from_secs(2);
        let expected = Duration::seconds(10);
        assert_eq!(duration * rhs, expected);
    }

    #[test]
    fn test_mul_scalar() {
        let duration = Duration::seconds(5);
        let rhs = 2;
        let expected = Duration::seconds(10);
        assert_eq!(duration * rhs, expected);
    }

    #[test]
    fn test_mul_scalar_float() {
        let duration = Duration::seconds(5);
        let rhs = 0.5;
        let expected = Duration::seconds_f64(2.5);
        assert_eq!(duration * rhs, expected);
    }

    #[test]
    fn test_mul_assign() {
        let mut duration = Duration::seconds(5);
        let rhs = 2;
        let expected = Duration::seconds(10);
        duration *= rhs;
        assert_eq!(duration, expected);
    }

    #[test]
    fn test_mul_assign_float() {
        let mut duration = Duration::seconds(5);
        let rhs = 0.5;
        let expected = Duration::seconds_f64(2.5);
        duration *= rhs;
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul() {
        let duration = Duration::seconds(10);
        let result = duration * Duration::seconds(5);
        assert_eq!(result, Duration::seconds(50));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    // it should multiply the duration with the given value
    #[test]
    fn test_mul() {
        let duration: Duration = Duration::new(2, 500_000_000);
        let result: Duration = duration.mul(3);
        let expected: Duration = Duration::new(7, 500_000_000);
        assert_eq!(result.seconds, expected.seconds);
        assert_eq!(result.nanoseconds, expected.nanoseconds);
    }
}
False
========================================
    use super::*;

use crate::*;

    // test case 1
    #[test]
    fn test_mul_duration() {
        let duration1 = Duration::new(1, 500_000_000);
        let duration2 = 2;

        let result = duration1 * duration2;

        let expected_result = Duration::new(3, 500_000_000);

        assert_eq!(result, expected_result);
    }

    // test case 2
    #[test]
    fn test_mul_duration_negative() {
        let duration1 = Duration::new(1, 500_000_000);
        let duration2 = -2;

        let result = duration1 * duration2;

        let expected_result = Duration::new(-3, -500_000_000);

        assert_eq!(result, expected_result);
    }

    // test case 3
    #[test]
    fn test_mul_duration_zero() {
        let duration1 = Duration::new(0, 0);
        let duration2 = 2;

        let result = duration1 * duration2;

        let expected_result = Duration::new(0, 0);

        assert_eq!(result, expected_result);
    }

    // test case 4
    #[test]
    fn test_mul_duration_overflow() {
        let duration1 = Duration::max_value();
        let duration2 = 2;

        let result = duration1.checked_mul(duration2);

        assert_eq!(result, None);
    }

    // test case 5
    #[test]
    fn test_mul_duration_overflow_negative() {
        let duration1 = Duration::min_value();
        let duration2 = 2;

        let result = duration1.checked_mul(duration2);

        assert_eq!(result, None);
    }

    // test case 6
    #[test]
    fn test_mul_primitive() {
        let duration = Duration::new(2, 500_000_000);
        let primitive = 1;

        let result = duration * primitive;

        let expected_result = Duration::new(2, 500_000_000);

        assert_eq!(result, expected_result);
    }

    // test case 7
    #[test]
    fn test_mul_primitive_negative() {
        let duration = Duration::new(2, 500_000_000);
        let primitive = -1;

        let result = duration * primitive;

        let expected_result = Duration::new(-2, -500_000_000);

        assert_eq!(result, expected_result);
    }

    // test case 8
    #[test]
    fn test_mul_primitive_zero() {
        let duration = Duration::new(2, 500_000_000);
        let primitive = 0;

        let result = duration * primitive;

        let expected_result = Duration::new(0, 0);

        assert_eq!(result, expected_result);
    }

    // test case 9
    #[test]
    fn test_mul_primitive_overflow() {
        let duration = Duration::max_value();
        let primitive = 2;

        let result = duration.checked_mul(primitive);

        assert_eq!(result, None);
    }

    // test case 10
    #[test]
    fn test_mul_primitive_overflow_negative() {
        let duration = Duration::min_value();
        let primitive = 2;

        let result = duration.checked_mul(primitive);

        assert_eq!(result, None);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul() {
        let duration = Duration {
            seconds: 10,
            nanoseconds: 0,
        };
        let rhs = 5u16;
        let expected = Duration {
            seconds: 50,
            nanoseconds: 0,
        };
        assert_eq!(duration.mul(rhs), expected);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul() {
        let duration = Duration::new(10, 500_000_000);
        let rhs = 2;
        let expected = Duration::new(2, 1_000_000_000);
        assert_eq!(duration.mul(rhs), expected);
    }
}
True
========================================
   use super::*;

use crate::*;

   #[test]
   fn test_mul() {
      let duration = Duration::new(2, 500_000_000);
      let result = duration.mul(2);
      assert_eq!(result, Duration::new(5, 0));
   }
}
True
========================================
    use std::cmp::Ordering;
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;
    use crate::duration::Duration;

    #[test]
    fn test_sub() {
        let d1 = Duration {
            seconds: 10,
            nanoseconds: 0
        };
        let d2 = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        let expected = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        assert_eq!(d1 - d2, expected);
    }

    #[test]
    fn test_sub_std() {
        let d1 = StdDuration::from_secs(10);
        let d2 = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        let expected: Duration = (d1 - d2).try_into().unwrap();
        assert_eq!(d1 - d2, expected);
    }

    #[test]
    fn test_sub_assign() {
        let mut d1 = Duration {
            seconds: 10,
            nanoseconds: 0
        };
        let d2 = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        let expected = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        d1 -= d2;
        assert_eq!(d1, expected);
    }

    #[test]
    fn test_sub_assign_std() {
        let mut d1 = StdDuration::from_secs(10);
        let d2 = Duration {
            seconds: 5,
            nanoseconds: 0
        };
        let mut expected: Duration = (d1 - d2).try_into().unwrap();
        d1 -= d2;
        expected.nanoseconds = expected.nanoseconds.abs();
        assert_eq!(d1.try_into().unwrap(), expected);
    }
    
    #[test]
    fn test_partial_ord_duration_std() {
        let d1 = Duration {
            seconds: 10,
            nanoseconds: 0
        };
        let d2 = StdDuration::from_secs(5);
        assert_eq!(d1.partial_cmp(&d2), Some(Ordering::Greater));
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    
    #[test]
    fn test_sub_assign() {
        let mut duration = Duration::new(10, 500);
        duration -= Duration::new(5, 250);
        assert_eq!(duration, Duration::new(5, 250));

        let mut duration = Duration::new(0, 500);
        duration -= Duration::new(1, 750);
        assert_eq!(duration, Duration::new(-1, 750));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_abs() {
        assert_eq!(Duration::zero().abs(), Duration::zero());
        assert_eq!(Duration::nanosecond().abs(), Duration::nanosecond());
        assert_eq!(Duration::microsecond().abs(), Duration::microsecond());
        assert_eq!(Duration::millisecond().abs(), Duration::millisecond());
        assert_eq!(Duration::second().abs(), Duration::second());
        assert_eq!(Duration::minute().abs(), Duration::minute());
        assert_eq!(Duration::hour().abs(), Duration::hour());
        assert_eq!(Duration::day().abs(), Duration::day());
        assert_eq!(Duration::week().abs(), Duration::week());
        assert_eq!(Duration::new(1, 0).abs(), Duration::new(1, 0));
        assert_eq!(Duration::new(0, 1).abs(), Duration::new(0, 1));
        assert_eq!(Duration::new(-1, 0).abs(), Duration::new(1, 0));
        assert_eq!(Duration::new(0, -1).abs(), Duration::new(0, 1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    #[cfg(feature = "std")]
    fn test_abs_std() {
        let duration = Duration::new(10, 500_000_000);
        let std_duration = StdDuration::new(10, 500_000_000);

        let result = duration.abs_std();

        assert_eq!(result, std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDurationShort;

    #[test]
    fn test_as_seconds_f32() {
        assert_eq!(NumericalStdDurationShort::seconds(1.5).as_seconds_f32(), 1.5);
        assert_eq!(NumericalStdDurationShort::seconds(-1.5).as_seconds_f32(), -1.5);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_as_seconds_f64() {
        assert_eq!(Duration::seconds_f64(1.5).as_seconds_f64(), 1.5);
        assert_eq!(Duration::seconds_f64(-1.5).as_seconds_f64(), -1.5);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_checked_add() {
        assert_eq!(
            NumericalStdDurationShort::seconds(5).checked_add(5.seconds()),
            Some(10.seconds())
        );
        assert_eq!(
            NumericalDuration::max_value().checked_add(1.nanoseconds()),
            None
        );
        assert_eq!(
            NumericalStdDurationShort::seconds(-5).checked_add(5.seconds()),
            Some(0.seconds())
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_checked_div() {
        assert_eq!(Duration::seconds(10).checked_div(2), Some(Duration::seconds(5)));
        assert_eq!(Duration::seconds(10).checked_div(-2), Some(Duration::seconds(-5)));
        assert_eq!(Duration::seconds(1).checked_div(0), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_checked_mul() {
        assert_eq!(
            Duration::seconds(5).checked_mul(2),
            Some(Duration::seconds(10))
        );
        assert_eq!(
            Duration::seconds(5).checked_mul(-2),
            Some(Duration::seconds(-10))
        );
        assert_eq!(
            Duration::seconds(5).checked_mul(0),
            Some(Duration::seconds(0))
        );
        assert_eq!(
            Duration::max_value().checked_mul(2),
            None
        );
        assert_eq!(
            Duration::min_value().checked_mul(2),
            None
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;
    
    #[test]
    fn test_checked_sub() {
        assert_eq!(Duration::checked_sub(Duration::seconds(5), Duration::seconds(5)), Some(Duration::zero()));
        assert_eq!(Duration::checked_sub(Duration::min_value(), Duration::nanoseconds(1)), None);
        assert_eq!(Duration::checked_sub(Duration::seconds(5), Duration::seconds(10)), Some(Duration::seconds(-5)));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;

    #[test]
    fn test_day() {
        assert_eq!(Duration::day(), Duration::days(1));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_days() {
        assert_eq!(Duration::days(1), Duration::seconds(86_400));
        assert_eq!(Duration::days(0), Duration::seconds(0));
        assert_eq!(Duration::days(-1), Duration::seconds(-86_400));
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn test_from_std() {
        let std_duration = StdDuration::from_secs(5);
        let result = Duration::from_std(std_duration);
        let expected = Ok(Duration::seconds(5));
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_hour() {
        assert_eq!(Duration::hour(), Duration::hours(1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::macros::time;
    use crate::prelude::*;
    
    #[test]
    fn test_hours() {
        assert_eq!(Duration::hours(1), Duration::seconds(1 * 3_600));
        assert_eq!(Duration::hours(2), Duration::seconds(2 * 3_600));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;

    #[test]
    fn test_is_negative() {
        assert_eq!(true, (-1).numerical_std_duration_short().is_negative());
        assert_eq!(false, 0.numerical_std_duration_short().is_negative());
        assert_eq!(false, 1.numerical_std_duration_short().is_negative());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;
    
    #[test]
    fn test_is_positive() {
        assert!(Duration::seconds(1).is_positive());
        assert!(!Duration::seconds(0).is_positive());
        assert!(!Duration::seconds(-1).is_positive());
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_is_zero() {
        assert!(Duration::zero().is_zero());
        assert!(Duration::seconds(0).is_zero());
        assert!(Duration::nanoseconds(0).is_zero());
        assert!(!Duration::seconds(1).is_zero());
        assert!(!Duration::nanoseconds(1).is_zero());
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_max_value() {
        let max_value = Duration::max_value();
        assert_eq!(max_value.seconds, i64::max_value());
        assert_eq!(max_value.nanoseconds, 999_999_999);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_microsecond() {
        assert_eq!(Duration::microsecond(), Duration::microseconds(1));
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_microseconds() {
        assert_eq!(Duration::microseconds(1), Duration::nanoseconds(1_000));
        assert_eq!(Duration::microseconds(-1), Duration::nanoseconds(-1_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_millisecond() {
        assert_eq!(Duration::millisecond(), Duration::milliseconds(1));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_milliseconds() {
        assert_eq!(Duration::milliseconds(1), Duration::microseconds(1_000));
        assert_eq!(Duration::milliseconds(-1), Duration::microseconds(-1_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_min_value() {
        let expected = Duration::new(i64::min_value(), -999_999_999);
        let result = Duration::min_value();
        assert_eq!(expected, result);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use crate::prelude::*;
    use crate::duration::Duration;

    #[test]
    fn test_minute() {
        assert_eq!(Duration::minute(), 1.minutes());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    #[test]
    fn test_minutes() {
        assert_eq!(Duration::minutes(1), Duration::seconds(60));
        assert_eq!(Duration::minutes(2), Duration::seconds(120));
        assert_eq!(Duration::minutes(-1), Duration::seconds(-60));
        assert_eq!(Duration::minutes(0), Duration::seconds(0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_nanosecond() {
        assert_eq!(NumericalDuration::nanoseconds(1), 1.nanoseconds());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_nanoseconds() {
        assert_eq!(nanoseconds(1), Duration::nanoseconds(1));
        assert_eq!(nanoseconds(-1), Duration::nanoseconds(-1));
        assert_eq!(nanoseconds(1), Duration::microseconds(1) / 1_000);
        assert_eq!(nanoseconds(-1), Duration::microseconds(-1) / 1_000);
    }

    #[test]
    fn test_nanoseconds_eq_std() {
        let duration: Duration = Duration::nanoseconds(1);
        let std_duration: StdDuration = StdDuration::new(0, 1);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let duration: Duration = Duration::nanoseconds(-1);
        let std_duration: StdDuration = StdDuration::new(0, 1_000_000_000 - 1);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let duration: Duration = Duration::nanoseconds(0);
        let std_duration: StdDuration = StdDuration::new(0, 0);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let duration: Duration = Duration::nanoseconds(1);
        let std_duration: StdDuration = StdDuration::new(1, 0);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());

        let duration: Duration = Duration::nanoseconds(-1);
        let std_duration: StdDuration = StdDuration::new(std::u64::MAX - 1, 0);
        assert_eq!(duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;

    #[test]
    fn test_nanoseconds_i128() {
        assert_eq!(
            Duration::nanoseconds_i128(1_000_000_000),
            Duration::new(1, 0)
        );
        assert_eq!(
            Duration::nanoseconds_i128(2_000_000_000),
            Duration::new(2, 0)
        );
        assert_eq!(
            Duration::nanoseconds_i128(-1_000_000_000),
            Duration::new(-1, 0)
        );
        assert_eq!(
            Duration::nanoseconds_i128(-2_000_000_000),
            Duration::new(-2, 0)
        );
        assert_eq!(
            Duration::nanoseconds_i128(1_000_000_001),
            Duration::new(1, 1)
        );
        assert_eq!(
            Duration::nanoseconds_i128(-1_000_000_001),
            Duration::new(-1, -1)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_new() {
        assert_eq!(Duration::new(1, 0), Duration::seconds(1));
        assert_eq!(Duration::new(-1, 0), Duration::seconds(-1));
        assert_eq!(Duration::new(1, 2_000_000_000), Duration::seconds(3));
    }

    #[test]
    fn test_abs() {
        assert_eq!(Duration::new(1, 0).abs(), Duration::seconds(1));
        assert_eq!(Duration::new(-1, 0).abs(), Duration::seconds(1));
    }

    #[test]
    fn test_is_zero() {
        assert!(Duration::new(0, 0).is_zero());
        assert!(!Duration::new(1, 0).is_zero());
    }

    #[test]
    fn test_is_negative() {
        assert!(Duration::new(-1, 0).is_negative());
        assert!(!Duration::new(0, 0).is_negative());
    }

    #[test]
    fn test_is_positive() {
        assert!(Duration::new(1, 0).is_positive());
        assert!(!Duration::new(0, 0).is_positive());
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_time_fn() {
        let (_, result) = Duration::time_fn(|| {
            std::thread::sleep(StdDuration::from_secs(1));
            42
        });

        assert_eq!(result, 42);
    }

    #[test]
    fn test_checked_add() {
        assert_eq!(Duration::seconds(5).checked_add(Duration::seconds(5)), Some(Duration::seconds(10)));
        assert_eq!(Duration::max_value().checked_add(Duration::nanoseconds(1)), None);
        assert_eq!(Duration::seconds(-5).checked_add(Duration::seconds(5)), Some(Duration::zero()));
    }
    
    // more tests...
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;
    
    #[test]
    fn test_num_days() {
        let duration = Duration::days(7);
        assert_eq!(duration.num_days(), 7);
        
        let duration = Duration::days(-7);
        assert_eq!(duration.num_days(), -7);
        
        let duration = Duration::days(0);
        assert_eq!(duration.num_days(), 0);
        
        let duration = Duration::days(1);
        assert_eq!(duration.num_days(), 1);
        
        let duration = Duration::days(-1);
        assert_eq!(duration.num_days(), -1);
    }
    
    #[test]
    fn test_num_days_deprecated() {
        let duration = Duration::days(7);
        assert_eq!(duration.num_days(), duration.whole_days());
        
        let duration = Duration::days(-7);
        assert_eq!(duration.num_days(), duration.whole_days());
        
        let duration = Duration::days(0);
        assert_eq!(duration.num_days(), duration.whole_days());
        
        let duration = Duration::days(1);
        assert_eq!(duration.num_days(), duration.whole_days());
        
        let duration = Duration::days(-1);
        assert_eq!(duration.num_days(), duration.whole_days());
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_num_hours() {
        let duration = Duration::hours(2);
        assert_eq!(duration.num_hours(), 2);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_num_microseconds() {
        let duration = Duration::new(1, 0);
        assert_eq!(duration.num_microseconds(), Some(1_000_000));

        let duration = Duration::new(0, 1_000_000);
        assert_eq!(duration.num_microseconds(), Some(1_000));

        let duration = Duration::new(0, 999_999);
        assert_eq!(duration.num_microseconds(), Some(999));

        let duration = Duration::new(0, -1_000_000);
        assert_eq!(duration.num_microseconds(), Some(-1_000));

        let duration = Duration::new(0, -999_999);
        assert_eq!(duration.num_microseconds(), Some(-999));

        let duration = Duration::new(i64::max_value() as i128 as i64, 0);
        assert_eq!(duration.num_microseconds(), Some(i64::max_value()));

        let duration = Duration::new(i64::max_value() as i128 as i64 + 1, 0);
        assert_eq!(duration.num_microseconds(), None);

        let duration = Duration::new(i64::min_value() as i128 as i64, 0);
        assert_eq!(duration.num_microseconds(), Some(i64::min_value()));

        let duration = Duration::new(i64::min_value() as i128 as i64 - 1, 0);
        assert_eq!(duration.num_microseconds(), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_num_milliseconds() {
        let duration = Duration::new(1, 0);
        assert_eq!(duration.num_milliseconds(), 1_000); 

        let duration = Duration::new(0, 1_000_000);
        assert_eq!(duration.num_milliseconds(), 1); 

        let duration = Duration::new(1, 1_000_000_000);
        assert_eq!(duration.num_milliseconds(), 1_000_000); 

        let duration = Duration::new(2_147_483_647, 1_000_000_000);
        assert_eq!(duration.num_milliseconds(), i64::max_value());

        let duration = Duration::new(-2_147_483_648, 0);
        assert_eq!(duration.num_milliseconds(), i64::min_value());

        let duration = Duration::new(-2_147_483_648, 1_000_000_000);
        assert_eq!(duration.num_milliseconds(), i64::min_value());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_num_minutes() {
        let duration = Duration::minutes(10);
        let result = duration.num_minutes();
        assert_eq!(result, 10);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_num_nanoseconds() {
        let nanos = Duration::new(1, 500_000_000).num_nanoseconds();
        assert_eq!(nanos, Some(1_500_000_000));

        let nanos = Duration::new(0, 1_000_000_000).num_nanoseconds();
        assert_eq!(nanos, Some(1_000_000_000));

        let nanos = Duration::new(1, 1_000_000_000).num_nanoseconds();
        assert_eq!(nanos, Some(2_000_000_000));

        let nanos = Duration::new(0, -1_000_000_000).num_nanoseconds();
        assert_eq!(nanos, Some(-1_000_000_000));

        let nanos = Duration::new(-1, -1_000_000_000).num_nanoseconds();
        assert_eq!(nanos, Some(-2_000_000_000));

        let nanos = Duration::new(0, i32::max_value()).num_nanoseconds();
        assert_eq!(nanos, Some(i32::max_value() as i64));

        let nanos = Duration::new(0, -i32::max_value()).num_nanoseconds();
        assert_eq!(nanos, Some(-i32::max_value() as i64));

        let nanos = Duration::new(0, i32::max_value() as i32 + 1).num_nanoseconds();
        assert_eq!(nanos, None);

        let nanos = Duration::new(0, -i32::max_value() as i32 - 1).num_nanoseconds();
        assert_eq!(nanos, None);
    }
}

False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_num_seconds() {
        let duration = Duration::new(10, 500_000_000);
        assert_eq!(duration.num_seconds(), 10);
    }
}
True
========================================
    use std::crate::Duration as StdDuration;
    use crate::duration::Duration;
    use std::convert::TryFrom;

    #[test]
    fn test_num_weeks() {
        let d1 = Duration::weeks(2);
        let d2 = Duration::weeks(0);
        let d3 = Duration::weeks(-1);

        assert_eq!(d1.num_weeks(), 2);
        assert_eq!(d2.num_weeks(), 0);
        assert_eq!(d3.num_weeks(), -1);

        let std_duration = StdDuration::from_secs(7 * 24 * 60 * 60);
        let d4 = Duration::try_from(std_duration).unwrap();
        assert_eq!(d4.num_weeks(), 1);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;

    #[test]
    fn test_duration_second() {
        assert_eq!(Duration::second(), Duration::seconds(1));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_seconds() {
        assert_eq!(Duration::seconds(1), Duration { seconds: 1, nanoseconds: 0 });
        assert_eq!(Duration::seconds(-1), Duration { seconds: -1, nanoseconds: 0 });
        assert_eq!(Duration::seconds(0), Duration { seconds: 0, nanoseconds: 0 });
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_seconds_f32() {
        assert_eq!(Duration::seconds_f32(0.5), Duration::new(0, 500_000_000));
        assert_eq!(Duration::seconds_f32(-0.5), Duration::new(0, -500_000_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    #[test]
    fn test_seconds_f64() {
        assert_eq!(Duration::seconds_f64(0.5), Duration::new(0, 500000000));
        assert_eq!(Duration::seconds_f64(-0.5), Duration::new(0, -500000000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::*;
    use crate::Sign;

    #[test]
    #[allow(deprecated)]
    fn test_duration_sign() {
        assert_eq!(ext::NumericalDuration::seconds(1).sign(), Sign::Positive);
        assert_eq!(ext::NumericalDuration::seconds(-1).sign(), Sign::Negative);
        assert_eq!(ext::NumericalDuration::seconds(0).sign(), Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    #[cfg(feature = "std")]
    #[deprecated(since = "0.2.0", note = "Use the `time_fn` function")]
    fn test_span() {
        let start = StdDuration::from_secs(0);
        let end = StdDuration::from_secs(1);
        let result = Duration::span(|| {
            std::thread::sleep(end);
        });
        assert_eq!(Duration::from_std(start).unwrap(), result);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::*;

    #[test]
    fn test_subsec_microseconds() {
        assert_eq!(NumericalDuration::seconds(1.0004).subsec_microseconds(), 400);
        assert_eq!(NumericalDuration::seconds(-1.0004).subsec_microseconds(), -400);
    }
}
True
========================================
    use super::*;

use crate::*;

    use crate::ext::NumericalDuration;

    #[test]
    fn test_subsec_milliseconds() {
        assert_eq!(NumericalDuration::seconds(0).subsec_milliseconds(), 0);
        assert_eq!(NumericalDuration::seconds(1).subsec_milliseconds(), 0);
        assert_eq!(NumericalDuration::nanoseconds(1_400_000_000).subsec_milliseconds(), 400);
        assert_eq!(NumericalDuration::seconds(-1).subsec_milliseconds(), 0);
        assert_eq!(NumericalDuration::nanoseconds(-1_400_000_000).subsec_milliseconds(), -400);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_subsec_nanoseconds() {
        assert_eq!(Duration::seconds(1_000_000_400).subsec_nanoseconds(), 400);
        assert_eq!(Duration::seconds(-1_000_000_400).subsec_nanoseconds(), -400);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_time_fn() {
        let (duration, result) = super::time_fn(|| {
            StdDuration::from_secs(2)
        });

        assert!(duration >= Duration::seconds(2));
        assert!(duration <= Duration::seconds(3));
        assert_eq!(result, StdDuration::from_secs(2));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_to_std() {
        let duration = Duration::seconds(10);
        let std_duration = StdDuration::from_secs(10);
        assert_eq!(duration.to_std(), Ok(std_duration));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_week() {
        assert_eq!(
            <Duration as TryFrom<StdDuration>>::try_from(std::crate::Duration::from_secs(604800)),
            Ok(duration::Duration::week())
        );
    }
}
False
========================================
    use crate::duration::Duration;
    use crate::duration::SECONDS_PER_WEEK;

    #[test]
    fn test_weeks() {
        assert_eq!(Duration::weeks(1), Duration::seconds(1 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(2), Duration::seconds(2 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(10), Duration::seconds(10 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(-1), Duration::seconds(-1 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(-2), Duration::seconds(-2 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(-10), Duration::seconds(-10 * SECONDS_PER_WEEK));
        assert_eq!(Duration::weeks(0), Duration::seconds(0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_whole_days() {
        assert_eq!(ext::NumericalDuration::days(1).whole_days(), 1);
        assert_eq!(ext::NumericalDuration::days(-1).whole_days(), -1);
        assert_eq!(ext::NumericalDuration::hours(23).whole_days(), 0);
        assert_eq!(ext::NumericalDuration::hours(-23).whole_days(), 0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;

    #[test]
    fn test_whole_hours() {
        assert_eq!(ext::NumericalStdDurationShort::hours(1).whole_hours(), 1);
        assert_eq!(ext::NumericalStdDurationShort::hours(-1).whole_hours(), -1);
        assert_eq!(ext::NumericalDuration::minutes(59).whole_hours(), 0);
        assert_eq!(ext::NumericalDuration::minutes(-59).whole_hours(), 0);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_whole_microseconds() {
        assert_eq!(Duration::milliseconds(1).whole_microseconds(), 1_000);
        assert_eq!(Duration::milliseconds(-1).whole_microseconds(), -1_000);
        assert_eq!(Duration::microseconds(1).whole_microseconds(), 1);
        assert_eq!(Duration::microseconds(-1).whole_microseconds(), -1);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_whole_milliseconds() {
        assert_eq!(ext::NumericalStdDurationShort::seconds(1).whole_milliseconds(), 1_000);
        assert_eq!(ext::NumericalStdDurationShort::seconds(-1).whole_milliseconds(), -1_000);
        assert_eq!(ext::NumericalStdDurationShort::milliseconds(1).whole_milliseconds(), 1);
        assert_eq!(ext::NumericalStdDurationShort::milliseconds(-1).whole_milliseconds(), -1);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    use crate as time;

    #[test]
    fn test_whole_minutes() {
        assert_eq!(crate::Duration::minutes(1).whole_minutes(), 1);
        assert_eq!(crate::Duration::minutes(-1).whole_minutes(), -1);
        assert_eq!(crate::Duration::seconds(59).whole_minutes(), 0);
        assert_eq!(crate::Duration::seconds(-59).whole_minutes(), 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_whole_nanoseconds() {
        assert_eq!(
            ext::NumericalStdDurationShort::microseconds(1).whole_nanoseconds(),
            1_000
        );
        assert_eq!(
            ext::NumericalStdDurationShort::microseconds(-1).whole_nanoseconds(),
            -1_000
        );
        assert_eq!(
            ext::NumericalStdDurationShort::nanoseconds(1).whole_nanoseconds(),
            1
        );
        assert_eq!(
            ext::NumericalStdDurationShort::nanoseconds(-1).whole_nanoseconds(),
            -1
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;

    #[test]
    fn test_whole_seconds() {
        assert_eq!(ext::NumericalStdDurationShort::seconds(1).whole_seconds(), 1);
        assert_eq!(ext::NumericalStdDurationShort::seconds(-1).whole_seconds(), -1);
        assert_eq!(ext::NumericalStdDurationShort::minutes(1).whole_seconds(), 60);
        assert_eq!(ext::NumericalStdDurationShort::minutes(-1).whole_seconds(), -60);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDurationShort as _;

    #[test]
    fn test_whole_weeks() {
        assert_eq!(ext::NumericalStdDurationShort::weeks(1).whole_weeks(), 1);
        assert_eq!(ext::NumericalStdDurationShort::weeks(-1).whole_weeks(), -1);
        assert_eq!(ext::NumericalStdDurationShort::days(6).whole_weeks(), 0);
        assert_eq!(ext::NumericalStdDurationShort::days(-6).whole_weeks(), 0);
    }
}
False
========================================
    use crate::duration::Duration;

    #[test]
    fn test_zero() {
        let expected = Duration {
            seconds: 0,
            nanoseconds: 0,
        };

        let result = Duration::zero();

        assert_eq!(result, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Date;
    use crate::format::deferred::DeferredFormat;
    use crate::format::date::assert_date_parse_eq;
    use crate::format::date::assert_date_format_eq;
    use crate::format::date::date;
    use crate::format::date::parse;
    use crate::format::date::Parsable;
    use crate::error::ComponentRange;
    use crate::format::Date;

    #[test]
    fn test_fmt_A() {
        let date = Date::from_julian_day(0);
        let mut result = String::new();
        date::fmt_A(&mut result, date).unwrap();
        assert_eq!(result, "monday");
    }

    #[test]
    fn test_parse() {
        let date = Date::from_julian_day(0);
        assert_eq!(Some(date), Date::from_parsed_string("monday"));

        let date = Date::from_julian_day(0);
        assert_eq!(Some(date), Date::from_parsed_string("mon"));

        let date = Date::from_julian_day(0);
        assert_eq!(Some(date), Date::from_parsed_string("Mo"));

        let date = Date::from_julian_day(0);
        assert_eq!(Some(date), Date::from_parsed_string("MON"));

        let date = Date::from_julian_day(0);
        assert_eq!(Some(date), Date::from_parsed_string("MONDAY"));
    }

    #[test]
    fn test_parse_err() {
        let result = Date::from_parsed_string("");
        assert_eq!(result, None);
    }

    #[test]
    fn test_parse_unified() {
        let date = Date::from_julian_day(0);
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
        assert_date_parse_eq(&format!("{:?}", date), &Ok(date));
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::format::MONTHS_FULL;
    use std::fmt::Write;

    #[test]
    fn test_fmt_B() {
        let mut buf = String::new();
        let date = Date::try_from_ymd(2022, 3, 15).unwrap();
        let result = fmt_B(&mut buf, date);
        assert!(result.is_ok());
        assert_eq!(buf, "March");
    }

    #[test]
    fn test_fmt_B_invalid() {
        let mut buf = String::new();
        let date = Date::try_from_ymd(2022, 13, 25).unwrap();
        let result = fmt_B(&mut buf, date);
        assert!(result.is_err());
    }
}
False
========================================
    use crate::format::date::fmt_C;
    use crate::format::Padding;
    use crate::date::Date;
    use std::fmt::{Formatter, Result};

    #[test]
    fn test_fmt_C() {
        let mut f = Formatter::new(Vec::<u8>::new());
        let date = Date::from_ymd(2021, 8, 13); // year = 2021, 2021 / 100 = 20
        let padding = Padding::None;
        let expected = Ok(());
        let result = fmt_C(&mut f, date, padding);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::format::date::fmt_Y;
    use crate::format::date::fmt_d;
    use crate::format::date::fmt_m;
    use crate::format::date::Padding;
    use crate::crate::format::date::Padding as FormatPadding;
    use crate::crate::Date;
    use std::fmt::Write as _;

    #[test]
    fn test_fmt_G() {
        let date = Date::from_julian_day(2_458_485);
        let mut formatter = std::fmt::Formatter::new(String::new());
        let padding = FormatPadding::Zero;
        let result = fmt_G(&mut formatter, date, padding);
        assert!(result.is_ok());
        let output = formatter.into_inner();
        assert_eq!(output, "2019");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;

    #[test]
    fn test_fmt_U() {
        let mut f = crate::format::Formatter::new();
        let date = crate::date::Date::from_ymd(2022, 1, 1);
        let padding = Padding::Zero;
        assert_eq!(crate::format::date::fmt_U(&mut f, date, padding).unwrap(), ());

        let expected = "00";
        let actual = f.to_string();
        assert_eq!(actual, expected);
    }
}

False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::format::Padding;
    use core::fmt::{self, Write};

    #[test]
    fn test_fmt_V() {
        let date = Date::try_from_ymd(2022, 1, 1).unwrap();
        let padding = Padding::Zero;
        let mut buf = String::new();
        fmt_V(&mut buf, date, padding).unwrap();
        assert_eq!(buf, "53");

        let date = Date::try_from_ymd(2022, 12, 31).unwrap();
        let padding = Padding::Zero;
        let mut buf = String::new();
        fmt_V(&mut buf, date, padding).unwrap();
        assert_eq!(buf, "52");
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::*;
    use crate::format::Padding;
    use std::fmt;

    struct FormatterDouble {
        result: Result<(), fmt::Error>,
    }

    impl fmt::Write for FormatterDouble {
        fn write_str(&mut self, _: &str) -> fmt::Result {
            Ok(())
        }

        fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> fmt::Result {
            self.result = fmt::Result::fmt(&args, &mut fmt::Formatter::new(std::io::sink()));
            Ok(())
        }
    }

    #[test]
    fn test_fmt_W() {
        let date = Date::try_from_ymd(2021, 10, 6).unwrap();
        let mut formatter = FormatterDouble { result: Ok(()) };

        fmt_W(
            &mut formatter,
            date,
            Padding::Zero,
        )
        .unwrap();

        assert!(formatter.result.is_ok());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;
    use std::fmt::Write;

    #[test]
    fn test_fmt_Y() {
        let date = Date::try_from_ymd(2022, 9, 9).unwrap();
        let mut f = Formatter::new();
        let _ = fmt_Y(&mut f, date, Padding::None);

        assert_eq!(f.into_inner(), "2022");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::{Date, Weekday};
    use crate::error::ParseResult;
    use crate::format::date::WEEKDAYS_ABBR;
    use crate::format::deferred::DeferredFormat;
    use crate::format::numeric::*;
    use crate::format::Padding::*;
    use crate::format::strfcrate::StrftimeItems;
    use crate::format::ParseError::*;
    use crate::Parse;
    use crate::parse::ParsedItems;
    use alloc::borrow::ToOwned;
    use alloc::string::String;
    use alloc::vec::Vec;
    use core::convert::TryFrom;
    use core::fmt::{self, Display, Formatter};

    #[test]
    fn test_fmt_a() {
        let mut buf = String::new();
        let date = Date::from_ymd(2021, 1, 1).unwrap();
        let mut f = Formatter::new(&mut buf);
        fmt_a(&mut f, date).unwrap();
        assert_eq!(buf, WEEKDAYS_ABBR[4]);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;
    use crate::format::strfcrate::{Padding, StrftimeItems};

    #[test]
    fn test_fmt_b() {
        let date = Date::try_from_ymd(2021, 1, 1).unwrap();
        let mut buffer = Vec::new();
        {
            let mut f = Formatter::new(&mut buffer, Padding::Zero);
            fmt_b(&mut f, date).unwrap();
        }
        let result = String::from_utf8(buffer).unwrap();
        let expected = "JAN";
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;
    use chrono::NaiveDate;
    use std::fmt::Write;

    #[test]
    fn test_fmt_d() {
        let mut output = String::new();
        let date = Date::from_ymd(2021, 10, 3);
        crate::format::date::fmt_d(&mut output, date, Padding::Zero).unwrap();
        assert_eq!(output, "03");

        let mut output = String::new();
        let date = Date::from_ymd(2021, 10, 12);
        crate::format::date::fmt_d(&mut output, date, Padding::Zero).unwrap();
        assert_eq!(output, "12");

        let mut output = String::new();
        let date = Date::from_ymd(2021, 1, 1);
        crate::format::date::fmt_d(&mut output, date, Padding::Zero).unwrap();
        assert_eq!(output, "01");

        // test padding with spaces
        let mut output = String::new();
        let date = Date::from_ymd(2021, 10, 1);
        crate::format::date::fmt_d(&mut output, date, Padding::Space).unwrap();
        assert_eq!(output, " 1");

        let mut output = String::new();
        let date = Date::from_ymd(2021, 1, 10);
        crate::format::date::fmt_d(&mut output, date, Padding::Space).unwrap();
        assert_eq!(output, "10");

        let mut output = String::new();
        let date = Date::from_ymd(2021, 1, 31);
        crate::format::date::fmt_d(&mut output, date, Padding::Space).unwrap();
        assert_eq!(output, "31");
    }

    #[test]
    fn test_fmt_d_against_chrono() {
        for year in -10_000..10_000 {
            for month in 1..=12 {
                for day in 1..=31 {
                    let date = Date::from_ymd(year, month, day);
                    let mut output = String::new();
                    crate::format::date::fmt_d(&mut output, date, Padding::Zero).unwrap();

                    let chrono_date = NaiveDate::from_ymd(year, month as u32, day as u32);
                    let chrono_output = chrono_date.format("%d").to_string();

                    assert_eq!(output, chrono_output);
                }
            }
        }
    }
}
False
========================================
    use crate::format::date::fmt_g;
    use crate::format::date::Padding;
    use crate::format::Padding as FmtPadding;
    use crate::format::fmt_g;
    use crate::format::Formatter;
    use crate::format::date::fmt_g;
    use crate::format::Padding;
    use std::fmt;
    use std::string::ToString;
    use crate::date::Date;

    struct MockFormatter<'a>(&'a mut String);

    impl<'a> fmt::Write for MockFormatter<'a> {
        fn write_str(&mut self, s: &str) -> fmt::Result {
            self.0.push_str(s);
            Ok(())
        }
    }

    #[test]
    fn test_fmt_g() {
        let mut s = String::new();
        let mut f = MockFormatter(&mut s);
        let date = Date {
            value: 737598, // Example date 02 Jan 2020
        };
        let expected = "20";

        fmt_g(&mut f, date, FmtPadding::None).unwrap();

        assert_eq!(s, expected);
    }
}
False
========================================
            use crate::date::fmt_d;
            use crate::date::fmt_Y;
            use crate::date::fmt_j;
            use crate::date::fmt_m;
            use crate::date::Padding;
            use crate::date::Date;
            use std::fmt::Formatter;

            #[test]
            fn test_fmt_j() {
                let mut s = String::new();
                let date = Date::try_from_ymd(2019, 1, 2).unwrap();
                let padding = Padding::Zero;
                fmt_j(&mut s, date, padding).unwrap();
                assert_eq!(s, "002");
            }

            #[test]
            fn test_fmt_d() {
                let mut s = String::new();
                let date = Date::try_from_ymd(2019, 1, 2).unwrap();
                let padding = Padding::Zero;
                fmt_d(&mut s, date, padding).unwrap();
                assert_eq!(s, "02");
            }

            #[test]
            fn test_fmt_m() {
                let mut s = String::new();
                let date = Date::try_from_ymd(2019, 1, 2).unwrap();
                let padding = Padding::Zero;
                fmt_m(&mut s, date, padding).unwrap();
                assert_eq!(s, "01");
            }

            #[test]
            fn test_fmt_Y() {
                let mut s = String::new();
                let date = Date::try_from_ymd(2019, 1, 2).unwrap();
                let padding = Padding::Zero;
                fmt_Y(&mut s, date, padding).unwrap();
                assert_eq!(s, "2019");
            }
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;

    #[test]
    fn test_fmt_m() {
        let date = Date::try_from_ymd(2022, 1, 1).unwrap();
        let mut formatter = std::fmt::Formatter::new(Vec::new());
        assert!(fmt_m(&mut formatter, date, Padding::Zero).is_ok());
        assert_eq!(formatter.into_inner(), Ok(b"01".to_vec()));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use crate::format::date::Padding;
    use crate::format::Formatter;
    use std::fmt::Write;
    use std::string::ToString;
    
    #[test]
    pub fn test_fmt_u() {
        let date = Date::try_from_ymd(2022, 12, 25).unwrap();
        let mut buf = String::new();
        let mut f = Formatter::new(&mut buf);
        fmt_u(&mut f, date).unwrap();
        assert_eq!(buf, "7");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding::*;
    use std::fmt::Write;

    #[test]
    fn test_fmt_w() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0");
    }

    #[test]
    fn test_fmt_w_lowercase() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_lowercase(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0");
    }

    #[test]
    fn test_fmt_w_width() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_width(&mut f, date, 3).unwrap();
        assert_eq!(f.into_inner(), " 0");
    }

    #[test]
    fn test_fmt_w_zeros() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_zeros(&mut f, date, 3).unwrap();
        assert_eq!(f.into_inner(), "00");
    }

    #[test]
    fn test_fmt_w_alt() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt(&mut f, date, 3).unwrap();
        assert_eq!(f.into_inner(), "0");
    }

    #[test]
    fn test_fmt_w_alt_zeros() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros(&mut f, date, 3).unwrap();
        assert_eq!(f.into_inner(), "00");
    }

    #[test]
    fn test_fmt_w_alt_zeros_4() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_4(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_5() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_5(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_6() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_6(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_7() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_7(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_8() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_8(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_9() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_9(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_10() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_10(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_11() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_11(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_12() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_12(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_13() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_13(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_14() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_14(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_15() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_15(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_16() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_16(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_17() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_17(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_18() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_18(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_19() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_19(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_20() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_20(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_21() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_21(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_22() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_22(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_23() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_23(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "00000000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_24() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_24(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "000000000000000000000000");
    }

    #[test]
    fn test_fmt_w_alt_zeros_25() {
        let mut f = Formatter::new(Vec::new());
        let date = Date::from_ymd(2021, 10, 10);
        fmt_w_alt_zeros_25(&mut f, date).unwrap();
        assert_eq!(f.into_inner(), "0000000000000000000000000");
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_fmt_y() {
        let mut f = Formatter::new(&mut String::new());
        let date = Date::from_ymd(2021, 1, 1);
        let padding = Padding::Zero;
        fmt_y(&mut f, date, padding).unwrap();
        assert_eq!(f.to_string(), "21");
    }
}
False
========================================
    use crate::format::parse::ParsedItems;
    use crate::format::date::parse_A;
    use crate::error::Parse;
    use crate::error::ParseResult;
    use crate::WEEKDAYS_FULL;
    use crate::WEEKDAYS;
    use std::num::NonZeroU8;
    use chrono::Weekday;
    
    #[test]
    fn test_parse_A() -> ParseResult<()> {
        let mut items = ParsedItems::new();
        let mut s = "Sunday";
        parse_A(&mut items, &mut s)?;
        assert_eq!(items.weekday, Some(Weekday::Sun));
        
        let mut items = ParsedItems::new();
        let mut s = "Thursday";
        parse_A(&mut items, &mut s)?;
        assert_eq!(items.weekday, Some(Weekday::Thu));
        
        // Test invalid day of the week
        let mut items = ParsedItems::new();
        let mut s = "InvalidDay";
        assert_eq!(parse_A(&mut items, &mut s), Err(Parse::InvalidDayOfWeek));
        Ok(())
    }
}
False
========================================
  use super::*;

use crate::*;
  use crate::format::error;

  #[test]
  fn test_parse_B() {
    let mut items = ParsedItems::new();
    let mut s = "January";
    parse_B(&mut items, &mut s).unwrap();
    assert_eq!(items.month, Some(NonZeroU8::new(1).unwrap()));

    let mut items = ParsedItems::new();
    let mut s = "February";
    parse_B(&mut items, &mut s).unwrap();
    assert_eq!(items.month, Some(NonZeroU8::new(2).unwrap()));

    // Add more test cases here
  }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::date::Padding;

    #[test]
    fn test_parse_C() {
        let mut items = ParsedItems::new();
        let mut s = "123";
        let padding = Padding::None;

        let result = parse_C(&mut items, &mut s, padding);

        assert_eq!(result, Ok(()));
        assert_eq!(items.year, Some(123));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::parse::error::Parse;
    use crate::format::parse::ParsedItems;
    use crate::format::Padding;

    #[test]
    fn test_parse_G() {
        let mut items = ParsedItems::new();
        let mut s = "2022".as_mut();
        let padding = Padding::None;

        assert_eq!(crate::format::date::parse_G(&mut items, &mut &mut s, padding), Ok(()));
        assert_eq!(items.week_based_year, Some(2022));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;

    #[test]
    fn test_parse_U() {
        let mut items = ParsedItems::new();
        let mut s = "42";
        let padding = Padding::None;

        parse_U(&mut items, &mut s, padding).unwrap();

        assert_eq!(items.sunday_week, Some(42));
    }
}
True
========================================
    use crate::format::date::parse_V;
    use crate::format::parse::ParsedItems;
    use crate::format::Padding;
    use std::num::NonZeroU8;
    use crate::error;
    use std::num::NonZeroU16;
    
    #[test]
    fn test_parse_V() {
        let mut items = ParsedItems::new();
        let mut s = "08";
        let padding = Padding::Zero;
        let result = parse_V(&mut items, &mut s, padding);
        assert_eq!(result, Ok(()));
        assert_eq!(items.iso_week, Some(NonZeroU8::new(8).unwrap()));
        assert_eq!(s, "");
    
        let mut items = ParsedItems::new();
        let mut s = "3";
        let padding = Padding::None;
        let result = parse_V(&mut items, &mut s, padding);
        assert_eq!(result, Ok(()));
        assert_eq!(items.iso_week, Some(NonZeroU8::new(3).unwrap()));
        assert_eq!(s, "");
    
        let mut items = ParsedItems::new();
        let mut s = "53";
        let padding = Padding::Zero;
        let result = parse_V(&mut items, &mut s, padding);
        assert_eq!(result, Ok(()));
        assert_eq!(items.iso_week, Some(NonZeroU8::new(53).unwrap()));
        assert_eq!(s, "");
    
        let mut items = ParsedItems::new();
        let mut s = "100";
        let padding = Padding::None;
        let result = parse_V(&mut items, &mut s, padding);
        assert_eq!(result, Ok(()));
        assert_eq!(items.iso_week, Some(NonZeroU8::new(100).unwrap()));
        assert_eq!(s, "");
    
        let mut items = ParsedItems::new();
        let mut s = "";
        let padding = Padding::Zero;
        let result = parse_V(&mut items, &mut s, padding);
        assert_eq!(result, Err(error::Parse::InvalidWeek));
        assert_eq!(s, "");
    }
}
True
========================================
    use super::*;

use crate::*;
    use format::parse::ParsedItems;

    #[test]
    fn test_parse_W() {
        let mut items = ParsedItems::new();
        let mut s = "20";
        let padding = Padding::Space;

        parse_W(&mut items, &mut s, padding).unwrap();

        assert_eq!(items.monday_week, Some(20));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::parse::ParsedItems;
    use crate::format::Padding;

    #[test]
    fn test_parse_Y() {
        let mut items = ParsedItems::new();
        let mut s = "";
        let padding = Padding::None;

        parse_Y(&mut items, &mut s, padding).unwrap();

        assert_eq!(items.year, Some(0));
    }
}
True
========================================
    use crate::parse_a;
    use crate::format::date::ParsedItems;
    use crate::format::error::Parse;
    use crate::format::error::ParseResult;
    use crate::format::error::Parse as ErrorParse;
    use crate::format::weekday::Weekday;
  
    #[test]
    fn test_parse_a() {
        let mut items = ParsedItems::new();
        let mut s = "Mon";
        let result = parse_a(&mut items, &mut s);
        assert!(result.is_ok()); 
        assert_eq!(items.weekday, Some(Weekday::Mon));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::date::parse_b;
    use crate::format::date::ParsedItems;
    use crate::format::error::Parse;
    use crate::format::error::ParseResult;
    use std::num::NonZeroU8;
    use chrono::format::AbbrMonth;
    use chrono::format::error::Parse as ErrorParse;

    #[test]
    fn test_parse_b() {
        let mut items = ParsedItems::new();
        let mut s = "Jan";
        assert_eq!(parse_b(&mut items, &mut &s), Ok(()));
        let month = items.month.unwrap();
        assert_eq!(month.get(), 1);
    }
}
False
========================================
    use crate::format::date::{parse_d, Padding};
    use crate::format::parse::ParsedItems;
    use std::num::NonZeroU8;

    #[test]
    fn test_parse_d() {
        let mut items = ParsedItems::new();
        let mut s = "05";
        let padding = Padding::Zero;

        let result = parse_d(&mut items, &mut s, padding);

        assert_eq!(result, Ok(()));
        assert_eq!(items.day, Some(NonZeroU8::new(5).unwrap()));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_parse_g() {
        let mut items = ParsedItems::new();
        let mut s = "21-12-31";
        let padding = Padding::None;

        parse_g(&mut items, &mut s, padding).unwrap();

        assert_eq!(items.week_based_year, Some(2100));
    }
}
True
========================================
    use super::*;

use crate::*;
    use format::Padding;
    use std::num::NonZeroU16;

    #[test]
    fn test_parse_j() {
        let mut items = ParsedItems::new();
        let mut s = "123";
        let padding = Padding::None;

        let result = parse_j(&mut items, &mut s, padding);

        assert_eq!(result, Ok(()));
        assert_eq!(items.ordinal_day, Some(NonZeroU16::new(123).unwrap()));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::error::Parse;

    #[test]
    fn test_parse_m() {
        let mut items = ParsedItems::new();
        let mut s = "01";
        let padding = Padding::None;
        
        assert_eq!(Ok(()), parse_m(&mut items, &mut s, padding));
        assert_eq!(Some(NonZeroU8::new(1).unwrap()), items.month);
    }

    #[test]
    fn test_parse_m_invalid() {
        let mut items = ParsedItems::new();
        let mut s = "13";
        let padding = Padding::None;
        
        assert_eq!(Err(Parse::InvalidMonth), parse_m(&mut items, &mut s, padding));
        assert_eq!(None, items.month);
    }
}
True
========================================
    use crate::format::date::{parse_u, ParsedItems, Weekday};
    use crate::format::error::Parse;
    use std::num::NonZeroU8;
    use std::num::NonZeroU16;

    #[test]
    fn test_parse_u() {
        let mut items = ParsedItems::new();
        let mut s = "1";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Mon));

        let mut items = ParsedItems::new();
        let mut s = "2";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Tue));

        let mut items = ParsedItems::new();
        let mut s = "3";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Wed));

        let mut items = ParsedItems::new();
        let mut s = "4";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Thu));

        let mut items = ParsedItems::new();
        let mut s = "5";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Fri));

        let mut items = ParsedItems::new();
        let mut s = "6";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Sat));

        let mut items = ParsedItems::new();
        let mut s = "7";
        parse_u(&mut items, &mut s).unwrap();
        assert_eq!(items.weekday, Some(Weekday::Sun));

        let mut items = ParsedItems::new();
        let mut s = "8";
        let result = parse_u(&mut items, &mut s);
        assert_eq!(result, Err(Parse::InvalidDayOfWeek));
        assert_eq!(items.weekday, None);
        assert_eq!(s, "8");
    }
}
False
========================================
    use super::*;

use crate::*;

    use format::parse::ParsedItems;
    use format::error::Parse;

    #[test]
    fn test_parse_w() {
        let mut items = ParsedItems::new();
        let mut s: &mut &str = &mut "1";
        assert_eq!(parse_w(&mut items, &mut s), Ok(()));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::Padding;

    #[test]
    fn test_parse_y() {
        let mut items = ParsedItems::new();
        let mut s = "21";
        let padding = Padding::None;

        assert_eq!(parse_y(&mut items, &mut s, padding), Ok(()));
        assert_eq!(items.year, Some(2000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Date;
    use crate::macros::date;

    #[test]
    fn test_date() {
        let mut deferred_format = DeferredFormat::new("");
        deferred_format.with_date(date!(2022-01-01));

        assert_eq!(deferred_format.date(), Some(date!(2022-01-01)));
    }
}
False
========================================
    use crate::format::deferred_format::{DeferredFormat, Format};

    #[test]
    fn test_new() {
        let format: Format = "yyyy-MM-dd".into();
        let deferred_format = DeferredFormat::new(format);
        assert_eq!(deferred_format.date(), None);
        assert_eq!(deferred_format.time(), None);
        assert_eq!(deferred_format.offset(), None);
        assert_eq!(deferred_format.format, Format::Custom("yyyy-MM-dd".to_owned()));
    }
}
True
========================================
    use crate::format::deferred_format::{DeferredFormat, Format};
    use crate::format::{FormatItem, well_known};
    use crate::{Date, Time, UtcOffset};
    use std::fmt::{self, Formatter};
    use crate::ext::NumericalDuration;

    fn parse_fmt_string(_s: &str) -> Vec<FormatItem> {
        // Implement your own parse_fmt_string function
        unimplemented!();
    }

    #[test]
    fn test_offset() {
        let mut deferred_format = DeferredFormat::new(Format::Custom(String::from("")));
        let offset = UtcOffset::seconds(0);
        deferred_format.with_offset(offset);
        assert_eq!(deferred_format.offset(), Some(offset));
    }
}
True
========================================
    use super::*;

use crate::*;
    use format::{Date, Time, UtcOffset};

    #[test]
    fn test_time() {
        let mut deferred_format = DeferredFormat::new(format::Format::Custom("%H:%M:%S".to_owned()));
        deferred_format.with_time(Time::try_from_hms(12, 30, 45).unwrap());
        assert_eq!(deferred_format.time(), Some(Time::try_from_hms(12, 30, 45).unwrap()));

        deferred_format = DeferredFormat::new(format::Format::Rfc3339);
        assert_eq!(deferred_format.time(), None);
    }
}
True
========================================
use crate::interval::{Duration, duration, span, Interval};
use crate::crate::{Date, Time, date, time};
use crate::crate::format::well_known::rfc3339::Rfc3339;
use crate::crate::format::DeferredFormat;
use crate::crate::format::Format;
False
========================================
    use super::*;

use crate::*;
    use crate::format::format::Format;

    #[test]
    fn test_with_offset() {
        let mut deferred_format = DeferredFormat::new(Format::Custom(""));
        let offset = UtcOffset::hours(2);
        deferred_format.with_offset(offset);
        assert_eq!(deferred_format.offset(), Some(offset.clone()));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_with_time() {
        let mut df = DeferredFormat::new(Format::Custom("YYYY-MM-DD".to_string()));
        let mut time = Time::try_from_hms(12, 0, 0).unwrap();

        df.with_time(time);

        assert_eq!(df.time(), Some(time));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::Formatter;
    use crate::format::Specifier;
    use crate::format::Padding;
    use crate::error::FormatResult;
    use crate::Date;
    use crate::Time;
    use crate::UtcOffset;
    use std::fmt::Write;

    #[test]
    fn test_format_specifier() -> FormatResult<()> {
        let mut f = Formatter::new(String::new());
        let date = Some(Date);
        let time = Some(Time);
        let offset = Some(UtcOffset);
        let specifier = Specifier::A;
        format_specifier(&mut f, date, time, offset, specifier)?;
        assert_eq!(f.to_string(), /* expected result */);
        Ok(())
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::*;

    #[test]
    fn test_fmt_z_positive_offset() {
        use std::fmt::Write;
        let offset = UtcOffset::hours(2);

        let mut buffer = String::new();
        let result = fmt_z(&mut buffer, offset);

        assert_eq!(buffer, "+0200");
        assert!(result.is_ok());
    }

    #[test]
    fn test_fmt_z_negative_offset() {
        use std::fmt::Write;
        let offset = UtcOffset::hours(-2);

        let mut buffer = String::new();
        let result = fmt_z(&mut buffer, offset);

        assert_eq!(buffer, "-0200");
        assert!(result.is_ok());
    }

    #[test]
    fn test_fmt_z_zero_offset() {
        use std::fmt::Write;
        let offset = UtcOffset::hours(0);

        let mut buffer = String::new();
        let result = fmt_z(&mut buffer, offset);

        assert_eq!(buffer, "+0000");
        assert!(result.is_ok());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::Parse;
    use crate::format::{
        offset::parse_z,
        padding::Padding,
        ParsedItems,
    };
    use crate::offset::UtcOffset;

    #[test]
    fn test_parse_z() {
        let mut items = ParsedItems::new();
        let mut s = "+0500";
        assert_eq!(parse_z(&mut items, &mut s), Ok(()));
        assert_eq!(items.offset, Some(UtcOffset::minutes(300).into()));

        let mut items = ParsedItems::new();
        let mut s = "-0700";
        assert_eq!(parse_z(&mut items, &mut s), Ok(()));
        assert_eq!(items.offset, Some(UtcOffset::minutes(-420).into()));
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_new() {
        let parsed_items = ParsedItems::new();
        
        assert_eq!(parsed_items.week_based_year, None);
        assert_eq!(parsed_items.year, None);
        assert_eq!(parsed_items.month, None);
        assert_eq!(parsed_items.day, None);
        assert_eq!(parsed_items.weekday, None);
        assert_eq!(parsed_items.ordinal_day, None);
        assert_eq!(parsed_items.iso_week, None);
        assert_eq!(parsed_items.sunday_week, None);
        assert_eq!(parsed_items.monday_week, None);
        assert_eq!(parsed_items.hour_12, None);
        assert_eq!(parsed_items.hour_24, None);
        assert_eq!(parsed_items.minute, None);
        assert_eq!(parsed_items.second, None);
        assert_eq!(parsed_items.nanosecond, None);
        assert_eq!(parsed_items.offset, None);
        assert_eq!(parsed_items.am_pm, None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use format::Padding;

    #[test]
    fn test_consume_padding_space() {
        let mut s = "   12:34:56".as_bytes();
        let s_str = String::from_utf8_lossy(&mut s).into_owned();
        let mut s = s_str.as_ref();
        let padding = Padding::Space;
        let max_chars = 3;
        let expected = 3;

        let result = consume_padding(&mut s, padding, max_chars);

        assert_eq!(result, expected);
        assert_eq!(s, "12:34:56");
    }

    #[test]
    fn test_consume_padding_zero() {
        let mut s = "00012:34:56".as_bytes();
        let s_str = String::from_utf8_lossy(&mut s).into_owned();
        let mut s = s_str.as_ref();
        let padding = Padding::Zero;
        let max_chars = 4;
        let expected = 4;

        let result = consume_padding(&mut s, padding, max_chars);

        assert_eq!(result, expected);
        assert_eq!(s, "12:34:56");
    }

    #[test]
    fn test_consume_padding_none() {
        let mut s = "12:34:56".as_bytes();
        let s_str = String::from_utf8_lossy(&mut s).into_owned();
        let mut s = s_str.as_ref();
        let padding = Padding::None;
        let max_chars = 10;
        let expected = 0;

        let result = consume_padding(&mut s, padding, max_chars);

        assert_eq!(result, expected);
        assert_eq!(s, "12:34:56");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::parse::parse;
    use crate::format::Format;

    #[test]
    fn test_parse() {
        let s = "2021-01-01T00:00:00Z";
        let format = Format::Rfc3339;

        let result = parse(s, &format);

        assert!(result.is_ok());
        let parsed_items = result.unwrap();
        // Add assertions here
    }
}
True
========================================
#[test]
fn test_try_consume_char() {
    use crate::format::parse::{try_consume_char, Error};
    use crate::format::ParseResult;

    // Test case 1: Successful consumption
    let mut input = "abc";
    let expected = Ok(());
    let result = try_consume_char(&mut input, 'a');
    assert_eq!(result, expected);
    assert_eq!(input, "bc");

    // Test case 2: Unexpected character
    let mut input = "abc";
    let expected = Err(Error::UnexpectedCharacter { expected: 'd', actual: 'a' });
    let result = try_consume_char(&mut input, 'd');
    assert_eq!(result, expected);
    assert_eq!(input, "abc");

    // Test case 3: Unexpected end of string
    let mut input = "";
    let expected = Err(Error::UnexpectedEndOfString);
    let result = try_consume_char(&mut input, 'a');
    assert_eq!(result, expected);
    assert_eq!(input, "");
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::parse::Error;

    #[test]
    fn test_try_consume_char_case_insensitive_success() {
        let mut s = "rUsT";
        let expected = 'r';
        assert_eq!(try_consume_char_case_insensitive(&mut s, expected), Ok(()));
        assert_eq!(s, "UsT");
    }

    #[test]
    fn test_try_consume_char_case_insensitive_failure_unexpected_character() {
        let mut s = "rUsT";
        let expected = 'T';
        assert_eq!(try_consume_char_case_insensitive(&mut s, expected), Err(Error::UnexpectedCharacter {
            expected: 'T',
            actual: 'r',
        }));
        assert_eq!(s, "rUsT");
    }

    #[test]
    fn test_try_consume_char_case_insensitive_failure_unexpected_end_of_string() {
        let mut s = "";
        let expected = 'r';
        assert_eq!(try_consume_char_case_insensitive(&mut s, expected), Err(Error::UnexpectedEndOfString));
        assert_eq!(s, "");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_try_consume_digits() {
        let mut s = "12345";
        let min_digits = 2;
        let max_digits = 4;
        let result: Option<u32> = try_consume_digits(&mut s, min_digits, max_digits);
        assert_eq!(s, "5");
        assert_eq!(result, Some(1234));
    }
}
True
========================================
    use super::*;

use crate::*;
    use format::Padding;
    use std::str::FromStr;

    #[test]
    fn test_try_consume_exact_digits() {
        let mut input = "1234";
        let mut input_ref = &mut input;
        let result = try_consume_exact_digits::<u32>(&mut input_ref, 4, Padding::None);
        assert_eq!(result, Some(1234u32));

        let mut input = "abc";
        let mut input_ref = &mut input;
        let result = try_consume_exact_digits::<u32>(&mut input_ref, 3, Padding::None);
        assert_eq!(result, None);

        let mut input = "12 34";
        let mut input_ref = &mut input;
        let result = try_consume_exact_digits::<u32>(&mut input_ref, 4, Padding::Space);
        assert_eq!(result, Some(12u32));

        let mut input = "0123";
        let mut input_ref = &mut input;
        let result = try_consume_exact_digits::<u32>(&mut input_ref, 3, Padding::Zero);
        assert_eq!(result, Some(123u32));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_parse_date() {
        assert_eq!(parse_date("2021-07-15"), Ok(date!(2021-07-15)));
        assert_eq!(parse_date("2021-32-15"), Err(ParseResult::MissingComponents("missing month field".to_string())));
        assert_eq!(parse_date("2021-07-15-08:00"), Err(ParseResult::ExtraComponents("extra time field".to_string())));
    }
}
False
========================================
    use crate::format::parse::{try_consume_str, ParseResult, Error};

    fn assert_try_consume_str(s: &str, expected: &str, result: ParseResult<()>) {
        let mut s = s;
        assert_eq!(try_consume_str(&mut s, expected), result);
    }

    #[test]
    fn test_try_consume_str_success() {
        assert_try_consume_str("abc", "a", Ok(()));
        assert_try_consume_str("abc", "ab", Ok(()));
        assert_try_consume_str("abc", "abc", Ok(()));
    }

    #[test]
    fn test_try_consume_str_failure() {
        assert_try_consume_str("abc", "d", Err(Error));
        assert_try_consume_str("abc", "ac", Err(Error));
        assert_try_consume_str("abc", "bcd", Err(Error));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::parse_items::{parse_fmt_string, FormatItem};

    #[test]
    #[should_panic]
    fn test_parse_fmt_string_invalid_input() {
        parse_fmt_string("invalid_format");
    }

    #[test]
    fn test_parse_fmt_string_valid_input() {
        let expected_output: Vec<FormatItem<'_>> = vec![
            FormatItem::Literal("Hello"),
            FormatItem::Specifier("Y", false, None, None),
            FormatItem::Literal(","),
            FormatItem::Specifier("m", true, Some('0'), Some(2)),
            FormatItem::Literal(","),
            FormatItem::Specifier("D", true, Some('-'), Some(2)),
            FormatItem::Specifier("h", true, Some('0'), Some(2)),
            FormatItem::Specifier("M", true, Some('0'), Some(2)),
            FormatItem::Specifier("S", true, Some('0'), Some(2)),
            FormatItem::Literal("end"),
        ];

        let output = parse_fmt_string("Hello %Y,%m{0}{2},%D%-2-%h%0-%M%0-%S%0end");

        assert_eq!(output, expected_output);
    }
}
False
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_try_parse_fmt_string() {
        let result = try_parse_fmt_string("%Y-%m-%d");
        assert!(result.is_ok());

        let result = try_parse_fmt_string("%H:%M:%S");
        assert!(result.is_ok());

        let result = try_parse_fmt_string("This is a literal");
        assert!(result.is_ok());

        let result = try_parse_fmt_string("%");
        assert!(result.is_err());

        let result = try_parse_fmt_string("Invalid %d specifier");
        assert!(result.is_err());
    }
}
True
========================================

True
========================================
    use super::*;

use crate::*;
    use std::fmt::{Debug, Formatter, Result};

    struct MockFormatter {
        buf: String,
    }

    impl MockFormatter {
        fn new() -> Self {
            MockFormatter { buf: String::new() }
        }
    }

    impl std::fmt::Write for MockFormatter {
        fn write_str(&mut self, s: &str) -> Result {
            self.buf.push_str(s);
            Ok(())
        }
    }

    impl Debug for MockFormatter {
        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
            self.buf.fmt(f)
        }
    }

    #[test]
    fn test_fmt_I_none_padding() {
        let mut f = MockFormatter::new();
        let time = Time {
            hour: 12,
            minute: 34,
            second: 56,
            nanosecond: 0,
        };
        let padding = Padding::None;

        assert_eq!(fmt_I(&mut f, time, padding).unwrap(), ());
        assert_eq!(format!("{:?}", f), "12");
    }

    #[test]
    fn test_fmt_I_space_padding() {
        let mut f = MockFormatter::new();
        let time = Time {
            hour: 0,
            minute: 9,
            second: 43,
            nanosecond: 0,
        };
        let padding = Padding::Space;

        assert_eq!(fmt_I(&mut f, time, padding).unwrap(), ());
        assert_eq!(format!("{:?}", f), " 1");
    }

    #[test]
    fn test_fmt_I_zero_padding() {
        let mut f = MockFormatter::new();
        let time = Time {
            hour: 23,
            minute: 59,
            second: 1,
            nanosecond: 0,
        };
        let padding = Padding::Zero;

        assert_eq!(fmt_I(&mut f, time, padding).unwrap(), ());
        assert_eq!(format!("{:?}", f), "12");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::crate::fmt_M;
    use crate::format::Padding;

    #[test]
    fn test_fmt_M() {
        let mut f = std::fmt::Formatter::new(&mut std::io::sink());
        let time = time_mod::Time {
            hour: 1,
            minute: 2,
            second: 3,
            nanosecond: 4,
        };
        let padding = format::Padding::None;

        assert!(fmt_M(&mut f, time, padding).is_ok());
        assert_eq!(f.into_inner(), &mut std::io::sink());
    }
}
False
========================================
    use crate::fmt_N;
    use crate::Time;
    use crate::formatter::fmt::Formatter;
    use std::fmt;

    #[test]
    fn test_fmt_N() {
        let time = Time {
            hour: 12,
            minute: 0,
            second: 0,
            nanosecond: 123456789,
        };
        let expected = String::from("123456789");
        let mut output = String::new();
        let result = fmt_N(&mut Formatter::new(&mut output), time);
        assert_eq!(result, Ok(()));
        assert_eq!(output, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::*; // import all items from the format module
    use std::fmt;

    #[test]
    fn test_fmt_P() {
        struct MockFormatter {}

        impl<'a> fmt::Write for MockFormatter {
            fn write_str(&mut self, s: &str) -> fmt::Result {
                assert_eq!(s, "PM");
                Ok(())
            }
        }

        let mut f = MockFormatter {};
        let time = Time {
            hour: 13,
            minute: 30,
            second: 0,
            nanosecond: 0,
        };
        fmt_P(&mut f, time).unwrap();
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_fmt_S() {
        let mut buffer = Vec::new();
        let mut f = std::fmt::Formatter::new(&mut buffer);
        let time = Time {
            hour: 12,
            minute: 30,
            second: 45,
            nanosecond: 0,
        };
        let padding = Padding::Zero;

        fmt_S(&mut f, time, padding).unwrap();

        let result = std::str::from_utf8(&buffer).unwrap();
        assert_eq!(result, "45");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::format::crate::{fmt_p, Padding};
    use std::fmt::{self, Write};

    struct MockFormatter<'a> {
        output: &'a mut String,
    }

    impl<'a> MockFormatter<'a> {
        fn new(output: &'a mut String) -> Self {
            MockFormatter { output }
        }
    }

    impl<'a> fmt::Write for MockFormatter<'a> {
        fn write_str(&mut self, s: &str) -> fmt::Result {
            self.output.push_str(s);
            Ok(())
        }
    }

    fn am_pm_test_case(input: (Time, &str)) {
        let (time, expected_str) = input;
        let mut output = String::new();
        fmt_p(&mut MockFormatter::new(&mut output), time).unwrap();
        assert_eq!(output, expected_str);
    }

    #[test]
    fn am_pm_test() {
        am_pm_test_case((Time::try_from_hms(0, 0, 0).unwrap(), "am"));
        am_pm_test_case((Time::try_from_hms(11, 59, 59).unwrap(), "am"));
        am_pm_test_case((Time::try_from_hms(12, 0, 0).unwrap(), "pm"));
        am_pm_test_case((Time::try_from_hms(23, 59, 59).unwrap(), "pm"));
    }
}
False
========================================
    use super::*;

use crate::*;
    use format::parse::ParsedItems;
    use format::Padding;
    use std::num::NonZeroU8;
    use std::num::NonZeroU16;
    use crate::Weekday;

    #[test]
    fn test_parse_H() {
        let padding = Padding::None;
        let mut items = ParsedItems::new();
        let mut s = "23";
        let result = parse_H(&mut items, &mut s, padding);
        assert_eq!(result, Ok(()));
        assert_eq!(items.hour_24, Some(23));
    }
}
True
========================================
    use crate::format::crate::{parse_I, Padding, ParsedItems};
    use std::num::NonZeroU8;
    use crate::format::error::Parse;

    #[test]
    fn test_parse_I() {
        let mut items = ParsedItems::new();
        let mut s = "01";
        let padding = Padding::None;

        assert_eq!(
            parse_I(&mut items, &mut s, padding),
            Ok(())
        );
        assert_eq!(
            items.hour_12,
            Some(NonZeroU8::new(1).unwrap())
        );
    }

    #[test]
    fn test_parse_I_invalid() {
        let mut items = ParsedItems::new();
        let mut s = "abc";
        let padding = Padding::None;

        assert_eq!(
            parse_I(&mut items, &mut s, padding),
            Err(Parse::InvalidHour)
        );
        assert_eq!(
            items.hour_12,
            None
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::Parse;
    use crate::format::crate::{parse_M, Padding, ParsedItems};
    use std::num::NonZeroU8;

    #[test]
    fn test_parse_M() {
        let mut items = ParsedItems::new();
        let mut s = "30";
        let padding = Padding::None;

        let result = parse_M(&mut items, &mut s, padding);

        assert_eq!(result, Ok(()));
        assert_eq!(items.minute, Some(30));
    }

    #[test]
    fn test_parse_M_invalid_minute() {
        let mut items = ParsedItems::new();
        let mut s = "abc";
        let padding = Padding::None;

        let result = parse_M(&mut items, &mut s, padding);

        assert_eq!(result, Err(Parse::InvalidMinute));
        assert_eq!(items.minute, None);
    }

    // Add more tests here...
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::Parse;

    #[test]
    fn test_parse_N() {
        let mut items = ParsedItems::new();
        let mut s = "123456789";
        assert_eq!(parse_N(&mut items, &mut s), Ok(()));
        assert_eq!(items.nanosecond, Some(123456789));

        let mut items = ParsedItems::new();
        let mut s = "12345678";
        assert_eq!(parse_N(&mut items, &mut s), Err(Parse::InvalidNanosecond));
        assert_eq!(items.nanosecond, None);

        let mut items = ParsedItems::new();
        let mut s = "1234567890";
        assert_eq!(parse_N(&mut items, &mut s), Err(Parse::InvalidNanosecond));
        assert_eq!(items.nanosecond, None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::Parse;

    #[test]
    fn test_parse_P() {
        let mut items = ParsedItems::new();
        let mut s = "AM";
        assert_eq!(parse_P(&mut items, &mut s), Ok(()));
        assert_eq!(items.am_pm, Some(AM));
        assert_eq!(s, "");

        let mut items = ParsedItems::new();
        let mut s = "PM";
        assert_eq!(parse_P(&mut items, &mut s), Ok(()));
        assert_eq!(items.am_pm, Some(PM));
        assert_eq!(s, "");

        let mut items = ParsedItems::new();
        let mut s = "A";
        assert_eq!(parse_P(&mut items, &mut s), Err(Parse::InvalidAmPm));
        assert_eq!(items.am_pm, None);
        assert_eq!(s, "A");

        let mut items = ParsedItems::new();
        let mut s = "AM";
        s = &s[..1];
        assert_eq!(parse_P(&mut items, &mut s), Err(Parse::InvalidAmPm));
        assert_eq!(items.am_pm, None);
        assert_eq!(s, "M");

        let mut items = ParsedItems::new();
        let mut s = "";
        assert_eq!(parse_P(&mut items, &mut s), Err(Parse::InvalidAmPm));
        assert_eq!(items.am_pm, None);
        assert_eq!(s, "");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::crate::parse_S;
    use crate::format::crate::_padding::Padding;
    use crate::format::parse::ParsedItems;
    use std::num::NonZeroU8;

    #[test]
    fn test_parse_S() {
        let mut items = ParsedItems::new();
        let mut s = "59";
        let padding = Padding::None;
        assert_eq!(parse_S(&mut items, &mut s, padding), Ok(()));
        assert_eq!(items.second, Some(59));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::Parse;

    #[test]
    fn test_parse_p_valid_am() {
        let mut items = ParsedItems::new();
        let mut s = "am";
        let result = parse_p(&mut items, &mut s);
        assert_eq!(result, Ok(()));
        assert_eq!(items.am_pm, Some(AM));
    }

    #[test]
    fn test_parse_p_valid_pm() {
        let mut items = ParsedItems::new();
        let mut s = "pm";
        let result = parse_p(&mut items, &mut s);
        assert_eq!(result, Ok(()));
        assert_eq!(items.am_pm, Some(PM));
    }

    #[test]
    fn test_parse_p_invalid() {
        let mut items = ParsedItems::new();
        let mut s = "invalid";
        let result = parse_p(&mut items, &mut s);
        assert_eq!(result, Err(Parse::InvalidAmPm));
        assert_eq!(items.am_pm, None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::format::well_known::rfc3339::fmt;
    use crate::format::format::Format;
    use crate::format::deferred_format::DeferredFormat;
    use chrono::{TimeZone, Utc, Date, Time, UtcOffset};
    use std::fmt::Write;


    #[test]
    fn test_fmt() {
        let df = DeferredFormat::new(Format::Rfc3339)
            .with_date(Date::from(Utc.ymd(2022, 8, 1)))
            .with_time(Time::from(Utc.ymd(2022, 8, 1).and_hms(12, 0, 0)))
            .with_offset(UtcOffset::hours(2));
        let mut result = String::new();
        fmt(&df, &mut result).unwrap();
        assert_eq!(result, "2022-08-01T12:00:00+02:00");
    }
}
False
========================================
use crate::{UtcOffset, error, format::{ParsedItems, self, PadDirection, Padding}, macros::internals::{self, try_consume_char, try_consume_char_case_insensitive, try_consume_exact_digits, try_consume_first_match, Padding::*}};
use std::num::NonZeroU8;

#[test]
fn test_parse() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56Z";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Ok(()));
    assert_eq!(items.year, Some(2021));
    assert_eq!(items.month, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.day, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.hour_24, Some(12));
    assert_eq!(items.minute, Some(34));
    assert_eq!(items.second, Some(56));
    assert_eq!(items.nanosecond, None);
    assert_eq!(items.offset, Some(UtcOffset::UTC));
}

#[test]
fn test_parse_with_nanoseconds() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56.123456789Z";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Ok(()));
    assert_eq!(items.year, Some(2021));
    assert_eq!(items.month, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.day, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.hour_24, Some(12));
    assert_eq!(items.minute, Some(34));
    assert_eq!(items.second, Some(56));
    assert_eq!(items.nanosecond, Some(123_456_789));
    assert_eq!(items.offset, Some(UtcOffset::UTC));
}

#[test]
fn test_parse_with_offset() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56+09:00";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Ok(()));
    assert_eq!(items.year, Some(2021));
    assert_eq!(items.month, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.day, Some(NonZeroU8::new(1).unwrap()));
    assert_eq!(items.hour_24, Some(12));
    assert_eq!(items.minute, Some(34));
    assert_eq!(items.second, Some(56));
    assert_eq!(items.nanosecond, None);
    assert_eq!(items.offset, Some(UtcOffset::minutes(9 * 60)));
}

#[test]
fn test_parse_invalid_year() {
    let mut items = ParsedItems::new();
    let mut s = "abcd-01-01T12:34:56Z";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Err(error::Parse::InvalidYear));
}

#[test]
fn test_parse_invalid_nanosecond() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56.abcdZ";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Err(error::Parse::InvalidNanosecond));
}

#[test]
fn test_parse_unexpected_character() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56PST";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(
        result,
        Err(error::Parse::UnexpectedCharacter {
            actual: 'P',
            expected: '+',
        })
    );
}

#[test]
fn test_parse_unexpected_end_of_string() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Err(error::Parse::UnexpectedEndOfString));
}

#[test]
fn test_parse_invalid_offset() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56+99:00";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Err(error::Parse::InvalidOffset));
}

#[test]
fn test_parse_invalid_offset_minute() {
    let mut items = ParsedItems::new();
    let mut s = "2021-01-01T12:34:56+09:99";
    let result = format::well_known::rfc3339::parse(&mut items, &mut s);
    assert_eq!(result, Err(error::Parse::InvalidOffset));
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;

    #[test]
    fn test_eq() {
        let instant1 = Instant { inner: StdInstant::now() };
        let instant2 = Instant { inner: StdInstant::now() };
        let instant3 = Instant { inner: StdInstant::now() };

        assert_eq!(instant1.eq(&instant2), instant1.inner.eq(&instant2.inner));
        assert_eq!(instant2.eq(&instant3), instant2.inner.eq(&instant3.inner));
        assert_eq!(instant3.eq(&instant1), instant3.inner.eq(&instant1.inner));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDurationShort;

    #[test]
    fn test_partial_cmp() {
        let instant1 = Instant::now();
        let instant2 = Instant::now() + NumericalStdDurationShort::seconds(1);
        let instant3 = Instant::now() + NumericalStdDurationShort::seconds(2);

        assert_eq!(instant1.partial_cmp(&instant2), Some(Ordering::Less));
        assert_eq!(instant2.partial_cmp(&instant1), Some(Ordering::Greater));
        assert_eq!(instant2.partial_cmp(&instant2), Some(Ordering::Equal));
        assert_eq!(instant2.partial_cmp(&instant3), Some(Ordering::Less));
    }
}
True
========================================
    use crate::prelude::*;
    use std::crate::{Instant as StdInstant, Duration as StdDuration};
    
    #[test]
    fn test_from() {
        let instant = StdInstant::now();
        let converted_instant: crate::Instant = instant.into();
        
        assert_eq!(instant, converted_instant.inner);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_add() {
        let instant = StdInstant::now();
        let duration = Duration::seconds(10);
        let result = instant.add(duration);
        assert_eq!(result, instant + duration);
    }
}
True
========================================
    use std::crate::Duration;
    use crate::Duration as TimeDuration;
    use crate::Instant;
    use std::ops::AddAssign;
    
    #[test]
    fn test_add_assign() {
        let mut instant = Instant::now();
        let duration = TimeDuration::seconds(5);
        instant += duration;
        assert_eq!(Instant::now() - instant, duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub() {
        let instant = std::crate::Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant - duration;

        let result = instant - duration;
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_sub() {
        let instant_1 = Instant::now();
        let instant_2 = Instant::now();
        let duration = instant_1 - instant_2;
        assert_eq!(duration, Duration::zero());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub_assign() {
        let mut instant = StdInstant::now();
        let duration = Duration::seconds(5);
        instant -= duration;

        assert_eq!(instant, StdInstant::now() - StdDuration::from_secs(5));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_checked_add() {
        let now = Instant::now();
        assert_eq!(
            now.checked_add(Duration::seconds(5)),
            Some(now + Duration::seconds(5)),
        );
        assert_eq!(
            now.checked_add(Duration::seconds(-5)),
            Some(now + Duration::seconds(-5)),
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::duration::Duration as StdDuration;

    #[test]
    fn test_checked_sub() {
        // Positive duration
        let now = Instant::now();
        let duration = Duration::seconds(5);
        assert_eq!(now.checked_sub(duration), Some(now - duration));

        // Negative duration
        let now = Instant::now();
        let duration = Duration::seconds(-5);
        assert_eq!(now.checked_sub(duration), Some(now - duration));

        // Overflow
        let now = Instant::now();
        let max_duration = Duration::max_value();
        assert_eq!(now.checked_sub(max_duration), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::prelude::*;
    #[cfg(feature = "std")]
    use std::thread;

    #[test]
    fn test_elapsed() {
        let instant = Instant::now();
        #[cfg(feature = "std")]
        thread::sleep(1.std_milliseconds());
        #[cfg(not(feature = "std"))]
        std::thread::sleep_1(1);
        assert!(instant.elapsed() >= 1.milliseconds());
    }
}
False
========================================
    use crate::{Instant, Duration};
    
    #[test]
    fn test_now() {
        let instant = Instant::now();
        assert!(instant.elapsed().as_nanos() >= Duration::zero().as_nanos());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDurationShort;
    use crate::Duration as StdDuration;

    #[test]
    fn test_to() {
        let instant = Instant::now();
        let later = instant + NumericalStdDurationShort::seconds(5);
        let duration = instant.to(later);
        let expected = later - instant;

        assert_eq!(duration, expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Weekday;

    #[test]
    fn test_from_iso_ywd_unchecked() {
        assert_eq!(
            crate::internals::Date::from_iso_ywd_unchecked(2019, 1, Weekday::Monday),
            crate::Date::try_from_iso_ywd(2019, 1, Weekday::Monday).unwrap()
        );
        assert_eq!(
            crate::internals::Date::from_iso_ywd_unchecked(2019, 1, Weekday::Tuesday),
            crate::Date::try_from_iso_ywd(2019, 1, Weekday::Tuesday).unwrap()
        );
        assert_eq!(
            crate::internals::Date::from_iso_ywd_unchecked(2020, 53, Weekday::Friday),
            crate::Date::try_from_iso_ywd(2020, 53, Weekday::Friday).unwrap()
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Date; // Add explicit import of `Date` to disambiguate

    #[test]
    fn test_from_ymd_unchecked() {
        let year = 2021;
        let month = 3;
        let day = 15;
        let date = Date::from_ymd_unchecked(year, month, day);
        assert_eq!(date.year(), year);
        assert_eq!(date.month(), month);
        assert_eq!(date.day(), day);
    }
}
False
========================================
    use crate::internals::Date;
    use crate::date::date;

    #[test]
    fn test_from_yo_unchecked() {
        assert_eq!(Date::from_yo_unchecked(2019, 1), date!(2019-001));
        assert_eq!(Date::from_yo_unchecked(2019, 365), date!(2019-365));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_from_hms_nanos_unchecked() {
        let time = crate::internals::Time::from_hms_nanos_unchecked(12, 34, 56, 789_012_345);
        assert_eq!(time.hour, 12);
        assert_eq!(time.minute, 34);
        assert_eq!(time.second, 56);
        assert_eq!(time.nanosecond, 789_012_345);
    }
    
    #[test]
    #[should_panic]
    fn test_invalid_hour() {
        crate::internals::Time::from_hms_nanos_unchecked(24, 0, 0, 0);
    }
    
    #[test]
    #[should_panic]
    fn test_invalid_minute() {
        crate::internals::Time::from_hms_nanos_unchecked(0, 60, 0, 0);
    }
    
    #[test]
    #[should_panic]
    fn test_invalid_second() {
        crate::internals::Time::from_hms_nanos_unchecked(0, 0, 60, 0);
    }
    
    #[test]
    #[should_panic]
    fn test_invalid_nanosecond() {
        crate::internals::Time::from_hms_nanos_unchecked(0, 0, 0, 1_000_000_000);
    }
}
False
========================================
    use crate::internals::jan_weekday;

    #[test]
    fn test_jan_weekday() {
        assert_eq!(jan_weekday(2022, 1), 6);
        assert_eq!(jan_weekday(2023, 1), 0);
        assert_eq!(jan_weekday(2024, 1), 1);
        assert_eq!(jan_weekday(2025, 1), 2);
        assert_eq!(jan_weekday(2026, 1), 3);
    }
}
True
offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq exceed
offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp exceed
offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from exceed
========================================
    use std::crate::{Duration, SystemTime};
    use crate::offset_date_crate::OffsetDateTime;
    use crate::PrimitiveDateTime;

    #[test]
    fn test_add_duration() {
        let sys_time = SystemTime::now();
        let duration = Duration::from_secs(3600);
        let result = sys_time + duration;
        // assert result is correct
    }

    #[test]
    fn test_add_assign_duration() {
        let mut sys_time = SystemTime::now();
        let duration = Duration::from_secs(3600);
        sys_time += duration;
        // assert sys_time is correct
    }

    #[test]
    fn test_into_offset_date_time() {
        let sys_time = SystemTime::now();
        let offset_date_time: OffsetDateTime = sys_time.into();
        // assert offset_date_time is correct
    }

    #[test]
    fn test_into_primitive_date_time() {
        let sys_time = SystemTime::now();
        let primitive_date_time: PrimitiveDateTime = sys_time.into();
        // assert primitive_date_time is correct
    }

    #[test]
    fn test_eq_offset_date_time() {
        let sys_time = SystemTime::now();
        let offset_date_time = OffsetDateTime::now();
        assert_eq!(sys_time, offset_date_time);
    }

    #[test]
    fn test_eq_primitive_date_time() {
        let sys_time = SystemTime::now();
        let primitive_date_time = PrimitiveDateTime::now();
        assert_eq!(sys_time, primitive_date_time);
    }

    #[test]
    fn test_partial_cmp_offset_date_time() {
        let sys_time = SystemTime::now();
        let offset_date_time = OffsetDateTime::now();
        assert!(sys_time.partial_cmp(&offset_date_time).is_some());
    }

    #[test]
    fn test_partial_cmp_primitive_date_time() {
        let sys_time = SystemTime::now();
        let primitive_date_time = PrimitiveDateTime::now();
        assert!(sys_time.partial_cmp(&primitive_date_time).is_some());
    }

    #[test]
    fn test_sub_duration() {
        let sys_time = SystemTime::now();
        let duration = Duration::from_secs(3600);
        let result = sys_time - duration;
        // assert result is correct
    }

    #[test]
    fn test_sub_offset_date_time() {
        let sys_time = SystemTime::now();
        let offset_date_time = OffsetDateTime::now();
        let result = sys_time - offset_date_time;
        // assert result is correct
    }

    #[test]
    fn test_sub_primitive_date_time() {
        let sys_time = SystemTime::now();
        let primitive_date_time = PrimitiveDateTime::now();
        let result = sys_time - primitive_date_time;
        // assert result is correct
    }

    #[test]
    fn test_sub_assign_duration() {
        let mut sys_time = SystemTime::now();
        let duration = Duration::from_secs(3600);
        sys_time -= duration;
        // assert sys_time is correct
    }
}
False
========================================
    use std::cmp::Ordering;
    use std::convert::TryFrom;
    use std::crate::{Duration as StdDuration, SystemTime};

    use crate::error::ConversionRange;
    use crate::{Duration, OffsetDateTime, PrimitiveDateTime};
    use crate::ext::{NumericalDuration, NumericalStdDuration};
    use crate::macros::date;

    const UNIX_EPOCH: SystemTime = SystemTime::UNIX_EPOCH;

    #[test]
    fn test_duration_add_assign_duration() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 1.hours();
        dt.add_assign(24.hours());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-02)).unwrap());
    }

    #[test]
    fn test_duration_add_assign_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        dt += 1.hours();
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 1.hours());
    }

    #[test]
    fn test_duration_add_assign_std_duration() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 1.hours();
        dt.add_assign(1.hours().std());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-02)).unwrap());
    }

    #[test]
    fn test_duration_add_assign_std_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        dt += 1.hours().std();
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 1.hours());
    }

    #[test]
    fn test_duration_sub_assign_duration() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap() - 1.hours();
        dt.sub_assign(24.hours());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-01)).unwrap());
    }

    #[test]
    fn test_duration_sub_assign_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        dt -= 1.hours();
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-02)).unwrap() - 1.hours());
    }

    #[test]
    fn test_duration_sub_assign_std_duration() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap() - 1.hours();
        dt.sub_assign(1.hours().std());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-01)).unwrap());
    }

    #[test]
    fn test_duration_sub_assign_std_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        dt -= 1.hours().std();
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-02)).unwrap() - 1.hours());
    }

    #[test]
    fn test_duration_checked_add_duration() {
        assert_eq!(
            5.hours().checked_add(5.hours()),
            Some(10.hours())
        );
        assert_eq!(
            Duration::max_value().checked_add(1.nanoseconds()),
            None
        );
        assert_eq!(
            (-5).hours().checked_add(5.hours()),
            Some(0.hours())
        );
    }

    #[test]
    fn test_duration_checked_add_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        assert_eq!(dt.checked_add(24.hours()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours()));
    }

    #[test]
    fn test_duration_checked_add_duration_assign_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        assert_eq!(dt.checked_add_assign(24.hours()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours()));
    }

    #[test]
    fn test_duration_checked_add_std_duration() {
        assert_eq!(
            5.hours().checked_add(2.hours().std()),
            Some(7.hours())
        );
        assert_eq!(
            5.hours().checked_add((-2).hours().std()),
            Some(3.hours())
        );
        assert_eq!(
            5.hours().checked_add(0.seconds().std()),
            Some(5.hours())
        );
        assert_eq!(
            Duration::max_value().checked_add(2.hours().std()),
            None
        );
        assert_eq!(
            Duration::min_value().checked_add(2.hours().std()),
            None
        );
        assert_eq!(
            Duration::max_value().checked_add(1.hours().std()),
            Some(Duration::max_value())
        );
        assert_eq!(
            Duration::min_value().checked_add((-1).hours().std()),
            Some(Duration::min_value())
        );
    }

    #[test]
    fn test_duration_checked_add_std_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        assert_eq!(dt.checked_add(24.hours().std()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours()));
    }

    #[test]
    fn test_duration_checked_add_std_duration_assign_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap();
        assert_eq!(dt.checked_add_assign(24.hours().std()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours()));
    }

    #[test]
    fn test_duration_checked_sub_duration() {
        assert_eq!(
            5.hours().checked_sub(5.hours()),
            Some(0.hours())
        );
        assert_eq!(
            Duration::min_value().checked_sub(1.nanoseconds()),
            None
        );
        assert_eq!(
            5.hours().checked_sub(10.hours()),
            Some((-5).hours())
        );
    }

    #[test]
    fn test_duration_checked_sub_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        assert_eq!(dt.checked_sub(24.hours()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap()));
    }

    #[test]
    fn test_duration_checked_sub_duration_assign_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        assert_eq!(dt.checked_sub_assign(24.hours()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap()));
    }

    #[test]
    fn test_duration_checked_sub_std_duration() {
        assert_eq!(
            5.hours().checked_sub((-5).hours().std()),
            Some(10.hours())
        );
        assert_eq!(
            5.hours().checked_sub(5.hours().std()),
            Some(0.hours())
        );
        assert_eq!(
            5.hours().checked_sub(0.seconds().std()),
            Some(5.hours())
        );
        assert_eq!(
            Duration::min_value().checked_sub(1.hours().std()),
            None
        );
        assert_eq!(
            Duration::min_value().checked_sub(2.hours().std()),
            None
        );
        assert_eq!(
            Duration::min_value().checked_sub(1.hours().std()),
            Some(Duration::min_value())
        );
        assert_eq!(
            Duration::max_value().checked_sub(1.hours().std()),
            Some(Duration::max_value())
        );
    }

    #[test]
    fn test_duration_checked_sub_std_duration_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        assert_eq!(dt.checked_sub(24.hours().std()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap()));
    }

    #[test]
    fn test_duration_checked_sub_std_duration_assign_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-02)).unwrap();
        assert_eq!(dt.checked_sub_assign(24.hours().std()), Some(OffsetDateTime::try_from(date!(2000-01-01)).unwrap()));
    }

    #[test]
    fn test_duration_checked_mul() {
        assert_eq!(
            5.seconds().checked_mul(2),
            Some(10.seconds())
        );
        assert_eq!(
            5.seconds().checked_mul(-2),
            Some((-10).seconds())
        );
        assert_eq!(
            5.seconds().checked_mul(0),
            Some(0.seconds())
        );
        assert_eq!(
            Duration::max_value().checked_mul(2),
            None
        );
        assert_eq!(
            Duration::min_value().checked_mul(2),
            None
        );
    }

    #[test]
    fn test_duration_checked_mul_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 1.hours();
        dt.checked_mul_assign(24.hours().std());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours());
    }

    #[test]
    fn test_duration_checked_div() {
        assert_eq!(
            10.seconds().checked_div(2),
            Some(5.seconds())
        );
        assert_eq!(
            10.seconds().checked_div(-2),
            Some((-5).seconds())
        );
        assert_eq!(
            1.seconds().checked_div(0),
            None
        );
    }

    #[test]
    fn test_duration_checked_div_assign() {
        let mut dt = OffsetDateTime::try_from(date!(2000-01-01)).unwrap() + 24.hours();
        dt.checked_div_assign(2.hours().std());
        assert_eq!(dt, OffsetDateTime::try_from(date!(2000-01-02)).unwrap());
    }

    #[test]
    fn test_duration_is_zero() {
        assert!(Duration::seconds(0).is_zero());
        assert!(!Duration::seconds(1).is_zero());
        assert!(!Duration::seconds(-1).is_zero());
    }

    #[test]
    fn test_duration_is_negative() {
        assert!(Duration::seconds(-1).is_negative());
        assert!(!Duration::seconds(0).is_negative());
        assert!(!Duration::seconds(1).is_negative());
    }

    #[test]
    fn test_duration_is_positive() {
        assert!(Duration::seconds(1).is_positive());
        assert!(!Duration::seconds(0).is_positive());
        assert!(!Duration::seconds(-1).is_positive());
    }

    #[test]
    fn test_duration_abs() {
        assert_eq!(Duration::seconds(1).abs(), Duration::seconds(1));
        assert_eq!(Duration::seconds(0).abs(), Duration::seconds(0));
        assert_eq!(Duration::seconds(-1).abs(), Duration::seconds(1));
    }

    #[test]
    fn test_duration_cmp() {
        assert_eq!(Duration::seconds(1).cmp(&Duration::seconds(1)), Ordering::Equal);
        assert_eq!(Duration::seconds(1).cmp(&Duration::seconds(2)), Ordering::Less);
        assert_eq!(Duration::seconds(2).cmp(&Duration::seconds(1)), Ordering::Greater);
    }

    #[test]
    fn test_duration_as_seconds_f64() {
        assert_eq!(Duration::seconds(1).as_seconds_f64(), 1.);
        assert_eq!(Duration::seconds(1).neg().as_seconds_f64(), -1.);
    }

    #[test]
    fn test_duration_as_seconds_f32() {
        assert_eq!(Duration::seconds(1).as_seconds_f32(), 1.);
        assert_eq!(Duration::seconds(1).neg().as_seconds_f32(), -1.);
    }

    #[test]
    fn test_duration_as_milliseconds() {
        assert_eq!(Duration::seconds(1).as_milliseconds(), 1_000);
        assert_eq!(Duration::seconds(1).neg().as_milliseconds(), -1_000);
        assert_eq!(Duration::milliseconds(1).as_milliseconds(), 1);
        assert_eq!(Duration::milliseconds(-1).as_milliseconds(), -1);
    }

    #[test]
    fn test_duration_subsec_milliseconds() {
        assert_eq!(Duration::seconds(1).subsec_milliseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_milliseconds(), 0);
        assert_eq!(Duration::seconds(1).subsec_milliseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_milliseconds(), 0);
    }

    #[test]
    fn test_duration_as_microseconds() {
        assert_eq!(Duration::seconds(1).as_microseconds(), 1_000_000);
        assert_eq!(Duration::seconds(1).neg().as_microseconds(), -1_000_000);
        assert_eq!(Duration::microseconds(1).as_microseconds(), 1);
        assert_eq!(Duration::microseconds(-1).as_microseconds(), -1);
    }

    #[test]
    fn test_duration_subsec_microseconds() {
        assert_eq!(Duration::seconds(1).subsec_microseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_microseconds(), 0);
        assert_eq!(Duration::seconds(1).subsec_microseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_microseconds(), 0);
    }

    #[test]
    fn test_duration_as_nanoseconds() {
        assert_eq!(Duration::seconds(1).as_nanoseconds(), 1_000_000_000);
        assert_eq!(Duration::seconds(1).neg().as_nanoseconds(), -1_000_000_000);
        assert_eq!(Duration::nanoseconds(1).as_nanoseconds(), 1);
        assert_eq!(Duration::nanoseconds(-1).as_nanoseconds(), -1);
    }

    #[test]
    fn test_duration_subsec_nanoseconds() {
        assert_eq!(Duration::seconds(1).subsec_nanoseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_nanoseconds(), 0);
        assert_eq!(Duration::seconds(1).subsec_nanoseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_nanoseconds(), 0);
    }

    #[test]
    fn test_duration_try_from_std_duration() {
        assert_eq!(Duration::try_from(StdDuration::new(1, 0)), Ok(Duration::seconds(1)));
    }

    #[test]
    fn test_duration_try_from_std_duration_err() {
        assert_eq!(Duration::try_from(StdDuration::new(2_000_000_000, 0)), Err(ConversionRange));
    }

    #[test]
    fn test_duration_to_std_duration() {
        assert_eq!(Duration::seconds(1).to_std(), Ok(StdDuration::new(1, 0)));
    }

    #[test]
    fn test_duration_to_std_duration_err() {
        assert_eq!(Duration::seconds(2_000_000_000).to_std(), Err(ConversionRange));
    }

    #[test]
    fn test_system_time_add_duration() {
        assert_eq!(
            UNIX_EPOCH + 1.seconds(),
            UNIX_EPOCH + 1.seconds()
        );
        assert_eq!(
            UNIX_EPOCH + 1.seconds(),
            UNIX_EPOCH + 1.seconds().std().unwrap()
        );
        assert_eq!(
            UNIX_EPOCH + 1.seconds(),
            UNIX_EPOCH + 1.seconds()
        );
    }

    #[test]
    fn test_system_time_add_assign_duration() {
        let mut sys_time = UNIX_EPOCH;
        sys_time += 1.seconds().std().unwrap();
        assert_eq!(sys_time, UNIX_EPOCH + 1.seconds().std().unwrap());
    }

    #[test]
    fn test_system_time_try_from_offset_date_time() {
        let dt = OffsetDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()), UNIX_EPOCH);
    }

    #[test]
    fn test_system_time_try_from_primitive_date_time() {
        let dt = PrimitiveDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()), UNIX_EPOCH);
    }

    #[test]
    fn test_system_time_eq_offset_date_time() {
        let dt = OffsetDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()), UNIX_EPOCH);
    }

    #[test]
    fn test_system_time_eq_primitive_date_time() {
        let dt = PrimitiveDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()), UNIX_EPOCH);
    }

    #[test]
    fn test_system_time_partial_cmp_offset_date_time() {
        let dt = OffsetDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap())), Some(Ordering::Equal));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap()).add(1.seconds())), Some(Ordering::Less));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap()).sub(1.seconds())), Some(Ordering::Greater));
    }

    #[test]
    fn test_system_time_partial_cmp_primitive_date_time() {
        let dt = PrimitiveDateTime::try_from(date!(2000-01-01));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap())), Some(Ordering::Equal));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap()).add(1.seconds())), Some(Ordering::Less));
        assert_eq!(SystemTime::from(dt.unwrap()).partial_cmp(&SystemTime::from(dt.unwrap()).sub(1.seconds())), Some(Ordering::Greater));
    }

    #[test]
    fn test_system_time_sub_duration() {
        assert_eq!(
            SystemTime::from(UNIX_EPOCH) - 5.seconds(),
            UNIX_EPOCH - 5.seconds()
        );
    }

    #[test]
    fn test_system_time_sub_offset_date_time() {
        let dt = OffsetDateTime::try_from(date!(2000-01-01));
        assert_eq!(
            SystemTime::from(dt.unwrap()).sub(dt.unwrap()),
            (UNIX_EPOCH - dt.unwrap()).std().unwrap()
        );
    }

    #[test]
    fn test_system_time_sub_primitive_date_time() {
        let dt = PrimitiveDateTime::try_from(date!(2000-01-01));
        assert_eq!(
            SystemTime::from(dt.unwrap()).sub(dt.unwrap()),
            (UNIX_EPOCH - dt.unwrap()).std().unwrap()
        );
    }

    #[test]
    fn test_system_time_sub_assign_duration() {
        let mut sys_time = UNIX_EPOCH;
        sys_time -= 5.seconds();
        assert_eq!(sys_time, UNIX_EPOCH - 5.seconds());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::SystemTime;

    use crate::Duration;

    #[test]
    fn test_sub() {
        let offset_date_time = OffsetDateTime::now();
        let duration = Duration::seconds(5);
        let output = offset_date_time.sub(duration);
        let expected: OffsetDateTime = (OffsetDateTime::from(offset_date_time) - duration).into();
        assert_eq!(output, expected);
    }
}
False
offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub exceed
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration as StdDuration, SystemTime};

    #[test]
    fn test_sub_assign() {
        let mut system_time = SystemTime::UNIX_EPOCH;

        system_time.sub_assign(Duration::seconds(5));

        assert_eq!(
            system_time,
            SystemTime::UNIX_EPOCH + Duration::seconds(-5)
        );
    }
}
False
offset_date_time::OffsetDateTime::date exceed
offset_date_time::OffsetDateTime::day exceed
offset_date_time::OffsetDateTime::format exceed
offset_date_time::OffsetDateTime::from_unix_timestamp exceed
offset_date_time::OffsetDateTime::from_unix_timestamp_nanos exceed
offset_date_time::OffsetDateTime::hour exceed
offset_date_time::OffsetDateTime::iso_year_week exceed
offset_date_time::OffsetDateTime::lazy_format exceed
offset_date_time::OffsetDateTime::microsecond exceed
offset_date_time::OffsetDateTime::millisecond exceed
offset_date_time::OffsetDateTime::minute exceed
offset_date_time::OffsetDateTime::month exceed
offset_date_time::OffsetDateTime::month_day exceed
offset_date_time::OffsetDateTime::nanosecond exceed
offset_date_time::OffsetDateTime::new_assuming_offset exceed
offset_date_time::OffsetDateTime::new_assuming_utc exceed
offset_date_time::OffsetDateTime::now exceed
offset_date_time::OffsetDateTime::now_local exceed
offset_date_time::OffsetDateTime::now_utc exceed
offset_date_time::OffsetDateTime::offset exceed
offset_date_time::OffsetDateTime::ordinal exceed
========================================
    use super::*;

use crate::*;
    use crate::date;
    use crate::OffsetDateTime;
    use crate::time;

    #[test]
    fn test_parse() {
        assert_eq!(
            OffsetDateTime::parse("2019-01-02 00:00:00 +0000", "%F %T %z"),
            Ok(date!(2019-01-02).midnight().assume_utc()),
        );
        assert_eq!(
            OffsetDateTime::parse("2019-002 23:59:59 +0000", "%Y-%j %T %z"),
            Ok(date!(2019-002).with_time(time!(23:59:59)).assume_utc()),
        );
        assert_eq!(
            OffsetDateTime::parse("2019-W01-3 12:00:00 pm +0000", "%G-W%V-%u %r %z"),
            Ok(date!(2019-W01-3).with_time(time!(12:00)).assume_utc()),
        );
    }
}
False
offset_date_time::OffsetDateTime::second exceed
offset_date_time::OffsetDateTime::time exceed
offset_date_time::OffsetDateTime::timestamp exceed
offset_date_time::OffsetDateTime::timestamp_nanos exceed
offset_date_time::OffsetDateTime::to_offset exceed
========================================
    use super::*;

use crate::*;
    use crate::format::parse::ParsedItems;
    use crate::primitive::Time as PrimitiveDateTime;
    use crate::error::ParseResult;

    #[test]
    fn test_try_from_parsed_items() {
        let items = ParsedItems::new();
        let result = OffsetDateTime::try_from_parsed_items(items);
        assert!(result.is_err());
    }
}
False
========================================
    use crate::crate::offset_date_crate::OffsetDateTime;
    use crate::crate::UtcOffset;
    use crate::crate::error::IndeterminateOffset;
    
    #[test]
    fn test_try_now_local() {
        let result = OffsetDateTime::try_now_local();
        assert!(result.is_ok());
    }
}
False
offset_date_time::OffsetDateTime::unix_epoch exceed
offset_date_time::OffsetDateTime::unix_timestamp exceed
offset_date_time::OffsetDateTime::unix_timestamp_nanos exceed
offset_date_time::OffsetDateTime::week exceed
offset_date_time::OffsetDateTime::weekday exceed
offset_date_time::OffsetDateTime::year exceed
========================================
    use super::*;

use crate::*;
    use crate::offset_date_crate::OffsetDateTime;
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::time_mod::Time;
    use crate::utc_offset::UtcOffset;
    use crate::offset::Utc;
    use std::convert::TryFrom;
    use crate::date::*;

    const TEST_FORMAT: &str = "%Y-%m-%d";

    #[test]
    fn test_parse_date() {
        let date_str = "2021-01-01";
        let date = Date::parse(date_str, TEST_FORMAT).unwrap();
        let expected_date = Date::from_ymd(2021, 1, 1);

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_date_invalid() {
        let date_str = "2021-01";
        let _date = Date::parse(date_str, TEST_FORMAT).unwrap();
    }
    
    #[test]
    fn test_parse_calendar_date() {
        let date_str = "2021-01-01";
        let date = CalendarDate::parse(date_str, TEST_FORMAT).unwrap();
        let expected_date = CalendarDate::from_ymd(2021, 1, 1);

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_calendar_date_invalid() {
        let date_str = "2021-01";
        let _date = CalendarDate::parse(date_str, TEST_FORMAT).unwrap();
    }
    
    #[test]
    fn test_parse_offset_date_time() {
        let date_str = "2021-01-01T10:00:00+00:00";
        let date = OffsetDateTime::parse(date_str, "%Y-%m-%dT%T%z").unwrap();
        let expected_date = OffsetDateTime::try_from("2021-01-01T10:00:00+00:00").unwrap();

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_offset_date_time_invalid() {
        let date_str = "2021-01-01T10:00:00";
        let _date = OffsetDateTime::parse(date_str, "%Y-%m-%dT%T%z").unwrap();
    }
    
    #[test]
    fn test_parse_primitive_date_time() {
        let date_str = "2021-01-01T10:00:00";
        let date = PrimitiveDateTime::parse(date_str, "%Y-%m-%dT%T").unwrap();
        let expected_date = PrimitiveDateTime::try_from("2021-01-01T10:00:00").unwrap();

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_primitive_date_time_invalid() {
        let date_str = "2021-01-01T10:00";
        let _date = PrimitiveDateTime::parse(date_str, "%Y-%m-%dT%T").unwrap();
    }
    
    #[test]
    fn test_parse_time() {
        let date_str = "10:00:00";
        let date = Time::parse(date_str, "%T").unwrap();
        let expected_date = Time::try_from("10:00:00").unwrap();

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_time_invalid() {
        let date_str = "10:00";
        let _date = Time::parse(date_str, "%T").unwrap();
    }
    
    #[test]
    fn test_parse_utc_offset() {
        let date_str = "+00:00";
        let date = UtcOffset::parse(date_str, "%z").unwrap();
        let expected_date = UtcOffset::hours(0);

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_utc_offset_invalid() {
        let date_str = "+";
        let _date = UtcOffset::parse(date_str, "%z").unwrap();
    }
    
    #[test]
    fn test_parse_utc_offset_date_time() {
        let date_str = "2022-07-08T10:00:00+00:00";
        let date = Utc::parse(date_str, "%Y-%m-%dT%T%z").unwrap();
        let expected_date = UtcOffset::hours(0).and_hms(10, 0, 0);

        assert_eq!(date, expected_date);
    }
    
    #[test]
    #[should_panic]
    fn test_parse_utc_offset_date_time_invalid() {
        let date_str = "2022-07-08T10:00:00";
        let _date = Utc::parse(date_str, "%Y-%m-%dT%T%z").unwrap();
    }
    
    #[test]
    fn test_parse_utc_offset_date_time_offset() {
        let date_str = "2022-07-08T10:00:00+02:00";
        let date = Utc::parse(date_str, "%Y-%m-%dT%T%z").unwrap();
        let expected_date = UtcOffset::hours(2
False
========================================
    use super::*;

use crate::*;
    use std::crate::SystemTime;

    #[test]
    fn test_precise_time_ns() {
        let start_time = SystemTime::UNIX_EPOCH;
        let current_time = SystemTime::now();
        let expected = current_time
            .duration_since(start_time)
            .expect("System clock was before 1970.")
            .as_nanos();

        let actual = precise_time_ns();

        assert_eq!(actual, expected);
    }
}
False
========================================
    use crate::precise_time_s;

    #[test]
    fn test_precise_time_s() {
        let now = precise_time_s();
        assert!(now >= 0.0, "Returned time should be greater than or equal to 0.0");
    }
}
True
primitive_date_time::<impl std::cmp::PartialEq<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::eq exceed
primitive_date_time::<impl std::cmp::PartialOrd<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::partial_cmp exceed
primitive_date_time::<impl std::convert::From<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::from exceed
primitive_date_time::<impl std::ops::Sub<primitive_date_time::PrimitiveDateTime> for std::time::SystemTime>::sub exceed
primitive_date_time::PrimitiveDateTime::assume_offset exceed
primitive_date_time::PrimitiveDateTime::assume_utc exceed
primitive_date_time::PrimitiveDateTime::date exceed
primitive_date_time::PrimitiveDateTime::day exceed
primitive_date_time::PrimitiveDateTime::format exceed
primitive_date_time::PrimitiveDateTime::from_unix_timestamp exceed
primitive_date_time::PrimitiveDateTime::hour exceed
primitive_date_time::PrimitiveDateTime::iso_year_week exceed
primitive_date_time::PrimitiveDateTime::lazy_format exceed
primitive_date_time::PrimitiveDateTime::microsecond exceed
primitive_date_time::PrimitiveDateTime::millisecond exceed
primitive_date_time::PrimitiveDateTime::minute exceed
primitive_date_time::PrimitiveDateTime::monday_based_week exceed
primitive_date_time::PrimitiveDateTime::month exceed
primitive_date_time::PrimitiveDateTime::month_day exceed
primitive_date_time::PrimitiveDateTime::nanosecond exceed
primitive_date_time::PrimitiveDateTime::new exceed
primitive_date_time::PrimitiveDateTime::now exceed
primitive_date_time::PrimitiveDateTime::ordinal exceed
========================================
    use super::*;

use crate::*;
    use crate::date;
    use crate::internals::Time;
    use crate::time;
    
    #[test]
    fn test_parse() {
        assert_eq!(
            PrimitiveDateTime::parse("2019-01-02 00:00:00", "%F %T"),
            Ok(date!(2019-01-02).midnight()),
        );
        
        assert_eq!(
            PrimitiveDateTime::parse("2019-002 23:59:59", "%Y-%j %T"),
            Ok(date!(2019-002).with_time(time!(23:59:59))),
        );
        
        assert_eq!(
            PrimitiveDateTime::parse("2019-W01-3 12:00:00 pm", "%G-W%V-%u %r"),
            Ok(date!(2019-W01-3).with_time(time!(12:00))),
        );
    }
}
False
primitive_date_time::PrimitiveDateTime::second exceed
primitive_date_time::PrimitiveDateTime::sunday_based_week exceed
primitive_date_time::PrimitiveDateTime::time exceed
primitive_date_time::PrimitiveDateTime::timestamp exceed
========================================
    use super::*;

use crate::*;
    use chrono::Weekday;
    use format::parse::ParsedItems;
    use std::convert::TryFrom;
    use std::num::NonZeroU16;
    use std::num::NonZeroU8;

    #[test]
    fn test_try_from_parsed_items() {
        let items = ParsedItems {
            week_based_year: Some(2022),
            year: Some(2022),
            month: Some(NonZeroU8::new(1).unwrap()),
            day: Some(NonZeroU8::new(1).unwrap()),
            weekday: Some(Weekday::Friday),
            ordinal_day: Some(NonZeroU16::new(1).unwrap()),
            iso_week: Some(NonZeroU8::new(1).unwrap()),
            sunday_week: Some(1),
            monday_week: Some(1),
            hour_12: Some(NonZeroU8::new(12).unwrap()),
            hour_24: Some(12),
            minute: Some(0),
            second: Some(0),
            nanosecond: Some(0),
            offset: Some(UtcOffset::hours(0)),
            am_pm: Some(AmPm::AM),
        };

        let result = PrimitiveDateTime::try_from_parsed_items(items);

        let expected_date = Date::try_from_parsed_items(items.clone()).unwrap();
        let expected_time = Time::try_from_parsed_items(items.clone()).unwrap();
        let expected = PrimitiveDateTime {
            date: expected_date,
            time: expected_time,
        };

        assert_eq!(result, Ok(expected));
    }
}
False
primitive_date_time::PrimitiveDateTime::unix_epoch exceed
primitive_date_time::PrimitiveDateTime::using_offset exceed
primitive_date_time::PrimitiveDateTime::week exceed
primitive_date_time::PrimitiveDateTime::weekday exceed
primitive_date_time::PrimitiveDateTime::year exceed
========================================
    use sign::Sign;
    use std::ops::Div;

    #[test]
    fn test_div() {
        let positive = Sign::Positive;
        let negative = Sign::Negative;
        let zero = Sign::Zero;

        let result1 = positive.div(negative);
        assert_eq!(result1, Sign::Negative);

        let result2 = negative.div(positive);
        assert_eq!(result2, Sign::Negative);

        let result3 = positive.div(positive);
        assert_eq!(result3, Sign::Positive);

        let result4 = negative.div(negative);
        assert_eq!(result4, Sign::Positive);

        let result5 = positive.div(zero);
        assert_eq!(result5, Sign::Zero);

        let result6 = negative.div(zero);
        assert_eq!(result6, Sign::Zero);

        let result7 = zero.div(positive);
        assert_eq!(result7, Sign::Zero);

        let result8 = zero.div(negative);
        assert_eq!(result8, Sign::Zero);

        let result9 = zero.div(zero);
        assert_eq!(result9, Sign::Zero);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_div() {
        let sign_positive = Sign::Positive;
        let sign_negative = Sign::Negative;
        let sign_zero = Sign::Zero;
        let value = 10.0;
        
        let result_positive = value.div(sign_positive);
        let result_negative = value.div(sign_negative);
        let result_zero = value.div(sign_zero);
        
        assert_eq!(result_positive, value);
        assert_eq!(result_negative, -value);
        assert_eq!(result_zero, 0.0);
    }
}
True
========================================
    use sign::Sign;
    use std::ops::Div;

    #[test]
    fn test_div_positive() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Positive;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_div_negative() {
        let sign1 = Sign::Negative;
        let sign2 = Sign::Negative;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_div_positive_negative() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Negative;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_div_negative_positive() {
        let sign1 = Sign::Negative;
        let sign2 = Sign::Positive;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_div_zero() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Zero;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_div_zero_zero() {
        let sign1 = Sign::Zero;
        let sign2 = Sign::Zero;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Zero);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_div() {
        let a = Sign::Positive;
        let b = Sign::Negative;
        assert_eq!(a.div(b), Sign::Negative);

        let c = Sign::Negative;
        let d = Sign::Positive;
        assert_eq!(c.div(d), Sign::Negative);

        let e = Sign::Positive;
        let f = Sign::Zero;
        assert_eq!(e.div(f), Sign::Zero);

        let g = Sign::Zero;
        let h = Sign::Negative;
        assert_eq!(g.div(h), Sign::Zero);

        let i = Sign::Zero;
        let j = Sign::Positive;
        assert_eq!(i.div(j), Sign::Zero);

        let k = Sign::Positive;
        let l = Sign::Positive;
        assert_eq!(k.div(l), Sign::Positive);

        let m = Sign::Negative;
        let n = Sign::Negative;
        assert_eq!(m.div(n), Sign::Positive);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Div;
    
    #[test]
    fn test_div() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Negative;
        let result = sign1.div(sign2);
        assert_eq!(result, Sign::Negative);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Div;

    #[test]
    fn test_div_positive_positive() {
        let result = Sign::Positive.div(Sign::Positive);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_div_positive_negative() {
        let result = Sign::Positive.div(Sign::Negative);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_div_positive_zero() {
        let result = Sign::Positive.div(Sign::Zero);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_div_negative_positive() {
        let result = Sign::Negative.div(Sign::Positive);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_div_negative_negative() {
        let result = Sign::Negative.div(Sign::Negative);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_div_negative_zero() {
        let result = Sign::Negative.div(Sign::Zero);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_div_zero_positive() {
        let result = Sign::Zero.div(Sign::Positive);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_div_zero_negative() {
        let result = Sign::Zero.div(Sign::Negative);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_div_zero_zero() {
        let result = Sign::Zero.div(Sign::Zero);
        assert_eq!(result, Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Div;

    #[test]
    fn test_div() {
        let sign1 = Sign::Positive; // or any valid sign
        let sign2 = Sign::Negative; // or any valid sign
        let result = sign1.div(sign2);
        // assert any necessary conditions here
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);
        
        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);
        
        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);
        
        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);
        
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::DivAssign;

    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_div_assign_positive_positive() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);
    }
    
    #[test]
    fn test_div_assign_positive_negative() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);
    }
    
    #[test]
    fn test_div_assign_positive_zero() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
    
    #[test]
    fn test_div_assign_negative_positive() {
        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);
    }
    
    #[test]
    fn test_div_assign_negative_negative() {
        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);
    }
    
    #[test]
    fn test_div_assign_negative_zero() {
        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
    
    #[test]
    fn test_div_assign_zero_positive() {
        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);
    }
    
    #[test]
    fn test_div_assign_zero_negative() {
        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
    }
    
    #[test]
    fn test_div_assign_zero_zero() {
        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Sign;

    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);
    }
}
True
========================================
    use crate::sign::{Sign, DivAssign};

    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use sign::Sign;

    #[test]
    fn test_div_assign_positive_positive() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);
    }

    #[test]
    fn test_div_assign_positive_negative() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);
    }

    #[test]
    fn test_div_assign_positive_zero() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
    
    // ...add more tests for other scenarios...
}
True
========================================
    use super::*;

use crate::*;
    use crate::Sign;

    #[test]
    fn test_div_assign() {
        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Positive;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.div_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul_positive_positive() {
        let result = Sign::Positive * Sign::Positive;
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_mul_positive_negative() {
        let result = Sign::Positive * Sign::Negative;
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_mul_positive_zero() {
        let result = Sign::Positive * Sign::Zero;
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_negative_positive() {
        let result = Sign::Negative * Sign::Positive;
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_mul_negative_negative() {
        let result = Sign::Negative * Sign::Negative;
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_mul_negative_zero() {
        let result = Sign::Negative * Sign::Zero;
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_positive() {
        let result = Sign::Zero * Sign::Positive;
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_negative() {
        let result = Sign::Zero * Sign::Negative;
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_zero() {
        let result = Sign::Zero * Sign::Zero;
        assert_eq!(result, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::sign::Sign;

    #[test]
    fn test_mul() {
        assert_eq!(Sign::Positive.mul(Sign::Positive), Sign::Positive);
        assert_eq!(Sign::Positive.mul(Sign::Negative), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Positive), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Negative), Sign::Positive);
        assert_eq!(Sign::Zero.mul(Sign::Positive), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Negative), Sign::Zero);
        assert_eq!(Sign::Positive.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Negative.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Zero), Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::Mul;

    #[test]
    fn test_mul() {
        let sign = Sign::Positive;
        let rhs = Sign::Negative;

        let result = sign.mul(rhs);
        assert_eq!(result, Sign::Negative);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::sign::Sign;
    
    #[test]
    fn test_mul() {
        assert_eq!(Sign::Positive.mul(Sign::Positive), Sign::Positive);
        assert_eq!(Sign::Positive.mul(Sign::Negative), Sign::Negative);
        assert_eq!(Sign::Positive.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Negative.mul(Sign::Positive), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Negative), Sign::Positive);
        assert_eq!(Sign::Negative.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Positive), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Negative), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Zero), Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul() {
        assert_eq!(Sign::Positive.mul(Sign::Positive), Sign::Positive);
        assert_eq!(Sign::Positive.mul(Sign::Negative), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Positive), Sign::Negative);
        assert_eq!(Sign::Negative.mul(Sign::Negative), Sign::Positive);
        assert_eq!(Sign::Positive.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Positive), Sign::Zero);
        assert_eq!(Sign::Negative.mul(Sign::Zero), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Negative), Sign::Zero);
        assert_eq!(Sign::Zero.mul(Sign::Zero), Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::sign::Sign;

    #[test]
    fn test_mul_positive_positive() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Positive;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_mul_positive_negative() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Negative;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_mul_negative_positive() {
        let sign1 = Sign::Negative;
        let sign2 = Sign::Positive;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Negative);
    }

    #[test]
    fn test_mul_negative_negative() {
        let sign1 = Sign::Negative;
        let sign2 = Sign::Negative;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Positive);
    }

    #[test]
    fn test_mul_positive_zero() {
        let sign1 = Sign::Positive;
        let sign2 = Sign::Zero;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_negative_zero() {
        let sign1 = Sign::Negative;
        let sign2 = Sign::Zero;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_positive() {
        let sign1 = Sign::Zero;
        let sign2 = Sign::Positive;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_negative() {
        let sign1 = Sign::Zero;
        let sign2 = Sign::Negative;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Zero);
    }

    #[test]
    fn test_mul_zero_zero() {
        let sign1 = Sign::Zero;
        let sign2 = Sign::Zero;
        let result = sign1.mul(sign2);
        assert_eq!(result, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul_positive_positive() {
        let x = Sign::Positive;
        let y = Sign::Positive;
        let expected = Sign::Positive;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_positive_negative() {
        let x = Sign::Positive;
        let y = Sign::Negative;
        let expected = Sign::Negative;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_positive_zero() {
        let x = Sign::Positive;
        let y = Sign::Zero;
        let expected = Sign::Zero;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_negative_positive() {
        let x = Sign::Negative;
        let y = Sign::Positive;
        let expected = Sign::Negative;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_negative_negative() {
        let x = Sign::Negative;
        let y = Sign::Negative;
        let expected = Sign::Positive;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_negative_zero() {
        let x = Sign::Negative;
        let y = Sign::Zero;
        let expected = Sign::Zero;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_zero_positive() {
        let x = Sign::Zero;
        let y = Sign::Positive;
        let expected = Sign::Zero;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_zero_negative() {
        let x = Sign::Zero;
        let y = Sign::Negative;
        let expected = Sign::Zero;
        assert_eq!(x.mul(y), expected);
    }

    #[test]
    fn test_mul_zero_zero() {
        let x = Sign::Zero;
        let y = Sign::Zero;
        let expected = Sign::Zero;
        assert_eq!(x.mul(y), expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::MulAssign;
    
    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);
        
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);
        
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
        
        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);
        
        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);
        
        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
        
        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);
        
        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
        
        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::MulAssign;

    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use sign::Sign;

    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================

True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_mul_assign() {
        // Test case 1
        let mut sign = Sign::Positive;
        let rhs = Sign::Negative;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Negative);
        
        // Test case 2
        let mut sign = Sign::Negative;
        let rhs = Sign::Positive;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Negative);
        
        // Test case 3
        let mut sign = Sign::Negative;
        let rhs = Sign::Negative;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Positive);
        
        // Test case 4
        let mut sign = Sign::Positive;
        let rhs = Sign::Zero;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Zero);
        
        // Test case 5
        let mut sign = Sign::Negative;
        let rhs = Sign::Zero;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Zero);
        
        // Test case 6
        let mut sign = Sign::Zero;
        let rhs = Sign::Positive;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Zero);
        
        // Test case 7
        let mut sign = Sign::Zero;
        let rhs = Sign::Negative;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Zero);
        
        // Test case 8
        let mut sign = Sign::Zero;
        let rhs = Sign::Zero;
        sign.mul_assign(rhs);
        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::MulAssign;

    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Zero);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Negative);
        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Positive);
        assert_eq!(sign, Sign::Positive);
    }
}
True
========================================
    use crate::sign::Sign;
    use std::ops::MulAssign;

    #[test]
    fn test_mul_assign() {
        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Negative);

        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Positive);

        assert_eq!(sign, Sign::Negative);

        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Positive);

        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Negative);

        assert_eq!(sign, Sign::Positive);

        let mut sign = Sign::Positive;
        sign.mul_assign(Sign::Zero);

        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Zero;
        sign.mul_assign(Sign::Positive);

        assert_eq!(sign, Sign::Zero);

        let mut sign = Sign::Negative;
        sign.mul_assign(Sign::Zero);

        assert_eq!(sign, Sign::Zero);
    }
}
True
========================================
    use crate::Sign;

    #[test]
    #[allow(deprecated)]
    fn test_is_negative() {
        assert!(!Sign::Positive.is_negative());
        assert!(Sign::Negative.is_negative());
        assert!(!Sign::Zero.is_negative());
    }
}
True
========================================
    use crate::sign::Sign;
    
    #[test]
    fn test_is_positive() {
        assert_eq!(Sign::Positive.is_positive(), true);
        assert_eq!(Sign::Negative.is_positive(), false);
        assert_eq!(Sign::Zero.is_positive(), false);
    }
}
True
========================================
    use crate::sign::Sign;

    #[test]
    fn test_is_zero() {
        assert_eq!(Sign::Positive.is_zero(), false);
        assert_eq!(Sign::Negative.is_zero(), false);
        assert_eq!(Sign::Zero.is_zero(), true);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::sign::Sign::*;
    
    #[test]
    fn test_negate() {
        assert_eq!(Positive.negate(), Negative);
        assert_eq!(Negative.negate(), Positive);
        assert_eq!(Zero.negate(), Zero);
    }
}
True
========================================
    use super::*;

use crate::*;
    use core::convert::TryFrom;

    #[test]
    fn test_format() {
        assert_eq!(Time::try_from_hms(0, 0, 0).unwrap().format("%T"), "00:00:00");
        assert_eq!(Time::try_from_hms(12, 0, 0).unwrap().format("%T"), "12:00:00");
        assert_eq!(Time::try_from_hms(23, 59, 59).unwrap().format("%T"), "23:59:59");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_nanoseconds_since_midnight() {
        let nanoseconds = 0;
        let expected = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        let actual = Time::from_nanoseconds_since_midnight(nanoseconds);
        assert_eq!(expected, actual);

        let nanoseconds = 1_000_000_000;
        let expected = Time {
            hour: 0,
            minute: 0,
            second: 1,
            nanosecond: 0,
        };
        let actual = Time::from_nanoseconds_since_midnight(nanoseconds);
        assert_eq!(expected, actual);

        let nanoseconds = 3_600_000_000_000;
        let expected = Time {
            hour: 1,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        let actual = Time::from_nanoseconds_since_midnight(nanoseconds);
        assert_eq!(expected, actual);

        let nanoseconds = 3_600_000_000_001;
        let expected = Time {
            hour: 1,
            minute: 0,
            second: 0,
            nanosecond: 1,
        };
        let actual = Time::from_nanoseconds_since_midnight(nanoseconds);
        assert_eq!(expected, actual);

        let nanoseconds = 86_400_000_000_000;
        let expected = Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        };
        let actual = Time::from_nanoseconds_since_midnight(nanoseconds);
        assert_eq!(expected, actual);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Time;
    use crate::error::ComponentRangeError;
    use std::convert::TryFrom;

    #[test]
    fn test_hour() {
        assert_eq!(Time::try_from_hms(0, 0, 0).unwrap().hour(), 0);
        assert_eq!(Time::try_from_hms(23, 59, 59).unwrap().hour(), 23);
    }

    #[test]
    fn test_hour_invalid() {
        assert_eq!(
            Time::try_from_hms(24, 0, 0),
            Err(ComponentRangeError::HourOutOfRange { value: 24 })
        );
        assert_eq!(
            Time::try_from_hms(0, 60, 0),
            Err(ComponentRangeError::MinuteOutOfRange { value: 60 })
        );
        assert_eq!(
            Time::try_from_hms(0, 0, 60),
            Err(ComponentRangeError::SecondOutOfRange { value: 60 })
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::time_macro::time;
    
    #[test]
    fn test_lazy_format() {
        assert_eq!(time!(0:00).lazy_format("%r").to_string(), "12:00:00 am");
    }
}
False
========================================
use crate::Time as OtherTime;
assert_eq!(OtherTime::try_from_hms(0, 0, 0).unwrap().microsecond(), 0);
assert_eq!(OtherTime::try_from_hms(23, 59, 59).unwrap().microsecond(), 999_999);
use crate::Time as OtherTime;

#[test]
fn test_microsecond() {
    assert_eq!(OtherTime::try_from_hms(0, 0, 0).unwrap().microsecond(), 0);
    assert_eq!(OtherTime::try_from_hms(23, 59, 59).unwrap().microsecond(), 999_999);
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_midnight() {
        assert_eq!(Time::midnight(), Time {
            hour: 0,
            minute: 0,
            second: 0,
            nanosecond: 0,
        });
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_millisecond() {
        use Time;

        assert_eq!(Time::midnight().millisecond(), 0);
        assert_eq!(Time::try_from_hms(23, 59, 59).unwrap().millisecond(), 999);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::time_mod::AmPm::AM;
    use core::num::NonZeroU8;

    #[test]
    fn test_minute() {
        assert_eq!(Time::try_from_hms(0, 0, 0).unwrap().minute(), 0);
        assert_eq!(Time::try_from_hms(23, 59, 59).unwrap().minute(), 59);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::*;
    use crate::prelude::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_nanosecond() {
        assert_eq!(Time::try_from_hms(0, 0, 0).unwrap().nanosecond(), 0);
        assert_eq!(Time::try_from_hms(23, 59, 59).unwrap().nanosecond(), 0);
        assert_eq!(
            Time::try_from_hms_nano(0, 0, 0, 999_999_999).unwrap().nanosecond(),
            999_999_999
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use core::crate::Duration;

    #[test]
    fn test_nanoseconds_since_midnight() {
        let time = Time {
            hour: 8,
            minute: 30,
            second: 15,
            nanosecond: 500,
        };
        assert_eq!(time.nanoseconds_since_midnight(), 30615500000000);
    }

    #[test]
    fn test_from_nanoseconds_since_midnight() {
        let nanoseconds = 30615500000000;
        let expected_time = Time {
            hour: 8,
            minute: 30,
            second: 15,
            nanosecond: 500,
        };
        assert_eq!(Time::from_nanoseconds_since_midnight(nanoseconds), expected_time);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::PrimitiveDateTime;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;
    use std::fmt::Write;
    use crate::Duration;
    use crate::format::Padding;
    
    #[test]
    fn test_time_now() {
        let time = Time::now();
        let primitive_time = PrimitiveDateTime::now();
        let primitive_time_time = primitive_time.time();
        assert_eq!(time, primitive_time_time);
    }

    #[test]
    fn test_time_from_nanoseconds_since_midnight() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time, Time::midnight());

        let time = Time::from_nanoseconds_since_midnight(1_000_000_000);
        assert_eq!(time, time!(0:00:01));

        let time = Time::from_nanoseconds_since_midnight(3_600_000_000_000);
        assert_eq!(time, time!(1:00:00));

        let time = Time::from_nanoseconds_since_midnight(86_400_000_000_000);
        assert_eq!(time, Time::midnight());
    }

    #[test]
    fn test_time_hour() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.hour(), 0);

        let time = Time::from_nanoseconds_since_midnight(3_600_000_000_000);
        assert_eq!(time.hour(), 1);

        let time = Time::from_nanoseconds_since_midnight(86_400_000_000_000);
        assert_eq!(time.hour(), 0);
    }

    #[test]
    fn test_time_minute() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.minute(), 0);

        let time = Time::from_nanoseconds_since_midnight(60_000_000_000);
        assert_eq!(time.minute(), 1);

        let time = Time::from_nanoseconds_since_midnight(360_000_000_000);
        assert_eq!(time.minute(), 6);
    }

    #[test]
    fn test_time_second() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.second(), 0);

        let time = Time::from_nanoseconds_since_midnight(1_000_000_000);
        assert_eq!(time.second(), 1);

        let time = Time::from_nanoseconds_since_midnight(3_000_000_000);
        assert_eq!(time.second(), 3);
    }

    #[test]
    fn test_time_millisecond() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.millisecond(), 0);

        let time = Time::from_nanoseconds_since_midnight(1_000_000);
        assert_eq!(time.millisecond(), 1);

        let time = Time::from_nanoseconds_since_midnight(3_000_000);
        assert_eq!(time.millisecond(), 3);
    }

    #[test]
    fn test_time_microsecond() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.microsecond(), 0);

        let time = Time::from_nanoseconds_since_midnight(1_000);
        assert_eq!(time.microsecond(), 1);

        let time = Time::from_nanoseconds_since_midnight(3_000);
        assert_eq!(time.microsecond(), 3);
    }

    #[test]
    fn test_time_nanosecond() {
        let time = Time::from_nanoseconds_since_midnight(0);
        assert_eq!(time.nanosecond(), 0);

        let time = Time::from_nanoseconds_since_midnight(1);
        assert_eq!(time.nanosecond(), 1);

        let time = Time::from_nanoseconds_since_midnight(3);
        assert_eq!(time.nanosecond(), 3);
    }

    #[test]
    fn test_time_add_duration() {
        let mut time = time!(0:00);
        time += Duration::nanoseconds(5_000);
        assert_eq!(time, time!(0:00:00.000_000_005));

        let mut time = time!(0:00);
        time += Duration::nanoseconds(3_600_000_000_000);
        assert_eq!(time, time!(1:00:00));
        time += Duration::nanoseconds(86_400_000_000_000);
        assert_eq!(time, time!(1:00:00));

        let mut time = time!(0:00);
        time += Duration::nanoseconds(86_393_000_000_000);
        assert_eq!(time, time!(23:58:13));
    }

    #[test]
    fn test_time_add_assign_duration() {
        let mut time = time!(0:00);
        time.add_assign(Duration::nanoseconds(5_000));
        assert_eq!(time, time!(0:00:00.000_000_005));

        let mut time = time!(0:00);
        time.add_assign(Duration::nanoseconds(3_600_000_000_000));
        assert_eq!(time, time!(1:00:00));
        time.add_assign(Duration::nanoseconds(86_400_000_000_000));
        assert_eq!(time, time!(1:00:00));

        let mut time = time!(0:00);
        time.add_assign(Duration::nanoseconds(86_393_000_000_000));
        assert_eq!(time, time!(23:58:13));
    }

    #[test]
    fn test_time_sub_duration() {
        let mut time = time!(0:00);
        time -= Duration::nanoseconds(5_000);
        assert_eq!(time, time!(23:59:59.999_994));

        let mut time = time!(0:00);
        time -= Duration::nanoseconds(3_600_000_000_000);
        assert_eq!(time, time!(23:00:00));
        time -= Duration::nanoseconds(86_400_000_000_000);
        assert_eq!(time, time!(23:00:00));

        let mut time = time!(0:00);
        time -= Duration::nanoseconds(86_393_000_000_000);
        assert_eq!(time, time!(0:01:47));
    }

    #[test]
    fn test_time_sub_assign_duration() {
        let mut time = time!(0:00);
        time.sub_assign(Duration::nanoseconds(5_000));
        assert_eq!(time, time!(23:59:59.999_994));

        let mut time = time!(0:00);
        time.sub_assign(Duration::nanoseconds(3_600_000_000_000));
        assert_eq!(time, time!(23:00:00));
        time.sub_assign(Duration::nanoseconds(86_400_000_000_000));
        assert_eq!(time, time!(23:00:00));

        let mut time = time!(0:00);
        time.sub_assign(Duration::nanoseconds(86_393_000_000_000));
        assert_eq!(time, time!(0:01:47));
    }
    
    #[test]
    fn test_time_sub_time() {
        assert_eq!(time!(0:00).sub(time!(0:00)), Duration::zero());
        assert_eq!(time!(1:00).sub(time!(0:00)), Duration::hours(1));
        assert_eq!(time!(0:00).sub(time!(1:00)), Duration::minutes(-60));
        assert_eq!(time!(0:00).sub(time!(23:00)), Duration::hours(-23));
    }

    #[test]
    fn test_time_format() {
        let time = time!(12:00:00);
        assert_eq!(time.format("%r"), "12:00:00 pm");
    }

    #[test]
False
========================================
    use super::*;

use crate::*;
    use crate::Time;
    use crate::macros::time;

    #[test]
    fn test_parse() {
        assert_eq!(
            Time::parse("0:00:00", "%T"),
            Ok(time!(0:00))
        );
        assert_eq!(
            Time::parse("23:59:59", "%T"),
            Ok(time!(23:59:59))
        );
        assert_eq!(
            Time::parse("12:00:00 am", "%r"),
            Ok(time!(0:00))
        );
        assert_eq!(
            Time::parse("12:00:00 pm", "%r"),
            Ok(time!(12:00))
        );
        assert_eq!(
            Time::parse("11:59:59 pm", "%r"),
            Ok(time!(23:59:59))
        );
    }
}
False
========================================
    #[test]
    fn test_second() {
        assert_eq!(time!(0:00:00).second(), 0);
        assert_eq!(time!(23:59:59).second(), 59);
    }
}
False
========================================
    use crate::time_mod::Time;

    #[test]
    fn test_try_from_hms_valid() {
        assert!(Time::try_from_hms(1, 2, 3).is_ok());
    }

    #[test]
    fn test_try_from_hms_invalid_hour() {
        assert!(Time::try_from_hms(24, 0, 0).is_err());
    }

    #[test]
    fn test_try_from_hms_invalid_minute() {
        assert!(Time::try_from_hms(0, 60, 0).is_err());
    }

    #[test]
    fn test_try_from_hms_invalid_second() {
        assert!(Time::try_from_hms(0, 0, 60).is_err());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Time;
    use crate::error::ComponentRange::*;

    #[test]
    fn test_try_from_hms_micro_successful() {
        assert!(Time::try_from_hms_micro(1, 2, 3, 4).is_ok());
    }

    #[test]
    fn test_try_from_hms_micro_invalid_hour() {
        assert_eq!(
            Time::try_from_hms_micro(24, 0, 0, 0),
            Err(HourOutOfRange)
        );
    }

    #[test]
    fn test_try_from_hms_micro_invalid_minute() {
        assert_eq!(
            Time::try_from_hms_micro(0, 60, 0, 0),
            Err(MinuteOutOfRange)
        );
    }

    #[test]
    fn test_try_from_hms_micro_invalid_second() {
        assert_eq!(
            Time::try_from_hms_micro(0, 0, 60, 0),
            Err(SecondOutOfRange)
        );
    }

    #[test]
    fn test_try_from_hms_micro_invalid_microsecond() {
        assert_eq!(
            Time::try_from_hms_micro(0, 0, 0, 1_000_000),
            Err(MicrosecondOutOfRange)
        );
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_try_from_hms_milli_ok() {
        assert!(Time::try_from_hms_milli(1, 2, 3, 4).is_ok());
    }

    #[test]
    fn test_try_from_hms_milli_err_hour() {
        assert!(Time::try_from_hms_milli(24, 0, 0, 0).is_err());
    }

    #[test]
    fn test_try_from_hms_milli_err_minute() {
        assert!(Time::try_from_hms_milli(0, 60, 0, 0).is_err());
    }

    #[test]
    fn test_try_from_hms_milli_err_second() {
        assert!(Time::try_from_hms_milli(0, 0, 60, 0).is_err());
    }

    #[test]
    fn test_try_from_hms_milli_err_millisecond() {
        assert!(Time::try_from_hms_milli(0, 0, 0, 1_000).is_err());
    }
}
True
========================================
    use crate::time_mod::{Time, error};

    #[test]
    fn test_try_from_hms_nano() {
        assert!(Time::try_from_hms_nano(1, 2, 3, 4).is_ok());

        assert!(Time::try_from_hms_nano(24, 0, 0, 0).is_err());
        assert!(Time::try_from_hms_nano(0, 60, 0, 0).is_err());
        assert!(Time::try_from_hms_nano(0, 0, 60, 0).is_err());
        assert!(Time::try_from_hms_nano(0, 0, 0, 1_000_000_000).is_err());
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::num::NonZeroU8;
    use crate::format::parse::ParsedItems;
    use crate::error::Parse;

    #[test]
    fn test_try_from_parsed_items() {
        // First Test Case
        let items1 = ParsedItems {
            hour_24: Some(NonZeroU8::new(12).unwrap()),
            minute: Some(30),
            second: Some(45),
            nanosecond: Some(500_000_000),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items1),
            Ok(Time::try_from_hms_nano(12, 30, 45, 500_000_000).unwrap())
        );

        // Second Test Case
        let items2 = ParsedItems {
            hour_12: Some(NonZeroU8::new(3).unwrap()),
            minute: Some(45),
            second: Some(0),
            nanosecond: Some(0),
            am_pm: Some(AmPm::PM),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items2),
            Ok(Time::try_from_hms_nano(15, 45, 0, 0).unwrap())
        );

        // Third Test Case
        let items3 = ParsedItems {
            hour_24: Some(23),
            minute: Some(45),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items3),
            Ok(Time::try_from_hms(23, 45, 0).unwrap())
        );

        // Fourth Test Case
        let items4 = ParsedItems {
            hour_12: Some(NonZeroU8::new(8).unwrap()),
            minute: Some(0),
            am_pm: Some(AmPm::AM),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items4),
            Ok(Time::try_from_hms(8, 0, 0).unwrap())
        );

        // Fifth Test Case
        let items5 = ParsedItems {
            hour_24: Some(5),
            minute: Some(15),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items5),
            Ok(Time::try_from_hms(5, 15, 0).unwrap())
        );

        // Sixth Test Case
        let items6 = ParsedItems {
            hour_12: Some(NonZeroU8::new(11).unwrap()),
            minute: Some(30),
            am_pm: Some(AmPm::PM),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items6),
            Ok(Time::try_from_hms(23, 30, 0).unwrap())
        );

        // Seventh Test Case
        let items7 = ParsedItems {
            hour_24: Some(2),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items7),
            Ok(Time::try_from_hms(2, 0, 0).unwrap())
        );

        // Eighth Test Case
        let items8 = ParsedItems {
            hour_12: Some(NonZeroU8::new(6).unwrap()),
            am_pm: Some(AmPm::AM),
            ..ParsedItems::new()
        };
        assert_eq!(
            Time::try_from_parsed_items(items8),
            Ok(Time::try_from_hms(6, 0, 0).unwrap())
        );

        // Ninth Test Case
        let items9 = ParsedItems::new();
        assert_eq!(
            Time::try_from_parsed_items(items9),
            Err(Parse::InsufficientInformation)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::crate::Time;
    use crate::crate::Time::try_from_parsed_items::hour_12_to_24;
    use crate::crate::format::parse::AmPm;
    use std::num::NonZeroU8;
    
    #[test]
    fn test_hour_12_to_24() {
        assert_eq!(hour_12_to_24(NonZeroU8::new(12).unwrap(), AmPm::AM), 0);
        assert_eq!(hour_12_to_24(NonZeroU8::new(12).unwrap(), AmPm::PM), 12);
        assert_eq!(hour_12_to_24(NonZeroU8::new(3).unwrap(), AmPm::AM), 3);
        assert_eq!(hour_12_to_24(NonZeroU8::new(6).unwrap(), AmPm::PM), 18);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_as_duration() {
        let offset = UtcOffset::hours(2);
        let duration = offset.as_duration();
        assert_eq!(duration, Duration::hours(2));
    }
}
True
========================================
    use super::*;

use crate::*;
    #[test]
    fn test_as_hours() {
        assert_eq!(UtcOffset::UTC.as_hours(), 0);
        assert_eq!(UtcOffset::hours(12).as_hours(), 12);
        assert_eq!(UtcOffset::hours(-12).as_hours(), -12);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::utc_offset::UtcOffset;

    #[test]
    fn test_as_minutes() {
        assert_eq!(UtcOffset::UTC.as_minutes(), 0);
        assert_eq!(UtcOffset::hours(12).as_minutes(), 720);
        assert_eq!(UtcOffset::hours(-12).as_minutes(), -720);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::utc_offset::UtcOffset;

    #[test]
    fn test_as_seconds() {
        assert_eq!(UtcOffset::UTC.as_seconds(), 0);
        assert_eq!(UtcOffset::hours(12).as_seconds(), 43_200);
        assert_eq!(UtcOffset::hours(-12).as_seconds(), -43_200);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{OffsetDateTime, offset, error::IndeterminateOffset};

    #[test]
    #[cfg(feature = "std")]
    fn test_current_local_offset() {
        let result = UtcOffset::try_current_local_offset();
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_current_local_offset_mock() {
        let now = OffsetDateTime::unix_epoch();
        let offset = UtcOffset::seconds(0);
        let expected_result = Ok(offset);
        let result = UtcOffset::try_local_offset_at(now);
        assert_eq!(result, expected_result);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::UtcOffset;

    #[test]
    fn test_east_hours() {
        assert_eq!(UtcOffset::east_hours(1).as_hours(), 1);
        assert_eq!(UtcOffset::east_hours(2).as_minutes(), 120);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::private::Parsable;

    #[test]
    fn test_east_minutes() {
        assert_eq!(UtcOffset::east_minutes(60).as_hours(), 1);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::utc_offset::UtcOffset;

    #[test]
    fn test_east_seconds() {
        assert_eq!(UtcOffset::east_seconds(3_600).as_hours(), 1);
        assert_eq!(UtcOffset::east_seconds(1_800).as_minutes(), 30);
    }
}
True
========================================
    use crate::utc_offset::UtcOffset;
    
    #[test]
    fn test_format() {
        assert_eq!(UtcOffset::hours(2).format("%z"), "+0200");
        assert_eq!(UtcOffset::hours(-2).format("%z"), "-0200");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::utc_offset::UtcOffset;

    #[test]
    fn test_hours() {
        assert_eq!(UtcOffset::hours(2).as_minutes(), 120);
        assert_eq!(UtcOffset::hours(-2).as_minutes(), -120);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::fmt::Display;
    
    #[test]
    fn test_lazy_format() {
        assert_eq!(UtcOffset::hours(2).lazy_format("%z").to_string(), "+0200");
        assert_eq!(UtcOffset::hours(-2).lazy_format("%z").to_string(), "-0200");
    }
}
True
utc_offset::UtcOffset::local_offset_at exceed
========================================
    use super::*;

use crate::*;
    use crate::UtcOffset;

    #[test]
    fn test_minutes() {
        assert_eq!(UtcOffset::minutes(60).as_hours(), 1);
        assert_eq!(UtcOffset::minutes(-60).as_hours(), -1);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::UtcOffset;

    #[test]
    fn test_parse() {
        assert_eq!(UtcOffset::parse("+0200", "%z"), Ok(UtcOffset::hours(2)));
        assert_eq!(UtcOffset::parse("-0200", "%z"), Ok(UtcOffset::hours(-2)));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::UtcOffset;

    #[test]
    fn test_seconds_positive() {
        assert_eq!(UtcOffset::seconds(3_600).as_hours(), 1);
    }

    #[test]
    fn test_seconds_negative() {
        assert_eq!(UtcOffset::seconds(-3_600).as_hours(), -1);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_try_current_local_offset() {
        let result = UtcOffset::try_current_local_offset();
        assert!(result.is_ok());
    }
}
True
========================================
    use crate::utc_offset::{UtcOffset, ParsedItems, ParseResult, error::{self, Parse}};
    use std::num::NonZeroU8;
    use crate::try_from_parsed_items;

    #[test]
    fn test_try_from_parsed_items() {
        // Test case 1: offset is Some
        {
            let items = ParsedItems {
                offset: Some(UtcOffset::hours(2)),
                ..ParsedItems::new()
            };
            let result = try_from_parsed_items(items);
            assert_eq!(result, Ok(UtcOffset::hours(2)));
        }

        // Test case 2: offset is None
        {
            let items = ParsedItems::new();
            let result = try_from_parsed_items(items);
            assert_eq!(result, Err(error::Parse::InsufficientInformation));
        }
    }
}
False
utc_offset::UtcOffset::try_local_offset_at exceed
========================================
    use super::*;

use crate::*;
    use crate::{UtcOffset, offset};

    #[test]
    fn test_west_hours() {
        assert_eq!(UtcOffset::west_hours(1).as_hours(), -1);
        assert_eq!(UtcOffset::west_hours(2).as_minutes(), -120);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_west_minutes() {
        assert_eq!(UtcOffset::west_minutes(60).as_hours(), -1);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{UtcOffset, offset};

    #[test]
    fn test_west_seconds() {
        assert_eq!(UtcOffset::west_seconds(3_600).as_hours(), -1);
        assert_eq!(UtcOffset::west_seconds(1_800).as_minutes(), -30);
    }
}
True
utc_offset::try_local_offset_at exceed
========================================
    use super::*;

use crate::*;
    use crate::util::is_leap_year;

    #[test]
    fn test_days_in_year() {
        assert_eq!(days_in_year(1900), 365);
        assert_eq!(days_in_year(2000), 366);
        assert_eq!(days_in_year(2004), 366);
        assert_eq!(days_in_year(2005), 365);
        assert_eq!(days_in_year(2100), 365);
    }
}
True
========================================
    use crate::util::{days_in_year_month, is_leap_year};

    #[test]
    fn test_days_in_year_month() {
        assert_eq!(days_in_year_month(2021, 1), 31);
        assert_eq!(days_in_year_month(2021, 2), 28);
        assert_eq!(days_in_year_month(2021, 3), 31);
        assert_eq!(days_in_year_month(2021, 4), 30);
        assert_eq!(days_in_year_month(2021, 5), 31);
        assert_eq!(days_in_year_month(2021, 6), 30);
        assert_eq!(days_in_year_month(2021, 7), 31);
        assert_eq!(days_in_year_month(2021, 8), 31);
        assert_eq!(days_in_year_month(2021, 9), 30);
        assert_eq!(days_in_year_month(2021, 10), 31);
        assert_eq!(days_in_year_month(2021, 11), 30);
        assert_eq!(days_in_year_month(2021, 12), 31);
        assert_eq!(days_in_year_month(2020, 2), 29);
        assert_eq!(days_in_year_month(2000, 2), 29);
        assert_eq!(days_in_year_month(1900, 2), 28);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_is_leap_year() {
        assert_eq!(is_leap_year(1900), false);
        assert_eq!(is_leap_year(2000), true);
        assert_eq!(is_leap_year(2004), true);
        assert_eq!(is_leap_year(2005), false);
        assert_eq!(is_leap_year(2100), false);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_validate_format_string_valid() {
        assert_eq!(validate_format_string("{}"), Ok(()));
        assert_eq!(validate_format_string("abc"), Ok(()));
        assert_eq!(validate_format_string("Hello, {}!"), Ok(()));
    }
    
    #[test]
    fn test_validate_format_string_invalid() {
        assert_eq!(validate_format_string("{"), Err("mismatched braces".to_string()));
        assert_eq!(validate_format_string("}"), Err("mismatched braces".to_string()));
        assert_eq!(validate_format_string("{abc"), Err("mismatched braces".to_string()));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::internals;

    #[test]
    fn test_weeks_in_year() {
        assert_eq!(weeks_in_year(2019), 52);
        assert_eq!(weeks_in_year(2020), 53);
    }
}
True
========================================
    use crate::weekday::Weekday;

    #[test]
    fn test_iso_weekday_number() {
        assert_eq!(Weekday::Monday.iso_weekday_number(), 1);
        assert_eq!(Weekday::Tuesday.iso_weekday_number(), 2);
        assert_eq!(Weekday::Wednesday.iso_weekday_number(), 3);
        assert_eq!(Weekday::Thursday.iso_weekday_number(), 4);
        assert_eq!(Weekday::Friday.iso_weekday_number(), 5);
        assert_eq!(Weekday::Saturday.iso_weekday_number(), 6);
        assert_eq!(Weekday::Sunday.iso_weekday_number(), 7);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::string::ToString;

    #[test]
    fn test_next_weekday() {
        assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);
        assert_eq!(Weekday::Tuesday.next(), Weekday::Wednesday);
        assert_eq!(Weekday::Wednesday.next(), Weekday::Thursday);
        assert_eq!(Weekday::Thursday.next(), Weekday::Friday);
        assert_eq!(Weekday::Friday.next(), Weekday::Saturday);
        assert_eq!(Weekday::Saturday.next(), Weekday::Sunday);
        assert_eq!(Weekday::Sunday.next(), Weekday::Monday);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Weekday;

    #[test]
    fn test_number_days_from_monday() {
        assert_eq!(Weekday::Monday.number_days_from_monday(), 0);
        assert_eq!(Weekday::Tuesday.number_days_from_monday(), 1);
        assert_eq!(Weekday::Wednesday.number_days_from_monday(), 2);
        assert_eq!(Weekday::Thursday.number_days_from_monday(), 3);
        assert_eq!(Weekday::Friday.number_days_from_monday(), 4);
        assert_eq!(Weekday::Saturday.number_days_from_monday(), 5);
        assert_eq!(Weekday::Sunday.number_days_from_monday(), 6);
    }
}
True
========================================
    use crate::weekday::Weekday;

    #[test]
    fn test_number_days_from_sunday() {
        assert_eq!(Weekday::Monday.number_days_from_sunday(), 1);
        assert_eq!(Weekday::Tuesday.number_days_from_sunday(), 2);
        assert_eq!(Weekday::Wednesday.number_days_from_sunday(), 3);
        assert_eq!(Weekday::Thursday.number_days_from_sunday(), 4);
        assert_eq!(Weekday::Friday.number_days_from_sunday(), 5);
        assert_eq!(Weekday::Saturday.number_days_from_sunday(), 6);
        assert_eq!(Weekday::Sunday.number_days_from_sunday(), 0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Weekday;
    use std::fmt::Display;
    use std::fmt::Write;
    use std::hash::Hash;
    use std::marker::Copy;
    use std::marker::StructuralEq;
    use std::marker::StructuralPartialEq;
    use std::cmp::Eq;
    use std::cmp::PartialEq;
    use std::fmt::Debug;
    use std::fmt::Formatter;
    use std::fmt::Result;

    #[test]
    fn test_number_from_monday() {
        assert_eq!(Weekday::Monday.number_from_monday(), 1);
        assert_eq!(Weekday::Tuesday.number_from_monday(), 2);
        assert_eq!(Weekday::Wednesday.number_from_monday(), 3);
        assert_eq!(Weekday::Thursday.number_from_monday(), 4);
        assert_eq!(Weekday::Friday.number_from_monday(), 5);
        assert_eq!(Weekday::Saturday.number_from_monday(), 6);
        assert_eq!(Weekday::Sunday.number_from_monday(), 7);
    }
 }
False
========================================
    use crate::weekday::{Weekday};

    #[test]
    fn test_number_from_sunday() {
        assert_eq!(Weekday::Monday.number_from_sunday(), 2);
        assert_eq!(Weekday::Tuesday.number_from_sunday(), 3);
        assert_eq!(Weekday::Wednesday.number_from_sunday(), 4);
        assert_eq!(Weekday::Thursday.number_from_sunday(), 5);
        assert_eq!(Weekday::Friday.number_from_sunday(), 6);
        assert_eq!(Weekday::Saturday.number_from_sunday(), 7);
        assert_eq!(Weekday::Sunday.number_from_sunday(), 1);
    }
}
True
========================================
    use super::*;

use crate::*;
    use weekday::Weekday::{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};

    #[test]
    fn test_previous_weekday() {
        assert_eq!(Monday.previous(), Sunday);
        assert_eq!(Tuesday.previous(), Monday);
        assert_eq!(Wednesday.previous(), Tuesday);
        assert_eq!(Thursday.previous(), Wednesday);
        assert_eq!(Friday.previous(), Thursday);
        assert_eq!(Saturday.previous(), Friday);
        assert_eq!(Sunday.previous(), Saturday);
    }
}
True
time time 241 610
