{"dependencies":{"<Delimiter as std::clone::Clone>::clone":["Delimiter"],"<Delimiter as std::cmp::Eq>::assert_receiver_is_total_eq":["Delimiter"],"<Delimiter as std::cmp::PartialEq>::eq":["Delimiter"],"<Delimiter as std::fmt::Debug>::fmt":["Delimiter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<Group as std::clone::Clone>::clone":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<Group as std::fmt::Debug>::fmt":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<Group as std::fmt::Display>::fmt":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<Ident as std::clone::Clone>::clone":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Ident as std::cmp::Ord>::cmp":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Ident as std::cmp::PartialEq<T>>::eq":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Ident as std::cmp::PartialEq>::eq":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Ident as std::cmp::PartialOrd>::partial_cmp":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Ident as std::fmt::Debug>::fmt":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Ident as std::fmt::Display>::fmt":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Ident as std::hash::Hash>::hash":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<LexError as std::fmt::Debug>::fmt":["LexError","fallback::LexError","imp::LexError","proc_macro::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<LexError as std::fmt::Display>::fmt":["LexError","fallback::LexError","imp::LexError","proc_macro::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<Literal as std::clone::Clone>::clone":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Literal as std::fmt::Debug>::fmt":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Literal as std::fmt::Display>::fmt":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Punct as std::clone::Clone>::clone":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"<Punct as std::fmt::Debug>::fmt":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::result::Result"],"<Punct as std::fmt::Display>::fmt":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::result::Result"],"<Spacing as std::clone::Clone>::clone":["Spacing"],"<Spacing as std::cmp::Eq>::assert_receiver_is_total_eq":["Spacing"],"<Spacing as std::cmp::PartialEq>::eq":["Spacing"],"<Spacing as std::fmt::Debug>::fmt":["Spacing","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<Span as std::clone::Clone>::clone":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"<Span as std::fmt::Debug>::fmt":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::result::Result"],"<TokenStream as std::clone::Clone>::clone":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::convert::From<TokenTree>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenStream","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::default::Default>::default":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::fmt::Debug>::fmt":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<TokenStream as std::fmt::Display>::fmt":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<TokenStream as std::iter::Extend<TokenStream>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::iter::Extend<TokenTree>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::iter::FromIterator<TokenStream>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<TokenStream as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<TokenTree as std::clone::Clone>::clone":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenTree as std::convert::From<Group>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenTree as std::convert::From<Ident>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenTree as std::convert::From<Literal>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenTree as std::convert::From<Punct>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<TokenTree as std::fmt::Debug>::fmt":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<TokenTree as std::fmt::Display>::fmt":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<fallback::Group as std::clone::Clone>::clone":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::Group as std::fmt::Debug>::fmt":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<fallback::Group as std::fmt::Display>::fmt":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<fallback::Ident as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<fallback::Ident as std::cmp::PartialEq<T>>::eq":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<fallback::Ident as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<fallback::Ident as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<fallback::Ident as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<fallback::LexError as std::fmt::Debug>::fmt":["fallback::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fallback::LexError as std::fmt::Display>::fmt":["fallback::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fallback::LineColumn as std::clone::Clone>::clone":["fallback::LineColumn"],"<fallback::LineColumn as std::cmp::Eq>::assert_receiver_is_total_eq":["fallback::LineColumn"],"<fallback::LineColumn as std::cmp::PartialEq>::eq":["fallback::LineColumn"],"<fallback::LineColumn as std::fmt::Debug>::fmt":["fallback::LineColumn","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fallback::Literal as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<fallback::Literal as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<fallback::Literal as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<fallback::SourceFile as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<fallback::SourceFile as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<fallback::SourceFile as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<fallback::SourceFile as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::sys::unix::os_str::Buf","std::vec::Vec"],"<fallback::Span as std::clone::Clone>::clone":["fallback::Span"],"<fallback::Span as std::cmp::Eq>::assert_receiver_is_total_eq":["fallback::Span"],"<fallback::Span as std::cmp::PartialEq>::eq":["fallback::Span"],"<fallback::Span as std::fmt::Debug>::fmt":["fallback::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fallback::TokenStream as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::convert::From<TokenTree>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<fallback::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["alloc::raw_vec::RawVec","fallback::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<fallback::TokenStream as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<fallback::TokenStream as std::iter::Extend<TokenTree>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::iter::Extend<fallback::TokenStream>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::iter::FromIterator<fallback::TokenStream>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::iter::IntoIterator>::into_iter":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::ptr::Unique","std::vec::IntoIter","std::vec::Vec"],"<fallback::TokenStream as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<fallback::TokenStream as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<imp::DeferredTokenStream as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::Group as std::clone::Clone>::clone":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::Group as std::convert::From<fallback::Group>>::from":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::Group as std::fmt::Debug>::fmt":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<imp::Group as std::fmt::Display>::fmt":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<imp::Ident as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::Ident as std::cmp::PartialEq<T>>::eq":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::Ident as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::Ident as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<imp::Ident as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<imp::LexError as std::convert::From<fallback::LexError>>::from":["fallback::LexError","imp::LexError","proc_macro::LexError"],"<imp::LexError as std::convert::From<proc_macro::LexError>>::from":["fallback::LexError","imp::LexError","proc_macro::LexError"],"<imp::LexError as std::fmt::Debug>::fmt":["fallback::LexError","imp::LexError","proc_macro::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<imp::LexError as std::fmt::Display>::fmt":["fallback::LexError","imp::LexError","proc_macro::LexError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<imp::Literal as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::Literal as std::convert::From<fallback::Literal>>::from":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::Literal as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<imp::Literal as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<imp::Span as std::clone::Clone>::clone":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"<imp::Span as std::convert::From<fallback::Span>>::from":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"<imp::Span as std::fmt::Debug>::fmt":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::result::Result"],"<imp::TokenStream as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::convert::From<TokenTree>>::from":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<imp::TokenStream as std::convert::From<fallback::TokenStream>>::from":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<imp::TokenStream as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<imp::TokenStream as std::iter::Extend<TokenTree>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::iter::Extend<imp::TokenStream>>::extend":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::iter::FromIterator<imp::TokenStream>>::from_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<imp::TokenStream as std::iter::IntoIterator>::into_iter":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","imp::TokenTreeIter","proc_macro::TokenStream","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::IntoIter","std::vec::Vec"],"<imp::TokenStream as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<imp::TokenTreeIter as std::clone::Clone>::clone":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter"],"<imp::TokenTreeIter as std::fmt::Debug>::fmt":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","std::vec::IntoIter"],"<imp::TokenTreeIter as std::iter::Iterator>::next":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::vec::IntoIter"],"<imp::TokenTreeIter as std::iter::Iterator>::size_hint":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::vec::IntoIter"],"<impl std::convert::From<TokenStream> for proc_macro::TokenStream>::from":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<parse::Cursor<'a> as std::clone::Clone>::clone":["parse::Cursor"],"<parse::Cursor<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["parse::Cursor"],"<parse::Cursor<'a> as std::cmp::PartialEq>::eq":["parse::Cursor"],"<token_stream::IntoIter as std::clone::Clone>::clone":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter","token_stream::IntoIter"],"<token_stream::IntoIter as std::fmt::Debug>::fmt":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::result::Result","std::vec::IntoIter","token_stream::IntoIter"],"<token_stream::IntoIter as std::iter::Iterator>::next":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::vec::IntoIter","token_stream::IntoIter"],"Delimiter":["Delimiter"],"Group":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::_new":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::_new_stable":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::delimiter":["Delimiter","Group","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::new":["Delimiter","Group","TokenStream","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::set_span":["Delimiter","Group","Span","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::span":["Delimiter","Group","Span","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::span_close":["Delimiter","Group","Span","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::span_open":["Delimiter","Group","Span","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Group::stream":["Delimiter","Group","TokenStream","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"Ident":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Ident::_new":["Ident","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Ident::_new_raw":["Ident","Span","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Ident::new":["Ident","Span","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Ident::set_span":["Ident","Span","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Ident::span":["Ident","Span","alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"LexError":["LexError","fallback::LexError","imp::LexError","proc_macro::LexError","std::marker::PhantomData"],"Literal":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::_new":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::_new_stable":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::byte_string":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::character":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::f32_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::f32_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::f64_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::f64_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i128_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i128_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i16_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i16_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i32_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i32_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i64_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i64_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i8_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::i8_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::isize_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::isize_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::set_span":["Literal","Span","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","imp::Span","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::span":["Literal","Span","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","imp::Span","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::string":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::subspan":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u128_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u128_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u16_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u16_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u32_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u32_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u64_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u64_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u8_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::u8_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::usize_suffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Literal::usize_unsuffixed":["Literal","alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Punct":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Punct::as_char":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Punct::new":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Punct::set_span":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Punct::spacing":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Punct::span":["Punct","Spacing","Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Spacing":["Spacing"],"Span":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::_new":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::_new_stable":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::call_site":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::join":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option"],"Span::located_at":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::mixed_site":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::resolved_at":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::unstable":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"Span::unwrap":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"TokenStream":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"TokenStream::_new":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"TokenStream::_new_stable":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"TokenStream::is_empty":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"TokenStream::new":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"TokenTree":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"TokenTree::set_span":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"TokenTree::span":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"detection::force_fallback":[],"detection::initialize":[],"detection::inside_proc_macro":[],"detection::unforce_fallback":[],"fallback::<impl std::convert::From<fallback::TokenStream> for proc_macro::TokenStream>::from":["alloc::raw_vec::RawVec","fallback::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::delimiter":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::new":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::set_span":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::span":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::span_close":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::span_open":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Group::stream":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::Ident":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Ident::_new":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Ident::new":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Ident::new_raw":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Ident::set_span":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Ident::span":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::LexError":["fallback::LexError"],"fallback::LineColumn":["fallback::LineColumn"],"fallback::Literal":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::_new":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::byte_string":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::character":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::f32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::f32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::f64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::f64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i128_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i128_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i16_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i16_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i8_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::i8_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::isize_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::isize_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::set_span":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::span":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::string":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::subspan":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u128_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u128_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u16_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u16_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u8_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::u8_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::usize_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::Literal::usize_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::SourceFile":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"fallback::SourceFile::is_real":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"fallback::SourceFile::path":["alloc::raw_vec::RawVec","fallback::SourceFile","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::path::PathBuf","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"fallback::Span":["fallback::Span"],"fallback::Span::call_site":["fallback::Span"],"fallback::Span::first_byte":["fallback::Span"],"fallback::Span::join":["fallback::Span","std::marker::Sized","std::option::Option"],"fallback::Span::last_byte":["fallback::Span"],"fallback::Span::located_at":["fallback::Span"],"fallback::Span::mixed_site":["fallback::Span"],"fallback::Span::resolved_at":["fallback::Span"],"fallback::TokenStream":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::TokenStream::is_empty":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::TokenStream::new":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::TokenStream::push_token":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::TokenStream::push_token::push_negative_literal":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"fallback::TokenStream::take_inner":["alloc::raw_vec::RawVec","fallback::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"fallback::debug_span_field_if_nontrivial":["fallback::Span","std::fmt::DebugStruct","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"fallback::force":[],"fallback::get_cursor":["parse::Cursor"],"fallback::is_ident_continue":[],"fallback::is_ident_start":[],"fallback::unforce":[],"fallback::validate_ident":[],"fallback::validate_ident::ident_ok":[],"imp::<impl std::convert::From<imp::TokenStream> for proc_macro::TokenStream>::from":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::<impl std::convert::From<proc_macro::Span> for Span>::from":["Span","fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::DeferredTokenStream":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::DeferredTokenStream::evaluate_now":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::DeferredTokenStream::into_token_stream":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::DeferredTokenStream::is_empty":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::DeferredTokenStream::new":["alloc::raw_vec::RawVec","imp::DeferredTokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::delimiter":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::new":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::set_span":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::span":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::span_close":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::span_open":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Span","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::stream":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::TokenStream","proc_macro::Delimiter","proc_macro::Group","proc_macro::TokenStream","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Group::unwrap_nightly":["Delimiter","alloc::raw_vec::RawVec","fallback::Group","fallback::Span","fallback::TokenStream","imp::Group","proc_macro::Delimiter","proc_macro::Group","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::Ident":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Ident::new":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Ident::new_raw":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Ident::set_span":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Ident::span":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","imp::Span","proc_macro::Ident","proc_macro::Span","proc_macro::bridge::Ident","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Ident::unwrap_nightly":["alloc::raw_vec::RawVec","fallback::Ident","fallback::Span","imp::Ident","proc_macro::Ident","proc_macro::bridge::Ident","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::LexError":["fallback::LexError","imp::LexError","proc_macro::LexError"],"imp::Literal":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::byte_string":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::character":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::f32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::f32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::f64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::f64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i128_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i128_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i16_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i16_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i8_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::i8_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::isize_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::isize_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::set_span":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","imp::Span","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::span":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","imp::Span","proc_macro::Literal","proc_macro::Span","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::string":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::subspan":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u128_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u128_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u16_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u16_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u32_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u32_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u64_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u64_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u8_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::u8_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::unwrap_nightly":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::usize_suffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Literal::usize_unsuffixed":["alloc::raw_vec::RawVec","fallback::Literal","fallback::Span","imp::Literal","proc_macro::Literal","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::Span":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::call_site":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::join":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option"],"imp::Span::located_at":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::mixed_site":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::resolved_at":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::unwrap":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::Span::unwrap_nightly":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::marker::PhantomData","std::num::NonZeroU32"],"imp::TokenStream":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::TokenStream::is_empty":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::TokenStream::new":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::TokenStream::unwrap_nightly":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::TokenStream::unwrap_stable":["alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","proc_macro::TokenStream","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"imp::TokenTreeIter":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter"],"imp::debug_span_field_if_nontrivial":["fallback::Span","imp::Span","proc_macro::Span","proc_macro::bridge::client::Span","std::fmt::DebugStruct","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::result::Result"],"imp::into_compiler_token":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenTree","alloc::raw_vec::RawVec","fallback::Group","fallback::Ident","fallback::Literal","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","proc_macro::Delimiter","proc_macro::Group","proc_macro::Ident","proc_macro::Literal","proc_macro::Punct","proc_macro::Span","proc_macro::TokenTree","proc_macro::bridge::DelimSpan","proc_macro::bridge::Group","proc_macro::bridge::Ident","proc_macro::bridge::LitKind","proc_macro::bridge::Literal","proc_macro::bridge::Punct","proc_macro::bridge::client::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"imp::mismatch":[],"imp::proc_macro_parse":["std::marker::Sized","std::result::Result"],"marker::ProcMacroAutoTraits":["marker::ProcMacroAutoTraits","std::marker::PhantomData","std::ptr::NonNull","std::rc::Rc"],"parse::Cursor":["parse::Cursor"],"parse::Cursor::<'a>::advance":["parse::Cursor"],"parse::Cursor::<'a>::as_bytes":["parse::Cursor"],"parse::Cursor::<'a>::bytes":["parse::Cursor","std::iter::Copied","std::marker::Sized","std::str::Bytes"],"parse::Cursor::<'a>::char_indices":["parse::Cursor","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::CharIndices","std::str::Chars"],"parse::Cursor::<'a>::chars":["parse::Cursor","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parse::Cursor::<'a>::is_empty":["parse::Cursor"],"parse::Cursor::<'a>::len":["parse::Cursor"],"parse::Cursor::<'a>::parse":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::Cursor::<'a>::starts_with":["parse::Cursor"],"parse::backslash_u":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter"],"parse::backslash_x_byte":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter"],"parse::backslash_x_char":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter"],"parse::block_comment":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::byte":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::byte_string":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::character":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::cooked_byte_string":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::cooked_string":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::digits":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::doc_comment":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::doc_comment_contents":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::float":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::float_digits":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::ident":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::ident_any":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::ident_not_raw":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::int":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::is_whitespace":[],"parse::leaf_token":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::literal":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::literal_nocapture":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::literal_suffix":["parse::Cursor"],"parse::punct":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::punct_char":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::raw_string":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::skip_whitespace":["parse::Cursor"],"parse::string":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::take_until_newline_or_eof":["parse::Cursor"],"parse::token_stream":["parse::Cursor","std::marker::Sized","std::result::Result"],"parse::word_break":["parse::Cursor","std::marker::Sized","std::result::Result"],"token_stream::<impl std::iter::IntoIterator for TokenStream>::into_iter":["TokenStream","alloc::raw_vec::RawVec","fallback::TokenStream","imp::DeferredTokenStream","imp::TokenStream","imp::TokenTreeIter","proc_macro::TokenStream","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::IntoIter","std::vec::Vec","token_stream::IntoIter"],"token_stream::IntoIter":["imp::TokenTreeIter","proc_macro::token_stream::IntoIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::mem::ManuallyDrop","std::ptr::NonNull","std::vec::IntoIter","token_stream::IntoIter"]},"glob_path_import":{},"self_to_fn":{"Delimiter":["Clone","Copy","Debug","Eq","PartialEq"],"Group":["Clone","impl Debug for Group {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, formatter)\n    }\n}","impl Display for Group {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.inner, formatter)\n    }\n}","impl Group {\n    fn _new(inner: imp::Group) -> Self {\n        Group { inner }\n    }\n\n    fn _new_stable(inner: fallback::Group) -> Self {\n        Group {\n            inner: inner.into(),\n        }\n    }\n\n    /// Creates a new `Group` with the given delimiter and token stream.\n    ///\n    /// This constructor will set the span for this group to\n    /// `Span::call_site()`. To change the span you can use the `set_span`\n    /// method below.\n    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n        Group {\n            inner: imp::Group::new(delimiter, stream.inner),\n        }\n    }\n\n    /// Returns the delimiter of this `Group`\n    pub fn delimiter(&self) -> Delimiter {\n        self.inner.delimiter()\n    }\n\n    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n    ///\n    /// Note that the returned token stream does not include the delimiter\n    /// returned above.\n    pub fn stream(&self) -> TokenStream {\n        TokenStream::_new(self.inner.stream())\n    }\n\n    /// Returns the span for the delimiters of this token stream, spanning the\n    /// entire `Group`.\n    ///\n    /// ```text\n    /// pub fn span(&self) -> Span {\n    ///            ^^^^^^^\n    /// ```\n    pub fn span(&self) -> Span {\n        Span::_new(self.inner.span())\n    }\n\n    /// Returns the span pointing to the opening delimiter of this group.\n    ///\n    /// ```text\n    /// pub fn span_open(&self) -> Span {\n    ///                 ^\n    /// ```\n    pub fn span_open(&self) -> Span {\n        Span::_new(self.inner.span_open())\n    }\n\n    /// Returns the span pointing to the closing delimiter of this group.\n    ///\n    /// ```text\n    /// pub fn span_close(&self) -> Span {\n    ///                        ^\n    /// ```\n    pub fn span_close(&self) -> Span {\n        Span::_new(self.inner.span_close())\n    }\n\n    /// Configures the span for this `Group`'s delimiters, but not its internal\n    /// tokens.\n    ///\n    /// This method will **not** set the span of all the internal tokens spanned\n    /// by this group, but rather it will only set the span of the delimiter\n    /// tokens at the level of the `Group`.\n    pub fn set_span(&mut self, span: Span) {\n        self.inner.set_span(span.inner)\n    }\n}"],"Ident":["Clone","impl Debug for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, f)\n    }\n}","impl Display for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.inner, f)\n    }\n}","impl Eq for Ident {}","impl Hash for Ident {\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        self.to_string().hash(hasher)\n    }\n}","impl Ident {\n    fn _new(inner: imp::Ident) -> Ident {\n        Ident {\n            inner,\n            _marker: Marker,\n        }\n    }\n\n    /// Creates a new `Ident` with the given `string` as well as the specified\n    /// `span`.\n    ///\n    /// The `string` argument must be a valid identifier permitted by the\n    /// language, otherwise the function will panic.\n    ///\n    /// Note that `span`, currently in rustc, configures the hygiene information\n    /// for this identifier.\n    ///\n    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\"\n    /// hygiene meaning that identifiers created with this span will be resolved\n    /// as if they were written directly at the location of the macro call, and\n    /// other code at the macro call site will be able to refer to them as well.\n    ///\n    /// Later spans like `Span::def_site()` will allow to opt-in to\n    /// \"definition-site\" hygiene meaning that identifiers created with this\n    /// span will be resolved at the location of the macro definition and other\n    /// code at the macro call site will not be able to refer to them.\n    ///\n    /// Due to the current importance of hygiene this constructor, unlike other\n    /// tokens, requires a `Span` to be specified at construction.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the input string is neither a keyword nor a legal variable\n    /// name. If you are not sure whether the string contains an identifier and\n    /// need to handle an error case, use\n    /// <a href=\"https://docs.rs/syn/1.0/syn/fn.parse_str.html\"><code\n    ///   style=\"padding-right:0;\">syn::parse_str</code></a><code\n    ///   style=\"padding-left:0;\">::&lt;Ident&gt;</code>\n    /// rather than `Ident::new`.\n    pub fn new(string: &str, span: Span) -> Ident {\n        Ident::_new(imp::Ident::new(string, span.inner))\n    }\n\n    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n    ///\n    /// This method is semver exempt and not exposed by default.\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn new_raw(string: &str, span: Span) -> Ident {\n        Ident::_new_raw(string, span)\n    }\n\n    fn _new_raw(string: &str, span: Span) -> Ident {\n        Ident::_new(imp::Ident::new_raw(string, span.inner))\n    }\n\n    /// Returns the span of this `Ident`.\n    pub fn span(&self) -> Span {\n        Span::_new(self.inner.span())\n    }\n\n    /// Configures the span of this `Ident`, possibly changing its hygiene\n    /// context.\n    pub fn set_span(&mut self, span: Span) {\n        self.inner.set_span(span.inner);\n    }\n}","impl Ord for Ident {\n    fn cmp(&self, other: &Ident) -> Ordering {\n        self.to_string().cmp(&other.to_string())\n    }\n}","impl PartialEq for Ident {\n    fn eq(&self, other: &Ident) -> bool {\n        self.inner == other.inner\n    }\n}","impl PartialOrd for Ident {\n    fn partial_cmp(&self, other: &Ident) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl<T> PartialEq<T> for Ident\nwhere\n    T: ?Sized + AsRef<str>,\n{\n    fn eq(&self, other: &T) -> bool {\n        self.inner == other\n    }\n}"],"LexError":["impl Debug for LexError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, f)\n    }\n}","impl Display for LexError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.inner, f)\n    }\n}","impl Error for LexError {}"],"Literal":["Clone","impl Debug for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, f)\n    }\n}","impl Display for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.inner, f)\n    }\n}","impl Literal {\n    fn _new(inner: imp::Literal) -> Literal {\n        Literal {\n            inner,\n            _marker: Marker,\n        }\n    }\n\n    fn _new_stable(inner: fallback::Literal) -> Literal {\n        Literal {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }\n\n    suffixed_int_literals! {\n        u8_suffixed => u8,\n        u16_suffixed => u16,\n        u32_suffixed => u32,\n        u64_suffixed => u64,\n        u128_suffixed => u128,\n        usize_suffixed => usize,\n        i8_suffixed => i8,\n        i16_suffixed => i16,\n        i32_suffixed => i32,\n        i64_suffixed => i64,\n        i128_suffixed => i128,\n        isize_suffixed => isize,\n    }\n\n    unsuffixed_int_literals! {\n        u8_unsuffixed => u8,\n        u16_unsuffixed => u16,\n        u32_unsuffixed => u32,\n        u64_unsuffixed => u64,\n        u128_unsuffixed => u128,\n        usize_unsuffixed => usize,\n        i8_unsuffixed => i8,\n        i16_unsuffixed => i16,\n        i32_unsuffixed => i32,\n        i64_unsuffixed => i64,\n        i128_unsuffixed => i128,\n        isize_unsuffixed => isize,\n    }\n\n    /// Creates a new unsuffixed floating-point literal.\n    ///\n    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n    /// the float's value is emitted directly into the token but no suffix is\n    /// used, so it may be inferred to be a `f64` later in the compiler.\n    /// Literals created from negative numbers may not survive rountrips through\n    /// `TokenStream` or strings and may be broken into two tokens (`-` and\n    /// positive literal).\n    ///\n    /// # Panics\n    ///\n    /// This function requires that the specified float is finite, for example\n    /// if it is infinity or NaN this function will panic.\n    pub fn f64_unsuffixed(f: f64) -> Literal {\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f64_unsuffixed(f))\n    }\n\n    /// Creates a new suffixed floating-point literal.\n    ///\n    /// This constructor will create a literal like `1.0f64` where the value\n    /// specified is the preceding part of the token and `f64` is the suffix of\n    /// the token. This token will always be inferred to be an `f64` in the\n    /// compiler. Literals created from negative numbers may not survive\n    /// rountrips through `TokenStream` or strings and may be broken into two\n    /// tokens (`-` and positive literal).\n    ///\n    /// # Panics\n    ///\n    /// This function requires that the specified float is finite, for example\n    /// if it is infinity or NaN this function will panic.\n    pub fn f64_suffixed(f: f64) -> Literal {\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f64_suffixed(f))\n    }\n\n    /// Creates a new unsuffixed floating-point literal.\n    ///\n    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n    /// the float's value is emitted directly into the token but no suffix is\n    /// used, so it may be inferred to be a `f64` later in the compiler.\n    /// Literals created from negative numbers may not survive rountrips through\n    /// `TokenStream` or strings and may be broken into two tokens (`-` and\n    /// positive literal).\n    ///\n    /// # Panics\n    ///\n    /// This function requires that the specified float is finite, for example\n    /// if it is infinity or NaN this function will panic.\n    pub fn f32_unsuffixed(f: f32) -> Literal {\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f32_unsuffixed(f))\n    }\n\n    /// Creates a new suffixed floating-point literal.\n    ///\n    /// This constructor will create a literal like `1.0f32` where the value\n    /// specified is the preceding part of the token and `f32` is the suffix of\n    /// the token. This token will always be inferred to be an `f32` in the\n    /// compiler. Literals created from negative numbers may not survive\n    /// rountrips through `TokenStream` or strings and may be broken into two\n    /// tokens (`-` and positive literal).\n    ///\n    /// # Panics\n    ///\n    /// This function requires that the specified float is finite, for example\n    /// if it is infinity or NaN this function will panic.\n    pub fn f32_suffixed(f: f32) -> Literal {\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f32_suffixed(f))\n    }\n\n    /// String literal.\n    pub fn string(string: &str) -> Literal {\n        Literal::_new(imp::Literal::string(string))\n    }\n\n    /// Character literal.\n    pub fn character(ch: char) -> Literal {\n        Literal::_new(imp::Literal::character(ch))\n    }\n\n    /// Byte string literal.\n    pub fn byte_string(s: &[u8]) -> Literal {\n        Literal::_new(imp::Literal::byte_string(s))\n    }\n\n    /// Returns the span encompassing this literal.\n    pub fn span(&self) -> Span {\n        Span::_new(self.inner.span())\n    }\n\n    /// Configures the span associated for this literal.\n    pub fn set_span(&mut self, span: Span) {\n        self.inner.set_span(span.inner);\n    }\n\n    /// Returns a `Span` that is a subset of `self.span()` containing only\n    /// the source bytes in range `range`. Returns `None` if the would-be\n    /// trimmed span is outside the bounds of `self`.\n    ///\n    /// Warning: the underlying [`proc_macro::Literal::subspan`] method is\n    /// nightly-only. When called from within a procedural macro not using a\n    /// nightly compiler, this method will always return `None`.\n    ///\n    /// [`proc_macro::Literal::subspan`]: https://doc.rust-lang.org/proc_macro/struct.Literal.html#method.subspan\n    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n        self.inner.subspan(range).map(Span::_new)\n    }\n}"],"Punct":["Clone","impl Debug for Punct {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = fmt.debug_struct(\"Punct\");\n        debug.field(\"char\", &self.ch);\n        debug.field(\"spacing\", &self.spacing);\n        imp::debug_span_field_if_nontrivial(&mut debug, self.span.inner);\n        debug.finish()\n    }\n}","impl Display for Punct {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.ch, f)\n    }\n}","impl Punct {\n    /// Creates a new `Punct` from the given character and spacing.\n    ///\n    /// The `ch` argument must be a valid punctuation character permitted by the\n    /// language, otherwise the function will panic.\n    ///\n    /// The returned `Punct` will have the default span of `Span::call_site()`\n    /// which can be further configured with the `set_span` method below.\n    pub fn new(ch: char, spacing: Spacing) -> Punct {\n        Punct {\n            ch,\n            spacing,\n            span: Span::call_site(),\n        }\n    }\n\n    /// Returns the value of this punctuation character as `char`.\n    pub fn as_char(&self) -> char {\n        self.ch\n    }\n\n    /// Returns the spacing of this punctuation character, indicating whether\n    /// it's immediately followed by another `Punct` in the token stream, so\n    /// they can potentially be combined into a multicharacter operator\n    /// (`Joint`), or it's followed by some other token or whitespace (`Alone`)\n    /// so the operator has certainly ended.\n    pub fn spacing(&self) -> Spacing {\n        self.spacing\n    }\n\n    /// Returns the span for this punctuation character.\n    pub fn span(&self) -> Span {\n        self.span\n    }\n\n    /// Configure the span for this punctuation character.\n    pub fn set_span(&mut self, span: Span) {\n        self.span = span;\n    }\n}"],"Spacing":["Clone","Copy","Debug","Eq","PartialEq"],"Span":["Clone","Copy","impl Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, f)\n    }\n}","impl From<proc_macro::Span> for crate::Span {\n    fn from(proc_span: proc_macro::Span) -> crate::Span {\n        crate::Span::_new(Span::Compiler(proc_span))\n    }\n}","impl Span {\n    fn _new(inner: imp::Span) -> Span {\n        Span {\n            inner,\n            _marker: Marker,\n        }\n    }\n\n    fn _new_stable(inner: fallback::Span) -> Span {\n        Span {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }\n\n    /// The span of the invocation of the current procedural macro.\n    ///\n    /// Identifiers created with this span will be resolved as if they were\n    /// written directly at the macro call location (call-site hygiene) and\n    /// other code at the macro call site will be able to refer to them as well.\n    pub fn call_site() -> Span {\n        Span::_new(imp::Span::call_site())\n    }\n\n    /// The span located at the invocation of the procedural macro, but with\n    /// local variables, labels, and `$crate` resolved at the definition site\n    /// of the macro. This is the same hygiene behavior as `macro_rules`.\n    ///\n    /// This function requires Rust 1.45 or later.\n    #[cfg(hygiene)]\n    pub fn mixed_site() -> Span {\n        Span::_new(imp::Span::mixed_site())\n    }\n\n    /// A span that resolves at the macro definition site.\n    ///\n    /// This method is semver exempt and not exposed by default.\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn def_site() -> Span {\n        Span::_new(imp::Span::def_site())\n    }\n\n    /// Creates a new span with the same line/column information as `self` but\n    /// that resolves symbols as though it were at `other`.\n    pub fn resolved_at(&self, other: Span) -> Span {\n        Span::_new(self.inner.resolved_at(other.inner))\n    }\n\n    /// Creates a new span with the same name resolution behavior as `self` but\n    /// with the line/column information of `other`.\n    pub fn located_at(&self, other: Span) -> Span {\n        Span::_new(self.inner.located_at(other.inner))\n    }\n\n    /// Convert `proc_macro2::Span` to `proc_macro::Span`.\n    ///\n    /// This method is available when building with a nightly compiler, or when\n    /// building with rustc 1.29+ *without* semver exempt features.\n    ///\n    /// # Panics\n    ///\n    /// Panics if called from outside of a procedural macro. Unlike\n    /// `proc_macro2::Span`, the `proc_macro::Span` type can only exist within\n    /// the context of a procedural macro invocation.\n    #[cfg(wrap_proc_macro)]\n    pub fn unwrap(self) -> proc_macro::Span {\n        self.inner.unwrap()\n    }\n\n    // Soft deprecated. Please use Span::unwrap.\n    #[cfg(wrap_proc_macro)]\n    #[doc(hidden)]\n    pub fn unstable(self) -> proc_macro::Span {\n        self.unwrap()\n    }\n\n    /// The original source file into which this span points.\n    ///\n    /// This method is semver exempt and not exposed by default.\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn source_file(&self) -> SourceFile {\n        SourceFile::_new(self.inner.source_file())\n    }\n\n    /// Get the starting line/column in the source file for this span.\n    ///\n    /// This method requires the `\"span-locations\"` feature to be enabled.\n    #[cfg(span_locations)]\n    pub fn start(&self) -> LineColumn {\n        let imp::LineColumn { line, column } = self.inner.start();\n        LineColumn { line, column }\n    }\n\n    /// Get the ending line/column in the source file for this span.\n    ///\n    /// This method requires the `\"span-locations\"` feature to be enabled.\n    #[cfg(span_locations)]\n    pub fn end(&self) -> LineColumn {\n        let imp::LineColumn { line, column } = self.inner.end();\n        LineColumn { line, column }\n    }\n\n    /// Create a new span encompassing `self` and `other`.\n    ///\n    /// Returns `None` if `self` and `other` are from different files.\n    ///\n    /// Warning: the underlying [`proc_macro::Span::join`] method is\n    /// nightly-only. When called from within a procedural macro not using a\n    /// nightly compiler, this method will always return `None`.\n    ///\n    /// [`proc_macro::Span::join`]: https://doc.rust-lang.org/proc_macro/struct.Span.html#method.join\n    pub fn join(&self, other: Span) -> Option<Span> {\n        self.inner.join(other.inner).map(Span::_new)\n    }\n\n    /// Compares two spans to see if they're equal.\n    ///\n    /// This method is semver exempt and not exposed by default.\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn eq(&self, other: &Span) -> bool {\n        self.inner.eq(&other.inner)\n    }\n}"],"TokenStream":["Clone","impl Debug for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(&self.inner, f)\n    }\n}","impl Default for TokenStream {\n    fn default() -> Self {\n        TokenStream::new()\n    }\n}","impl Display for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.inner, f)\n    }\n}","impl Extend<TokenStream> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n        self.inner\n            .extend(streams.into_iter().map(|stream| stream.inner))\n    }\n}","impl Extend<TokenTree> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, streams: I) {\n        self.inner.extend(streams)\n    }\n}","impl From<TokenTree> for TokenStream {\n    fn from(token: TokenTree) -> Self {\n        TokenStream::_new(imp::TokenStream::from(token))\n    }\n}","impl From<proc_macro::TokenStream> for TokenStream {\n    fn from(inner: proc_macro::TokenStream) -> TokenStream {\n        TokenStream::_new(inner.into())\n    }\n}","impl FromIterator<TokenStream> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n        TokenStream::_new(streams.into_iter().map(|i| i.inner).collect())\n    }\n}","impl FromIterator<TokenTree> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenTree>>(streams: I) -> Self {\n        TokenStream::_new(streams.into_iter().collect())\n    }\n}","impl FromStr for TokenStream {\n    type Err = LexError;\n\n    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n        let e = src.parse().map_err(|e| LexError {\n            inner: e,\n            _marker: Marker,\n        })?;\n        Ok(TokenStream::_new(e))\n    }\n}","impl IntoIterator for TokenStream {\n        type Item = TokenTree;\n        type IntoIter = IntoIter;\n\n        fn into_iter(self) -> IntoIter {\n            IntoIter {\n                inner: self.inner.into_iter(),\n                _marker: Marker,\n            }\n        }\n    }","impl TokenStream {\n    fn _new(inner: imp::TokenStream) -> TokenStream {\n        TokenStream {\n            inner,\n            _marker: Marker,\n        }\n    }\n\n    fn _new_stable(inner: fallback::TokenStream) -> TokenStream {\n        TokenStream {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }\n\n    /// Returns an empty `TokenStream` containing no token trees.\n    pub fn new() -> TokenStream {\n        TokenStream::_new(imp::TokenStream::new())\n    }\n\n    /// Checks if this `TokenStream` is empty.\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n}"],"TokenTree":["Clone","impl Debug for TokenTree {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Each of these has the name in the struct type in the derived debug,\n        // so don't bother with an extra layer of indirection\n        match self {\n            TokenTree::Group(t) => Debug::fmt(t, f),\n            TokenTree::Ident(t) => {\n                let mut debug = f.debug_struct(\"Ident\");\n                debug.field(\"sym\", &format_args!(\"{}\", t));\n                imp::debug_span_field_if_nontrivial(&mut debug, t.span().inner);\n                debug.finish()\n            }\n            TokenTree::Punct(t) => Debug::fmt(t, f),\n            TokenTree::Literal(t) => Debug::fmt(t, f),\n        }\n    }\n}","impl Display for TokenTree {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            TokenTree::Group(t) => Display::fmt(t, f),\n            TokenTree::Ident(t) => Display::fmt(t, f),\n            TokenTree::Punct(t) => Display::fmt(t, f),\n            TokenTree::Literal(t) => Display::fmt(t, f),\n        }\n    }\n}","impl From<Group> for TokenTree {\n    fn from(g: Group) -> TokenTree {\n        TokenTree::Group(g)\n    }\n}","impl From<Ident> for TokenTree {\n    fn from(g: Ident) -> TokenTree {\n        TokenTree::Ident(g)\n    }\n}","impl From<Literal> for TokenTree {\n    fn from(g: Literal) -> TokenTree {\n        TokenTree::Literal(g)\n    }\n}","impl From<Punct> for TokenTree {\n    fn from(g: Punct) -> TokenTree {\n        TokenTree::Punct(g)\n    }\n}","impl TokenTree {\n    /// Returns the span of this tree, delegating to the `span` method of\n    /// the contained token or a delimited stream.\n    pub fn span(&self) -> Span {\n        match self {\n            TokenTree::Group(t) => t.span(),\n            TokenTree::Ident(t) => t.span(),\n            TokenTree::Punct(t) => t.span(),\n            TokenTree::Literal(t) => t.span(),\n        }\n    }\n\n    /// Configures the span for *only this token*.\n    ///\n    /// Note that if this token is a `Group` then this method will not configure\n    /// the span of each of the internal tokens, this will simply delegate to\n    /// the `set_span` method of each variant.\n    pub fn set_span(&mut self, span: Span) {\n        match self {\n            TokenTree::Group(t) => t.set_span(span),\n            TokenTree::Ident(t) => t.set_span(span),\n            TokenTree::Punct(t) => t.set_span(span),\n            TokenTree::Literal(t) => t.set_span(span),\n        }\n    }\n}"],"fallback::Group":["Clone","impl Debug for Group {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = fmt.debug_struct(\"Group\");\n        debug.field(\"delimiter\", &self.delimiter);\n        debug.field(\"stream\", &self.stream);\n        debug_span_field_if_nontrivial(&mut debug, self.span);\n        debug.finish()\n    }\n}","impl Display for Group {\n    // We attempt to match libproc_macro's formatting.\n    // Empty parens: ()\n    // Nonempty parens: (...)\n    // Empty brackets: []\n    // Nonempty brackets: [...]\n    // Empty braces: { }\n    // Nonempty braces: { ... }\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (open, close) = match self.delimiter {\n            Delimiter::Parenthesis => (\"(\", \")\"),\n            Delimiter::Brace => (\"{ \", \"}\"),\n            Delimiter::Bracket => (\"[\", \"]\"),\n            Delimiter::None => (\"\", \"\"),\n        };\n\n        f.write_str(open)?;\n        Display::fmt(&self.stream, f)?;\n        if self.delimiter == Delimiter::Brace && !self.stream.inner.is_empty() {\n            f.write_str(\" \")?;\n        }\n        f.write_str(close)?;\n\n        Ok(())\n    }\n}","impl Group {\n    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n        Group {\n            delimiter,\n            stream,\n            span: Span::call_site(),\n        }\n    }\n\n    pub fn delimiter(&self) -> Delimiter {\n        self.delimiter\n    }\n\n    pub fn stream(&self) -> TokenStream {\n        self.stream.clone()\n    }\n\n    pub fn span(&self) -> Span {\n        self.span\n    }\n\n    pub fn span_open(&self) -> Span {\n        self.span.first_byte()\n    }\n\n    pub fn span_close(&self) -> Span {\n        self.span.last_byte()\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        self.span = span;\n    }\n}"],"fallback::Ident":["Clone","impl Debug for Ident {\n    // Ident(proc_macro), Ident(r#union)\n    #[cfg(not(span_locations))]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = f.debug_tuple(\"Ident\");\n        debug.field(&format_args!(\"{}\", self));\n        debug.finish()\n    }\n\n    // Ident {\n    //     sym: proc_macro,\n    //     span: bytes(128..138)\n    // }\n    #[cfg(span_locations)]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = f.debug_struct(\"Ident\");\n        debug.field(\"sym\", &format_args!(\"{}\", self));\n        debug_span_field_if_nontrivial(&mut debug, self.span);\n        debug.finish()\n    }\n}","impl Display for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.raw {\n            f.write_str(\"r#\")?;\n        }\n        Display::fmt(&self.sym, f)\n    }\n}","impl Ident {\n    fn _new(string: &str, raw: bool, span: Span) -> Ident {\n        validate_ident(string);\n\n        Ident {\n            sym: string.to_owned(),\n            span,\n            raw,\n        }\n    }\n\n    pub fn new(string: &str, span: Span) -> Ident {\n        Ident::_new(string, false, span)\n    }\n\n    pub fn new_raw(string: &str, span: Span) -> Ident {\n        Ident::_new(string, true, span)\n    }\n\n    pub fn span(&self) -> Span {\n        self.span\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        self.span = span;\n    }\n}","impl PartialEq for Ident {\n    fn eq(&self, other: &Ident) -> bool {\n        self.sym == other.sym && self.raw == other.raw\n    }\n}","impl<T> PartialEq<T> for Ident\nwhere\n    T: ?Sized + AsRef<str>,\n{\n    fn eq(&self, other: &T) -> bool {\n        let other = other.as_ref();\n        if self.raw {\n            other.starts_with(\"r#\") && self.sym == other[2..]\n        } else {\n            self.sym == other\n        }\n    }\n}"],"fallback::LexError":["Debug","impl Display for LexError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(\"cannot parse string into token stream\")\n    }\n}"],"fallback::LineColumn":["Clone","Copy","Debug","Eq","PartialEq"],"fallback::Literal":["Clone","impl Debug for Literal {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = fmt.debug_struct(\"Literal\");\n        debug.field(\"lit\", &format_args!(\"{}\", self.text));\n        debug_span_field_if_nontrivial(&mut debug, self.span);\n        debug.finish()\n    }\n}","impl Display for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.text, f)\n    }\n}","impl Literal {\n    pub(crate) fn _new(text: String) -> Literal {\n        Literal {\n            text,\n            span: Span::call_site(),\n        }\n    }\n\n    suffixed_numbers! {\n        u8_suffixed => u8,\n        u16_suffixed => u16,\n        u32_suffixed => u32,\n        u64_suffixed => u64,\n        u128_suffixed => u128,\n        usize_suffixed => usize,\n        i8_suffixed => i8,\n        i16_suffixed => i16,\n        i32_suffixed => i32,\n        i64_suffixed => i64,\n        i128_suffixed => i128,\n        isize_suffixed => isize,\n\n        f32_suffixed => f32,\n        f64_suffixed => f64,\n    }\n\n    unsuffixed_numbers! {\n        u8_unsuffixed => u8,\n        u16_unsuffixed => u16,\n        u32_unsuffixed => u32,\n        u64_unsuffixed => u64,\n        u128_unsuffixed => u128,\n        usize_unsuffixed => usize,\n        i8_unsuffixed => i8,\n        i16_unsuffixed => i16,\n        i32_unsuffixed => i32,\n        i64_unsuffixed => i64,\n        i128_unsuffixed => i128,\n        isize_unsuffixed => isize,\n    }\n\n    pub fn f32_unsuffixed(f: f32) -> Literal {\n        let mut s = f.to_string();\n        if !s.contains('.') {\n            s.push_str(\".0\");\n        }\n        Literal::_new(s)\n    }\n\n    pub fn f64_unsuffixed(f: f64) -> Literal {\n        let mut s = f.to_string();\n        if !s.contains('.') {\n            s.push_str(\".0\");\n        }\n        Literal::_new(s)\n    }\n\n    pub fn string(t: &str) -> Literal {\n        let mut text = String::with_capacity(t.len() + 2);\n        text.push('\"');\n        for c in t.chars() {\n            if c == '\\'' {\n                // escape_debug turns this into \"\\'\" which is unnecessary.\n                text.push(c);\n            } else {\n                text.extend(c.escape_debug());\n            }\n        }\n        text.push('\"');\n        Literal::_new(text)\n    }\n\n    pub fn character(t: char) -> Literal {\n        let mut text = String::new();\n        text.push('\\'');\n        if t == '\"' {\n            // escape_debug turns this into '\\\"' which is unnecessary.\n            text.push(t);\n        } else {\n            text.extend(t.escape_debug());\n        }\n        text.push('\\'');\n        Literal::_new(text)\n    }\n\n    pub fn byte_string(bytes: &[u8]) -> Literal {\n        let mut escaped = \"b\\\"\".to_string();\n        for b in bytes {\n            #[allow(clippy::match_overlapping_arm)]\n            match *b {\n                b'\\0' => escaped.push_str(r\"\\0\"),\n                b'\\t' => escaped.push_str(r\"\\t\"),\n                b'\\n' => escaped.push_str(r\"\\n\"),\n                b'\\r' => escaped.push_str(r\"\\r\"),\n                b'\"' => escaped.push_str(\"\\\\\\\"\"),\n                b'\\\\' => escaped.push_str(\"\\\\\\\\\"),\n                b'\\x20'..=b'\\x7E' => escaped.push(*b as char),\n                _ => escaped.push_str(&format!(\"\\\\x{:02X}\", b)),\n            }\n        }\n        escaped.push('\"');\n        Literal::_new(escaped)\n    }\n\n    pub fn span(&self) -> Span {\n        self.span\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        self.span = span;\n    }\n\n    pub fn subspan<R: RangeBounds<usize>>(&self, _range: R) -> Option<Span> {\n        None\n    }\n}"],"fallback::SourceFile":["Clone","Eq","PartialEq","impl Debug for SourceFile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SourceFile\")\n            .field(\"path\", &self.path())\n            .field(\"is_real\", &self.is_real())\n            .finish()\n    }\n}","impl SourceFile {\n    /// Get the path to this source file as a string.\n    pub fn path(&self) -> PathBuf {\n        self.path.clone()\n    }\n\n    pub fn is_real(&self) -> bool {\n        // XXX(nika): Support real files in the future?\n        false\n    }\n}"],"fallback::Span":["Clone","Copy","Eq","PartialEq","impl Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        #[cfg(span_locations)]\n        return write!(f, \"bytes({}..{})\", self.lo, self.hi);\n\n        #[cfg(not(span_locations))]\n        write!(f, \"Span\")\n    }\n}","impl Span {\n    #[cfg(not(span_locations))]\n    pub fn call_site() -> Span {\n        Span {}\n    }\n\n    #[cfg(span_locations)]\n    pub fn call_site() -> Span {\n        Span { lo: 0, hi: 0 }\n    }\n\n    #[cfg(hygiene)]\n    pub fn mixed_site() -> Span {\n        Span::call_site()\n    }\n\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn def_site() -> Span {\n        Span::call_site()\n    }\n\n    pub fn resolved_at(&self, _other: Span) -> Span {\n        // Stable spans consist only of line/column information, so\n        // `resolved_at` and `located_at` only select which span the\n        // caller wants line/column information from.\n        *self\n    }\n\n    pub fn located_at(&self, other: Span) -> Span {\n        other\n    }\n\n    #[cfg(procmacro2_semver_exempt)]\n    pub fn source_file(&self) -> SourceFile {\n        SOURCE_MAP.with(|cm| {\n            let cm = cm.borrow();\n            let fi = cm.fileinfo(*self);\n            SourceFile {\n                path: Path::new(&fi.name).to_owned(),\n            }\n        })\n    }\n\n    #[cfg(span_locations)]\n    pub fn start(&self) -> LineColumn {\n        SOURCE_MAP.with(|cm| {\n            let cm = cm.borrow();\n            let fi = cm.fileinfo(*self);\n            fi.offset_line_column(self.lo as usize)\n        })\n    }\n\n    #[cfg(span_locations)]\n    pub fn end(&self) -> LineColumn {\n        SOURCE_MAP.with(|cm| {\n            let cm = cm.borrow();\n            let fi = cm.fileinfo(*self);\n            fi.offset_line_column(self.hi as usize)\n        })\n    }\n\n    #[cfg(not(span_locations))]\n    pub fn join(&self, _other: Span) -> Option<Span> {\n        Some(Span {})\n    }\n\n    #[cfg(span_locations)]\n    pub fn join(&self, other: Span) -> Option<Span> {\n        SOURCE_MAP.with(|cm| {\n            let cm = cm.borrow();\n            // If `other` is not within the same FileInfo as us, return None.\n            if !cm.fileinfo(*self).span_within(other) {\n                return None;\n            }\n            Some(Span {\n                lo: cmp::min(self.lo, other.lo),\n                hi: cmp::max(self.hi, other.hi),\n            })\n        })\n    }\n\n    #[cfg(not(span_locations))]\n    fn first_byte(self) -> Self {\n        self\n    }\n\n    #[cfg(span_locations)]\n    fn first_byte(self) -> Self {\n        Span {\n            lo: self.lo,\n            hi: cmp::min(self.lo.saturating_add(1), self.hi),\n        }\n    }\n\n    #[cfg(not(span_locations))]\n    fn last_byte(self) -> Self {\n        self\n    }\n\n    #[cfg(span_locations)]\n    fn last_byte(self) -> Self {\n        Span {\n            lo: cmp::max(self.hi.saturating_sub(1), self.lo),\n            hi: self.hi,\n        }\n    }\n}"],"fallback::TokenStream":["Clone","impl Debug for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(\"TokenStream \")?;\n        f.debug_list().entries(self.clone()).finish()\n    }\n}","impl Display for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut joint = false;\n        for (i, tt) in self.inner.iter().enumerate() {\n            if i != 0 && !joint {\n                write!(f, \" \")?;\n            }\n            joint = false;\n            match tt {\n                TokenTree::Group(tt) => Display::fmt(tt, f),\n                TokenTree::Ident(tt) => Display::fmt(tt, f),\n                TokenTree::Punct(tt) => {\n                    joint = tt.spacing() == Spacing::Joint;\n                    Display::fmt(tt, f)\n                }\n                TokenTree::Literal(tt) => Display::fmt(tt, f),\n            }?\n        }\n\n        Ok(())\n    }\n}","impl Drop for TokenStream {\n    fn drop(&mut self) {\n        while let Some(token) = self.inner.pop() {\n            let group = match token {\n                TokenTree::Group(group) => group.inner,\n                _ => continue,\n            };\n            #[cfg(wrap_proc_macro)]\n            let group = match group {\n                crate::imp::Group::Fallback(group) => group,\n                _ => continue,\n            };\n            let mut group = group;\n            self.inner.extend(group.stream.take_inner());\n        }\n    }\n}","impl Extend<TokenStream> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n        self.inner.extend(streams.into_iter().flatten());\n    }\n}","impl Extend<TokenTree> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, tokens: I) {\n        tokens.into_iter().for_each(|token| self.push_token(token));\n    }\n}","impl From<TokenTree> for TokenStream {\n    fn from(tree: TokenTree) -> TokenStream {\n        let mut stream = TokenStream::new();\n        stream.push_token(tree);\n        stream\n    }\n}","impl From<proc_macro::TokenStream> for TokenStream {\n    fn from(inner: proc_macro::TokenStream) -> TokenStream {\n        inner\n            .to_string()\n            .parse()\n            .expect(\"compiler token stream parse failed\")\n    }\n}","impl FromIterator<TokenStream> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n        let mut v = Vec::new();\n\n        for mut stream in streams {\n            v.extend(stream.take_inner());\n        }\n\n        TokenStream { inner: v }\n    }\n}","impl FromIterator<TokenTree> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenTree>>(tokens: I) -> Self {\n        let mut stream = TokenStream::new();\n        stream.extend(tokens);\n        stream\n    }\n}","impl FromStr for TokenStream {\n    type Err = LexError;\n\n    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n        // Create a dummy file & add it to the source map\n        let cursor = get_cursor(src);\n\n        let (rest, tokens) = token_stream(cursor)?;\n        if rest.is_empty() {\n            Ok(tokens)\n        } else {\n            Err(LexError)\n        }\n    }\n}","impl IntoIterator for TokenStream {\n    type Item = TokenTree;\n    type IntoIter = TokenTreeIter;\n\n    fn into_iter(mut self) -> TokenTreeIter {\n        self.take_inner().into_iter()\n    }\n}","impl TokenStream {\n    pub fn new() -> TokenStream {\n        TokenStream { inner: Vec::new() }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.inner.len() == 0\n    }\n\n    fn take_inner(&mut self) -> Vec<TokenTree> {\n        mem::replace(&mut self.inner, Vec::new())\n    }\n\n    fn push_token(&mut self, token: TokenTree) {\n        // https://github.com/alexcrichton/proc-macro2/issues/235\n        match token {\n            #[cfg(not(no_bind_by_move_pattern_guard))]\n            TokenTree::Literal(crate::Literal {\n                #[cfg(wrap_proc_macro)]\n                    inner: crate::imp::Literal::Fallback(literal),\n                #[cfg(not(wrap_proc_macro))]\n                    inner: literal,\n                ..\n            }) if literal.text.starts_with('-') => {\n                push_negative_literal(self, literal);\n            }\n            #[cfg(no_bind_by_move_pattern_guard)]\n            TokenTree::Literal(crate::Literal {\n                #[cfg(wrap_proc_macro)]\n                    inner: crate::imp::Literal::Fallback(literal),\n                #[cfg(not(wrap_proc_macro))]\n                    inner: literal,\n                ..\n            }) => {\n                if literal.text.starts_with('-') {\n                    push_negative_literal(self, literal);\n                } else {\n                    self.inner\n                        .push(TokenTree::Literal(crate::Literal::_new_stable(literal)));\n                }\n            }\n            _ => self.inner.push(token),\n        }\n\n        #[cold]\n        fn push_negative_literal(stream: &mut TokenStream, mut literal: Literal) {\n            literal.text.remove(0);\n            let mut punct = crate::Punct::new('-', Spacing::Alone);\n            punct.set_span(crate::Span::_new_stable(literal.span));\n            stream.inner.push(TokenTree::Punct(punct));\n            stream\n                .inner\n                .push(TokenTree::Literal(crate::Literal::_new_stable(literal)));\n        }\n    }\n}"],"imp::DeferredTokenStream":["Clone","impl DeferredTokenStream {\n    fn new(stream: proc_macro::TokenStream) -> Self {\n        DeferredTokenStream {\n            stream,\n            extra: Vec::new(),\n        }\n    }\n\n    fn is_empty(&self) -> bool {\n        self.stream.is_empty() && self.extra.is_empty()\n    }\n\n    fn evaluate_now(&mut self) {\n        // If-check provides a fast short circuit for the common case of `extra`\n        // being empty, which saves a round trip over the proc macro bridge.\n        // Improves macro expansion time in winrt by 6% in debug mode.\n        if !self.extra.is_empty() {\n            self.stream.extend(self.extra.drain(..));\n        }\n    }\n\n    fn into_token_stream(mut self) -> proc_macro::TokenStream {\n        self.evaluate_now();\n        self.stream\n    }\n}"],"imp::Group":["Clone","impl Debug for Group {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Group::Compiler(group) => Debug::fmt(group, formatter),\n            Group::Fallback(group) => Debug::fmt(group, formatter),\n        }\n    }\n}","impl Display for Group {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Group::Compiler(group) => Display::fmt(group, formatter),\n            Group::Fallback(group) => Display::fmt(group, formatter),\n        }\n    }\n}","impl From<fallback::Group> for Group {\n    fn from(g: fallback::Group) -> Self {\n        Group::Fallback(g)\n    }\n}","impl Group {\n    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n        match stream {\n            TokenStream::Compiler(tts) => {\n                let delimiter = match delimiter {\n                    Delimiter::Parenthesis => proc_macro::Delimiter::Parenthesis,\n                    Delimiter::Bracket => proc_macro::Delimiter::Bracket,\n                    Delimiter::Brace => proc_macro::Delimiter::Brace,\n                    Delimiter::None => proc_macro::Delimiter::None,\n                };\n                Group::Compiler(proc_macro::Group::new(delimiter, tts.into_token_stream()))\n            }\n            TokenStream::Fallback(stream) => {\n                Group::Fallback(fallback::Group::new(delimiter, stream))\n            }\n        }\n    }\n\n    pub fn delimiter(&self) -> Delimiter {\n        match self {\n            Group::Compiler(g) => match g.delimiter() {\n                proc_macro::Delimiter::Parenthesis => Delimiter::Parenthesis,\n                proc_macro::Delimiter::Bracket => Delimiter::Bracket,\n                proc_macro::Delimiter::Brace => Delimiter::Brace,\n                proc_macro::Delimiter::None => Delimiter::None,\n            },\n            Group::Fallback(g) => g.delimiter(),\n        }\n    }\n\n    pub fn stream(&self) -> TokenStream {\n        match self {\n            Group::Compiler(g) => TokenStream::Compiler(DeferredTokenStream::new(g.stream())),\n            Group::Fallback(g) => TokenStream::Fallback(g.stream()),\n        }\n    }\n\n    pub fn span(&self) -> Span {\n        match self {\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span()),\n        }\n    }\n\n    pub fn span_open(&self) -> Span {\n        match self {\n            #[cfg(proc_macro_span)]\n            Group::Compiler(g) => Span::Compiler(g.span_open()),\n            #[cfg(not(proc_macro_span))]\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span_open()),\n        }\n    }\n\n    pub fn span_close(&self) -> Span {\n        match self {\n            #[cfg(proc_macro_span)]\n            Group::Compiler(g) => Span::Compiler(g.span_close()),\n            #[cfg(not(proc_macro_span))]\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span_close()),\n        }\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        match (self, span) {\n            (Group::Compiler(g), Span::Compiler(s)) => g.set_span(s),\n            (Group::Fallback(g), Span::Fallback(s)) => g.set_span(s),\n            _ => mismatch(),\n        }\n    }\n\n    fn unwrap_nightly(self) -> proc_macro::Group {\n        match self {\n            Group::Compiler(g) => g,\n            Group::Fallback(_) => mismatch(),\n        }\n    }\n}"],"imp::Ident":["Clone","impl Debug for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Ident::Compiler(t) => Debug::fmt(t, f),\n            Ident::Fallback(t) => Debug::fmt(t, f),\n        }\n    }\n}","impl Display for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Ident::Compiler(t) => Display::fmt(t, f),\n            Ident::Fallback(t) => Display::fmt(t, f),\n        }\n    }\n}","impl Ident {\n    pub fn new(string: &str, span: Span) -> Ident {\n        match span {\n            Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new(string, s)),\n            Span::Fallback(s) => Ident::Fallback(fallback::Ident::new(string, s)),\n        }\n    }\n\n    pub fn new_raw(string: &str, span: Span) -> Ident {\n        match span {\n            Span::Compiler(s) => {\n                let p: proc_macro::TokenStream = string.parse().unwrap();\n                let ident = match p.into_iter().next() {\n                    Some(proc_macro::TokenTree::Ident(mut i)) => {\n                        i.set_span(s);\n                        i\n                    }\n                    _ => panic!(),\n                };\n                Ident::Compiler(ident)\n            }\n            Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_raw(string, s)),\n        }\n    }\n\n    pub fn span(&self) -> Span {\n        match self {\n            Ident::Compiler(t) => Span::Compiler(t.span()),\n            Ident::Fallback(t) => Span::Fallback(t.span()),\n        }\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        match (self, span) {\n            (Ident::Compiler(t), Span::Compiler(s)) => t.set_span(s),\n            (Ident::Fallback(t), Span::Fallback(s)) => t.set_span(s),\n            _ => mismatch(),\n        }\n    }\n\n    fn unwrap_nightly(self) -> proc_macro::Ident {\n        match self {\n            Ident::Compiler(s) => s,\n            Ident::Fallback(_) => mismatch(),\n        }\n    }\n}","impl PartialEq for Ident {\n    fn eq(&self, other: &Ident) -> bool {\n        match (self, other) {\n            (Ident::Compiler(t), Ident::Compiler(o)) => t.to_string() == o.to_string(),\n            (Ident::Fallback(t), Ident::Fallback(o)) => t == o,\n            _ => mismatch(),\n        }\n    }\n}","impl<T> PartialEq<T> for Ident\nwhere\n    T: ?Sized + AsRef<str>,\n{\n    fn eq(&self, other: &T) -> bool {\n        let other = other.as_ref();\n        match self {\n            Ident::Compiler(t) => t.to_string() == other,\n            Ident::Fallback(t) => t == other,\n        }\n    }\n}"],"imp::LexError":["impl Debug for LexError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            LexError::Compiler(e) => Debug::fmt(e, f),\n            LexError::Fallback(e) => Debug::fmt(e, f),\n        }\n    }\n}","impl Display for LexError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            #[cfg(lexerror_display)]\n            LexError::Compiler(e) => Display::fmt(e, f),\n            #[cfg(not(lexerror_display))]\n            LexError::Compiler(_e) => Display::fmt(&fallback::LexError, f),\n            LexError::Fallback(e) => Display::fmt(e, f),\n        }\n    }\n}","impl From<fallback::LexError> for LexError {\n    fn from(e: fallback::LexError) -> LexError {\n        LexError::Fallback(e)\n    }\n}","impl From<proc_macro::LexError> for LexError {\n    fn from(e: proc_macro::LexError) -> LexError {\n        LexError::Compiler(e)\n    }\n}"],"imp::Literal":["Clone","impl Debug for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Literal::Compiler(t) => Debug::fmt(t, f),\n            Literal::Fallback(t) => Debug::fmt(t, f),\n        }\n    }\n}","impl Display for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Literal::Compiler(t) => Display::fmt(t, f),\n            Literal::Fallback(t) => Display::fmt(t, f),\n        }\n    }\n}","impl From<fallback::Literal> for Literal {\n    fn from(s: fallback::Literal) -> Literal {\n        Literal::Fallback(s)\n    }\n}","impl Literal {\n    suffixed_numbers! {\n        u8_suffixed => u8,\n        u16_suffixed => u16,\n        u32_suffixed => u32,\n        u64_suffixed => u64,\n        u128_suffixed => u128,\n        usize_suffixed => usize,\n        i8_suffixed => i8,\n        i16_suffixed => i16,\n        i32_suffixed => i32,\n        i64_suffixed => i64,\n        i128_suffixed => i128,\n        isize_suffixed => isize,\n\n        f32_suffixed => f32,\n        f64_suffixed => f64,\n    }\n\n    unsuffixed_integers! {\n        u8_unsuffixed => u8,\n        u16_unsuffixed => u16,\n        u32_unsuffixed => u32,\n        u64_unsuffixed => u64,\n        u128_unsuffixed => u128,\n        usize_unsuffixed => usize,\n        i8_unsuffixed => i8,\n        i16_unsuffixed => i16,\n        i32_unsuffixed => i32,\n        i64_unsuffixed => i64,\n        i128_unsuffixed => i128,\n        isize_unsuffixed => isize,\n    }\n\n    pub fn f32_unsuffixed(f: f32) -> Literal {\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::f32_unsuffixed(f))\n        } else {\n            Literal::Fallback(fallback::Literal::f32_unsuffixed(f))\n        }\n    }\n\n    pub fn f64_unsuffixed(f: f64) -> Literal {\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::f64_unsuffixed(f))\n        } else {\n            Literal::Fallback(fallback::Literal::f64_unsuffixed(f))\n        }\n    }\n\n    pub fn string(t: &str) -> Literal {\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::string(t))\n        } else {\n            Literal::Fallback(fallback::Literal::string(t))\n        }\n    }\n\n    pub fn character(t: char) -> Literal {\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::character(t))\n        } else {\n            Literal::Fallback(fallback::Literal::character(t))\n        }\n    }\n\n    pub fn byte_string(bytes: &[u8]) -> Literal {\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::byte_string(bytes))\n        } else {\n            Literal::Fallback(fallback::Literal::byte_string(bytes))\n        }\n    }\n\n    pub fn span(&self) -> Span {\n        match self {\n            Literal::Compiler(lit) => Span::Compiler(lit.span()),\n            Literal::Fallback(lit) => Span::Fallback(lit.span()),\n        }\n    }\n\n    pub fn set_span(&mut self, span: Span) {\n        match (self, span) {\n            (Literal::Compiler(lit), Span::Compiler(s)) => lit.set_span(s),\n            (Literal::Fallback(lit), Span::Fallback(s)) => lit.set_span(s),\n            _ => mismatch(),\n        }\n    }\n\n    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n        match self {\n            #[cfg(proc_macro_span)]\n            Literal::Compiler(lit) => lit.subspan(range).map(Span::Compiler),\n            #[cfg(not(proc_macro_span))]\n            Literal::Compiler(_lit) => None,\n            Literal::Fallback(lit) => lit.subspan(range).map(Span::Fallback),\n        }\n    }\n\n    fn unwrap_nightly(self) -> proc_macro::Literal {\n        match self {\n            Literal::Compiler(s) => s,\n            Literal::Fallback(_) => mismatch(),\n        }\n    }\n}"],"imp::Span":["Clone","Copy","impl Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Span::Compiler(s) => Debug::fmt(s, f),\n            Span::Fallback(s) => Debug::fmt(s, f),\n        }\n    }\n}","impl From<fallback::Span> for Span {\n    fn from(inner: fallback::Span) -> Span {\n        Span::Fallback(inner)\n    }\n}","impl Span {\n    pub fn call_site() -> Span {\n        if inside_proc_macro() {\n            Span::Compiler(proc_macro::Span::call_site())\n        } else {\n            Span::Fallback(fallback::Span::call_site())\n        }\n    }\n\n    #[cfg(hygiene)]\n    pub fn mixed_site() -> Span {\n        if inside_proc_macro() {\n            Span::Compiler(proc_macro::Span::mixed_site())\n        } else {\n            Span::Fallback(fallback::Span::mixed_site())\n        }\n    }\n\n    #[cfg(super_unstable)]\n    pub fn def_site() -> Span {\n        if inside_proc_macro() {\n            Span::Compiler(proc_macro::Span::def_site())\n        } else {\n            Span::Fallback(fallback::Span::def_site())\n        }\n    }\n\n    pub fn resolved_at(&self, other: Span) -> Span {\n        match (self, other) {\n            #[cfg(hygiene)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.resolved_at(b)),\n\n            // Name resolution affects semantics, but location is only cosmetic\n            #[cfg(not(hygiene))]\n            (Span::Compiler(_), Span::Compiler(_)) => other,\n\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.resolved_at(b)),\n            _ => mismatch(),\n        }\n    }\n\n    pub fn located_at(&self, other: Span) -> Span {\n        match (self, other) {\n            #[cfg(hygiene)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.located_at(b)),\n\n            // Name resolution affects semantics, but location is only cosmetic\n            #[cfg(not(hygiene))]\n            (Span::Compiler(_), Span::Compiler(_)) => *self,\n\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.located_at(b)),\n            _ => mismatch(),\n        }\n    }\n\n    pub fn unwrap(self) -> proc_macro::Span {\n        match self {\n            Span::Compiler(s) => s,\n            Span::Fallback(_) => panic!(\"proc_macro::Span is only available in procedural macros\"),\n        }\n    }\n\n    #[cfg(super_unstable)]\n    pub fn source_file(&self) -> SourceFile {\n        match self {\n            Span::Compiler(s) => SourceFile::nightly(s.source_file()),\n            Span::Fallback(s) => SourceFile::Fallback(s.source_file()),\n        }\n    }\n\n    #[cfg(any(super_unstable, feature = \"span-locations\"))]\n    pub fn start(&self) -> LineColumn {\n        match self {\n            #[cfg(proc_macro_span)]\n            Span::Compiler(s) => {\n                let proc_macro::LineColumn { line, column } = s.start();\n                LineColumn { line, column }\n            }\n            #[cfg(not(proc_macro_span))]\n            Span::Compiler(_) => LineColumn { line: 0, column: 0 },\n            Span::Fallback(s) => {\n                let fallback::LineColumn { line, column } = s.start();\n                LineColumn { line, column }\n            }\n        }\n    }\n\n    #[cfg(any(super_unstable, feature = \"span-locations\"))]\n    pub fn end(&self) -> LineColumn {\n        match self {\n            #[cfg(proc_macro_span)]\n            Span::Compiler(s) => {\n                let proc_macro::LineColumn { line, column } = s.end();\n                LineColumn { line, column }\n            }\n            #[cfg(not(proc_macro_span))]\n            Span::Compiler(_) => LineColumn { line: 0, column: 0 },\n            Span::Fallback(s) => {\n                let fallback::LineColumn { line, column } = s.end();\n                LineColumn { line, column }\n            }\n        }\n    }\n\n    pub fn join(&self, other: Span) -> Option<Span> {\n        let ret = match (self, other) {\n            #[cfg(proc_macro_span)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.join(b)?),\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.join(b)?),\n            _ => return None,\n        };\n        Some(ret)\n    }\n\n    #[cfg(super_unstable)]\n    pub fn eq(&self, other: &Span) -> bool {\n        match (self, other) {\n            (Span::Compiler(a), Span::Compiler(b)) => a.eq(b),\n            (Span::Fallback(a), Span::Fallback(b)) => a.eq(b),\n            _ => false,\n        }\n    }\n\n    fn unwrap_nightly(self) -> proc_macro::Span {\n        match self {\n            Span::Compiler(s) => s,\n            Span::Fallback(_) => mismatch(),\n        }\n    }\n}"],"imp::TokenStream":["Clone","impl Debug for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            TokenStream::Compiler(tts) => Debug::fmt(&tts.clone().into_token_stream(), f),\n            TokenStream::Fallback(tts) => Debug::fmt(tts, f),\n        }\n    }\n}","impl Display for TokenStream {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            TokenStream::Compiler(tts) => Display::fmt(&tts.clone().into_token_stream(), f),\n            TokenStream::Fallback(tts) => Display::fmt(tts, f),\n        }\n    }\n}","impl Extend<TokenStream> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n        match self {\n            TokenStream::Compiler(tts) => {\n                tts.evaluate_now();\n                tts.stream\n                    .extend(streams.into_iter().map(TokenStream::unwrap_nightly));\n            }\n            TokenStream::Fallback(tts) => {\n                tts.extend(streams.into_iter().map(TokenStream::unwrap_stable));\n            }\n        }\n    }\n}","impl Extend<TokenTree> for TokenStream {\n    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, stream: I) {\n        match self {\n            TokenStream::Compiler(tts) => {\n                // Here is the reason for DeferredTokenStream.\n                for token in stream {\n                    tts.extra.push(into_compiler_token(token));\n                }\n            }\n            TokenStream::Fallback(tts) => tts.extend(stream),\n        }\n    }\n}","impl From<TokenTree> for TokenStream {\n    fn from(token: TokenTree) -> TokenStream {\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(into_compiler_token(token).into()))\n        } else {\n            TokenStream::Fallback(token.into())\n        }\n    }\n}","impl From<fallback::TokenStream> for TokenStream {\n    fn from(inner: fallback::TokenStream) -> TokenStream {\n        TokenStream::Fallback(inner)\n    }\n}","impl From<proc_macro::TokenStream> for TokenStream {\n    fn from(inner: proc_macro::TokenStream) -> TokenStream {\n        TokenStream::Compiler(DeferredTokenStream::new(inner))\n    }\n}","impl FromIterator<TokenStream> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n        let mut streams = streams.into_iter();\n        match streams.next() {\n            Some(TokenStream::Compiler(mut first)) => {\n                first.evaluate_now();\n                first.stream.extend(streams.map(|s| match s {\n                    TokenStream::Compiler(s) => s.into_token_stream(),\n                    TokenStream::Fallback(_) => mismatch(),\n                }));\n                TokenStream::Compiler(first)\n            }\n            Some(TokenStream::Fallback(mut first)) => {\n                first.extend(streams.map(|s| match s {\n                    TokenStream::Fallback(s) => s,\n                    TokenStream::Compiler(_) => mismatch(),\n                }));\n                TokenStream::Fallback(first)\n            }\n            None => TokenStream::new(),\n        }\n    }\n}","impl FromIterator<TokenTree> for TokenStream {\n    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(\n                trees.into_iter().map(into_compiler_token).collect(),\n            ))\n        } else {\n            TokenStream::Fallback(trees.into_iter().collect())\n        }\n    }\n}","impl FromStr for TokenStream {\n    type Err = LexError;\n\n    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n        if inside_proc_macro() {\n            Ok(TokenStream::Compiler(DeferredTokenStream::new(\n                proc_macro_parse(src)?,\n            )))\n        } else {\n            Ok(TokenStream::Fallback(src.parse()?))\n        }\n    }\n}","impl IntoIterator for TokenStream {\n    type Item = TokenTree;\n    type IntoIter = TokenTreeIter;\n\n    fn into_iter(self) -> TokenTreeIter {\n        match self {\n            TokenStream::Compiler(tts) => {\n                TokenTreeIter::Compiler(tts.into_token_stream().into_iter())\n            }\n            TokenStream::Fallback(tts) => TokenTreeIter::Fallback(tts.into_iter()),\n        }\n    }\n}","impl TokenStream {\n    pub fn new() -> TokenStream {\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::new()))\n        } else {\n            TokenStream::Fallback(fallback::TokenStream::new())\n        }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        match self {\n            TokenStream::Compiler(tts) => tts.is_empty(),\n            TokenStream::Fallback(tts) => tts.is_empty(),\n        }\n    }\n\n    fn unwrap_nightly(self) -> proc_macro::TokenStream {\n        match self {\n            TokenStream::Compiler(s) => s.into_token_stream(),\n            TokenStream::Fallback(_) => mismatch(),\n        }\n    }\n\n    fn unwrap_stable(self) -> fallback::TokenStream {\n        match self {\n            TokenStream::Compiler(_) => mismatch(),\n            TokenStream::Fallback(s) => s,\n        }\n    }\n}"],"imp::TokenTreeIter":["Clone","impl Debug for TokenTreeIter {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"TokenTreeIter\").finish()\n    }\n}","impl Iterator for TokenTreeIter {\n    type Item = TokenTree;\n\n    fn next(&mut self) -> Option<TokenTree> {\n        let token = match self {\n            TokenTreeIter::Compiler(iter) => iter.next()?,\n            TokenTreeIter::Fallback(iter) => return iter.next(),\n        };\n        Some(match token {\n            proc_macro::TokenTree::Group(tt) => crate::Group::_new(Group::Compiler(tt)).into(),\n            proc_macro::TokenTree::Punct(tt) => {\n                let spacing = match tt.spacing() {\n                    proc_macro::Spacing::Joint => Spacing::Joint,\n                    proc_macro::Spacing::Alone => Spacing::Alone,\n                };\n                let mut o = Punct::new(tt.as_char(), spacing);\n                o.set_span(crate::Span::_new(Span::Compiler(tt.span())));\n                o.into()\n            }\n            proc_macro::TokenTree::Ident(s) => crate::Ident::_new(Ident::Compiler(s)).into(),\n            proc_macro::TokenTree::Literal(l) => crate::Literal::_new(Literal::Compiler(l)).into(),\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self {\n            TokenTreeIter::Compiler(tts) => tts.size_hint(),\n            TokenTreeIter::Fallback(tts) => tts.size_hint(),\n        }\n    }\n}"],"marker::ProcMacroAutoTraits":["impl RefUnwindSafe for ProcMacroAutoTraits {}","impl UnwindSafe for ProcMacroAutoTraits {}"],"parse::Cursor":["Clone","Copy","Eq","PartialEq","impl<'a> Cursor<'a> {\n    fn advance(&self, bytes: usize) -> Cursor<'a> {\n        let (_front, rest) = self.rest.split_at(bytes);\n        Cursor {\n            rest,\n            #[cfg(span_locations)]\n            off: self.off + _front.chars().count() as u32,\n        }\n    }\n\n    fn starts_with(&self, s: &str) -> bool {\n        self.rest.starts_with(s)\n    }\n\n    pub(crate) fn is_empty(&self) -> bool {\n        self.rest.is_empty()\n    }\n\n    fn len(&self) -> usize {\n        self.rest.len()\n    }\n\n    fn as_bytes(&self) -> &'a [u8] {\n        self.rest.as_bytes()\n    }\n\n    fn bytes(&self) -> Bytes<'a> {\n        self.rest.bytes()\n    }\n\n    fn chars(&self) -> Chars<'a> {\n        self.rest.chars()\n    }\n\n    fn char_indices(&self) -> CharIndices<'a> {\n        self.rest.char_indices()\n    }\n\n    fn parse(&self, tag: &str) -> Result<Cursor<'a>, LexError> {\n        if self.starts_with(tag) {\n            Ok(self.advance(tag.len()))\n        } else {\n            Err(LexError)\n        }\n    }\n}"],"proc_macro::TokenStream":["impl From<TokenStream> for proc_macro::TokenStream {\n    fn from(inner: TokenStream) -> proc_macro::TokenStream {\n        inner\n            .to_string()\n            .parse()\n            .expect(\"failed to parse to compiler tokens\")\n    }\n}","impl From<TokenStream> for proc_macro::TokenStream {\n    fn from(inner: TokenStream) -> proc_macro::TokenStream {\n        inner.inner.into()\n    }\n}","impl From<TokenStream> for proc_macro::TokenStream {\n    fn from(inner: TokenStream) -> proc_macro::TokenStream {\n        match inner {\n            TokenStream::Compiler(inner) => inner.into_token_stream(),\n            TokenStream::Fallback(inner) => inner.to_string().parse().unwrap(),\n        }\n    }\n}"],"token_stream::IntoIter":["Clone","impl Debug for IntoIter {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            Debug::fmt(&self.inner, f)\n        }\n    }","impl Iterator for IntoIter {\n        type Item = TokenTree;\n\n        fn next(&mut self) -> Option<TokenTree> {\n            self.inner.next()\n        }\n    }"]},"single_path_import":{"TokenStream":"token_stream::TokenStream"},"srcs":{"<Group as std::fmt::Debug>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, formatter)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Group as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.inner, formatter)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Ident) -> Ordering{\n        self.to_string().cmp(&other.to_string())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::cmp::PartialEq<T>>::eq":["fn eq(&self, other: &T) -> bool{\n        self.inner == other\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Ident) -> bool{\n        self.inner == other.inner\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Ident) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ident as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, hasher: &mut H){\n        self.to_string().hash(hasher)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<LexError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<LexError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Literal as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Literal as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Punct as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = fmt.debug_struct(\"Punct\");\n        debug.field(\"char\", &self.ch);\n        debug.field(\"spacing\", &self.spacing);\n        imp::debug_span_field_if_nontrivial(&mut debug, self.span.inner);\n        debug.finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Punct as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.ch, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::convert::From<TokenTree>>::from":["fn from(token: TokenTree) -> Self{\n        TokenStream::_new(imp::TokenStream::from(token))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["fn from(inner: proc_macro::TokenStream) -> TokenStream{\n        TokenStream::_new(inner.into())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::default::Default>::default":["fn default() -> Self{\n        TokenStream::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::iter::Extend<TokenStream>>::extend":["fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I){\n        self.inner\n            .extend(streams.into_iter().map(|stream| stream.inner))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::iter::Extend<TokenTree>>::extend":["fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, streams: I){\n        self.inner.extend(streams)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::iter::FromIterator<TokenStream>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self{\n        TokenStream::_new(streams.into_iter().map(|i| i.inner).collect())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenTree>>(streams: I) -> Self{\n        TokenStream::_new(streams.into_iter().collect())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenStream as std::str::FromStr>::from_str":["fn from_str(src: &str) -> Result<TokenStream, LexError>{\n        let e = src.parse().map_err(|e| LexError {\n            inner: e,\n            _marker: Marker,\n        })?;\n        Ok(TokenStream::_new(e))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::convert::From<Group>>::from":["fn from(g: Group) -> TokenTree{\n        TokenTree::Group(g)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::convert::From<Ident>>::from":["fn from(g: Ident) -> TokenTree{\n        TokenTree::Ident(g)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::convert::From<Literal>>::from":["fn from(g: Literal) -> TokenTree{\n        TokenTree::Literal(g)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::convert::From<Punct>>::from":["fn from(g: Punct) -> TokenTree{\n        TokenTree::Punct(g)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        // Each of these has the name in the struct type in the derived debug,\n        // so don't bother with an extra layer of indirection\n        match self {\n            TokenTree::Group(t) => Debug::fmt(t, f),\n            TokenTree::Ident(t) => {\n                let mut debug = f.debug_struct(\"Ident\");\n                debug.field(\"sym\", &format_args!(\"{}\", t));\n                imp::debug_span_field_if_nontrivial(&mut debug, t.span().inner);\n                debug.finish()\n            }\n            TokenTree::Punct(t) => Debug::fmt(t, f),\n            TokenTree::Literal(t) => Debug::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<TokenTree as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            TokenTree::Group(t) => Display::fmt(t, f),\n            TokenTree::Ident(t) => Display::fmt(t, f),\n            TokenTree::Punct(t) => Display::fmt(t, f),\n            TokenTree::Literal(t) => Display::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<fallback::Group as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = fmt.debug_struct(\"Group\");\n        debug.field(\"delimiter\", &self.delimiter);\n        debug.field(\"stream\", &self.stream);\n        debug_span_field_if_nontrivial(&mut debug, self.span);\n        debug.finish()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Group as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let (open, close) = match self.delimiter {\n            Delimiter::Parenthesis => (\"(\", \")\"),\n            Delimiter::Brace => (\"{ \", \"}\"),\n            Delimiter::Bracket => (\"[\", \"]\"),\n            Delimiter::None => (\"\", \"\"),\n        };\n\n        f.write_str(open)?;\n        Display::fmt(&self.stream, f)?;\n        if self.delimiter == Delimiter::Brace && !self.stream.inner.is_empty() {\n            f.write_str(\" \")?;\n        }\n        f.write_str(close)?;\n\n        Ok(())\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Ident as std::cmp::PartialEq<T>>::eq":["fn eq(&self, other: &T) -> bool{\n        let other = other.as_ref();\n        if self.raw {\n            other.starts_with(\"r#\") && self.sym == other[2..]\n        } else {\n            self.sym == other\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Ident as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Ident) -> bool{\n        self.sym == other.sym && self.raw == other.raw\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Ident as std::fmt::Debug>::fmt":["#[cfg(not(span_locations))]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = f.debug_tuple(\"Ident\");\n        debug.field(&format_args!(\"{}\", self));\n        debug.finish()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Ident as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.raw {\n            f.write_str(\"r#\")?;\n        }\n        Display::fmt(&self.sym, f)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::LexError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(\"cannot parse string into token stream\")\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Literal as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = fmt.debug_struct(\"Literal\");\n        debug.field(\"lit\", &format_args!(\"{}\", self.text));\n        debug_span_field_if_nontrivial(&mut debug, self.span);\n        debug.finish()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Literal as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.text, f)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::SourceFile as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"SourceFile\")\n            .field(\"path\", &self.path())\n            .field(\"is_real\", &self.is_real())\n            .finish()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        #[cfg(span_locations)]\n        return write!(f, \"bytes({}..{})\", self.lo, self.hi);\n\n        #[cfg(not(span_locations))]\n        write!(f, \"Span\")\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::convert::From<TokenTree>>::from":["fn from(tree: TokenTree) -> TokenStream{\n        let mut stream = TokenStream::new();\n        stream.push_token(tree);\n        stream\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["fn from(inner: proc_macro::TokenStream) -> TokenStream{\n        inner\n            .to_string()\n            .parse()\n            .expect(\"compiler token stream parse failed\")\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(\"TokenStream \")?;\n        f.debug_list().entries(self.clone()).finish()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut joint = false;\n        for (i, tt) in self.inner.iter().enumerate() {\n            if i != 0 && !joint {\n                write!(f, \" \")?;\n            }\n            joint = false;\n            match tt {\n                TokenTree::Group(tt) => Display::fmt(tt, f),\n                TokenTree::Ident(tt) => Display::fmt(tt, f),\n                TokenTree::Punct(tt) => {\n                    joint = tt.spacing() == Spacing::Joint;\n                    Display::fmt(tt, f)\n                }\n                TokenTree::Literal(tt) => Display::fmt(tt, f),\n            }?\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::iter::Extend<TokenTree>>::extend":["fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, tokens: I){\n        tokens.into_iter().for_each(|token| self.push_token(token));\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::iter::Extend<fallback::TokenStream>>::extend":["fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I){\n        self.inner.extend(streams.into_iter().flatten());\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenTree>>(tokens: I) -> Self{\n        let mut stream = TokenStream::new();\n        stream.extend(tokens);\n        stream\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::iter::FromIterator<fallback::TokenStream>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self{\n        let mut v = Vec::new();\n\n        for mut stream in streams {\n            v.extend(stream.take_inner());\n        }\n\n        TokenStream { inner: v }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::iter::IntoIterator>::into_iter":["fn into_iter(mut self) -> TokenTreeIter{\n        self.take_inner().into_iter()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::ops::Drop>::drop":["fn drop(&mut self){\n        while let Some(token) = self.inner.pop() {\n            let group = match token {\n                TokenTree::Group(group) => group.inner,\n                _ => continue,\n            };\n            #[cfg(wrap_proc_macro)]\n            let group = match group {\n                crate::imp::Group::Fallback(group) => group,\n                _ => continue,\n            };\n            let mut group = group;\n            self.inner.extend(group.stream.take_inner());\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<fallback::TokenStream as std::str::FromStr>::from_str":["fn from_str(src: &str) -> Result<TokenStream, LexError>{\n        // Create a dummy file & add it to the source map\n        let cursor = get_cursor(src);\n\n        let (rest, tokens) = token_stream(cursor)?;\n        if rest.is_empty() {\n            Ok(tokens)\n        } else {\n            Err(LexError)\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"<imp::Group as std::convert::From<fallback::Group>>::from":["fn from(g: fallback::Group) -> Self{\n        Group::Fallback(g)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Group as std::fmt::Debug>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Group::Compiler(group) => Debug::fmt(group, formatter),\n            Group::Fallback(group) => Debug::fmt(group, formatter),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Group as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Group::Compiler(group) => Display::fmt(group, formatter),\n            Group::Fallback(group) => Display::fmt(group, formatter),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Ident as std::cmp::PartialEq<T>>::eq":["fn eq(&self, other: &T) -> bool{\n        let other = other.as_ref();\n        match self {\n            Ident::Compiler(t) => t.to_string() == other,\n            Ident::Fallback(t) => t == other,\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Ident as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Ident) -> bool{\n        match (self, other) {\n            (Ident::Compiler(t), Ident::Compiler(o)) => t.to_string() == o.to_string(),\n            (Ident::Fallback(t), Ident::Fallback(o)) => t == o,\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Ident as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Ident::Compiler(t) => Debug::fmt(t, f),\n            Ident::Fallback(t) => Debug::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Ident as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Ident::Compiler(t) => Display::fmt(t, f),\n            Ident::Fallback(t) => Display::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::LexError as std::convert::From<fallback::LexError>>::from":["fn from(e: fallback::LexError) -> LexError{\n        LexError::Fallback(e)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::LexError as std::convert::From<proc_macro::LexError>>::from":["fn from(e: proc_macro::LexError) -> LexError{\n        LexError::Compiler(e)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::LexError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            LexError::Compiler(e) => Debug::fmt(e, f),\n            LexError::Fallback(e) => Debug::fmt(e, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::LexError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            #[cfg(lexerror_display)]\n            LexError::Compiler(e) => Display::fmt(e, f),\n            #[cfg(not(lexerror_display))]\n            LexError::Compiler(_e) => Display::fmt(&fallback::LexError, f),\n            LexError::Fallback(e) => Display::fmt(e, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Literal as std::convert::From<fallback::Literal>>::from":["fn from(s: fallback::Literal) -> Literal{\n        Literal::Fallback(s)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Literal as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Literal::Compiler(t) => Debug::fmt(t, f),\n            Literal::Fallback(t) => Debug::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Literal as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Literal::Compiler(t) => Display::fmt(t, f),\n            Literal::Fallback(t) => Display::fmt(t, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Span as std::convert::From<fallback::Span>>::from":["fn from(inner: fallback::Span) -> Span{\n        Span::Fallback(inner)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Span::Compiler(s) => Debug::fmt(s, f),\n            Span::Fallback(s) => Debug::fmt(s, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::convert::From<TokenTree>>::from":["fn from(token: TokenTree) -> TokenStream{\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(into_compiler_token(token).into()))\n        } else {\n            TokenStream::Fallback(token.into())\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::convert::From<fallback::TokenStream>>::from":["fn from(inner: fallback::TokenStream) -> TokenStream{\n        TokenStream::Fallback(inner)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["fn from(inner: proc_macro::TokenStream) -> TokenStream{\n        TokenStream::Compiler(DeferredTokenStream::new(inner))\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            TokenStream::Compiler(tts) => Debug::fmt(&tts.clone().into_token_stream(), f),\n            TokenStream::Fallback(tts) => Debug::fmt(tts, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            TokenStream::Compiler(tts) => Display::fmt(&tts.clone().into_token_stream(), f),\n            TokenStream::Fallback(tts) => Display::fmt(tts, f),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::iter::Extend<TokenTree>>::extend":["fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, stream: I){\n        match self {\n            TokenStream::Compiler(tts) => {\n                // Here is the reason for DeferredTokenStream.\n                for token in stream {\n                    tts.extra.push(into_compiler_token(token));\n                }\n            }\n            TokenStream::Fallback(tts) => tts.extend(stream),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::iter::Extend<imp::TokenStream>>::extend":["fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I){\n        match self {\n            TokenStream::Compiler(tts) => {\n                tts.evaluate_now();\n                tts.stream\n                    .extend(streams.into_iter().map(TokenStream::unwrap_nightly));\n            }\n            TokenStream::Fallback(tts) => {\n                tts.extend(streams.into_iter().map(TokenStream::unwrap_stable));\n            }\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self{\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(\n                trees.into_iter().map(into_compiler_token).collect(),\n            ))\n        } else {\n            TokenStream::Fallback(trees.into_iter().collect())\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::iter::FromIterator<imp::TokenStream>>::from_iter":["fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self{\n        let mut streams = streams.into_iter();\n        match streams.next() {\n            Some(TokenStream::Compiler(mut first)) => {\n                first.evaluate_now();\n                first.stream.extend(streams.map(|s| match s {\n                    TokenStream::Compiler(s) => s.into_token_stream(),\n                    TokenStream::Fallback(_) => mismatch(),\n                }));\n                TokenStream::Compiler(first)\n            }\n            Some(TokenStream::Fallback(mut first)) => {\n                first.extend(streams.map(|s| match s {\n                    TokenStream::Fallback(s) => s,\n                    TokenStream::Compiler(_) => mismatch(),\n                }));\n                TokenStream::Fallback(first)\n            }\n            None => TokenStream::new(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> TokenTreeIter{\n        match self {\n            TokenStream::Compiler(tts) => {\n                TokenTreeIter::Compiler(tts.into_token_stream().into_iter())\n            }\n            TokenStream::Fallback(tts) => TokenTreeIter::Fallback(tts.into_iter()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenStream as std::str::FromStr>::from_str":["fn from_str(src: &str) -> Result<TokenStream, LexError>{\n        if inside_proc_macro() {\n            Ok(TokenStream::Compiler(DeferredTokenStream::new(\n                proc_macro_parse(src)?,\n            )))\n        } else {\n            Ok(TokenStream::Fallback(src.parse()?))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenTreeIter as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"TokenTreeIter\").finish()\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenTreeIter as std::iter::Iterator>::next":["fn next(&mut self) -> Option<TokenTree>{\n        let token = match self {\n            TokenTreeIter::Compiler(iter) => iter.next()?,\n            TokenTreeIter::Fallback(iter) => return iter.next(),\n        };\n        Some(match token {\n            proc_macro::TokenTree::Group(tt) => crate::Group::_new(Group::Compiler(tt)).into(),\n            proc_macro::TokenTree::Punct(tt) => {\n                let spacing = match tt.spacing() {\n                    proc_macro::Spacing::Joint => Spacing::Joint,\n                    proc_macro::Spacing::Alone => Spacing::Alone,\n                };\n                let mut o = Punct::new(tt.as_char(), spacing);\n                o.set_span(crate::Span::_new(Span::Compiler(tt.span())));\n                o.into()\n            }\n            proc_macro::TokenTree::Ident(s) => crate::Ident::_new(Ident::Compiler(s)).into(),\n            proc_macro::TokenTree::Literal(l) => crate::Literal::_new(Literal::Compiler(l)).into(),\n        })\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<imp::TokenTreeIter as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        match self {\n            TokenTreeIter::Compiler(tts) => tts.size_hint(),\n            TokenTreeIter::Fallback(tts) => tts.size_hint(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<impl std::convert::From<TokenStream> for proc_macro::TokenStream>::from":["fn from(inner: TokenStream) -> proc_macro::TokenStream{\n        inner.inner.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<token_stream::IntoIter as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n            Debug::fmt(&self.inner, f)\n        }","Real(LocalPath(\"src/lib.rs\"))"],"<token_stream::IntoIter as std::iter::Iterator>::next":["fn next(&mut self) -> Option<TokenTree>{\n            self.inner.next()\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Delimiter":["/// Describes how a sequence of token trees is delimited.\npub enum Delimiter {\n    /// `( ... )`\n    Parenthesis,\n    /// `{ ... }`\n    Brace,\n    /// `[ ... ]`\n    Bracket,\n    /// `Ø ... Ø`\n    ///\n    /// An implicit delimiter, that may, for example, appear around tokens\n    /// coming from a \"macro variable\" `$var`. It is important to preserve\n    /// operator priorities in cases like `$var * 3` where `$var` is `1 + 2`.\n    /// Implicit delimiters may not survive roundtrip of a token stream through\n    /// a string.\n    None,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Group":["/// A delimited token stream.\n///\n/// A `Group` internally contains a `TokenStream` which is surrounded by\n/// `Delimiter`s.\npub struct Group {\n    inner: imp::Group,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Group::_new":["fn _new(inner: imp::Group) -> Self{\n        Group { inner }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::_new_stable":["fn _new_stable(inner: fallback::Group) -> Self{\n        Group {\n            inner: inner.into(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::delimiter":["/// Returns the delimiter of this `Group`\npub fn delimiter(&self) -> Delimiter{\n        self.inner.delimiter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::new":["/// Creates a new `Group` with the given delimiter and token stream.\n///\n/// This constructor will set the span for this group to\n/// `Span::call_site()`. To change the span you can use the `set_span`\n/// method below.\npub fn new(delimiter: Delimiter, stream: TokenStream) -> Group{\n        Group {\n            inner: imp::Group::new(delimiter, stream.inner),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::set_span":["/// Configures the span for this `Group`'s delimiters, but not its internal\n/// tokens.\n///\n/// This method will **not** set the span of all the internal tokens spanned\n/// by this group, but rather it will only set the span of the delimiter\n/// tokens at the level of the `Group`.\npub fn set_span(&mut self, span: Span){\n        self.inner.set_span(span.inner)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::span":["/// Returns the span for the delimiters of this token stream, spanning the\n/// entire `Group`.\n///\n/// ```text\n/// pub fn span(&self) -> Span {\n///            ^^^^^^^\n/// ```\npub fn span(&self) -> Span{\n        Span::_new(self.inner.span())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::span_close":["/// Returns the span pointing to the closing delimiter of this group.\n///\n/// ```text\n/// pub fn span_close(&self) -> Span {\n///                        ^\n/// ```\npub fn span_close(&self) -> Span{\n        Span::_new(self.inner.span_close())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::span_open":["/// Returns the span pointing to the opening delimiter of this group.\n///\n/// ```text\n/// pub fn span_open(&self) -> Span {\n///                 ^\n/// ```\npub fn span_open(&self) -> Span{\n        Span::_new(self.inner.span_open())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Group::stream":["/// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n///\n/// Note that the returned token stream does not include the delimiter\n/// returned above.\npub fn stream(&self) -> TokenStream{\n        TokenStream::_new(self.inner.stream())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ident":["/// A word of Rust code, which may be a keyword or legal variable name.\n///\n/// An identifier consists of at least one Unicode code point, the first of\n/// which has the XID_Start property and the rest of which have the XID_Continue\n/// property.\n///\n/// - The empty string is not an identifier. Use `Option<Ident>`.\n/// - A lifetime is not an identifier. Use `syn::Lifetime` instead.\n///\n/// An identifier constructed with `Ident::new` is permitted to be a Rust\n/// keyword, though parsing one through its [`Parse`] implementation rejects\n/// Rust keywords. Use `input.call(Ident::parse_any)` when parsing to match the\n/// behaviour of `Ident::new`.\n///\n/// [`Parse`]: https://docs.rs/syn/1.0/syn/parse/trait.Parse.html\n///\n/// # Examples\n///\n/// A new ident can be created from a string using the `Ident::new` function.\n/// A span must be provided explicitly which governs the name resolution\n/// behavior of the resulting identifier.\n///\n/// ```\n/// use proc_macro2::{Ident, Span};\n///\n/// fn main() {\n///     let call_ident = Ident::new(\"calligraphy\", Span::call_site());\n///\n///     println!(\"{}\", call_ident);\n/// }\n/// ```\n///\n/// An ident can be interpolated into a token stream using the `quote!` macro.\n///\n/// ```\n/// use proc_macro2::{Ident, Span};\n/// use quote::quote;\n///\n/// fn main() {\n///     let ident = Ident::new(\"demo\", Span::call_site());\n///\n///     // Create a variable binding whose name is this ident.\n///     let expanded = quote! { let #ident = 10; };\n///\n///     // Create a variable binding with a slightly different name.\n///     let temp_ident = Ident::new(&format!(\"new_{}\", ident), Span::call_site());\n///     let expanded = quote! { let #temp_ident = 10; };\n/// }\n/// ```\n///\n/// A string representation of the ident is available through the `to_string()`\n/// method.\n///\n/// ```\n/// # use proc_macro2::{Ident, Span};\n/// #\n/// # let ident = Ident::new(\"another_identifier\", Span::call_site());\n/// #\n/// // Examine the ident as a string.\n/// let ident_string = ident.to_string();\n/// if ident_string.len() > 60 {\n///     println!(\"Very long identifier: {}\", ident_string)\n/// }\n/// ```\npub struct Ident {\n    inner: imp::Ident,\n    _marker: Marker,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Ident::_new":["fn _new(inner: imp::Ident) -> Ident{\n        Ident {\n            inner,\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ident::_new_raw":["fn _new_raw(string: &str, span: Span) -> Ident{\n        Ident::_new(imp::Ident::new_raw(string, span.inner))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ident::new":["/// Creates a new `Ident` with the given `string` as well as the specified\n/// `span`.\n///\n/// The `string` argument must be a valid identifier permitted by the\n/// language, otherwise the function will panic.\n///\n/// Note that `span`, currently in rustc, configures the hygiene information\n/// for this identifier.\n///\n/// As of this time `Span::call_site()` explicitly opts-in to \"call-site\"\n/// hygiene meaning that identifiers created with this span will be resolved\n/// as if they were written directly at the location of the macro call, and\n/// other code at the macro call site will be able to refer to them as well.\n///\n/// Later spans like `Span::def_site()` will allow to opt-in to\n/// \"definition-site\" hygiene meaning that identifiers created with this\n/// span will be resolved at the location of the macro definition and other\n/// code at the macro call site will not be able to refer to them.\n///\n/// Due to the current importance of hygiene this constructor, unlike other\n/// tokens, requires a `Span` to be specified at construction.\n///\n/// # Panics\n///\n/// Panics if the input string is neither a keyword nor a legal variable\n/// name. If you are not sure whether the string contains an identifier and\n/// need to handle an error case, use\n/// <a href=\"https://docs.rs/syn/1.0/syn/fn.parse_str.html\"><code\n///   style=\"padding-right:0;\">syn::parse_str</code></a><code\n///   style=\"padding-left:0;\">::&lt;Ident&gt;</code>\n/// rather than `Ident::new`.\npub fn new(string: &str, span: Span) -> Ident{\n        Ident::_new(imp::Ident::new(string, span.inner))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ident::set_span":["/// Configures the span of this `Ident`, possibly changing its hygiene\n/// context.\npub fn set_span(&mut self, span: Span){\n        self.inner.set_span(span.inner);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ident::span":["/// Returns the span of this `Ident`.\npub fn span(&self) -> Span{\n        Span::_new(self.inner.span())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"LexError":["/// Error returned from `TokenStream::from_str`.\npub struct LexError {\n    inner: imp::LexError,\n    _marker: Marker,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Literal":["/// A literal string (`\"hello\"`), byte string (`b\"hello\"`), character (`'a'`),\n/// byte character (`b'a'`), an integer or floating point number with or without\n/// a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n///\n/// Boolean literals like `true` and `false` do not belong here, they are\n/// `Ident`s.\npub struct Literal {\n    inner: imp::Literal,\n    _marker: Marker,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Literal::_new":["fn _new(inner: imp::Literal) -> Literal{\n        Literal {\n            inner,\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::_new_stable":["fn _new_stable(inner: fallback::Literal) -> Literal{\n        Literal {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::byte_string":["/// Byte string literal.\npub fn byte_string(s: &[u8]) -> Literal{\n        Literal::_new(imp::Literal::byte_string(s))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::character":["/// Character literal.\npub fn character(ch: char) -> Literal{\n        Literal::_new(imp::Literal::character(ch))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::f32_suffixed":["/// Creates a new suffixed floating-point literal.\n///\n/// This constructor will create a literal like `1.0f32` where the value\n/// specified is the preceding part of the token and `f32` is the suffix of\n/// the token. This token will always be inferred to be an `f32` in the\n/// compiler. Literals created from negative numbers may not survive\n/// rountrips through `TokenStream` or strings and may be broken into two\n/// tokens (`-` and positive literal).\n///\n/// # Panics\n///\n/// This function requires that the specified float is finite, for example\n/// if it is infinity or NaN this function will panic.\npub fn f32_suffixed(f: f32) -> Literal{\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f32_suffixed(f))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::f32_unsuffixed":["/// Creates a new unsuffixed floating-point literal.\n///\n/// This constructor is similar to those like `Literal::i8_unsuffixed` where\n/// the float's value is emitted directly into the token but no suffix is\n/// used, so it may be inferred to be a `f64` later in the compiler.\n/// Literals created from negative numbers may not survive rountrips through\n/// `TokenStream` or strings and may be broken into two tokens (`-` and\n/// positive literal).\n///\n/// # Panics\n///\n/// This function requires that the specified float is finite, for example\n/// if it is infinity or NaN this function will panic.\npub fn f32_unsuffixed(f: f32) -> Literal{\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f32_unsuffixed(f))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::f64_suffixed":["/// Creates a new suffixed floating-point literal.\n///\n/// This constructor will create a literal like `1.0f64` where the value\n/// specified is the preceding part of the token and `f64` is the suffix of\n/// the token. This token will always be inferred to be an `f64` in the\n/// compiler. Literals created from negative numbers may not survive\n/// rountrips through `TokenStream` or strings and may be broken into two\n/// tokens (`-` and positive literal).\n///\n/// # Panics\n///\n/// This function requires that the specified float is finite, for example\n/// if it is infinity or NaN this function will panic.\npub fn f64_suffixed(f: f64) -> Literal{\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f64_suffixed(f))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::f64_unsuffixed":["/// Creates a new unsuffixed floating-point literal.\n///\n/// This constructor is similar to those like `Literal::i8_unsuffixed` where\n/// the float's value is emitted directly into the token but no suffix is\n/// used, so it may be inferred to be a `f64` later in the compiler.\n/// Literals created from negative numbers may not survive rountrips through\n/// `TokenStream` or strings and may be broken into two tokens (`-` and\n/// positive literal).\n///\n/// # Panics\n///\n/// This function requires that the specified float is finite, for example\n/// if it is infinity or NaN this function will panic.\npub fn f64_unsuffixed(f: f64) -> Literal{\n        assert!(f.is_finite());\n        Literal::_new(imp::Literal::f64_unsuffixed(f))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i128_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i128_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i16_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i16_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i32_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i32_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i64_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i64_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i8_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::i8_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::isize_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::isize_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::set_span":["/// Configures the span associated for this literal.\npub fn set_span(&mut self, span: Span){\n        self.inner.set_span(span.inner);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::span":["/// Returns the span encompassing this literal.\npub fn span(&self) -> Span{\n        Span::_new(self.inner.span())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::string":["/// String literal.\npub fn string(string: &str) -> Literal{\n        Literal::_new(imp::Literal::string(string))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::subspan":["/// Returns a `Span` that is a subset of `self.span()` containing only\n/// the source bytes in range `range`. Returns `None` if the would-be\n/// trimmed span is outside the bounds of `self`.\n///\n/// Warning: the underlying [`proc_macro::Literal::subspan`] method is\n/// nightly-only. When called from within a procedural macro not using a\n/// nightly compiler, this method will always return `None`.\n///\n/// [`proc_macro::Literal::subspan`]: https://doc.rust-lang.org/proc_macro/struct.Literal.html#method.subspan\npub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span>{\n        self.inner.subspan(range).map(Span::_new)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u128_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u128_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u16_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u16_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u32_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u32_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u64_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u64_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u8_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::u8_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::usize_suffixed":["/// Creates a new suffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1u32` where the integer\n/// value specified is the first part of the token and the integral is\n/// also suffixed at the end. Literals created from negative numbers may\n/// not survive rountrips through `TokenStream` or strings and may be\n/// broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Literal::usize_unsuffixed":["/// Creates a new unsuffixed integer literal with the specified value.\n///\n/// This function will create an integer like `1` where the integer\n/// value specified is the first part of the token. No suffix is\n/// specified on this token, meaning that invocations like\n/// `Literal::i8_unsuffixed(1)` are equivalent to\n/// `Literal::u32_unsuffixed(1)`. Literals created from negative numbers\n/// may not survive rountrips through `TokenStream` or strings and may\n/// be broken into two tokens (`-` and positive literal).\n///\n/// Literals created through this method have the `Span::call_site()`\n/// span by default, which can be configured with the `set_span` method\n/// below.\npub fn $name(n: $kind) -> Literal{\n            Literal::_new(imp::Literal::$name(n))\n        }","Real(LocalPath(\"src/lib.rs\"))"],"Punct":["/// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n///\n/// Multicharacter operators like `+=` are represented as two instances of\n/// `Punct` with different forms of `Spacing` returned.\npub struct Punct {\n    ch: char,\n    spacing: Spacing,\n    span: Span,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Punct::as_char":["/// Returns the value of this punctuation character as `char`.\npub fn as_char(&self) -> char{\n        self.ch\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Punct::new":["/// Creates a new `Punct` from the given character and spacing.\n///\n/// The `ch` argument must be a valid punctuation character permitted by the\n/// language, otherwise the function will panic.\n///\n/// The returned `Punct` will have the default span of `Span::call_site()`\n/// which can be further configured with the `set_span` method below.\npub fn new(ch: char, spacing: Spacing) -> Punct{\n        Punct {\n            ch,\n            spacing,\n            span: Span::call_site(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Punct::set_span":["/// Configure the span for this punctuation character.\npub fn set_span(&mut self, span: Span){\n        self.span = span;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Punct::spacing":["/// Returns the spacing of this punctuation character, indicating whether\n/// it's immediately followed by another `Punct` in the token stream, so\n/// they can potentially be combined into a multicharacter operator\n/// (`Joint`), or it's followed by some other token or whitespace (`Alone`)\n/// so the operator has certainly ended.\npub fn spacing(&self) -> Spacing{\n        self.spacing\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Punct::span":["/// Returns the span for this punctuation character.\npub fn span(&self) -> Span{\n        self.span\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Spacing":["/// Whether an `Punct` is followed immediately by another `Punct` or followed by\n/// another token or whitespace.\npub enum Spacing {\n    /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n    Alone,\n    /// E.g. `+` is `Joint` in `+=` or `'` is `Joint` in `'#`.\n    ///\n    /// Additionally, single quote `'` can join with identifiers to form\n    /// lifetimes `'ident`.\n    Joint,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Span":["/// A region of source code, along with macro expansion information.\npub struct Span {\n    inner: imp::Span,\n    _marker: Marker,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Span::_new":["fn _new(inner: imp::Span) -> Span{\n        Span {\n            inner,\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::_new_stable":["fn _new_stable(inner: fallback::Span) -> Span{\n        Span {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::call_site":["/// The span of the invocation of the current procedural macro.\n///\n/// Identifiers created with this span will be resolved as if they were\n/// written directly at the macro call location (call-site hygiene) and\n/// other code at the macro call site will be able to refer to them as well.\npub fn call_site() -> Span{\n        Span::_new(imp::Span::call_site())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::join":["/// Create a new span encompassing `self` and `other`.\n///\n/// Returns `None` if `self` and `other` are from different files.\n///\n/// Warning: the underlying [`proc_macro::Span::join`] method is\n/// nightly-only. When called from within a procedural macro not using a\n/// nightly compiler, this method will always return `None`.\n///\n/// [`proc_macro::Span::join`]: https://doc.rust-lang.org/proc_macro/struct.Span.html#method.join\npub fn join(&self, other: Span) -> Option<Span>{\n        self.inner.join(other.inner).map(Span::_new)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::located_at":["/// Creates a new span with the same name resolution behavior as `self` but\n/// with the line/column information of `other`.\npub fn located_at(&self, other: Span) -> Span{\n        Span::_new(self.inner.located_at(other.inner))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::mixed_site":["/// The span located at the invocation of the procedural macro, but with\n/// local variables, labels, and `$crate` resolved at the definition site\n/// of the macro. This is the same hygiene behavior as `macro_rules`.\n///\n/// This function requires Rust 1.45 or later.\n#[cfg(hygiene)]\npub fn mixed_site() -> Span{\n        Span::_new(imp::Span::mixed_site())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::resolved_at":["/// Creates a new span with the same line/column information as `self` but\n/// that resolves symbols as though it were at `other`.\npub fn resolved_at(&self, other: Span) -> Span{\n        Span::_new(self.inner.resolved_at(other.inner))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::unstable":["#[cfg(wrap_proc_macro)]\n#[doc(hidden)]\npub fn unstable(self) -> proc_macro::Span{\n        self.unwrap()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Span::unwrap":["/// Convert `proc_macro2::Span` to `proc_macro::Span`.\n///\n/// This method is available when building with a nightly compiler, or when\n/// building with rustc 1.29+ *without* semver exempt features.\n///\n/// # Panics\n///\n/// Panics if called from outside of a procedural macro. Unlike\n/// `proc_macro2::Span`, the `proc_macro::Span` type can only exist within\n/// the context of a procedural macro invocation.\n#[cfg(wrap_proc_macro)]\npub fn unwrap(self) -> proc_macro::Span{\n        self.inner.unwrap()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenStream":["/// An abstract stream of tokens, or more concretely a sequence of token trees.\n///\n/// This type provides interfaces for iterating over token trees and for\n/// collecting token trees into one stream.\n///\n/// Token stream is both the input and output of `#[proc_macro]`,\n/// `#[proc_macro_attribute]` and `#[proc_macro_derive]` definitions.\npub struct TokenStream {\n    inner: imp::TokenStream,\n    _marker: Marker,\n}","Real(LocalPath(\"src/lib.rs\"))"],"TokenStream::_new":["fn _new(inner: imp::TokenStream) -> TokenStream{\n        TokenStream {\n            inner,\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenStream::_new_stable":["fn _new_stable(inner: fallback::TokenStream) -> TokenStream{\n        TokenStream {\n            inner: inner.into(),\n            _marker: Marker,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenStream::is_empty":["/// Checks if this `TokenStream` is empty.\npub fn is_empty(&self) -> bool{\n        self.inner.is_empty()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenStream::new":["/// Returns an empty `TokenStream` containing no token trees.\npub fn new() -> TokenStream{\n        TokenStream::_new(imp::TokenStream::new())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenTree":["/// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\npub enum TokenTree {\n    /// A token stream surrounded by bracket delimiters.\n    Group(Group),\n    /// An identifier.\n    Ident(Ident),\n    /// A single punctuation character (`+`, `,`, `$`, etc.).\n    Punct(Punct),\n    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n    Literal(Literal),\n}","Real(LocalPath(\"src/lib.rs\"))"],"TokenTree::set_span":["/// Configures the span for *only this token*.\n///\n/// Note that if this token is a `Group` then this method will not configure\n/// the span of each of the internal tokens, this will simply delegate to\n/// the `set_span` method of each variant.\npub fn set_span(&mut self, span: Span){\n        match self {\n            TokenTree::Group(t) => t.set_span(span),\n            TokenTree::Ident(t) => t.set_span(span),\n            TokenTree::Punct(t) => t.set_span(span),\n            TokenTree::Literal(t) => t.set_span(span),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"TokenTree::span":["/// Returns the span of this tree, delegating to the `span` method of\n/// the contained token or a delimited stream.\npub fn span(&self) -> Span{\n        match self {\n            TokenTree::Group(t) => t.span(),\n            TokenTree::Ident(t) => t.span(),\n            TokenTree::Punct(t) => t.span(),\n            TokenTree::Literal(t) => t.span(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"detection::force_fallback":["pub(crate) fn force_fallback(){\n    WORKS.store(1, Ordering::SeqCst);\n}","Real(LocalPath(\"src/detection.rs\"))"],"detection::initialize":["fn initialize(){\n    type PanicHook = dyn Fn(&PanicInfo) + Sync + Send + 'static;\n\n    let null_hook: Box<PanicHook> = Box::new(|_panic_info| { /* ignore */ });\n    let sanity_check = &*null_hook as *const PanicHook;\n    let original_hook = panic::take_hook();\n    panic::set_hook(null_hook);\n\n    let works = panic::catch_unwind(proc_macro::Span::call_site).is_ok();\n    WORKS.store(works as usize + 1, Ordering::SeqCst);\n\n    let hopefully_null_hook = panic::take_hook();\n    panic::set_hook(original_hook);\n    if sanity_check != &*hopefully_null_hook {\n        panic!(\"observed race condition in proc_macro2::inside_proc_macro\");\n    }\n}","Real(LocalPath(\"src/detection.rs\"))"],"detection::inside_proc_macro":["pub(crate) fn inside_proc_macro() -> bool{\n    match WORKS.load(Ordering::SeqCst) {\n        1 => return false,\n        2 => return true,\n        _ => {}\n    }\n\n    INIT.call_once(initialize);\n    inside_proc_macro()\n}","Real(LocalPath(\"src/detection.rs\"))"],"detection::unforce_fallback":["pub(crate) fn unforce_fallback(){\n    initialize();\n}","Real(LocalPath(\"src/detection.rs\"))"],"fallback::<impl std::convert::From<fallback::TokenStream> for proc_macro::TokenStream>::from":["fn from(inner: TokenStream) -> proc_macro::TokenStream{\n        inner\n            .to_string()\n            .parse()\n            .expect(\"failed to parse to compiler tokens\")\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group":["pub(crate) struct Group {\n    delimiter: Delimiter,\n    stream: TokenStream,\n    span: Span,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::delimiter":["pub fn delimiter(&self) -> Delimiter{\n        self.delimiter\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::new":["pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group{\n        Group {\n            delimiter,\n            stream,\n            span: Span::call_site(),\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::set_span":["pub fn set_span(&mut self, span: Span){\n        self.span = span;\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::span":["pub fn span(&self) -> Span{\n        self.span\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::span_close":["pub fn span_close(&self) -> Span{\n        self.span.last_byte()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::span_open":["pub fn span_open(&self) -> Span{\n        self.span.first_byte()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Group::stream":["pub fn stream(&self) -> TokenStream{\n        self.stream.clone()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident":["pub(crate) struct Ident {\n    sym: String,\n    span: Span,\n    raw: bool,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident::_new":["fn _new(string: &str, raw: bool, span: Span) -> Ident{\n        validate_ident(string);\n\n        Ident {\n            sym: string.to_owned(),\n            span,\n            raw,\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident::new":["pub fn new(string: &str, span: Span) -> Ident{\n        Ident::_new(string, false, span)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident::new_raw":["pub fn new_raw(string: &str, span: Span) -> Ident{\n        Ident::_new(string, true, span)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident::set_span":["pub fn set_span(&mut self, span: Span){\n        self.span = span;\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Ident::span":["pub fn span(&self) -> Span{\n        self.span\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::LexError":["pub(crate) struct LexError;","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::LineColumn":["pub(crate) struct LineColumn {\n    pub line: usize,\n    pub column: usize,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal":["pub(crate) struct Literal {\n    text: String,\n    span: Span,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::_new":["pub(crate) fn _new(text: String) -> Literal{\n        Literal {\n            text,\n            span: Span::call_site(),\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::byte_string":["pub fn byte_string(bytes: &[u8]) -> Literal{\n        let mut escaped = \"b\\\"\".to_string();\n        for b in bytes {\n            #[allow(clippy::match_overlapping_arm)]\n            match *b {\n                b'\\0' => escaped.push_str(r\"\\0\"),\n                b'\\t' => escaped.push_str(r\"\\t\"),\n                b'\\n' => escaped.push_str(r\"\\n\"),\n                b'\\r' => escaped.push_str(r\"\\r\"),\n                b'\"' => escaped.push_str(\"\\\\\\\"\"),\n                b'\\\\' => escaped.push_str(\"\\\\\\\\\"),\n                b'\\x20'..=b'\\x7E' => escaped.push(*b as char),\n                _ => escaped.push_str(&format!(\"\\\\x{:02X}\", b)),\n            }\n        }\n        escaped.push('\"');\n        Literal::_new(escaped)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::character":["pub fn character(t: char) -> Literal{\n        let mut text = String::new();\n        text.push('\\'');\n        if t == '\"' {\n            // escape_debug turns this into '\\\"' which is unnecessary.\n            text.push(t);\n        } else {\n            text.extend(t.escape_debug());\n        }\n        text.push('\\'');\n        Literal::_new(text)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::f32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::f32_unsuffixed":["pub fn f32_unsuffixed(f: f32) -> Literal{\n        let mut s = f.to_string();\n        if !s.contains('.') {\n            s.push_str(\".0\");\n        }\n        Literal::_new(s)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::f64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::f64_unsuffixed":["pub fn f64_unsuffixed(f: f64) -> Literal{\n        let mut s = f.to_string();\n        if !s.contains('.') {\n            s.push_str(\".0\");\n        }\n        Literal::_new(s)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i128_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i128_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i16_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i16_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i32_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i64_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i8_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::i8_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::isize_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::isize_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::set_span":["pub fn set_span(&mut self, span: Span){\n        self.span = span;\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::span":["pub fn span(&self) -> Span{\n        self.span\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::string":["pub fn string(t: &str) -> Literal{\n        let mut text = String::with_capacity(t.len() + 2);\n        text.push('\"');\n        for c in t.chars() {\n            if c == '\\'' {\n                // escape_debug turns this into \"\\'\" which is unnecessary.\n                text.push(c);\n            } else {\n                text.extend(c.escape_debug());\n            }\n        }\n        text.push('\"');\n        Literal::_new(text)\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::subspan":["pub fn subspan<R: RangeBounds<usize>>(&self, _range: R) -> Option<Span>{\n        None\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u128_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u128_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u16_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u16_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u32_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u64_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u8_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::u8_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::usize_suffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(format!(concat!(\"{}\", stringify!($kind)), n))\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Literal::usize_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            Literal::_new(n.to_string())\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::SourceFile":["pub(crate) struct SourceFile {\n    path: PathBuf,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::SourceFile::is_real":["pub fn is_real(&self) -> bool{\n        // XXX(nika): Support real files in the future?\n        false\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::SourceFile::path":["/// Get the path to this source file as a string.\npub fn path(&self) -> PathBuf{\n        self.path.clone()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span":["pub(crate) struct Span {\n    #[cfg(span_locations)]\n    pub(crate) lo: u32,\n    #[cfg(span_locations)]\n    pub(crate) hi: u32,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::call_site":["#[cfg(not(span_locations))]\npub fn call_site() -> Span{\n        Span {}\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::first_byte":["#[cfg(not(span_locations))]\nfn first_byte(self) -> Self{\n        self\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::join":["#[cfg(not(span_locations))]\npub fn join(&self, _other: Span) -> Option<Span>{\n        Some(Span {})\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::last_byte":["#[cfg(not(span_locations))]\nfn last_byte(self) -> Self{\n        self\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::located_at":["pub fn located_at(&self, other: Span) -> Span{\n        other\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::mixed_site":["#[cfg(hygiene)]\npub fn mixed_site() -> Span{\n        Span::call_site()\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::Span::resolved_at":["pub fn resolved_at(&self, _other: Span) -> Span{\n        // Stable spans consist only of line/column information, so\n        // `resolved_at` and `located_at` only select which span the\n        // caller wants line/column information from.\n        *self\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream":["pub(crate) struct TokenStream {\n    pub(crate) inner: Vec<TokenTree>,\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream::is_empty":["pub fn is_empty(&self) -> bool{\n        self.inner.len() == 0\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream::new":["pub fn new() -> TokenStream{\n        TokenStream { inner: Vec::new() }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream::push_token":["fn push_token(&mut self, token: TokenTree){\n        // https://github.com/alexcrichton/proc-macro2/issues/235\n        match token {\n            #[cfg(not(no_bind_by_move_pattern_guard))]\n            TokenTree::Literal(crate::Literal {\n                #[cfg(wrap_proc_macro)]\n                    inner: crate::imp::Literal::Fallback(literal),\n                #[cfg(not(wrap_proc_macro))]\n                    inner: literal,\n                ..\n            }) if literal.text.starts_with('-') => {\n                push_negative_literal(self, literal);\n            }\n            #[cfg(no_bind_by_move_pattern_guard)]\n            TokenTree::Literal(crate::Literal {\n                #[cfg(wrap_proc_macro)]\n                    inner: crate::imp::Literal::Fallback(literal),\n                #[cfg(not(wrap_proc_macro))]\n                    inner: literal,\n                ..\n            }) => {\n                if literal.text.starts_with('-') {\n                    push_negative_literal(self, literal);\n                } else {\n                    self.inner\n                        .push(TokenTree::Literal(crate::Literal::_new_stable(literal)));\n                }\n            }\n            _ => self.inner.push(token),\n        }\n\n        #[cold]\n        fn push_negative_literal(stream: &mut TokenStream, mut literal: Literal) {\n            literal.text.remove(0);\n            let mut punct = crate::Punct::new('-', Spacing::Alone);\n            punct.set_span(crate::Span::_new_stable(literal.span));\n            stream.inner.push(TokenTree::Punct(punct));\n            stream\n                .inner\n                .push(TokenTree::Literal(crate::Literal::_new_stable(literal)));\n        }\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream::push_token::push_negative_literal":["#[cold]\nfn push_negative_literal(stream: &mut TokenStream, mut literal: Literal){\n            literal.text.remove(0);\n            let mut punct = crate::Punct::new('-', Spacing::Alone);\n            punct.set_span(crate::Span::_new_stable(literal.span));\n            stream.inner.push(TokenTree::Punct(punct));\n            stream\n                .inner\n                .push(TokenTree::Literal(crate::Literal::_new_stable(literal)));\n        }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::TokenStream::take_inner":["fn take_inner(&mut self) -> Vec<TokenTree>{\n        mem::replace(&mut self.inner, Vec::new())\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::debug_span_field_if_nontrivial":["pub(crate) fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span){\n    #[cfg(span_locations)]\n    {\n        if span.lo == 0 && span.hi == 0 {\n            return;\n        }\n    }\n\n    if cfg!(span_locations) {\n        debug.field(\"span\", &span);\n    }\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::force":["/// Force use of proc-macro2's fallback implementation of the API for now, even\n/// if the compiler's implementation is available.\npub fn force(){\n    #[cfg(wrap_proc_macro)]\n    crate::detection::force_fallback();\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::get_cursor":["#[cfg(not(span_locations))]\nfn get_cursor(src: &str) -> Cursor{\n    Cursor { rest: src }\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::is_ident_continue":["pub(crate) fn is_ident_continue(c: char) -> bool{\n    ('a' <= c && c <= 'z')\n        || ('A' <= c && c <= 'Z')\n        || c == '_'\n        || ('0' <= c && c <= '9')\n        || (c > '\\x7f' && UnicodeXID::is_xid_continue(c))\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::is_ident_start":["pub(crate) fn is_ident_start(c: char) -> bool{\n    ('a' <= c && c <= 'z')\n        || ('A' <= c && c <= 'Z')\n        || c == '_'\n        || (c > '\\x7f' && UnicodeXID::is_xid_start(c))\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::unforce":["/// Resume using the compiler's implementation of the proc macro API if it is\n/// available.\npub fn unforce(){\n    #[cfg(wrap_proc_macro)]\n    crate::detection::unforce_fallback();\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::validate_ident":["fn validate_ident(string: &str){\n    let validate = string;\n    if validate.is_empty() {\n        panic!(\"Ident is not allowed to be empty; use Option<Ident>\");\n    }\n\n    if validate.bytes().all(|digit| digit >= b'0' && digit <= b'9') {\n        panic!(\"Ident cannot be a number; use Literal instead\");\n    }\n\n    fn ident_ok(string: &str) -> bool {\n        let mut chars = string.chars();\n        let first = chars.next().unwrap();\n        if !is_ident_start(first) {\n            return false;\n        }\n        for ch in chars {\n            if !is_ident_continue(ch) {\n                return false;\n            }\n        }\n        true\n    }\n\n    if !ident_ok(validate) {\n        panic!(\"{:?} is not a valid Ident\", string);\n    }\n}","Real(LocalPath(\"src/fallback.rs\"))"],"fallback::validate_ident::ident_ok":["fn ident_ok(string: &str) -> bool{\n        let mut chars = string.chars();\n        let first = chars.next().unwrap();\n        if !is_ident_start(first) {\n            return false;\n        }\n        for ch in chars {\n            if !is_ident_continue(ch) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/fallback.rs\"))"],"imp::<impl std::convert::From<imp::TokenStream> for proc_macro::TokenStream>::from":["fn from(inner: TokenStream) -> proc_macro::TokenStream{\n        match inner {\n            TokenStream::Compiler(inner) => inner.into_token_stream(),\n            TokenStream::Fallback(inner) => inner.to_string().parse().unwrap(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::<impl std::convert::From<proc_macro::Span> for Span>::from":["fn from(proc_span: proc_macro::Span) -> crate::Span{\n        crate::Span::_new(Span::Compiler(proc_span))\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::DeferredTokenStream":["pub(crate) struct DeferredTokenStream {\n    stream: proc_macro::TokenStream,\n    extra: Vec<proc_macro::TokenTree>,\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::DeferredTokenStream::evaluate_now":["fn evaluate_now(&mut self){\n        // If-check provides a fast short circuit for the common case of `extra`\n        // being empty, which saves a round trip over the proc macro bridge.\n        // Improves macro expansion time in winrt by 6% in debug mode.\n        if !self.extra.is_empty() {\n            self.stream.extend(self.extra.drain(..));\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::DeferredTokenStream::into_token_stream":["fn into_token_stream(mut self) -> proc_macro::TokenStream{\n        self.evaluate_now();\n        self.stream\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::DeferredTokenStream::is_empty":["fn is_empty(&self) -> bool{\n        self.stream.is_empty() && self.extra.is_empty()\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::DeferredTokenStream::new":["fn new(stream: proc_macro::TokenStream) -> Self{\n        DeferredTokenStream {\n            stream,\n            extra: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group":["pub(crate) enum Group {\n    Compiler(proc_macro::Group),\n    Fallback(fallback::Group),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::delimiter":["pub fn delimiter(&self) -> Delimiter{\n        match self {\n            Group::Compiler(g) => match g.delimiter() {\n                proc_macro::Delimiter::Parenthesis => Delimiter::Parenthesis,\n                proc_macro::Delimiter::Bracket => Delimiter::Bracket,\n                proc_macro::Delimiter::Brace => Delimiter::Brace,\n                proc_macro::Delimiter::None => Delimiter::None,\n            },\n            Group::Fallback(g) => g.delimiter(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::new":["pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group{\n        match stream {\n            TokenStream::Compiler(tts) => {\n                let delimiter = match delimiter {\n                    Delimiter::Parenthesis => proc_macro::Delimiter::Parenthesis,\n                    Delimiter::Bracket => proc_macro::Delimiter::Bracket,\n                    Delimiter::Brace => proc_macro::Delimiter::Brace,\n                    Delimiter::None => proc_macro::Delimiter::None,\n                };\n                Group::Compiler(proc_macro::Group::new(delimiter, tts.into_token_stream()))\n            }\n            TokenStream::Fallback(stream) => {\n                Group::Fallback(fallback::Group::new(delimiter, stream))\n            }\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::set_span":["pub fn set_span(&mut self, span: Span){\n        match (self, span) {\n            (Group::Compiler(g), Span::Compiler(s)) => g.set_span(s),\n            (Group::Fallback(g), Span::Fallback(s)) => g.set_span(s),\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::span":["pub fn span(&self) -> Span{\n        match self {\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::span_close":["pub fn span_close(&self) -> Span{\n        match self {\n            #[cfg(proc_macro_span)]\n            Group::Compiler(g) => Span::Compiler(g.span_close()),\n            #[cfg(not(proc_macro_span))]\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span_close()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::span_open":["pub fn span_open(&self) -> Span{\n        match self {\n            #[cfg(proc_macro_span)]\n            Group::Compiler(g) => Span::Compiler(g.span_open()),\n            #[cfg(not(proc_macro_span))]\n            Group::Compiler(g) => Span::Compiler(g.span()),\n            Group::Fallback(g) => Span::Fallback(g.span_open()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::stream":["pub fn stream(&self) -> TokenStream{\n        match self {\n            Group::Compiler(g) => TokenStream::Compiler(DeferredTokenStream::new(g.stream())),\n            Group::Fallback(g) => TokenStream::Fallback(g.stream()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Group::unwrap_nightly":["fn unwrap_nightly(self) -> proc_macro::Group{\n        match self {\n            Group::Compiler(g) => g,\n            Group::Fallback(_) => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident":["pub(crate) enum Ident {\n    Compiler(proc_macro::Ident),\n    Fallback(fallback::Ident),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident::new":["pub fn new(string: &str, span: Span) -> Ident{\n        match span {\n            Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new(string, s)),\n            Span::Fallback(s) => Ident::Fallback(fallback::Ident::new(string, s)),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident::new_raw":["pub fn new_raw(string: &str, span: Span) -> Ident{\n        match span {\n            Span::Compiler(s) => {\n                let p: proc_macro::TokenStream = string.parse().unwrap();\n                let ident = match p.into_iter().next() {\n                    Some(proc_macro::TokenTree::Ident(mut i)) => {\n                        i.set_span(s);\n                        i\n                    }\n                    _ => panic!(),\n                };\n                Ident::Compiler(ident)\n            }\n            Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_raw(string, s)),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident::set_span":["pub fn set_span(&mut self, span: Span){\n        match (self, span) {\n            (Ident::Compiler(t), Span::Compiler(s)) => t.set_span(s),\n            (Ident::Fallback(t), Span::Fallback(s)) => t.set_span(s),\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident::span":["pub fn span(&self) -> Span{\n        match self {\n            Ident::Compiler(t) => Span::Compiler(t.span()),\n            Ident::Fallback(t) => Span::Fallback(t.span()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Ident::unwrap_nightly":["fn unwrap_nightly(self) -> proc_macro::Ident{\n        match self {\n            Ident::Compiler(s) => s,\n            Ident::Fallback(_) => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::LexError":["pub(crate) enum LexError {\n    Compiler(proc_macro::LexError),\n    Fallback(fallback::LexError),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal":["pub(crate) enum Literal {\n    Compiler(proc_macro::Literal),\n    Fallback(fallback::Literal),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::byte_string":["pub fn byte_string(bytes: &[u8]) -> Literal{\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::byte_string(bytes))\n        } else {\n            Literal::Fallback(fallback::Literal::byte_string(bytes))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::character":["pub fn character(t: char) -> Literal{\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::character(t))\n        } else {\n            Literal::Fallback(fallback::Literal::character(t))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::f32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::f32_unsuffixed":["pub fn f32_unsuffixed(f: f32) -> Literal{\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::f32_unsuffixed(f))\n        } else {\n            Literal::Fallback(fallback::Literal::f32_unsuffixed(f))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::f64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::f64_unsuffixed":["pub fn f64_unsuffixed(f: f64) -> Literal{\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::f64_unsuffixed(f))\n        } else {\n            Literal::Fallback(fallback::Literal::f64_unsuffixed(f))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i128_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i128_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i16_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i16_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i32_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i64_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i8_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::i8_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::isize_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::isize_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::set_span":["pub fn set_span(&mut self, span: Span){\n        match (self, span) {\n            (Literal::Compiler(lit), Span::Compiler(s)) => lit.set_span(s),\n            (Literal::Fallback(lit), Span::Fallback(s)) => lit.set_span(s),\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::span":["pub fn span(&self) -> Span{\n        match self {\n            Literal::Compiler(lit) => Span::Compiler(lit.span()),\n            Literal::Fallback(lit) => Span::Fallback(lit.span()),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::string":["pub fn string(t: &str) -> Literal{\n        if inside_proc_macro() {\n            Literal::Compiler(proc_macro::Literal::string(t))\n        } else {\n            Literal::Fallback(fallback::Literal::string(t))\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::subspan":["pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span>{\n        match self {\n            #[cfg(proc_macro_span)]\n            Literal::Compiler(lit) => lit.subspan(range).map(Span::Compiler),\n            #[cfg(not(proc_macro_span))]\n            Literal::Compiler(_lit) => None,\n            Literal::Fallback(lit) => lit.subspan(range).map(Span::Fallback),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u128_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u128_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u16_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u16_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u32_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u32_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u64_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u64_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u8_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::u8_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::unwrap_nightly":["fn unwrap_nightly(self) -> proc_macro::Literal{\n        match self {\n            Literal::Compiler(s) => s,\n            Literal::Fallback(_) => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::usize_suffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Literal::usize_unsuffixed":["pub fn $name(n: $kind) -> Literal{\n            if inside_proc_macro() {\n                Literal::Compiler(proc_macro::Literal::$name(n))\n            } else {\n                Literal::Fallback(fallback::Literal::$name(n))\n            }\n        }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span":["pub(crate) enum Span {\n    Compiler(proc_macro::Span),\n    Fallback(fallback::Span),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::call_site":["pub fn call_site() -> Span{\n        if inside_proc_macro() {\n            Span::Compiler(proc_macro::Span::call_site())\n        } else {\n            Span::Fallback(fallback::Span::call_site())\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::join":["pub fn join(&self, other: Span) -> Option<Span>{\n        let ret = match (self, other) {\n            #[cfg(proc_macro_span)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.join(b)?),\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.join(b)?),\n            _ => return None,\n        };\n        Some(ret)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::located_at":["pub fn located_at(&self, other: Span) -> Span{\n        match (self, other) {\n            #[cfg(hygiene)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.located_at(b)),\n\n            // Name resolution affects semantics, but location is only cosmetic\n            #[cfg(not(hygiene))]\n            (Span::Compiler(_), Span::Compiler(_)) => *self,\n\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.located_at(b)),\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::mixed_site":["#[cfg(hygiene)]\npub fn mixed_site() -> Span{\n        if inside_proc_macro() {\n            Span::Compiler(proc_macro::Span::mixed_site())\n        } else {\n            Span::Fallback(fallback::Span::mixed_site())\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::resolved_at":["pub fn resolved_at(&self, other: Span) -> Span{\n        match (self, other) {\n            #[cfg(hygiene)]\n            (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.resolved_at(b)),\n\n            // Name resolution affects semantics, but location is only cosmetic\n            #[cfg(not(hygiene))]\n            (Span::Compiler(_), Span::Compiler(_)) => other,\n\n            (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.resolved_at(b)),\n            _ => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::unwrap":["pub fn unwrap(self) -> proc_macro::Span{\n        match self {\n            Span::Compiler(s) => s,\n            Span::Fallback(_) => panic!(\"proc_macro::Span is only available in procedural macros\"),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::Span::unwrap_nightly":["fn unwrap_nightly(self) -> proc_macro::Span{\n        match self {\n            Span::Compiler(s) => s,\n            Span::Fallback(_) => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenStream":["pub(crate) enum TokenStream {\n    Compiler(DeferredTokenStream),\n    Fallback(fallback::TokenStream),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenStream::is_empty":["pub fn is_empty(&self) -> bool{\n        match self {\n            TokenStream::Compiler(tts) => tts.is_empty(),\n            TokenStream::Fallback(tts) => tts.is_empty(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenStream::new":["pub fn new() -> TokenStream{\n        if inside_proc_macro() {\n            TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::new()))\n        } else {\n            TokenStream::Fallback(fallback::TokenStream::new())\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenStream::unwrap_nightly":["fn unwrap_nightly(self) -> proc_macro::TokenStream{\n        match self {\n            TokenStream::Compiler(s) => s.into_token_stream(),\n            TokenStream::Fallback(_) => mismatch(),\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenStream::unwrap_stable":["fn unwrap_stable(self) -> fallback::TokenStream{\n        match self {\n            TokenStream::Compiler(_) => mismatch(),\n            TokenStream::Fallback(s) => s,\n        }\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::TokenTreeIter":["pub(crate) enum TokenTreeIter {\n    Compiler(proc_macro::token_stream::IntoIter),\n    Fallback(fallback::TokenTreeIter),\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::debug_span_field_if_nontrivial":["pub(crate) fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span){\n    match span {\n        Span::Compiler(s) => {\n            debug.field(\"span\", &s);\n        }\n        Span::Fallback(s) => fallback::debug_span_field_if_nontrivial(debug, s),\n    }\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::into_compiler_token":["fn into_compiler_token(token: TokenTree) -> proc_macro::TokenTree{\n    match token {\n        TokenTree::Group(tt) => tt.inner.unwrap_nightly().into(),\n        TokenTree::Punct(tt) => {\n            let spacing = match tt.spacing() {\n                Spacing::Joint => proc_macro::Spacing::Joint,\n                Spacing::Alone => proc_macro::Spacing::Alone,\n            };\n            let mut punct = proc_macro::Punct::new(tt.as_char(), spacing);\n            punct.set_span(tt.span().inner.unwrap_nightly());\n            punct.into()\n        }\n        TokenTree::Ident(tt) => tt.inner.unwrap_nightly().into(),\n        TokenTree::Literal(tt) => tt.inner.unwrap_nightly().into(),\n    }\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::mismatch":["fn mismatch() -> !{\n    panic!(\"stable/nightly mismatch\")\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"imp::proc_macro_parse":["fn proc_macro_parse(src: &str) -> Result<proc_macro::TokenStream, LexError>{\n    panic::catch_unwind(|| src.parse().map_err(LexError::Compiler))\n        .unwrap_or(Err(LexError::Fallback(fallback::LexError)))\n}","Real(LocalPath(\"src/wrapper.rs\"))"],"marker::ProcMacroAutoTraits":["pub(crate) struct ProcMacroAutoTraits(Rc<()>);","Real(LocalPath(\"src/marker.rs\"))"],"parse::Cursor":["pub(crate) struct Cursor<'a> {\n    pub rest: &'a str,\n    #[cfg(span_locations)]\n    pub off: u32,\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::advance":["fn advance(&self, bytes: usize) -> Cursor<'a>{\n        let (_front, rest) = self.rest.split_at(bytes);\n        Cursor {\n            rest,\n            #[cfg(span_locations)]\n            off: self.off + _front.chars().count() as u32,\n        }\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::as_bytes":["fn as_bytes(&self) -> &'a [u8]{\n        self.rest.as_bytes()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::bytes":["fn bytes(&self) -> Bytes<'a>{\n        self.rest.bytes()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::char_indices":["fn char_indices(&self) -> CharIndices<'a>{\n        self.rest.char_indices()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::chars":["fn chars(&self) -> Chars<'a>{\n        self.rest.chars()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::is_empty":["pub(crate) fn is_empty(&self) -> bool{\n        self.rest.is_empty()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::len":["fn len(&self) -> usize{\n        self.rest.len()\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::parse":["fn parse(&self, tag: &str) -> Result<Cursor<'a>, LexError>{\n        if self.starts_with(tag) {\n            Ok(self.advance(tag.len()))\n        } else {\n            Err(LexError)\n        }\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Cursor::<'a>::starts_with":["fn starts_with(&self, s: &str) -> bool{\n        self.rest.starts_with(s)\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::backslash_u":["fn backslash_u<I>(chars: &mut I) -> bool\nwhere\n    I: Iterator<Item = (usize, char)>,{\n    next_ch!(chars @ '{');\n    let mut value = 0;\n    let mut len = 0;\n    while let Some((_, ch)) = chars.next() {\n        let digit = match ch {\n            '0'..='9' => ch as u8 - b'0',\n            'a'..='f' => 10 + ch as u8 - b'a',\n            'A'..='F' => 10 + ch as u8 - b'A',\n            '_' if len > 0 => continue,\n            '}' if len > 0 => return char::from_u32(value).is_some(),\n            _ => return false,\n        };\n        if len == 6 {\n            return false;\n        }\n        value *= 0x10;\n        value += u32::from(digit);\n        len += 1;\n    }\n    false\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::backslash_x_byte":["fn backslash_x_byte<I>(chars: &mut I) -> bool\nwhere\n    I: Iterator<Item = (usize, u8)>,{\n    next_ch!(chars @ b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F');\n    next_ch!(chars @ b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F');\n    true\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::backslash_x_char":["fn backslash_x_char<I>(chars: &mut I) -> bool\nwhere\n    I: Iterator<Item = (usize, char)>,{\n    next_ch!(chars @ '0'..='7');\n    next_ch!(chars @ '0'..='9' | 'a'..='f' | 'A'..='F');\n    true\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::block_comment":["fn block_comment(input: Cursor) -> PResult<&str>{\n    if !input.starts_with(\"/*\") {\n        return Err(LexError);\n    }\n\n    let mut depth = 0;\n    let bytes = input.as_bytes();\n    let mut i = 0;\n    let upper = bytes.len() - 1;\n\n    while i < upper {\n        if bytes[i] == b'/' && bytes[i + 1] == b'*' {\n            depth += 1;\n            i += 1; // eat '*'\n        } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {\n            depth -= 1;\n            if depth == 0 {\n                return Ok((input.advance(i + 2), &input.rest[..i + 2]));\n            }\n            i += 1; // eat '/'\n        }\n        i += 1;\n    }\n\n    Err(LexError)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::byte":["fn byte(input: Cursor) -> Result<Cursor, LexError>{\n    let input = input.parse(\"b'\")?;\n    let mut bytes = input.bytes().enumerate();\n    let ok = match bytes.next().map(|(_, b)| b) {\n        Some(b'\\\\') => match bytes.next().map(|(_, b)| b) {\n            Some(b'x') => backslash_x_byte(&mut bytes),\n            Some(b'n') | Some(b'r') | Some(b't') | Some(b'\\\\') | Some(b'0') | Some(b'\\'')\n            | Some(b'\"') => true,\n            _ => false,\n        },\n        b => b.is_some(),\n    };\n    if !ok {\n        return Err(LexError);\n    }\n    let (offset, _) = bytes.next().ok_or(LexError)?;\n    if !input.chars().as_str().is_char_boundary(offset) {\n        return Err(LexError);\n    }\n    let input = input.advance(offset).parse(\"'\")?;\n    Ok(literal_suffix(input))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::byte_string":["fn byte_string(input: Cursor) -> Result<Cursor, LexError>{\n    if let Ok(input) = input.parse(\"b\\\"\") {\n        cooked_byte_string(input)\n    } else if let Ok(input) = input.parse(\"br\") {\n        raw_string(input)\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::character":["fn character(input: Cursor) -> Result<Cursor, LexError>{\n    let input = input.parse(\"'\")?;\n    let mut chars = input.char_indices();\n    let ok = match chars.next().map(|(_, ch)| ch) {\n        Some('\\\\') => match chars.next().map(|(_, ch)| ch) {\n            Some('x') => backslash_x_char(&mut chars),\n            Some('u') => backslash_u(&mut chars),\n            Some('n') | Some('r') | Some('t') | Some('\\\\') | Some('0') | Some('\\'') | Some('\"') => {\n                true\n            }\n            _ => false,\n        },\n        ch => ch.is_some(),\n    };\n    if !ok {\n        return Err(LexError);\n    }\n    let (idx, _) = chars.next().ok_or(LexError)?;\n    let input = input.advance(idx).parse(\"'\")?;\n    Ok(literal_suffix(input))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::cooked_byte_string":["fn cooked_byte_string(mut input: Cursor) -> Result<Cursor, LexError>{\n    let mut bytes = input.bytes().enumerate();\n    while let Some((offset, b)) = bytes.next() {\n        match b {\n            b'\"' => {\n                let input = input.advance(offset + 1);\n                return Ok(literal_suffix(input));\n            }\n            b'\\r' => match bytes.next() {\n                Some((_, b'\\n')) => {}\n                _ => break,\n            },\n            b'\\\\' => match bytes.next() {\n                Some((_, b'x')) => {\n                    if !backslash_x_byte(&mut bytes) {\n                        break;\n                    }\n                }\n                Some((_, b'n')) | Some((_, b'r')) | Some((_, b't')) | Some((_, b'\\\\'))\n                | Some((_, b'0')) | Some((_, b'\\'')) | Some((_, b'\"')) => {}\n                Some((newline, b @ b'\\n')) | Some((newline, b @ b'\\r')) => {\n                    let mut last = b as char;\n                    let rest = input.advance(newline + 1);\n                    let mut chars = rest.char_indices();\n                    loop {\n                        if last == '\\r' && chars.next().map_or(true, |(_, ch)| ch != '\\n') {\n                            return Err(LexError);\n                        }\n                        match chars.next() {\n                            Some((_, ch)) if ch.is_whitespace() => last = ch,\n                            Some((offset, _)) => {\n                                input = rest.advance(offset);\n                                bytes = input.bytes().enumerate();\n                                break;\n                            }\n                            None => return Err(LexError),\n                        }\n                    }\n                }\n                _ => break,\n            },\n            b if b < 0x80 => {}\n            _ => break,\n        }\n    }\n    Err(LexError)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::cooked_string":["fn cooked_string(input: Cursor) -> Result<Cursor, LexError>{\n    let mut chars = input.char_indices().peekable();\n\n    while let Some((i, ch)) = chars.next() {\n        match ch {\n            '\"' => {\n                let input = input.advance(i + 1);\n                return Ok(literal_suffix(input));\n            }\n            '\\r' => match chars.next() {\n                Some((_, '\\n')) => {}\n                _ => break,\n            },\n            '\\\\' => match chars.next() {\n                Some((_, 'x')) => {\n                    if !backslash_x_char(&mut chars) {\n                        break;\n                    }\n                }\n                Some((_, 'n')) | Some((_, 'r')) | Some((_, 't')) | Some((_, '\\\\'))\n                | Some((_, '\\'')) | Some((_, '\"')) | Some((_, '0')) => {}\n                Some((_, 'u')) => {\n                    if !backslash_u(&mut chars) {\n                        break;\n                    }\n                }\n                Some((_, ch @ '\\n')) | Some((_, ch @ '\\r')) => {\n                    let mut last = ch;\n                    loop {\n                        if last == '\\r' && chars.next().map_or(true, |(_, ch)| ch != '\\n') {\n                            return Err(LexError);\n                        }\n                        match chars.peek() {\n                            Some((_, ch)) if ch.is_whitespace() => {\n                                last = *ch;\n                                chars.next();\n                            }\n                            _ => break,\n                        }\n                    }\n                }\n                _ => break,\n            },\n            _ch => {}\n        }\n    }\n    Err(LexError)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::digits":["fn digits(mut input: Cursor) -> Result<Cursor, LexError>{\n    let base = if input.starts_with(\"0x\") {\n        input = input.advance(2);\n        16\n    } else if input.starts_with(\"0o\") {\n        input = input.advance(2);\n        8\n    } else if input.starts_with(\"0b\") {\n        input = input.advance(2);\n        2\n    } else {\n        10\n    };\n\n    let mut len = 0;\n    let mut empty = true;\n    for b in input.bytes() {\n        match b {\n            b'0'..=b'9' => {\n                let digit = (b - b'0') as u64;\n                if digit >= base {\n                    return Err(LexError);\n                }\n            }\n            b'a'..=b'f' => {\n                let digit = 10 + (b - b'a') as u64;\n                if digit >= base {\n                    break;\n                }\n            }\n            b'A'..=b'F' => {\n                let digit = 10 + (b - b'A') as u64;\n                if digit >= base {\n                    break;\n                }\n            }\n            b'_' => {\n                if empty && base == 10 {\n                    return Err(LexError);\n                }\n                len += 1;\n                continue;\n            }\n            _ => break,\n        };\n        len += 1;\n        empty = false;\n    }\n    if empty {\n        Err(LexError)\n    } else {\n        Ok(input.advance(len))\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::doc_comment":["fn doc_comment(input: Cursor) -> PResult<Vec<TokenTree>>{\n    #[cfg(span_locations)]\n    let lo = input.off;\n    let (rest, (comment, inner)) = doc_comment_contents(input)?;\n    let span = crate::Span::_new_stable(Span {\n        #[cfg(span_locations)]\n        lo,\n        #[cfg(span_locations)]\n        hi: rest.off,\n    });\n\n    let mut scan_for_bare_cr = comment;\n    while let Some(cr) = scan_for_bare_cr.find('\\r') {\n        let rest = &scan_for_bare_cr[cr + 1..];\n        if !rest.starts_with('\\n') {\n            return Err(LexError);\n        }\n        scan_for_bare_cr = rest;\n    }\n\n    let mut trees = Vec::new();\n    trees.push(TokenTree::Punct(Punct::new('#', Spacing::Alone)));\n    if inner {\n        trees.push(Punct::new('!', Spacing::Alone).into());\n    }\n    let mut stream = vec![\n        TokenTree::Ident(crate::Ident::new(\"doc\", span)),\n        TokenTree::Punct(Punct::new('=', Spacing::Alone)),\n        TokenTree::Literal(crate::Literal::string(comment)),\n    ];\n    for tt in stream.iter_mut() {\n        tt.set_span(span);\n    }\n    let group = Group::new(Delimiter::Bracket, stream.into_iter().collect());\n    trees.push(crate::Group::_new_stable(group).into());\n    for tt in trees.iter_mut() {\n        tt.set_span(span);\n    }\n    Ok((rest, trees))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::doc_comment_contents":["fn doc_comment_contents(input: Cursor) -> PResult<(&str, bool)>{\n    if input.starts_with(\"//!\") {\n        let input = input.advance(3);\n        let (input, s) = take_until_newline_or_eof(input);\n        Ok((input, (s, true)))\n    } else if input.starts_with(\"/*!\") {\n        let (input, s) = block_comment(input)?;\n        Ok((input, (&s[3..s.len() - 2], true)))\n    } else if input.starts_with(\"///\") {\n        let input = input.advance(3);\n        if input.starts_with(\"/\") {\n            return Err(LexError);\n        }\n        let (input, s) = take_until_newline_or_eof(input);\n        Ok((input, (s, false)))\n    } else if input.starts_with(\"/**\") && !input.rest[3..].starts_with('*') {\n        let (input, s) = block_comment(input)?;\n        Ok((input, (&s[3..s.len() - 2], false)))\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::float":["fn float(input: Cursor) -> Result<Cursor, LexError>{\n    let mut rest = float_digits(input)?;\n    if let Some(ch) = rest.chars().next() {\n        if is_ident_start(ch) {\n            rest = ident_not_raw(rest)?.0;\n        }\n    }\n    word_break(rest)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::float_digits":["fn float_digits(input: Cursor) -> Result<Cursor, LexError>{\n    let mut chars = input.chars().peekable();\n    match chars.next() {\n        Some(ch) if ch >= '0' && ch <= '9' => {}\n        _ => return Err(LexError),\n    }\n\n    let mut len = 1;\n    let mut has_dot = false;\n    let mut has_exp = false;\n    while let Some(&ch) = chars.peek() {\n        match ch {\n            '0'..='9' | '_' => {\n                chars.next();\n                len += 1;\n            }\n            '.' => {\n                if has_dot {\n                    break;\n                }\n                chars.next();\n                if chars\n                    .peek()\n                    .map(|&ch| ch == '.' || is_ident_start(ch))\n                    .unwrap_or(false)\n                {\n                    return Err(LexError);\n                }\n                len += 1;\n                has_dot = true;\n            }\n            'e' | 'E' => {\n                chars.next();\n                len += 1;\n                has_exp = true;\n                break;\n            }\n            _ => break,\n        }\n    }\n\n    if !(has_dot || has_exp) {\n        return Err(LexError);\n    }\n\n    if has_exp {\n        let token_before_exp = if has_dot {\n            Ok(input.advance(len - 1))\n        } else {\n            Err(LexError)\n        };\n        let mut has_sign = false;\n        let mut has_exp_value = false;\n        while let Some(&ch) = chars.peek() {\n            match ch {\n                '+' | '-' => {\n                    if has_exp_value {\n                        break;\n                    }\n                    if has_sign {\n                        return token_before_exp;\n                    }\n                    chars.next();\n                    len += 1;\n                    has_sign = true;\n                }\n                '0'..='9' => {\n                    chars.next();\n                    len += 1;\n                    has_exp_value = true;\n                }\n                '_' => {\n                    chars.next();\n                    len += 1;\n                }\n                _ => break,\n            }\n        }\n        if !has_exp_value {\n            return token_before_exp;\n        }\n    }\n\n    Ok(input.advance(len))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::ident":["fn ident(input: Cursor) -> PResult<crate::Ident>{\n    if [\"r\\\"\", \"r#\\\"\", \"r##\", \"b\\\"\", \"b\\'\", \"br\\\"\", \"br#\"]\n        .iter()\n        .any(|prefix| input.starts_with(prefix))\n    {\n        Err(LexError)\n    } else {\n        ident_any(input)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::ident_any":["fn ident_any(input: Cursor) -> PResult<crate::Ident>{\n    let raw = input.starts_with(\"r#\");\n    let rest = input.advance((raw as usize) << 1);\n\n    let (rest, sym) = ident_not_raw(rest)?;\n\n    if !raw {\n        let ident = crate::Ident::new(sym, crate::Span::call_site());\n        return Ok((rest, ident));\n    }\n\n    if sym == \"_\" {\n        return Err(LexError);\n    }\n\n    let ident = crate::Ident::_new_raw(sym, crate::Span::call_site());\n    Ok((rest, ident))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::ident_not_raw":["fn ident_not_raw(input: Cursor) -> PResult<&str>{\n    let mut chars = input.char_indices();\n\n    match chars.next() {\n        Some((_, ch)) if is_ident_start(ch) => {}\n        _ => return Err(LexError),\n    }\n\n    let mut end = input.len();\n    for (i, ch) in chars {\n        if !is_ident_continue(ch) {\n            end = i;\n            break;\n        }\n    }\n\n    Ok((input.advance(end), &input.rest[..end]))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::int":["fn int(input: Cursor) -> Result<Cursor, LexError>{\n    let mut rest = digits(input)?;\n    if let Some(ch) = rest.chars().next() {\n        if is_ident_start(ch) {\n            rest = ident_not_raw(rest)?.0;\n        }\n    }\n    word_break(rest)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::is_whitespace":["fn is_whitespace(ch: char) -> bool{\n    // Rust treats left-to-right mark and right-to-left mark as whitespace\n    ch.is_whitespace() || ch == '\\u{200e}' || ch == '\\u{200f}'\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::leaf_token":["fn leaf_token(input: Cursor) -> PResult<TokenTree>{\n    if let Ok((input, l)) = literal(input) {\n        // must be parsed before ident\n        Ok((input, TokenTree::Literal(crate::Literal::_new_stable(l))))\n    } else if let Ok((input, p)) = punct(input) {\n        Ok((input, TokenTree::Punct(p)))\n    } else if let Ok((input, i)) = ident(input) {\n        Ok((input, TokenTree::Ident(i)))\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::literal":["fn literal(input: Cursor) -> PResult<Literal>{\n    match literal_nocapture(input) {\n        Ok(a) => {\n            let end = input.len() - a.len();\n            Ok((a, Literal::_new(input.rest[..end].to_string())))\n        }\n        Err(LexError) => Err(LexError),\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::literal_nocapture":["fn literal_nocapture(input: Cursor) -> Result<Cursor, LexError>{\n    if let Ok(ok) = string(input) {\n        Ok(ok)\n    } else if let Ok(ok) = byte_string(input) {\n        Ok(ok)\n    } else if let Ok(ok) = byte(input) {\n        Ok(ok)\n    } else if let Ok(ok) = character(input) {\n        Ok(ok)\n    } else if let Ok(ok) = float(input) {\n        Ok(ok)\n    } else if let Ok(ok) = int(input) {\n        Ok(ok)\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::literal_suffix":["fn literal_suffix(input: Cursor) -> Cursor{\n    match ident_not_raw(input) {\n        Ok((input, _)) => input,\n        Err(LexError) => input,\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::punct":["fn punct(input: Cursor) -> PResult<Punct>{\n    match punct_char(input) {\n        Ok((rest, '\\'')) => {\n            if ident_any(rest)?.0.starts_with(\"'\") {\n                Err(LexError)\n            } else {\n                Ok((rest, Punct::new('\\'', Spacing::Joint)))\n            }\n        }\n        Ok((rest, ch)) => {\n            let kind = match punct_char(rest) {\n                Ok(_) => Spacing::Joint,\n                Err(LexError) => Spacing::Alone,\n            };\n            Ok((rest, Punct::new(ch, kind)))\n        }\n        Err(LexError) => Err(LexError),\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::punct_char":["fn punct_char(input: Cursor) -> PResult<char>{\n    if input.starts_with(\"//\") || input.starts_with(\"/*\") {\n        // Do not accept `/` of a comment as a punct.\n        return Err(LexError);\n    }\n\n    let mut chars = input.chars();\n    let first = match chars.next() {\n        Some(ch) => ch,\n        None => {\n            return Err(LexError);\n        }\n    };\n    let recognized = \"~!@#$%^&*-=+|;:,<.>/?'\";\n    if recognized.contains(first) {\n        Ok((input.advance(first.len_utf8()), first))\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::raw_string":["fn raw_string(input: Cursor) -> Result<Cursor, LexError>{\n    let mut chars = input.char_indices();\n    let mut n = 0;\n    while let Some((i, ch)) = chars.next() {\n        match ch {\n            '\"' => {\n                n = i;\n                break;\n            }\n            '#' => {}\n            _ => return Err(LexError),\n        }\n    }\n    while let Some((i, ch)) = chars.next() {\n        match ch {\n            '\"' if input.rest[i + 1..].starts_with(&input.rest[..n]) => {\n                let rest = input.advance(i + 1 + n);\n                return Ok(literal_suffix(rest));\n            }\n            '\\r' => match chars.next() {\n                Some((_, '\\n')) => {}\n                _ => break,\n            },\n            _ => {}\n        }\n    }\n    Err(LexError)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::skip_whitespace":["fn skip_whitespace(input: Cursor) -> Cursor{\n    let mut s = input;\n\n    while !s.is_empty() {\n        let byte = s.as_bytes()[0];\n        if byte == b'/' {\n            if s.starts_with(\"//\")\n                && (!s.starts_with(\"///\") || s.starts_with(\"////\"))\n                && !s.starts_with(\"//!\")\n            {\n                let (cursor, _) = take_until_newline_or_eof(s);\n                s = cursor;\n                continue;\n            } else if s.starts_with(\"/**/\") {\n                s = s.advance(4);\n                continue;\n            } else if s.starts_with(\"/*\")\n                && (!s.starts_with(\"/**\") || s.starts_with(\"/***\"))\n                && !s.starts_with(\"/*!\")\n            {\n                match block_comment(s) {\n                    Ok((rest, _)) => {\n                        s = rest;\n                        continue;\n                    }\n                    Err(LexError) => return s,\n                }\n            }\n        }\n        match byte {\n            b' ' | 0x09..=0x0d => {\n                s = s.advance(1);\n                continue;\n            }\n            b if b <= 0x7f => {}\n            _ => {\n                let ch = s.chars().next().unwrap();\n                if is_whitespace(ch) {\n                    s = s.advance(ch.len_utf8());\n                    continue;\n                }\n            }\n        }\n        return s;\n    }\n    s\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::string":["fn string(input: Cursor) -> Result<Cursor, LexError>{\n    if let Ok(input) = input.parse(\"\\\"\") {\n        cooked_string(input)\n    } else if let Ok(input) = input.parse(\"r\") {\n        raw_string(input)\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::take_until_newline_or_eof":["fn take_until_newline_or_eof(input: Cursor) -> (Cursor, &str){\n    let chars = input.char_indices();\n\n    for (i, ch) in chars {\n        if ch == '\\n' {\n            return (input.advance(i), &input.rest[..i]);\n        } else if ch == '\\r' && input.rest[i + 1..].starts_with('\\n') {\n            return (input.advance(i + 1), &input.rest[..i]);\n        }\n    }\n\n    (input.advance(input.len()), input.rest)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::token_stream":["pub(crate) fn token_stream(mut input: Cursor) -> PResult<TokenStream>{\n    let mut trees = Vec::new();\n    let mut stack = Vec::new();\n\n    loop {\n        input = skip_whitespace(input);\n\n        if let Ok((rest, tt)) = doc_comment(input) {\n            trees.extend(tt);\n            input = rest;\n            continue;\n        }\n\n        #[cfg(span_locations)]\n        let lo = input.off;\n\n        let first = match input.bytes().next() {\n            Some(first) => first,\n            None => break,\n        };\n\n        if let Some(open_delimiter) = match first {\n            b'(' => Some(Delimiter::Parenthesis),\n            b'[' => Some(Delimiter::Bracket),\n            b'{' => Some(Delimiter::Brace),\n            _ => None,\n        } {\n            input = input.advance(1);\n            let frame = (open_delimiter, trees);\n            #[cfg(span_locations)]\n            let frame = (lo, frame);\n            stack.push(frame);\n            trees = Vec::new();\n        } else if let Some(close_delimiter) = match first {\n            b')' => Some(Delimiter::Parenthesis),\n            b']' => Some(Delimiter::Bracket),\n            b'}' => Some(Delimiter::Brace),\n            _ => None,\n        } {\n            input = input.advance(1);\n            let frame = stack.pop().ok_or(LexError)?;\n            #[cfg(span_locations)]\n            let (lo, frame) = frame;\n            let (open_delimiter, outer) = frame;\n            if open_delimiter != close_delimiter {\n                return Err(LexError);\n            }\n            let mut g = Group::new(open_delimiter, TokenStream { inner: trees });\n            g.set_span(Span {\n                #[cfg(span_locations)]\n                lo,\n                #[cfg(span_locations)]\n                hi: input.off,\n            });\n            trees = outer;\n            trees.push(TokenTree::Group(crate::Group::_new_stable(g)));\n        } else {\n            let (rest, mut tt) = leaf_token(input)?;\n            tt.set_span(crate::Span::_new_stable(Span {\n                #[cfg(span_locations)]\n                lo,\n                #[cfg(span_locations)]\n                hi: rest.off,\n            }));\n            trees.push(tt);\n            input = rest;\n        }\n    }\n\n    if stack.is_empty() {\n        Ok((input, TokenStream { inner: trees }))\n    } else {\n        Err(LexError)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::word_break":["fn word_break(input: Cursor) -> Result<Cursor, LexError>{\n    match input.chars().next() {\n        Some(ch) if is_ident_continue(ch) => Err(LexError),\n        Some(_) | None => Ok(input),\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"token_stream::<impl std::iter::IntoIterator for TokenStream>::into_iter":["fn into_iter(self) -> IntoIter{\n            IntoIter {\n                inner: self.inner.into_iter(),\n                _marker: Marker,\n            }\n        }","Real(LocalPath(\"src/lib.rs\"))"],"token_stream::IntoIter":["/// An iterator over `TokenStream`'s `TokenTree`s.\n///\n/// The iteration is \"shallow\", e.g. the iterator doesn't recurse into\n/// delimited groups, and returns whole groups as token trees.\npub struct IntoIter {\n        inner: imp::TokenTreeIter,\n        _marker: Marker,\n    }","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"!":["mismatch"],"&'a [u8]":["as_bytes"],"(parse::Cursor<'_>, &str)":["block_comment","ident_not_raw","take_until_newline_or_eof"],"(parse::Cursor<'_>, (&str, bool))":["doc_comment_contents"],"(parse::Cursor<'_>, Ident)":["ident","ident_any"],"(parse::Cursor<'_>, Punct)":["punct"],"(parse::Cursor<'_>, TokenTree)":["leaf_token"],"(parse::Cursor<'_>, char)":["punct_char"],"(parse::Cursor<'_>, fallback::Literal)":["literal"],"(parse::Cursor<'_>, fallback::TokenStream)":["token_stream"],"(parse::Cursor<'_>, std::vec::Vec<TokenTree>)":["doc_comment"],"(usize, std::option::Option<usize>)":["size_hint"],"Delimiter":["clone","delimiter"],"Group":["_new","_new_stable","clone","new"],"Ident":["_new","_new_raw","clone","new"],"Literal":["_new","_new_stable","byte_string","character","clone","f32_suffixed","f32_unsuffixed","f64_suffixed","f64_unsuffixed","i128_suffixed","i128_unsuffixed","i16_suffixed","i16_unsuffixed","i32_suffixed","i32_unsuffixed","i64_suffixed","i64_unsuffixed","i8_suffixed","i8_unsuffixed","isize_suffixed","isize_unsuffixed","string","u128_suffixed","u128_unsuffixed","u16_suffixed","u16_unsuffixed","u32_suffixed","u32_unsuffixed","u64_suffixed","u64_unsuffixed","u8_suffixed","u8_unsuffixed","usize_suffixed","usize_unsuffixed"],"Punct":["clone","new"],"Spacing":["clone","spacing"],"Span":["_new","_new_stable","call_site","clone","from","mixed_site","span","span_close","span_open","subspan"],"TokenStream":["_new","_new_stable","clone","default","from","from_iter","from_str","new","stream"],"TokenTree":["clone","from","next"],"bool":["backslash_u","backslash_x_byte","backslash_x_char","eq","ident_ok","inside_proc_macro","is_empty","is_ident_continue","is_ident_start","is_real","is_whitespace","starts_with"],"char":["as_char"],"fallback::Group":["clone","new"],"fallback::Ident":["_new","clone","new","new_raw"],"fallback::LineColumn":["clone"],"fallback::Literal":["_new","byte_string","character","clone","f32_suffixed","f32_unsuffixed","f64_suffixed","f64_unsuffixed","i128_suffixed","i128_unsuffixed","i16_suffixed","i16_unsuffixed","i32_suffixed","i32_unsuffixed","i64_suffixed","i64_unsuffixed","i8_suffixed","i8_unsuffixed","isize_suffixed","isize_unsuffixed","string","u128_suffixed","u128_unsuffixed","u16_suffixed","u16_unsuffixed","u32_suffixed","u32_unsuffixed","u64_suffixed","u64_unsuffixed","u8_suffixed","u8_unsuffixed","usize_suffixed","usize_unsuffixed"],"fallback::SourceFile":["clone"],"fallback::Span":["call_site","clone","mixed_site","span","span_close","span_open","subspan"],"fallback::TokenStream":["clone","from","from_iter","from_str","new","stream","unwrap_stable"],"imp::DeferredTokenStream":["clone","new"],"imp::Group":["clone","from","new"],"imp::Ident":["clone","new","new_raw"],"imp::LexError":["from"],"imp::Literal":["byte_string","character","clone","f32_suffixed","f32_unsuffixed","f64_suffixed","f64_unsuffixed","from","i128_suffixed","i128_unsuffixed","i16_suffixed","i16_unsuffixed","i32_suffixed","i32_unsuffixed","i64_suffixed","i64_unsuffixed","i8_suffixed","i8_unsuffixed","isize_suffixed","isize_unsuffixed","string","u128_suffixed","u128_unsuffixed","u16_suffixed","u16_unsuffixed","u32_suffixed","u32_unsuffixed","u64_suffixed","u64_unsuffixed","u8_suffixed","u8_unsuffixed","usize_suffixed","usize_unsuffixed"],"imp::Span":["call_site","clone","from","mixed_site","span","span_close","span_open","subspan"],"imp::TokenStream":["clone","from","from_iter","from_str","new","stream"],"imp::TokenTreeIter":["clone","into_iter"],"parse::Cursor":["advance","clone","get_cursor","parse"],"proc_macro::Group":["unwrap_nightly"],"proc_macro::Ident":["unwrap_nightly"],"proc_macro::Literal":["unwrap_nightly"],"proc_macro::Span":["unstable","unwrap","unwrap_nightly"],"proc_macro::TokenStream":["from","into_token_stream","proc_macro_parse","unwrap_nightly"],"proc_macro::TokenTree":["into_compiler_token"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::path::PathBuf":["path"],"std::str::Bytes":["bytes"],"std::str::CharIndices":["char_indices"],"std::str::Chars":["chars"],"std::vec::IntoIter":["into_iter"],"std::vec::Vec":["take_inner"],"token_stream::IntoIter":["clone","into_iter"],"usize":["len"]},"struct_to_trait":{"Delimiter":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Group":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"Ident":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash"],"LexError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"Literal":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"Punct":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"Spacing":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Span":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::marker::Copy"],"TokenStream":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::str::FromStr"],"TokenTree":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display"],"fallback::Group":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"fallback::Ident":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"],"fallback::LexError":["std::fmt::Debug","std::fmt::Display"],"fallback::LineColumn":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fallback::Literal":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"fallback::SourceFile":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fallback::Span":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fallback::TokenStream":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Drop","std::str::FromStr"],"imp::DeferredTokenStream":["std::clone::Clone"],"imp::Group":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display"],"imp::Ident":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"],"imp::LexError":["std::convert::From","std::fmt::Debug","std::fmt::Display"],"imp::Literal":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display"],"imp::Span":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::marker::Copy"],"imp::TokenStream":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::str::FromStr"],"imp::TokenTreeIter":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"marker::ProcMacroAutoTraits":["std::panic::RefUnwindSafe","std::panic::UnwindSafe"],"parse::Cursor":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"proc_macro::TokenStream":["std::convert::From"],"token_stream::IntoIter":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"]},"targets":{"<Group as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Group as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<Ident as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::Ord"],"<Ident as std::cmp::PartialEq<T>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<Ident as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<Ident as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialOrd"],"<Ident as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Ident as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<Ident as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"<LexError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<LexError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Literal as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<Punct as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Punct as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<TokenStream as std::convert::From<TokenTree>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenStream as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<TokenStream as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<TokenStream as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<TokenStream as std::iter::Extend<TokenStream>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<TokenStream as std::iter::Extend<TokenTree>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<TokenStream as std::iter::FromIterator<TokenStream>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<TokenStream as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/lib.rs\"))","std::str::FromStr"],"<TokenTree as std::convert::From<Group>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenTree as std::convert::From<Ident>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenTree as std::convert::From<Literal>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenTree as std::convert::From<Punct>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<TokenTree as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<TokenTree as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<fallback::Group as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::Group as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Display"],"<fallback::Ident as std::cmp::PartialEq<T>>::eq":["eq","Real(LocalPath(\"src/fallback.rs\"))","std::cmp::PartialEq"],"<fallback::Ident as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/fallback.rs\"))","std::cmp::PartialEq"],"<fallback::Ident as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::Ident as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Display"],"<fallback::LexError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Display"],"<fallback::Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::Literal as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Display"],"<fallback::SourceFile as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::TokenStream as std::convert::From<TokenTree>>::from":["from","Real(LocalPath(\"src/fallback.rs\"))","std::convert::From"],"<fallback::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["from","Real(LocalPath(\"src/fallback.rs\"))","std::convert::From"],"<fallback::TokenStream as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Debug"],"<fallback::TokenStream as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fallback.rs\"))","std::fmt::Display"],"<fallback::TokenStream as std::iter::Extend<TokenTree>>::extend":["extend","Real(LocalPath(\"src/fallback.rs\"))","std::iter::Extend"],"<fallback::TokenStream as std::iter::Extend<fallback::TokenStream>>::extend":["extend","Real(LocalPath(\"src/fallback.rs\"))","std::iter::Extend"],"<fallback::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["from_iter","Real(LocalPath(\"src/fallback.rs\"))","std::iter::FromIterator"],"<fallback::TokenStream as std::iter::FromIterator<fallback::TokenStream>>::from_iter":["from_iter","Real(LocalPath(\"src/fallback.rs\"))","std::iter::FromIterator"],"<fallback::TokenStream as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/fallback.rs\"))","std::iter::IntoIterator"],"<fallback::TokenStream as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/fallback.rs\"))","std::ops::Drop"],"<fallback::TokenStream as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/fallback.rs\"))","std::str::FromStr"],"<imp::Group as std::convert::From<fallback::Group>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::Group as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::Group as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<imp::Ident as std::cmp::PartialEq<T>>::eq":["eq","Real(LocalPath(\"src/wrapper.rs\"))","std::cmp::PartialEq"],"<imp::Ident as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/wrapper.rs\"))","std::cmp::PartialEq"],"<imp::Ident as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::Ident as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<imp::LexError as std::convert::From<fallback::LexError>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::LexError as std::convert::From<proc_macro::LexError>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::LexError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::LexError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<imp::Literal as std::convert::From<fallback::Literal>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::Literal as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<imp::Span as std::convert::From<fallback::Span>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::TokenStream as std::convert::From<TokenTree>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::TokenStream as std::convert::From<fallback::TokenStream>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::TokenStream as std::convert::From<proc_macro::TokenStream>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<imp::TokenStream as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::TokenStream as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<imp::TokenStream as std::iter::Extend<TokenTree>>::extend":["extend","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::Extend"],"<imp::TokenStream as std::iter::Extend<imp::TokenStream>>::extend":["extend","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::Extend"],"<imp::TokenStream as std::iter::FromIterator<TokenTree>>::from_iter":["from_iter","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::FromIterator"],"<imp::TokenStream as std::iter::FromIterator<imp::TokenStream>>::from_iter":["from_iter","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::FromIterator"],"<imp::TokenStream as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::IntoIterator"],"<imp::TokenStream as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/wrapper.rs\"))","std::str::FromStr"],"<imp::TokenTreeIter as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Debug"],"<imp::TokenTreeIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::Iterator"],"<imp::TokenTreeIter as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/wrapper.rs\"))","std::iter::Iterator"],"<impl std::convert::From<TokenStream> for proc_macro::TokenStream>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<token_stream::IntoIter as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<token_stream::IntoIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"Group::_new":["_new","Real(LocalPath(\"src/lib.rs\"))",""],"Group::_new_stable":["_new_stable","Real(LocalPath(\"src/lib.rs\"))",""],"Group::delimiter":["delimiter","Real(LocalPath(\"src/lib.rs\"))",""],"Group::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Group::set_span":["set_span","Real(LocalPath(\"src/lib.rs\"))",""],"Group::span":["span","Real(LocalPath(\"src/lib.rs\"))",""],"Group::span_close":["span_close","Real(LocalPath(\"src/lib.rs\"))",""],"Group::span_open":["span_open","Real(LocalPath(\"src/lib.rs\"))",""],"Group::stream":["stream","Real(LocalPath(\"src/lib.rs\"))",""],"Ident::_new":["_new","Real(LocalPath(\"src/lib.rs\"))",""],"Ident::_new_raw":["_new_raw","Real(LocalPath(\"src/lib.rs\"))",""],"Ident::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Ident::set_span":["set_span","Real(LocalPath(\"src/lib.rs\"))",""],"Ident::span":["span","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::_new":["_new","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::_new_stable":["_new_stable","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::byte_string":["byte_string","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::character":["character","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::f32_suffixed":["f32_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::f32_unsuffixed":["f32_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::f64_suffixed":["f64_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::f64_unsuffixed":["f64_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i128_suffixed":["i128_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i128_unsuffixed":["i128_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i16_suffixed":["i16_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i16_unsuffixed":["i16_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i32_suffixed":["i32_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i32_unsuffixed":["i32_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i64_suffixed":["i64_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i64_unsuffixed":["i64_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i8_suffixed":["i8_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::i8_unsuffixed":["i8_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::isize_suffixed":["isize_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::isize_unsuffixed":["isize_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::set_span":["set_span","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::span":["span","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::string":["string","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::subspan":["subspan","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u128_suffixed":["u128_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u128_unsuffixed":["u128_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u16_suffixed":["u16_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u16_unsuffixed":["u16_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u32_suffixed":["u32_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u32_unsuffixed":["u32_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u64_suffixed":["u64_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u64_unsuffixed":["u64_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u8_suffixed":["u8_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::u8_unsuffixed":["u8_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::usize_suffixed":["usize_suffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Literal::usize_unsuffixed":["usize_unsuffixed","Real(LocalPath(\"src/lib.rs\"))",""],"Punct::as_char":["as_char","Real(LocalPath(\"src/lib.rs\"))",""],"Punct::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Punct::set_span":["set_span","Real(LocalPath(\"src/lib.rs\"))",""],"Punct::spacing":["spacing","Real(LocalPath(\"src/lib.rs\"))",""],"Punct::span":["span","Real(LocalPath(\"src/lib.rs\"))",""],"Span::_new":["_new","Real(LocalPath(\"src/lib.rs\"))",""],"Span::_new_stable":["_new_stable","Real(LocalPath(\"src/lib.rs\"))",""],"Span::call_site":["call_site","Real(LocalPath(\"src/lib.rs\"))",""],"Span::join":["join","Real(LocalPath(\"src/lib.rs\"))",""],"Span::located_at":["located_at","Real(LocalPath(\"src/lib.rs\"))",""],"Span::mixed_site":["mixed_site","Real(LocalPath(\"src/lib.rs\"))",""],"Span::resolved_at":["resolved_at","Real(LocalPath(\"src/lib.rs\"))",""],"Span::unstable":["unstable","Real(LocalPath(\"src/lib.rs\"))",""],"Span::unwrap":["unwrap","Real(LocalPath(\"src/lib.rs\"))",""],"TokenStream::_new":["_new","Real(LocalPath(\"src/lib.rs\"))",""],"TokenStream::_new_stable":["_new_stable","Real(LocalPath(\"src/lib.rs\"))",""],"TokenStream::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"TokenStream::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"TokenTree::set_span":["set_span","Real(LocalPath(\"src/lib.rs\"))",""],"TokenTree::span":["span","Real(LocalPath(\"src/lib.rs\"))",""],"detection::force_fallback":["force_fallback","Real(LocalPath(\"src/detection.rs\"))",""],"detection::initialize":["initialize","Real(LocalPath(\"src/detection.rs\"))",""],"detection::inside_proc_macro":["inside_proc_macro","Real(LocalPath(\"src/detection.rs\"))",""],"detection::unforce_fallback":["unforce_fallback","Real(LocalPath(\"src/detection.rs\"))",""],"fallback::<impl std::convert::From<fallback::TokenStream> for proc_macro::TokenStream>::from":["from","Real(LocalPath(\"src/fallback.rs\"))","std::convert::From"],"fallback::Group::delimiter":["delimiter","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::new":["new","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::set_span":["set_span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::span":["span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::span_close":["span_close","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::span_open":["span_open","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Group::stream":["stream","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Ident::_new":["_new","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Ident::new":["new","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Ident::new_raw":["new_raw","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Ident::set_span":["set_span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Ident::span":["span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::_new":["_new","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::byte_string":["byte_string","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::character":["character","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::f32_suffixed":["f32_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::f32_unsuffixed":["f32_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::f64_suffixed":["f64_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::f64_unsuffixed":["f64_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i128_suffixed":["i128_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i128_unsuffixed":["i128_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i16_suffixed":["i16_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i16_unsuffixed":["i16_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i32_suffixed":["i32_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i32_unsuffixed":["i32_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i64_suffixed":["i64_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i64_unsuffixed":["i64_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i8_suffixed":["i8_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::i8_unsuffixed":["i8_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::isize_suffixed":["isize_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::isize_unsuffixed":["isize_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::set_span":["set_span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::span":["span","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::string":["string","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::subspan":["subspan","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u128_suffixed":["u128_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u128_unsuffixed":["u128_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u16_suffixed":["u16_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u16_unsuffixed":["u16_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u32_suffixed":["u32_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u32_unsuffixed":["u32_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u64_suffixed":["u64_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u64_unsuffixed":["u64_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u8_suffixed":["u8_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::u8_unsuffixed":["u8_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::usize_suffixed":["usize_suffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Literal::usize_unsuffixed":["usize_unsuffixed","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::SourceFile::is_real":["is_real","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::SourceFile::path":["path","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::call_site":["call_site","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::first_byte":["first_byte","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::join":["join","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::last_byte":["last_byte","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::located_at":["located_at","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::mixed_site":["mixed_site","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::Span::resolved_at":["resolved_at","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::TokenStream::is_empty":["is_empty","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::TokenStream::new":["new","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::TokenStream::push_token":["push_token","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::TokenStream::push_token::push_negative_literal":["push_negative_literal","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::TokenStream::take_inner":["take_inner","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::debug_span_field_if_nontrivial":["debug_span_field_if_nontrivial","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::force":["force","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::get_cursor":["get_cursor","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::is_ident_continue":["is_ident_continue","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::is_ident_start":["is_ident_start","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::unforce":["unforce","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::validate_ident":["validate_ident","Real(LocalPath(\"src/fallback.rs\"))",""],"fallback::validate_ident::ident_ok":["ident_ok","Real(LocalPath(\"src/fallback.rs\"))",""],"imp::<impl std::convert::From<imp::TokenStream> for proc_macro::TokenStream>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"imp::<impl std::convert::From<proc_macro::Span> for Span>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"imp::DeferredTokenStream::evaluate_now":["evaluate_now","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::DeferredTokenStream::into_token_stream":["into_token_stream","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::DeferredTokenStream::is_empty":["is_empty","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::DeferredTokenStream::new":["new","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::delimiter":["delimiter","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::new":["new","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::set_span":["set_span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::span":["span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::span_close":["span_close","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::span_open":["span_open","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::stream":["stream","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Group::unwrap_nightly":["unwrap_nightly","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Ident::new":["new","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Ident::new_raw":["new_raw","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Ident::set_span":["set_span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Ident::span":["span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Ident::unwrap_nightly":["unwrap_nightly","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::byte_string":["byte_string","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::character":["character","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::f32_suffixed":["f32_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::f32_unsuffixed":["f32_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::f64_suffixed":["f64_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::f64_unsuffixed":["f64_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i128_suffixed":["i128_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i128_unsuffixed":["i128_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i16_suffixed":["i16_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i16_unsuffixed":["i16_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i32_suffixed":["i32_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i32_unsuffixed":["i32_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i64_suffixed":["i64_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i64_unsuffixed":["i64_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i8_suffixed":["i8_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::i8_unsuffixed":["i8_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::isize_suffixed":["isize_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::isize_unsuffixed":["isize_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::set_span":["set_span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::span":["span","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::string":["string","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::subspan":["subspan","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u128_suffixed":["u128_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u128_unsuffixed":["u128_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u16_suffixed":["u16_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u16_unsuffixed":["u16_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u32_suffixed":["u32_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u32_unsuffixed":["u32_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u64_suffixed":["u64_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u64_unsuffixed":["u64_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u8_suffixed":["u8_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::u8_unsuffixed":["u8_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::unwrap_nightly":["unwrap_nightly","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::usize_suffixed":["usize_suffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Literal::usize_unsuffixed":["usize_unsuffixed","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::call_site":["call_site","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::join":["join","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::located_at":["located_at","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::mixed_site":["mixed_site","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::resolved_at":["resolved_at","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::unwrap":["unwrap","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::Span::unwrap_nightly":["unwrap_nightly","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::TokenStream::is_empty":["is_empty","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::TokenStream::new":["new","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::TokenStream::unwrap_nightly":["unwrap_nightly","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::TokenStream::unwrap_stable":["unwrap_stable","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::debug_span_field_if_nontrivial":["debug_span_field_if_nontrivial","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::into_compiler_token":["into_compiler_token","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::mismatch":["mismatch","Real(LocalPath(\"src/wrapper.rs\"))",""],"imp::proc_macro_parse":["proc_macro_parse","Real(LocalPath(\"src/wrapper.rs\"))",""],"parse::Cursor::<'a>::advance":["advance","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::bytes":["bytes","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::char_indices":["char_indices","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::chars":["chars","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::is_empty":["is_empty","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::len":["len","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::parse":["parse","Real(LocalPath(\"src/parse.rs\"))",""],"parse::Cursor::<'a>::starts_with":["starts_with","Real(LocalPath(\"src/parse.rs\"))",""],"parse::backslash_u":["backslash_u","Real(LocalPath(\"src/parse.rs\"))",""],"parse::backslash_x_byte":["backslash_x_byte","Real(LocalPath(\"src/parse.rs\"))",""],"parse::backslash_x_char":["backslash_x_char","Real(LocalPath(\"src/parse.rs\"))",""],"parse::block_comment":["block_comment","Real(LocalPath(\"src/parse.rs\"))",""],"parse::byte":["byte","Real(LocalPath(\"src/parse.rs\"))",""],"parse::byte_string":["byte_string","Real(LocalPath(\"src/parse.rs\"))",""],"parse::character":["character","Real(LocalPath(\"src/parse.rs\"))",""],"parse::cooked_byte_string":["cooked_byte_string","Real(LocalPath(\"src/parse.rs\"))",""],"parse::cooked_string":["cooked_string","Real(LocalPath(\"src/parse.rs\"))",""],"parse::digits":["digits","Real(LocalPath(\"src/parse.rs\"))",""],"parse::doc_comment":["doc_comment","Real(LocalPath(\"src/parse.rs\"))",""],"parse::doc_comment_contents":["doc_comment_contents","Real(LocalPath(\"src/parse.rs\"))",""],"parse::float":["float","Real(LocalPath(\"src/parse.rs\"))",""],"parse::float_digits":["float_digits","Real(LocalPath(\"src/parse.rs\"))",""],"parse::ident":["ident","Real(LocalPath(\"src/parse.rs\"))",""],"parse::ident_any":["ident_any","Real(LocalPath(\"src/parse.rs\"))",""],"parse::ident_not_raw":["ident_not_raw","Real(LocalPath(\"src/parse.rs\"))",""],"parse::int":["int","Real(LocalPath(\"src/parse.rs\"))",""],"parse::is_whitespace":["is_whitespace","Real(LocalPath(\"src/parse.rs\"))",""],"parse::leaf_token":["leaf_token","Real(LocalPath(\"src/parse.rs\"))",""],"parse::literal":["literal","Real(LocalPath(\"src/parse.rs\"))",""],"parse::literal_nocapture":["literal_nocapture","Real(LocalPath(\"src/parse.rs\"))",""],"parse::literal_suffix":["literal_suffix","Real(LocalPath(\"src/parse.rs\"))",""],"parse::punct":["punct","Real(LocalPath(\"src/parse.rs\"))",""],"parse::punct_char":["punct_char","Real(LocalPath(\"src/parse.rs\"))",""],"parse::raw_string":["raw_string","Real(LocalPath(\"src/parse.rs\"))",""],"parse::skip_whitespace":["skip_whitespace","Real(LocalPath(\"src/parse.rs\"))",""],"parse::string":["string","Real(LocalPath(\"src/parse.rs\"))",""],"parse::take_until_newline_or_eof":["take_until_newline_or_eof","Real(LocalPath(\"src/parse.rs\"))",""],"parse::token_stream":["token_stream","Real(LocalPath(\"src/parse.rs\"))",""],"parse::word_break":["word_break","Real(LocalPath(\"src/parse.rs\"))",""],"token_stream::<impl std::iter::IntoIterator for TokenStream>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"]},"trait_to_struct":{"std::clone::Clone":["Delimiter","Group","Ident","Literal","Punct","Spacing","Span","TokenStream","TokenTree","fallback::Group","fallback::Ident","fallback::LineColumn","fallback::Literal","fallback::SourceFile","fallback::Span","fallback::TokenStream","imp::DeferredTokenStream","imp::Group","imp::Ident","imp::Literal","imp::Span","imp::TokenStream","imp::TokenTreeIter","parse::Cursor","token_stream::IntoIter"],"std::cmp::Eq":["Delimiter","Ident","Spacing","fallback::LineColumn","fallback::SourceFile","fallback::Span","parse::Cursor"],"std::cmp::Ord":["Ident"],"std::cmp::PartialEq":["Delimiter","Ident","Spacing","fallback::Ident","fallback::LineColumn","fallback::SourceFile","fallback::Span","imp::Ident","parse::Cursor"],"std::cmp::PartialOrd":["Ident"],"std::convert::From":["Span","TokenStream","TokenTree","fallback::TokenStream","imp::Group","imp::LexError","imp::Literal","imp::Span","imp::TokenStream","proc_macro::TokenStream"],"std::default::Default":["TokenStream"],"std::error::Error":["LexError"],"std::fmt::Debug":["Delimiter","Group","Ident","LexError","Literal","Punct","Spacing","Span","TokenStream","TokenTree","fallback::Group","fallback::Ident","fallback::LexError","fallback::LineColumn","fallback::Literal","fallback::SourceFile","fallback::Span","fallback::TokenStream","imp::Group","imp::Ident","imp::LexError","imp::Literal","imp::Span","imp::TokenStream","imp::TokenTreeIter","token_stream::IntoIter"],"std::fmt::Display":["Group","Ident","LexError","Literal","Punct","TokenStream","TokenTree","fallback::Group","fallback::Ident","fallback::LexError","fallback::Literal","fallback::TokenStream","imp::Group","imp::Ident","imp::LexError","imp::Literal","imp::TokenStream"],"std::hash::Hash":["Ident"],"std::iter::Extend":["TokenStream","fallback::TokenStream","imp::TokenStream"],"std::iter::FromIterator":["TokenStream","fallback::TokenStream","imp::TokenStream"],"std::iter::IntoIterator":["TokenStream","fallback::TokenStream","imp::TokenStream"],"std::iter::Iterator":["imp::TokenTreeIter","token_stream::IntoIter"],"std::marker::Copy":["Delimiter","Spacing","Span","fallback::LineColumn","fallback::Span","imp::Span","parse::Cursor"],"std::marker::StructuralEq":["Delimiter","Spacing","fallback::LineColumn","fallback::SourceFile","fallback::Span","parse::Cursor"],"std::marker::StructuralPartialEq":["Delimiter","Spacing","fallback::LineColumn","fallback::SourceFile","fallback::Span","parse::Cursor"],"std::ops::Drop":["fallback::TokenStream"],"std::panic::RefUnwindSafe":["marker::ProcMacroAutoTraits"],"std::panic::UnwindSafe":["marker::ProcMacroAutoTraits"],"std::str::FromStr":["TokenStream","fallback::TokenStream","imp::TokenStream"]},"type_to_def_path":{"Delimiter":"Delimiter","Group":"Group","Ident":"Ident","LexError":"LexError","Literal":"Literal","Punct":"Punct","Spacing":"Spacing","Span":"Span","TokenStream":"TokenStream","TokenTree":"TokenTree","fallback::Group":"fallback::Group","fallback::Ident":"fallback::Ident","fallback::LexError":"fallback::LexError","fallback::LineColumn":"fallback::LineColumn","fallback::Literal":"fallback::Literal","fallback::SourceFile":"fallback::SourceFile","fallback::Span":"fallback::Span","fallback::TokenStream":"fallback::TokenStream","imp::DeferredTokenStream":"imp::DeferredTokenStream","imp::Group":"imp::Group","imp::Ident":"imp::Ident","imp::LexError":"imp::LexError","imp::Literal":"imp::Literal","imp::Span":"imp::Span","imp::TokenStream":"imp::TokenStream","imp::TokenTreeIter":"imp::TokenTreeIter","marker::ProcMacroAutoTraits":"marker::ProcMacroAutoTraits","parse::Cursor<'a>":"parse::Cursor","token_stream::IntoIter":"token_stream::IntoIter"}}