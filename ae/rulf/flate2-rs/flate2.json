{"dependencies":{"<Compression as std::clone::Clone>::clone":["Compression"],"<Compression as std::cmp::Eq>::assert_receiver_is_total_eq":["Compression"],"<Compression as std::cmp::PartialEq>::eq":["Compression"],"<Compression as std::default::Default>::default":["Compression"],"<Compression as std::fmt::Debug>::fmt":["Compression","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<bufreader::BufReader<R> as std::fmt::Debug>::fmt":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<bufreader::BufReader<R> as std::io::BufRead>::consume":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<bufreader::BufReader<R> as std::io::BufRead>::fill_buf":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<bufreader::BufReader<R> as std::io::Read>::read":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<crc::Crc as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<crc::CrcReader<R> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<crc::CrcReader<R> as std::io::BufRead>::consume":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"<crc::CrcReader<R> as std::io::BufRead>::fill_buf":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized","std::result::Result"],"<crc::CrcReader<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized","std::result::Result"],"<crc::CrcWriter<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<crc::CrcWriter<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized","std::result::Result"],"<crc::CrcWriter<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateDecoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateDecoder<R> as std::io::Read>::read":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::flush":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::write":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateEncoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateEncoder<R> as std::io::Read>::read":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::flush":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::write":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateDecoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateDecoder<R> as std::io::Read>::read":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::flush":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::write":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateEncoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateEncoder<R> as std::io::Read>::read":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::flush":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::write":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<deflate::write::DeflateDecoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateDecoder<W> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateEncoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateEncoder<W> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<ffi::rust::Deflate as ffi::Backend>::total_in":["ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Deflate as ffi::Backend>::total_out":["ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Deflate as ffi::DeflateBackend>::compress":["ffi::rust::Deflate","mem::FlushCompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<ffi::rust::Deflate as ffi::DeflateBackend>::make":["Compression","ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Deflate as ffi::DeflateBackend>::reset":["ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Deflate as std::fmt::Debug>::fmt":["ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ffi::rust::Inflate as ffi::Backend>::total_in":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Inflate as ffi::Backend>::total_out":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Inflate as ffi::InflateBackend>::decompress":["ffi::rust::Inflate","mem::FlushDecompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<ffi::rust::Inflate as ffi::InflateBackend>::make":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Inflate as ffi::InflateBackend>::reset":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<ffi::rust::Inflate as std::fmt::Debug>::fmt":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gz::GzBuilder as std::fmt::Debug>::fmt":["gz::GzBuilder","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<gz::GzHeader as std::clone::Clone>::clone":["gz::GzHeader","std::marker::Sized","std::option::Option"],"<gz::GzHeader as std::cmp::PartialEq>::eq":["gz::GzHeader","std::marker::Sized","std::option::Option"],"<gz::GzHeader as std::default::Default>::default":["gz::GzHeader","std::marker::Sized","std::option::Option"],"<gz::GzHeader as std::fmt::Debug>::fmt":["gz::GzHeader","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<gz::bufread::Buffer<'a, T> as std::io::Read>::read":["gz::bufread::Buffer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::GzDecoder<R> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::GzDecoder<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::GzDecoder<R> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::GzDecoder<R> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::GzEncoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::GzEncoder<R> as std::io::Read>::read":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::GzEncoder<R> as std::io::Write>::flush":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::GzEncoder<R> as std::io::Write>::write":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::GzState as std::fmt::Debug>::fmt":["gz::bufread::GzState","std::alloc::Allocator","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::bufread::MultiGzDecoder<R> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::MultiGzDecoder<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::GzDecoder<R> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::GzDecoder<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::GzDecoder<R> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::GzDecoder<R> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::GzEncoder<R> as std::fmt::Debug>::fmt":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::read::GzEncoder<R> as std::io::Read>::read":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::read::GzEncoder<R> as std::io::Write>::flush":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::read::GzEncoder<R> as std::io::Write>::write":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<gz::read::MultiGzDecoder<R> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::MultiGzDecoder<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<gz::write::Counter<T> as std::io::Read>::read":["bufreader::BufReader","gz::write::Counter","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized","std::result::Result"],"<gz::write::GzDecoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzDecoder<W> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzDecoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzDecoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzEncoder<R> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzEncoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzEncoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzEncoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<gz::write::GzEncoder<W> as std::ops::Drop>::drop":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"<mem::Compress as std::fmt::Debug>::fmt":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::Compress as zio::Ops>::run":["ffi::rust::Deflate","mem::Compress","mem::FlushCompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<mem::Compress as zio::Ops>::run_vec":["ffi::rust::Deflate","mem::Compress","mem::FlushCompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<mem::Compress as zio::Ops>::total_in":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<mem::Compress as zio::Ops>::total_out":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<mem::CompressError as std::fmt::Debug>::fmt":["mem::CompressError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::CompressError as std::fmt::Display>::fmt":["mem::CompressError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::Decompress as std::fmt::Debug>::fmt":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::Decompress as zio::Ops>::run":["ffi::rust::Inflate","mem::Decompress","mem::FlushDecompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<mem::Decompress as zio::Ops>::run_vec":["ffi::rust::Inflate","mem::Decompress","mem::FlushDecompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"<mem::Decompress as zio::Ops>::total_in":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<mem::Decompress as zio::Ops>::total_out":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<mem::DecompressError as std::fmt::Debug>::fmt":["mem::DecompressError","mem::DecompressErrorInner","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<mem::DecompressError as std::fmt::Display>::fmt":["mem::DecompressError","mem::DecompressErrorInner","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<mem::DecompressErrorInner as std::default::Default>::default":["mem::DecompressErrorInner","std::marker::Sized","std::option::Option"],"<mem::DecompressErrorInner as std::fmt::Debug>::fmt":["mem::DecompressErrorInner","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<mem::FlushCompress as std::clone::Clone>::clone":["mem::FlushCompress"],"<mem::FlushCompress as std::cmp::Eq>::assert_receiver_is_total_eq":["mem::FlushCompress"],"<mem::FlushCompress as std::cmp::PartialEq>::eq":["mem::FlushCompress"],"<mem::FlushCompress as std::fmt::Debug>::fmt":["mem::FlushCompress","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::FlushCompress as zio::Flush>::finish":["mem::FlushCompress"],"<mem::FlushCompress as zio::Flush>::none":["mem::FlushCompress"],"<mem::FlushCompress as zio::Flush>::sync":["mem::FlushCompress"],"<mem::FlushDecompress as std::clone::Clone>::clone":["mem::FlushDecompress"],"<mem::FlushDecompress as std::cmp::Eq>::assert_receiver_is_total_eq":["mem::FlushDecompress"],"<mem::FlushDecompress as std::cmp::PartialEq>::eq":["mem::FlushDecompress"],"<mem::FlushDecompress as std::fmt::Debug>::fmt":["mem::FlushDecompress","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mem::FlushDecompress as zio::Flush>::finish":["mem::FlushDecompress"],"<mem::FlushDecompress as zio::Flush>::none":["mem::FlushDecompress"],"<mem::FlushDecompress as zio::Flush>::sync":["mem::FlushDecompress"],"<mem::Status as std::clone::Clone>::clone":["mem::Status"],"<mem::Status as std::cmp::Eq>::assert_receiver_is_total_eq":["mem::Status"],"<mem::Status as std::cmp::PartialEq>::eq":["mem::Status"],"<mem::Status as std::fmt::Debug>::fmt":["mem::Status","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<zio::Writer<W, D> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<zio::Writer<W, D> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<zio::Writer<W, D> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"<zio::Writer<W, D> as std::ops::Drop>::drop":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"<zlib::bufread::ZlibDecoder<R> as std::fmt::Debug>::fmt":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder"],"<zlib::bufread::ZlibDecoder<R> as std::io::Read>::read":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::flush":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::write":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder"],"<zlib::bufread::ZlibEncoder<R> as std::fmt::Debug>::fmt":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder"],"<zlib::bufread::ZlibEncoder<R> as std::io::Read>::read":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::flush":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::write":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder"],"<zlib::read::ZlibDecoder<R> as std::fmt::Debug>::fmt":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"<zlib::read::ZlibDecoder<R> as std::io::Read>::read":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::flush":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::write":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"<zlib::read::ZlibEncoder<R> as std::fmt::Debug>::fmt":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"<zlib::read::ZlibEncoder<R> as std::io::Read>::read":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::flush":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::write":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"<zlib::write::ZlibDecoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"<zlib::write::ZlibDecoder<W> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"<zlib::write::ZlibEncoder<W> as std::fmt::Debug>::fmt":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"<zlib::write::ZlibEncoder<W> as std::io::Read>::read":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::flush":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::write":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"Compression":["Compression"],"Compression::best":["Compression"],"Compression::fast":["Compression"],"Compression::level":["Compression"],"Compression::new":["Compression"],"Compression::none":["Compression"],"_assert_send_sync":[],"_assert_send_sync::_assert_send_sync":["std::marker::Send","std::marker::Sized","std::marker::Sync"],"bufreader::BufReader":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::get_mut":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::get_ref":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::into_inner":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::new":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::reset":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bufreader::BufReader::<R>::with_buf":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"crc::Crc":["crc32fast::Hasher","crc::Crc"],"crc::Crc::amount":["crc32fast::Hasher","crc::Crc"],"crc::Crc::combine":["crc32fast::Hasher","crc::Crc"],"crc::Crc::new":["crc32fast::Hasher","crc::Crc"],"crc::Crc::reset":["crc32fast::Hasher","crc::Crc"],"crc::Crc::sum":["crc32fast::Hasher","crc::Crc"],"crc::Crc::update":["crc32fast::Hasher","crc::Crc"],"crc::CrcReader":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::crc":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::new":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcReader::<R>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcReader","std::marker::Sized"],"crc::CrcWriter":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::crc":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::new":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"crc::CrcWriter::<W>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","std::marker::Sized"],"deflate::bufread::DeflateDecoder":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::get_mut":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::get_ref":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::into_inner":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::new":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::reset":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::reset_data":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::total_in":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateDecoder::<R>::total_out":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::get_mut":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::get_ref":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::into_inner":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::new":["Compression","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::reset":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::total_in":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::DeflateEncoder::<R>::total_out":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::reset_decoder_data":["deflate::bufread::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::bufread::reset_encoder_data":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::get_mut":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::get_ref":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::into_inner":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::new":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::new_with_buf":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"deflate::read::DeflateDecoder::<R>::reset":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::total_in":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateDecoder::<R>::total_out":["deflate::bufread::DeflateDecoder","deflate::read::DeflateDecoder","ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::get_mut":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::get_ref":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::into_inner":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::new":["Compression","deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::reset":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::total_in":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::read::DeflateEncoder::<R>::total_out":["deflate::bufread::DeflateEncoder","deflate::read::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"deflate::write::DeflateDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::new":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::total_in":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::total_out":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateDecoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateDecoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::flush_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::new":["Compression","crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::total_in":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::total_out":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"deflate::write::DeflateEncoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","deflate::write::DeflateEncoder","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"ffi::Backend::total_in":[],"ffi::Backend::total_out":[],"ffi::DeflateBackend::compress":["mem::FlushCompress","std::marker::Sized","std::result::Result"],"ffi::DeflateBackend::make":["Compression"],"ffi::DeflateBackend::reset":[],"ffi::InflateBackend::decompress":["mem::FlushDecompress","std::marker::Sized","std::result::Result"],"ffi::InflateBackend::make":[],"ffi::InflateBackend::reset":[],"ffi::rust::Deflate":["ffi::rust::Deflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"ffi::rust::Inflate":["ffi::rust::Inflate","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"ffi::rust::format_from_bool":["miniz_oxide::DataFormat"],"gz::GzBuilder":["gz::GzBuilder","std::marker::Sized","std::option::Option"],"gz::GzBuilder::buf_read":["Compression","bufreader::BufReader","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::GzBuilder","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::BufRead","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::GzBuilder::comment":["gz::GzBuilder","std::convert::Into","std::marker::Sized","std::option::Option"],"gz::GzBuilder::extra":["gz::GzBuilder","std::convert::Into","std::marker::Sized","std::option::Option"],"gz::GzBuilder::filename":["gz::GzBuilder","std::convert::Into","std::marker::Sized","std::option::Option"],"gz::GzBuilder::into_header":["Compression","gz::GzBuilder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::GzBuilder::mtime":["gz::GzBuilder","std::marker::Sized","std::option::Option"],"gz::GzBuilder::new":["gz::GzBuilder","std::marker::Sized","std::option::Option"],"gz::GzBuilder::operating_system":["gz::GzBuilder","std::marker::Sized","std::option::Option"],"gz::GzBuilder::read":["Compression","bufreader::BufReader","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::GzBuilder","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::GzBuilder::write":["Compression","crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::GzBuilder","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::GzHeader":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::comment":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::extra":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::filename":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::mtime":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::mtime_as_datetime":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::GzHeader::operating_system":["gz::GzHeader","std::marker::Sized","std::option::Option"],"gz::bufread::Buffer":["gz::bufread::Buffer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"gz::bufread::Buffer::<'a, T>::new":["gz::bufread::Buffer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::header":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::multi":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzDecoder::<R>::new":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::GzEncoder":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzEncoder::<R>::get_mut":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzEncoder::<R>::get_ref":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzEncoder::<R>::into_inner":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzEncoder::<R>::new":["Compression","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::bufread::GzEncoder::<R>::read_footer":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"gz::bufread::GzState":["gz::bufread::GzState","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::vec::Vec"],"gz::bufread::MultiGzDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::MultiGzDecoder::<R>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::MultiGzDecoder::<R>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::MultiGzDecoder::<R>::header":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::MultiGzDecoder::<R>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::MultiGzDecoder::<R>::new":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::bufread::bad_header":["std::io::Error"],"gz::bufread::copy":[],"gz::bufread::corrupt":["std::io::Error"],"gz::bufread::finish":[],"gz::bufread::gz_encoder":["Compression","bufreader::BufReader","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::BufRead","std::marker::Sized","std::vec::Vec"],"gz::bufread::read_gz_header":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized","std::result::Result"],"gz::bufread::read_le_u16":["bufreader::BufReader","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized","std::result::Result"],"gz::read::GzDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzDecoder::<R>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzDecoder::<R>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzDecoder::<R>::header":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzDecoder::<R>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzDecoder::<R>::new":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::read::GzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::GzEncoder":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::read::GzEncoder::<R>::get_mut":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::read::GzEncoder::<R>::get_ref":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::read::GzEncoder::<R>::into_inner":["deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::read::GzEncoder::<R>::new":["Compression","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"gz::read::MultiGzDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::MultiGzDecoder::<R>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::MultiGzDecoder::<R>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::MultiGzDecoder::<R>::header":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::MultiGzDecoder::<R>::into_inner":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::MultiGzDecoder::<R>::new":["crc32fast::Hasher","crc::Crc","crc::CrcReader","gz::bufread::GzDecoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::MultiGzDecoder","std::alloc::Allocator","std::io::Error","std::marker::Sized","std::option::Option","std::vec::Vec"],"gz::read::gz_encoder":["bufreader::BufReader","deflate::bufread::DeflateEncoder","ffi::rust::Deflate","gz::bufread::GzEncoder","gz::read::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized","std::vec::Vec"],"gz::write::Counter":["bufreader::BufReader","gz::write::Counter","std::alloc::Allocator","std::boxed::Box","std::io::Read","std::marker::Sized"],"gz::write::GzDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::finish_and_check_crc":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::header":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::new":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzDecoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzDecoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::new":["Compression","crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::GzEncoder::<W>::write_header":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"gz::write::gz_encoder":["Compression","crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","gz::write::GzEncoder","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"mem::<impl std::convert::From<mem::CompressError> for std::io::Error>::from":["mem::CompressError","std::io::Error"],"mem::<impl std::convert::From<mem::DecompressError> for std::io::Error>::from":["mem::DecompressError","mem::DecompressErrorInner","std::io::Error","std::marker::Sized","std::option::Option"],"mem::Compress":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Compress::compress":["ffi::rust::Deflate","mem::Compress","mem::FlushCompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"mem::Compress::compress_vec":["ffi::rust::Deflate","mem::Compress","mem::FlushCompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"mem::Compress::new":["Compression","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Compress::reset":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Compress::total_in":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Compress::total_out":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::CompressError":["mem::CompressError"],"mem::Decompress":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Decompress::decompress":["ffi::rust::Inflate","mem::Decompress","mem::FlushDecompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"mem::Decompress::decompress_vec":["ffi::rust::Inflate","mem::Decompress","mem::FlushDecompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::vec::Vec"],"mem::Decompress::new":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Decompress::reset":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Decompress::total_in":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::Decompress::total_out":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"mem::DecompressError":["mem::DecompressError","mem::DecompressErrorInner","std::marker::Sized","std::option::Option"],"mem::DecompressError::needs_dictionary":["mem::DecompressError","mem::DecompressErrorInner","std::marker::Sized","std::option::Option"],"mem::DecompressErrorInner":["mem::DecompressErrorInner","std::marker::Sized","std::option::Option"],"mem::FlushCompress":["mem::FlushCompress"],"mem::FlushDecompress":["mem::FlushDecompress"],"mem::Status":["mem::Status"],"mem::decompress_failed":["std::marker::Sized","std::result::Result"],"mem::decompress_need_dict":["std::marker::Sized","std::result::Result"],"zio::Flush::finish":[],"zio::Flush::none":[],"zio::Flush::sync":[],"zio::Ops::run":["std::marker::Sized","std::result::Result"],"zio::Ops::run_vec":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"zio::Ops::total_in":[],"zio::Ops::total_out":[],"zio::Writer":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::dump":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::is_present":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::new":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::replace":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::take_inner":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer"],"zio::Writer::<W, D>::write_with_status":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer"],"zio::read":["bufreader::BufReader","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::BufRead","std::marker::Sized","std::result::Result","zio::Ops"],"zlib::bufread::ZlibDecoder":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::get_mut":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::get_ref":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::into_inner":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::new":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::reset":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::total_in":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibDecoder::<R>::total_out":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::ZlibEncoder":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::get_mut":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::get_ref":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::into_inner":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::new":["Compression","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::reset":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::total_in":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::ZlibEncoder::<R>::total_out":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::bufread::reset_decoder_data":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder"],"zlib::bufread::reset_encoder_data":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder"],"zlib::read::ZlibDecoder":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::get_mut":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::get_ref":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::into_inner":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::new":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::new_with_buf":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::reset":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::total_in":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibDecoder::<R>::total_out":["ffi::rust::Inflate","mem::Decompress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibDecoder","zlib::read::ZlibDecoder"],"zlib::read::ZlibEncoder":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::get_mut":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::get_ref":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::into_inner":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::new":["Compression","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::reset":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::total_in":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::read::ZlibEncoder::<R>::total_out":["ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","zlib::bufread::ZlibEncoder","zlib::read::ZlibEncoder"],"zlib::write::ZlibDecoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::new":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::total_in":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::total_out":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibDecoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibDecoder"],"zlib::write::ZlibEncoder":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::flush_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::get_mut":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::get_ref":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::new":["Compression","crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::reset":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::total_in":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::total_out":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"],"zlib::write::ZlibEncoder::<W>::try_finish":["crc32fast::Hasher","crc::Crc","crc::CrcWriter","ffi::rust::Deflate","mem::Compress","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","zio::Ops","zio::Writer","zlib::write::ZlibEncoder"]},"glob_path_import":{"ffi::rust":"ffi::","miniz_oxide":"ffi::rust::"},"self_to_fn":{"Compression":["Clone","Copy","Debug","Eq","PartialEq","impl Compression {\n    /// Creates a new description of the compression level with an explicitly\n    /// specified integer.\n    ///\n    /// The integer here is typically on a scale of 0-9 where 0 means \"no\n    /// compression\" and 9 means \"take as long as you'd like\".\n    pub const fn new(level: u32) -> Compression {\n        Compression(level)\n    }\n\n    /// No compression is to be performed, this may actually inflate data\n    /// slightly when encoding.\n    pub const fn none() -> Compression {\n        Compression(0)\n    }\n\n    /// Optimize for the best speed of encoding.\n    pub const fn fast() -> Compression {\n        Compression(1)\n    }\n\n    /// Optimize for the size of data being encoded.\n    pub const fn best() -> Compression {\n        Compression(9)\n    }\n\n    /// Returns an integer representing the compression level, typically on a\n    /// scale of 0-9\n    pub fn level(&self) -> u32 {\n        self.0\n    }\n}","impl Default for Compression {\n    fn default() -> Compression {\n        Compression(6)\n    }\n}"],"bufreader::BufReader":["impl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        // If we've reached the end of our internal buffer then we need to fetch\n        // some more data from the underlying reader.\n        if self.pos == self.cap {\n            self.cap = self.inner.read(&mut self.buf)?;\n            self.pos = 0;\n        }\n        Ok(&self.buf[self.pos..self.cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.pos = cmp::min(self.pos + amt, self.cap);\n    }\n}","impl<R: Read> BufReader<R> {\n    pub fn new(inner: R) -> BufReader<R> {\n        BufReader::with_buf(vec![0; 32 * 1024], inner)\n    }\n\n    pub fn with_buf(buf: Vec<u8>, inner: R) -> BufReader<R> {\n        BufReader {\n            inner: inner,\n            buf: buf.into_boxed_slice(),\n            pos: 0,\n            cap: 0,\n        }\n    }\n}","impl<R: Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n}","impl<R> ::std::fmt::Debug for BufReader<R>\nwhere\n    R: ::std::fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()),\n            )\n            .finish()\n    }\n}","impl<R> BufReader<R> {\n    pub fn get_ref(&self) -> &R {\n        &self.inner\n    }\n\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.inner\n    }\n\n    pub fn into_inner(self) -> R {\n        self.inner\n    }\n\n    pub fn reset(&mut self, inner: R) -> R {\n        self.pos = 0;\n        self.cap = 0;\n        mem::replace(&mut self.inner, inner)\n    }\n}"],"crc::Crc":["Debug","impl Crc {\n    /// Create a new CRC.\n    pub fn new() -> Crc {\n        Crc {\n            amt: 0,\n            hasher: Hasher::new(),\n        }\n    }\n\n    /// Returns the current crc32 checksum.\n    pub fn sum(&self) -> u32 {\n        self.hasher.clone().finalize()\n    }\n\n    /// The number of bytes that have been used to calculate the CRC.\n    /// This value is only accurate if the amount is lower than 2<sup>32</sup>.\n    pub fn amount(&self) -> u32 {\n        self.amt\n    }\n\n    /// Update the CRC with the bytes in `data`.\n    pub fn update(&mut self, data: &[u8]) {\n        self.amt = self.amt.wrapping_add(data.len() as u32);\n        self.hasher.update(data);\n    }\n\n    /// Reset the CRC.\n    pub fn reset(&mut self) {\n        self.amt = 0;\n        self.hasher.reset();\n    }\n\n    /// Combine the CRC with the CRC for the subsequent block of bytes.\n    pub fn combine(&mut self, additional_crc: &Crc) {\n        self.amt += additional_crc.amt;\n        self.hasher.combine(&additional_crc.hasher);\n    }\n}"],"crc::CrcReader":["Debug","impl<R: BufRead> BufRead for CrcReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        self.inner.fill_buf()\n    }\n    fn consume(&mut self, amt: usize) {\n        if let Ok(data) = self.inner.fill_buf() {\n            self.crc.update(&data[..amt]);\n        }\n        self.inner.consume(amt);\n    }\n}","impl<R: Read> CrcReader<R> {\n    /// Create a new CrcReader.\n    pub fn new(r: R) -> CrcReader<R> {\n        CrcReader {\n            inner: r,\n            crc: Crc::new(),\n        }\n    }\n}","impl<R: Read> Read for CrcReader<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        let amt = self.inner.read(into)?;\n        self.crc.update(&into[..amt]);\n        Ok(amt)\n    }\n}","impl<R> CrcReader<R> {\n    /// Get the Crc for this CrcReader.\n    pub fn crc(&self) -> &Crc {\n        &self.crc\n    }\n\n    /// Get the reader that is wrapped by this CrcReader.\n    pub fn into_inner(self) -> R {\n        self.inner\n    }\n\n    /// Get the reader that is wrapped by this CrcReader by reference.\n    pub fn get_ref(&self) -> &R {\n        &self.inner\n    }\n\n    /// Get a mutable reference to the reader that is wrapped by this CrcReader.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.inner\n    }\n\n    /// Reset the Crc in this CrcReader.\n    pub fn reset(&mut self) {\n        self.crc.reset();\n    }\n}"],"crc::CrcWriter":["Debug","impl<W: Write> CrcWriter<W> {\n    /// Create a new CrcWriter.\n    pub fn new(w: W) -> CrcWriter<W> {\n        CrcWriter {\n            inner: w,\n            crc: Crc::new(),\n        }\n    }\n}","impl<W: Write> Write for CrcWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let amt = self.inner.write(buf)?;\n        self.crc.update(&buf[..amt]);\n        Ok(amt)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}","impl<W> CrcWriter<W> {\n    /// Get the Crc for this CrcWriter.\n    pub fn crc(&self) -> &Crc {\n        &self.crc\n    }\n\n    /// Get the writer that is wrapped by this CrcWriter.\n    pub fn into_inner(self) -> W {\n        self.inner\n    }\n\n    /// Get the writer that is wrapped by this CrcWriter by reference.\n    pub fn get_ref(&self) -> &W {\n        &self.inner\n    }\n\n    /// Get a mutable reference to the writer that is wrapped by this CrcWriter.\n    pub fn get_mut(&mut self) -> &mut W {\n        &mut self.inner\n    }\n\n    /// Reset the Crc in this CrcWriter.\n    pub fn reset(&mut self) {\n        self.crc.reset();\n    }\n}"],"deflate::bufread::DeflateDecoder":["Debug","impl<R: BufRead> DeflateDecoder<R> {\n    /// Creates a new decoder which will decompress data read from the given\n    /// stream.\n    pub fn new(r: R) -> DeflateDecoder<R> {\n        DeflateDecoder {\n            obj: r,\n            data: Decompress::new(false),\n        }\n    }\n}","impl<R: BufRead> Read for DeflateDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        zio::read(&mut self.obj, &mut self.data, into)\n    }\n}","impl<R> DeflateDecoder<R> {\n    /// Resets the state of this decoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This will reset the internal state of this decoder and replace the\n    /// input stream with the one provided, returning the previous input\n    /// stream. Future data read from this decoder will be the decompressed\n    /// version of `r`'s data.\n    pub fn reset(&mut self, r: R) -> R {\n        reset_decoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }\n\n    /// Resets the state of this decoder's data\n    ///\n    /// This will reset the internal state of this decoder. It will continue\n    /// reading from the same stream.\n    pub fn reset_data(&mut self) {\n        reset_decoder_data(self);\n    }\n\n    /// Acquires a reference to the underlying stream\n    pub fn get_ref(&self) -> &R {\n        &self.obj\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.obj\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.obj\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed.\n    ///\n    /// Note that this will likely be smaller than what the decompressor\n    /// actually read from the underlying stream due to buffering.\n    pub fn total_in(&self) -> u64 {\n        self.data.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has produced.\n    pub fn total_out(&self) -> u64 {\n        self.data.total_out()\n    }\n}","impl<W: BufRead + Write> Write for DeflateDecoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}"],"deflate::bufread::DeflateEncoder":["Debug","impl<R: BufRead> DeflateEncoder<R> {\n    /// Creates a new encoder which will read uncompressed data from the given\n    /// stream and emit the compressed stream.\n    pub fn new(r: R, level: crate::Compression) -> DeflateEncoder<R> {\n        DeflateEncoder {\n            obj: r,\n            data: Compress::new(level, false),\n        }\n    }\n}","impl<R: BufRead> Read for DeflateEncoder<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        zio::read(&mut self.obj, &mut self.data, buf)\n    }\n}","impl<R> DeflateEncoder<R> {\n    /// Resets the state of this encoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This function will reset the internal state of this encoder and replace\n    /// the input stream with the one provided, returning the previous input\n    /// stream. Future data read from this encoder will be the compressed\n    /// version of `r`'s data.\n    pub fn reset(&mut self, r: R) -> R {\n        reset_encoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }\n\n    /// Acquires a reference to the underlying reader\n    pub fn get_ref(&self) -> &R {\n        &self.obj\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.obj\n    }\n\n    /// Consumes this encoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.obj\n    }\n\n    /// Returns the number of bytes that have been read into this compressor.\n    ///\n    /// Note that not all bytes read from the underlying object may be accounted\n    /// for, there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.data.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been read yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.data.total_out()\n    }\n}","impl<W: BufRead + Write> Write for DeflateEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}"],"deflate::read::DeflateDecoder":["Debug","impl<R: Read> DeflateDecoder<R> {\n    /// Creates a new decoder which will decompress data read from the given\n    /// stream.\n    pub fn new(r: R) -> DeflateDecoder<R> {\n        DeflateDecoder::new_with_buf(r, vec![0; 32 * 1024])\n    }\n\n    /// Same as `new`, but the intermediate buffer for data is specified.\n    ///\n    /// Note that the capacity of the intermediate buffer is never increased,\n    /// and it is recommended for it to be large.\n    pub fn new_with_buf(r: R, buf: Vec<u8>) -> DeflateDecoder<R> {\n        DeflateDecoder {\n            inner: bufread::DeflateDecoder::new(BufReader::with_buf(buf, r)),\n        }\n    }\n}","impl<R: Read> Read for DeflateDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(into)\n    }\n}","impl<R> DeflateDecoder<R> {\n    /// Resets the state of this decoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This will reset the internal state of this decoder and replace the\n    /// input stream with the one provided, returning the previous input\n    /// stream. Future data read from this decoder will be the decompressed\n    /// version of `r`'s data.\n    ///\n    /// Note that there may be currently buffered data when this function is\n    /// called, and in that case the buffered data is discarded.\n    pub fn reset(&mut self, r: R) -> R {\n        super::bufread::reset_decoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }\n\n    /// Acquires a reference to the underlying stream\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    ///\n    /// Note that there may be buffered bytes which are not re-acquired as part\n    /// of this transition. It's recommended to only call this function after\n    /// EOF has been reached.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed.\n    ///\n    /// Note that this will likely be smaller than what the decompressor\n    /// actually read from the underlying stream due to buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has produced.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n}","impl<W: Read + Write> Write for DeflateDecoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}"],"deflate::read::DeflateEncoder":["Debug","impl<R: Read> DeflateEncoder<R> {\n    /// Creates a new encoder which will read uncompressed data from the given\n    /// stream and emit the compressed stream.\n    pub fn new(r: R, level: crate::Compression) -> DeflateEncoder<R> {\n        DeflateEncoder {\n            inner: bufread::DeflateEncoder::new(BufReader::new(r), level),\n        }\n    }\n}","impl<R: Read> Read for DeflateEncoder<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n}","impl<R> DeflateEncoder<R> {\n    /// Resets the state of this encoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This function will reset the internal state of this encoder and replace\n    /// the input stream with the one provided, returning the previous input\n    /// stream. Future data read from this encoder will be the compressed\n    /// version of `r`'s data.\n    ///\n    /// Note that there may be currently buffered data when this function is\n    /// called, and in that case the buffered data is discarded.\n    pub fn reset(&mut self, r: R) -> R {\n        super::bufread::reset_encoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }\n\n    /// Acquires a reference to the underlying reader\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this encoder, returning the underlying reader.\n    ///\n    /// Note that there may be buffered bytes which are not re-acquired as part\n    /// of this transition. It's recommended to only call this function after\n    /// EOF has been reached.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n\n    /// Returns the number of bytes that have been read into this compressor.\n    ///\n    /// Note that not all bytes read from the underlying object may be accounted\n    /// for, there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been read yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n}","impl<W: Read + Write> Write for DeflateEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}"],"deflate::write::DeflateDecoder":["Debug","impl<W: Read + Write> Read for DeflateDecoder<W> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.get_mut().read(buf)\n    }\n}","impl<W: Write> DeflateDecoder<W> {\n    /// Creates a new decoder which will write uncompressed data to the stream.\n    ///\n    /// When this encoder is dropped or unwrapped the final pieces of data will\n    /// be flushed.\n    pub fn new(w: W) -> DeflateDecoder<W> {\n        DeflateDecoder {\n            inner: zio::Writer::new(w, Decompress::new(false)),\n        }\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutating the output/input state of the stream may corrupt this\n    /// object, so care must be taken when using this method.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Resets the state of this decoder entirely, swapping out the output\n    /// stream for another.\n    ///\n    /// This function will finish encoding the current stream into the current\n    /// output stream before swapping out the two output streams.\n    ///\n    /// This will then reset the internal state of this decoder and replace the\n    /// output stream with the one provided, returning the previous output\n    /// stream. Future data written to this decoder will be decompressed into\n    /// the output stream `w`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to finish the stream, and if that I/O\n    /// returns an error then that will be returned from this function.\n    pub fn reset(&mut self, w: W) -> io::Result<W> {\n        self.inner.finish()?;\n        self.inner.data = Decompress::new(false);\n        Ok(self.inner.replace(w))\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to finish the stream, returning any\n    /// errors which happen.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.inner.finish()\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream and then return the contained\n    /// writer if the flush succeeded.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed for\n    /// decompression.\n    ///\n    /// Note that this will likely be smaller than the number of bytes\n    /// successfully written to this stream due to internal buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.data.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has written to its\n    /// output stream.\n    pub fn total_out(&self) -> u64 {\n        self.inner.data.total_out()\n    }\n}","impl<W: Write> Write for DeflateDecoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}"],"deflate::write::DeflateEncoder":["Debug","impl<W: Read + Write> Read for DeflateEncoder<W> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.get_mut().read(buf)\n    }\n}","impl<W: Write> DeflateEncoder<W> {\n    /// Creates a new encoder which will write compressed data to the stream\n    /// given at the given compression level.\n    ///\n    /// When this encoder is dropped or unwrapped the final pieces of data will\n    /// be flushed.\n    pub fn new(w: W, level: crate::Compression) -> DeflateEncoder<W> {\n        DeflateEncoder {\n            inner: zio::Writer::new(w, Compress::new(level, false)),\n        }\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutating the output/input state of the stream may corrupt this\n    /// object, so care must be taken when using this method.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Resets the state of this encoder entirely, swapping out the output\n    /// stream for another.\n    ///\n    /// This function will finish encoding the current stream into the current\n    /// output stream before swapping out the two output streams. If the stream\n    /// cannot be finished an error is returned.\n    ///\n    /// After the current stream has been finished, this will reset the internal\n    /// state of this encoder and replace the output stream with the one\n    /// provided, returning the previous output stream. Future data written to\n    /// this encoder will be the compressed into the stream `w` provided.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn reset(&mut self, w: W) -> io::Result<W> {\n        self.inner.finish()?;\n        self.inner.data.reset();\n        Ok(self.inner.replace(w))\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.inner.finish()\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream, close off the compressed\n    /// stream and, if successful, return the contained writer.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream and then return the contained\n    /// writer if the flush succeeded.\n    /// The compressed stream will not closed but only flushed. This\n    /// means that obtained byte array can by extended by another deflated\n    /// stream. To close the stream add the two bytes 0x3 and 0x0.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn flush_finish(mut self) -> io::Result<W> {\n        self.inner.flush()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Returns the number of bytes that have been written to this compresor.\n    ///\n    /// Note that not all bytes written to this object may be accounted for,\n    /// there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.data.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been written yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.inner.data.total_out()\n    }\n}","impl<W: Write> Write for DeflateEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}"],"ffi::rust::Deflate":["impl Backend for Deflate {\n    #[inline]\n    fn total_in(&self) -> u64 {\n        self.total_in\n    }\n\n    #[inline]\n    fn total_out(&self) -> u64 {\n        self.total_out\n    }\n}","impl DeflateBackend for Deflate {\n    fn make(level: Compression, zlib_header: bool, window_bits: u8) -> Self {\n        assert!(\n            window_bits > 8 && window_bits < 16,\n            \"window_bits must be within 9 ..= 15\"\n        );\n\n        // Check in case the integer value changes at some point.\n        debug_assert!(level.level() <= 10);\n\n        let mut inner: Box<CompressorOxide> = Box::default();\n        let format = format_from_bool(zlib_header);\n        inner.set_format_and_level(format, level.level().try_into().unwrap_or(1));\n\n        Deflate {\n            inner,\n            total_in: 0,\n            total_out: 0,\n        }\n    }\n\n    fn compress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError> {\n        let flush = MZFlush::new(flush as i32).unwrap();\n        let res = deflate::stream::deflate(&mut self.inner, input, output, flush);\n        self.total_in += res.bytes_consumed as u64;\n        self.total_out += res.bytes_written as u64;\n\n        match res.status {\n            Ok(status) => match status {\n                MZStatus::Ok => Ok(Status::Ok),\n                MZStatus::StreamEnd => Ok(Status::StreamEnd),\n                MZStatus::NeedDict => Err(CompressError(())),\n            },\n            Err(status) => match status {\n                MZError::Buf => Ok(Status::BufError),\n                _ => Err(CompressError(())),\n            },\n        }\n    }\n\n    fn reset(&mut self) {\n        self.total_in = 0;\n        self.total_out = 0;\n        self.inner.reset();\n    }\n}","impl fmt::Debug for Deflate {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(\n            f,\n            \"miniz_oxide deflate internal state. total_in: {}, total_out: {}\",\n            self.total_in, self.total_out,\n        )\n    }\n}"],"ffi::rust::Inflate":["impl Backend for Inflate {\n    #[inline]\n    fn total_in(&self) -> u64 {\n        self.total_in\n    }\n\n    #[inline]\n    fn total_out(&self) -> u64 {\n        self.total_out\n    }\n}","impl InflateBackend for Inflate {\n    fn make(zlib_header: bool, window_bits: u8) -> Self {\n        assert!(\n            window_bits > 8 && window_bits < 16,\n            \"window_bits must be within 9 ..= 15\"\n        );\n\n        let format = format_from_bool(zlib_header);\n\n        Inflate {\n            inner: InflateState::new_boxed(format),\n            total_in: 0,\n            total_out: 0,\n        }\n    }\n\n    fn decompress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError> {\n        let flush = MZFlush::new(flush as i32).unwrap();\n\n        let res = inflate::stream::inflate(&mut self.inner, input, output, flush);\n        self.total_in += res.bytes_consumed as u64;\n        self.total_out += res.bytes_written as u64;\n\n        match res.status {\n            Ok(status) => match status {\n                MZStatus::Ok => Ok(Status::Ok),\n                MZStatus::StreamEnd => Ok(Status::StreamEnd),\n                MZStatus::NeedDict => {\n                    mem::decompress_need_dict(self.inner.decompressor().adler32().unwrap_or(0))\n                }\n            },\n            Err(status) => match status {\n                MZError::Buf => Ok(Status::BufError),\n                _ => mem::decompress_failed(),\n            },\n        }\n    }\n\n    fn reset(&mut self, zlib_header: bool) {\n        self.inner.reset(format_from_bool(zlib_header));\n        self.total_in = 0;\n        self.total_out = 0;\n    }\n}","impl fmt::Debug for Inflate {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(\n            f,\n            \"miniz_oxide inflate internal state. total_in: {}, total_out: {}\",\n            self.total_in, self.total_out,\n        )\n    }\n}"],"gz::GzBuilder":["Debug","impl GzBuilder {\n    /// Create a new blank builder with no header by default.\n    pub fn new() -> GzBuilder {\n        GzBuilder {\n            extra: None,\n            filename: None,\n            comment: None,\n            operating_system: None,\n            mtime: 0,\n        }\n    }\n\n    /// Configure the `mtime` field in the gzip header.\n    pub fn mtime(mut self, mtime: u32) -> GzBuilder {\n        self.mtime = mtime;\n        self\n    }\n\n    /// Configure the `operating_system` field in the gzip header.\n    pub fn operating_system(mut self, os: u8) -> GzBuilder {\n        self.operating_system = Some(os);\n        self\n    }\n\n    /// Configure the `extra` field in the gzip header.\n    pub fn extra<T: Into<Vec<u8>>>(mut self, extra: T) -> GzBuilder {\n        self.extra = Some(extra.into());\n        self\n    }\n\n    /// Configure the `filename` field in the gzip header.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the `filename` slice contains a zero.\n    pub fn filename<T: Into<Vec<u8>>>(mut self, filename: T) -> GzBuilder {\n        self.filename = Some(CString::new(filename.into()).unwrap());\n        self\n    }\n\n    /// Configure the `comment` field in the gzip header.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the `comment` slice contains a zero.\n    pub fn comment<T: Into<Vec<u8>>>(mut self, comment: T) -> GzBuilder {\n        self.comment = Some(CString::new(comment.into()).unwrap());\n        self\n    }\n\n    /// Consume this builder, creating a writer encoder in the process.\n    ///\n    /// The data written to the returned encoder will be compressed and then\n    /// written out to the supplied parameter `w`.\n    pub fn write<W: Write>(self, w: W, lvl: Compression) -> write::GzEncoder<W> {\n        write::gz_encoder(self.into_header(lvl), w, lvl)\n    }\n\n    /// Consume this builder, creating a reader encoder in the process.\n    ///\n    /// Data read from the returned encoder will be the compressed version of\n    /// the data read from the given reader.\n    pub fn read<R: Read>(self, r: R, lvl: Compression) -> read::GzEncoder<R> {\n        read::gz_encoder(self.buf_read(BufReader::new(r), lvl))\n    }\n\n    /// Consume this builder, creating a reader encoder in the process.\n    ///\n    /// Data read from the returned encoder will be the compressed version of\n    /// the data read from the given reader.\n    pub fn buf_read<R>(self, r: R, lvl: Compression) -> bufread::GzEncoder<R>\n    where\n        R: BufRead,\n    {\n        bufread::gz_encoder(self.into_header(lvl), r, lvl)\n    }\n\n    fn into_header(self, lvl: Compression) -> Vec<u8> {\n        let GzBuilder {\n            extra,\n            filename,\n            comment,\n            operating_system,\n            mtime,\n        } = self;\n        let mut flg = 0;\n        let mut header = vec![0u8; 10];\n        match extra {\n            Some(v) => {\n                flg |= FEXTRA;\n                header.push((v.len() >> 0) as u8);\n                header.push((v.len() >> 8) as u8);\n                header.extend(v);\n            }\n            None => {}\n        }\n        match filename {\n            Some(filename) => {\n                flg |= FNAME;\n                header.extend(filename.as_bytes_with_nul().iter().map(|x| *x));\n            }\n            None => {}\n        }\n        match comment {\n            Some(comment) => {\n                flg |= FCOMMENT;\n                header.extend(comment.as_bytes_with_nul().iter().map(|x| *x));\n            }\n            None => {}\n        }\n        header[0] = 0x1f;\n        header[1] = 0x8b;\n        header[2] = 8;\n        header[3] = flg;\n        header[4] = (mtime >> 0) as u8;\n        header[5] = (mtime >> 8) as u8;\n        header[6] = (mtime >> 16) as u8;\n        header[7] = (mtime >> 24) as u8;\n        header[8] = if lvl.0 >= Compression::best().0 {\n            2\n        } else if lvl.0 <= Compression::fast().0 {\n            4\n        } else {\n            0\n        };\n\n        // Typically this byte indicates what OS the gz stream was created on,\n        // but in an effort to have cross-platform reproducible streams just\n        // default this value to 255. I'm not sure that if we \"correctly\" set\n        // this it'd do anything anyway...\n        header[9] = operating_system.unwrap_or(255);\n        return header;\n    }\n}"],"gz::GzHeader":["Clone","Debug","Default","PartialEq","impl GzHeader {\n    /// Returns the `filename` field of this gzip stream's header, if present.\n    pub fn filename(&self) -> Option<&[u8]> {\n        self.filename.as_ref().map(|s| &s[..])\n    }\n\n    /// Returns the `extra` field of this gzip stream's header, if present.\n    pub fn extra(&self) -> Option<&[u8]> {\n        self.extra.as_ref().map(|s| &s[..])\n    }\n\n    /// Returns the `comment` field of this gzip stream's header, if present.\n    pub fn comment(&self) -> Option<&[u8]> {\n        self.comment.as_ref().map(|s| &s[..])\n    }\n\n    /// Returns the `operating_system` field of this gzip stream's header.\n    ///\n    /// There are predefined values for various operating systems.\n    /// 255 means that the value is unknown.\n    pub fn operating_system(&self) -> u8 {\n        self.operating_system\n    }\n\n    /// This gives the most recent modification time of the original file being compressed.\n    ///\n    /// The time is in Unix format, i.e., seconds since 00:00:00 GMT, Jan. 1, 1970.\n    /// (Note that this may cause problems for MS-DOS and other systems that use local\n    /// rather than Universal time.) If the compressed data did not come from a file,\n    /// `mtime` is set to the time at which compression started.\n    /// `mtime` = 0 means no time stamp is available.\n    ///\n    /// The usage of `mtime` is discouraged because of Year 2038 problem.\n    pub fn mtime(&self) -> u32 {\n        self.mtime\n    }\n\n    /// Returns the most recent modification time represented by a date-time type.\n    /// Returns `None` if the value of the underlying counter is 0,\n    /// indicating no time stamp is available.\n    ///\n    ///\n    /// The time is measured as seconds since 00:00:00 GMT, Jan. 1 1970.\n    /// See [`mtime`](#method.mtime) for more detail.\n    pub fn mtime_as_datetime(&self) -> Option<time::SystemTime> {\n        if self.mtime == 0 {\n            None\n        } else {\n            let duration = time::Duration::new(u64::from(self.mtime), 0);\n            let datetime = time::UNIX_EPOCH + duration;\n            Some(datetime)\n        }\n    }\n}"],"gz::bufread::Buffer":["impl<'a, T: Read> Read for Buffer<'a, T> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        if self.buf_cur == self.buf_max {\n            let len = self.reader.read(buf)?;\n            self.buf.extend_from_slice(&buf[..len]);\n            Ok(len)\n        } else {\n            let len = (&self.buf[self.buf_cur..self.buf_max]).read(buf)?;\n            self.buf_cur += len;\n            Ok(len)\n        }\n    }\n}","impl<'a, T> Buffer<'a, T> {\n    fn new(buf: &'a mut Vec<u8>, reader: &'a mut T) -> Buffer<'a, T> {\n        Buffer {\n            reader,\n            buf_cur: 0,\n            buf_max: buf.len(),\n            buf,\n        }\n    }\n}"],"gz::bufread::GzDecoder":["Debug","impl<R: BufRead + Write> Write for GzDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: BufRead> GzDecoder<R> {\n    /// Creates a new decoder from the given reader, immediately parsing the\n    /// gzip header.\n    pub fn new(mut r: R) -> GzDecoder<R> {\n        let mut buf = Vec::with_capacity(10); // minimum header length\n        let mut header = None;\n\n        let result = {\n            let mut reader = Buffer::new(&mut buf, &mut r);\n            read_gz_header(&mut reader)\n        };\n\n        let state = match result {\n            Ok(hdr) => {\n                header = Some(hdr);\n                GzState::Body\n            }\n            Err(ref err) if io::ErrorKind::WouldBlock == err.kind() => GzState::Header(buf),\n            Err(err) => GzState::Err(err),\n        };\n\n        GzDecoder {\n            inner: state,\n            reader: CrcReader::new(deflate::bufread::DeflateDecoder::new(r)),\n            multi: false,\n            header,\n        }\n    }\n\n    fn multi(mut self, flag: bool) -> GzDecoder<R> {\n        self.multi = flag;\n        self\n    }\n}","impl<R: BufRead> Read for GzDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        let GzDecoder {\n            inner,\n            header,\n            reader,\n            multi,\n        } = self;\n\n        loop {\n            *inner = match mem::replace(inner, GzState::End) {\n                GzState::Header(mut buf) => {\n                    let result = {\n                        let mut reader = Buffer::new(&mut buf, reader.get_mut().get_mut());\n                        read_gz_header(&mut reader)\n                    };\n                    let hdr = result.map_err(|err| {\n                        if io::ErrorKind::WouldBlock == err.kind() {\n                            *inner = GzState::Header(buf);\n                        }\n\n                        err\n                    })?;\n                    *header = Some(hdr);\n                    GzState::Body\n                }\n                GzState::Body => {\n                    if into.is_empty() {\n                        *inner = GzState::Body;\n                        return Ok(0);\n                    }\n\n                    let n = reader.read(into).map_err(|err| {\n                        if io::ErrorKind::WouldBlock == err.kind() {\n                            *inner = GzState::Body;\n                        }\n\n                        err\n                    })?;\n\n                    match n {\n                        0 => GzState::Finished(0, [0; 8]),\n                        n => {\n                            *inner = GzState::Body;\n                            return Ok(n);\n                        }\n                    }\n                }\n                GzState::Finished(pos, mut buf) => {\n                    if pos < buf.len() {\n                        let n = reader\n                            .get_mut()\n                            .get_mut()\n                            .read(&mut buf[pos..])\n                            .and_then(|n| {\n                                if n == 0 {\n                                    Err(io::ErrorKind::UnexpectedEof.into())\n                                } else {\n                                    Ok(n)\n                                }\n                            })\n                            .map_err(|err| {\n                                if io::ErrorKind::WouldBlock == err.kind() {\n                                    *inner = GzState::Finished(pos, buf);\n                                }\n\n                                err\n                            })?;\n\n                        GzState::Finished(pos + n, buf)\n                    } else {\n                        let (crc, amt) = finish(&buf);\n\n                        if crc != reader.crc().sum() || amt != reader.crc().amount() {\n                            return Err(corrupt());\n                        } else if *multi {\n                            let is_eof = reader\n                                .get_mut()\n                                .get_mut()\n                                .fill_buf()\n                                .map(|buf| buf.is_empty())\n                                .map_err(|err| {\n                                    if io::ErrorKind::WouldBlock == err.kind() {\n                                        *inner = GzState::Finished(pos, buf);\n                                    }\n\n                                    err\n                                })?;\n\n                            if is_eof {\n                                GzState::End\n                            } else {\n                                reader.reset();\n                                reader.get_mut().reset_data();\n                                header.take();\n                                GzState::Header(Vec::with_capacity(10))\n                            }\n                        } else {\n                            GzState::End\n                        }\n                    }\n                }\n                GzState::Err(err) => return Err(err),\n                GzState::End => return Ok(0),\n            };\n        }\n    }\n}","impl<R> GzDecoder<R> {\n    /// Returns the header associated with this stream, if it was valid\n    pub fn header(&self) -> Option<&GzHeader> {\n        self.header.as_ref()\n    }\n\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.reader.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream.\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.reader.get_mut().get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.reader.into_inner().into_inner()\n    }\n}"],"gz::bufread::GzEncoder":["Debug","impl<R: BufRead + Write> Write for GzEncoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: BufRead> GzEncoder<R> {\n    /// Creates a new encoder which will use the given compression level.\n    ///\n    /// The encoder is not configured specially for the emitted header. For\n    /// header configuration, see the `GzBuilder` type.\n    ///\n    /// The data read from the stream `r` will be compressed and available\n    /// through the returned reader.\n    pub fn new(r: R, level: Compression) -> GzEncoder<R> {\n        GzBuilder::new().buf_read(r, level)\n    }\n\n    fn read_footer(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        if self.pos == 8 {\n            return Ok(0);\n        }\n        let crc = self.inner.get_ref().crc();\n        let ref arr = [\n            (crc.sum() >> 0) as u8,\n            (crc.sum() >> 8) as u8,\n            (crc.sum() >> 16) as u8,\n            (crc.sum() >> 24) as u8,\n            (crc.amount() >> 0) as u8,\n            (crc.amount() >> 8) as u8,\n            (crc.amount() >> 16) as u8,\n            (crc.amount() >> 24) as u8,\n        ];\n        Ok(copy(into, arr, &mut self.pos))\n    }\n}","impl<R: BufRead> Read for GzEncoder<R> {\n    fn read(&mut self, mut into: &mut [u8]) -> io::Result<usize> {\n        let mut amt = 0;\n        if self.eof {\n            return self.read_footer(into);\n        } else if self.pos < self.header.len() {\n            amt += copy(into, &self.header, &mut self.pos);\n            if amt == into.len() {\n                return Ok(amt);\n            }\n            let tmp = into;\n            into = &mut tmp[amt..];\n        }\n        match self.inner.read(into)? {\n            0 => {\n                self.eof = true;\n                self.pos = 0;\n                self.read_footer(into)\n            }\n            n => Ok(amt + n),\n        }\n    }\n}","impl<R> GzEncoder<R> {\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying reader.\n    ///\n    /// Note that mutation of the reader may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Returns the underlying stream, consuming this encoder\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n}"],"gz::bufread::GzState":["Debug"],"gz::bufread::MultiGzDecoder":["Debug","impl<R: BufRead + Write> Write for MultiGzDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: BufRead> MultiGzDecoder<R> {\n    /// Creates a new decoder from the given reader, immediately parsing the\n    /// (first) gzip header. If the gzip stream contains multiple members all will\n    /// be decoded.\n    pub fn new(r: R) -> MultiGzDecoder<R> {\n        MultiGzDecoder(GzDecoder::new(r).multi(true))\n    }\n}","impl<R: BufRead> Read for MultiGzDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.0.read(into)\n    }\n}","impl<R> MultiGzDecoder<R> {\n    /// Returns the current header associated with this stream, if it's valid\n    pub fn header(&self) -> Option<&GzHeader> {\n        self.0.header()\n    }\n\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.0.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream.\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.0.get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.0.into_inner()\n    }\n}"],"gz::read::GzDecoder":["Debug","impl<R: Read + Write> Write for GzDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: Read> GzDecoder<R> {\n    /// Creates a new decoder from the given reader, immediately parsing the\n    /// gzip header.\n    pub fn new(r: R) -> GzDecoder<R> {\n        GzDecoder {\n            inner: bufread::GzDecoder::new(BufReader::new(r)),\n        }\n    }\n}","impl<R: Read> Read for GzDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(into)\n    }\n}","impl<R> GzDecoder<R> {\n    /// Returns the header associated with this stream, if it was valid.\n    pub fn header(&self) -> Option<&GzHeader> {\n        self.inner.header()\n    }\n\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream.\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n}"],"gz::read::GzEncoder":["Debug","impl<R: Read + Write> Write for GzEncoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: Read> GzEncoder<R> {\n    /// Creates a new encoder which will use the given compression level.\n    ///\n    /// The encoder is not configured specially for the emitted header. For\n    /// header configuration, see the `GzBuilder` type.\n    ///\n    /// The data read from the stream `r` will be compressed and available\n    /// through the returned reader.\n    pub fn new(r: R, level: Compression) -> GzEncoder<R> {\n        GzBuilder::new().read(r, level)\n    }\n}","impl<R: Read> Read for GzEncoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(into)\n    }\n}","impl<R> GzEncoder<R> {\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying reader.\n    ///\n    /// Note that mutation of the reader may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Returns the underlying stream, consuming this encoder\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n}"],"gz::read::MultiGzDecoder":["Debug","impl<R: Read + Write> Write for MultiGzDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: Read> MultiGzDecoder<R> {\n    /// Creates a new decoder from the given reader, immediately parsing the\n    /// (first) gzip header. If the gzip stream contains multiple members all will\n    /// be decoded.\n    pub fn new(r: R) -> MultiGzDecoder<R> {\n        MultiGzDecoder {\n            inner: bufread::MultiGzDecoder::new(BufReader::new(r)),\n        }\n    }\n}","impl<R: Read> Read for MultiGzDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(into)\n    }\n}","impl<R> MultiGzDecoder<R> {\n    /// Returns the current header associated with this stream, if it's valid.\n    pub fn header(&self) -> Option<&GzHeader> {\n        self.inner.header()\n    }\n\n    /// Acquires a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream.\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n}"],"gz::write::Counter":["impl<T: Read> Read for Counter<T> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let pos = self.inner.read(buf)?;\n        self.pos += pos;\n        Ok(pos)\n    }\n}"],"gz::write::GzDecoder":["Debug","impl<W: Read + Write> Read for GzDecoder<W> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.get_mut().get_mut().read(buf)\n    }\n}","impl<W: Write> GzDecoder<W> {\n    /// Creates a new decoder which will write uncompressed data to the stream.\n    ///\n    /// When this encoder is dropped or unwrapped the final pieces of data will\n    /// be flushed.\n    pub fn new(w: W) -> GzDecoder<W> {\n        GzDecoder {\n            inner: zio::Writer::new(CrcWriter::new(w), Decompress::new(false)),\n            crc_bytes: Vec::with_capacity(CRC_BYTES_LEN),\n            header: None,\n            header_buf: Vec::new(),\n        }\n    }\n\n    /// Returns the header associated with this stream.\n    pub fn header(&self) -> Option<&GzHeader> {\n        self.header.as_ref()\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutating the output/input state of the stream may corrupt this\n    /// object, so care must be taken when using this method.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to finish the stream, returning any\n    /// errors which happen.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.finish_and_check_crc()?;\n        Ok(())\n    }\n\n    /// Consumes this decoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream and then return the contained\n    /// writer if the flush succeeded.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.finish_and_check_crc()?;\n        Ok(self.inner.take_inner().into_inner())\n    }\n\n    fn finish_and_check_crc(&mut self) -> io::Result<()> {\n        self.inner.finish()?;\n\n        if self.crc_bytes.len() != 8 {\n            return Err(corrupt());\n        }\n\n        let crc = ((self.crc_bytes[0] as u32) << 0)\n            | ((self.crc_bytes[1] as u32) << 8)\n            | ((self.crc_bytes[2] as u32) << 16)\n            | ((self.crc_bytes[3] as u32) << 24);\n        let amt = ((self.crc_bytes[4] as u32) << 0)\n            | ((self.crc_bytes[5] as u32) << 8)\n            | ((self.crc_bytes[6] as u32) << 16)\n            | ((self.crc_bytes[7] as u32) << 24);\n        if crc != self.inner.get_ref().crc().sum() as u32 {\n            return Err(corrupt());\n        }\n        if amt != self.inner.get_ref().crc().amount() {\n            return Err(corrupt());\n        }\n        Ok(())\n    }\n}","impl<W: Write> Write for GzDecoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if self.header.is_none() {\n            // trying to avoid buffer usage\n            let (res, pos) = {\n                let mut counter = Counter {\n                    inner: self.header_buf.chain(buf),\n                    pos: 0,\n                };\n                let res = read_gz_header(&mut counter);\n                (res, counter.pos)\n            };\n\n            match res {\n                Err(err) => {\n                    if err.kind() == io::ErrorKind::UnexpectedEof {\n                        // not enough data for header, save to the buffer\n                        self.header_buf.extend(buf);\n                        Ok(buf.len())\n                    } else {\n                        Err(err)\n                    }\n                }\n                Ok(header) => {\n                    self.header = Some(header);\n                    let pos = pos - self.header_buf.len();\n                    self.header_buf.truncate(0);\n                    Ok(pos)\n                }\n            }\n        } else {\n            let (n, status) = self.inner.write_with_status(buf)?;\n\n            if status == Status::StreamEnd {\n                if n < buf.len() && self.crc_bytes.len() < 8 {\n                    let remaining = buf.len() - n;\n                    let crc_bytes = cmp::min(remaining, CRC_BYTES_LEN - self.crc_bytes.len());\n                    self.crc_bytes.extend(&buf[n..n + crc_bytes]);\n                    return Ok(n + crc_bytes);\n                }\n            }\n            Ok(n)\n        }\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}"],"gz::write::GzEncoder":["Debug","impl<R: Read + Write> Read for GzEncoder<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.get_mut().read(buf)\n    }\n}","impl<W: Write> Drop for GzEncoder<W> {\n    fn drop(&mut self) {\n        if self.inner.is_present() {\n            let _ = self.try_finish();\n        }\n    }\n}","impl<W: Write> GzEncoder<W> {\n    /// Creates a new encoder which will use the given compression level.\n    ///\n    /// The encoder is not configured specially for the emitted header. For\n    /// header configuration, see the `GzBuilder` type.\n    ///\n    /// The data written to the returned encoder will be compressed and then\n    /// written to the stream `w`.\n    pub fn new(w: W, level: Compression) -> GzEncoder<W> {\n        GzBuilder::new().write(w, level)\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutation of the writer may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.write_header()?;\n        self.inner.finish()?;\n\n        while self.crc_bytes_written < 8 {\n            let (sum, amt) = (self.crc.sum() as u32, self.crc.amount());\n            let buf = [\n                (sum >> 0) as u8,\n                (sum >> 8) as u8,\n                (sum >> 16) as u8,\n                (sum >> 24) as u8,\n                (amt >> 0) as u8,\n                (amt >> 8) as u8,\n                (amt >> 16) as u8,\n                (amt >> 24) as u8,\n            ];\n            let inner = self.inner.get_mut();\n            let n = inner.write(&buf[self.crc_bytes_written..])?;\n            self.crc_bytes_written += n;\n        }\n        Ok(())\n    }\n\n    /// Finish encoding this stream, returning the underlying writer once the\n    /// encoding is done.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.try_finish()?;\n        Ok(self.inner.take_inner())\n    }\n\n    fn write_header(&mut self) -> io::Result<()> {\n        while self.header.len() > 0 {\n            let n = self.inner.get_mut().write(&self.header)?;\n            self.header.drain(..n);\n        }\n        Ok(())\n    }\n}","impl<W: Write> Write for GzEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        assert_eq!(self.crc_bytes_written, 0);\n        self.write_header()?;\n        let n = self.inner.write(buf)?;\n        self.crc.update(&buf[..n]);\n        Ok(n)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        assert_eq!(self.crc_bytes_written, 0);\n        self.write_header()?;\n        self.inner.flush()\n    }\n}"],"mem::Compress":["Debug","impl Compress {\n    /// Creates a new object ready for compressing data that it's given.\n    ///\n    /// The `level` argument here indicates what level of compression is going\n    /// to be performed, and the `zlib_header` argument indicates whether the\n    /// output data should have a zlib header or not.\n    pub fn new(level: Compression, zlib_header: bool) -> Compress {\n        Compress {\n            inner: Deflate::make(level, zlib_header, ffi::MZ_DEFAULT_WINDOW_BITS as u8),\n        }\n    }\n\n    /// Creates a new object ready for compressing data that it's given.\n    ///\n    /// The `level` argument here indicates what level of compression is going\n    /// to be performed, and the `zlib_header` argument indicates whether the\n    /// output data should have a zlib header or not. The `window_bits` parameter\n    /// indicates the base-2 logarithm of the sliding window size and must be\n    /// between 9 and 15.\n    ///\n    /// # Panics\n    ///\n    /// If `window_bits` does not fall into the range 9 ..= 15,\n    /// `new_with_window_bits` will panic.\n    ///\n    /// # Note\n    ///\n    /// This constructor is only available when the `zlib` feature is used.\n    /// Other backends currently do not support custom window bits.\n    #[cfg(feature = \"any_zlib\")]\n    pub fn new_with_window_bits(\n        level: Compression,\n        zlib_header: bool,\n        window_bits: u8,\n    ) -> Compress {\n        Compress {\n            inner: Deflate::make(level, zlib_header, window_bits),\n        }\n    }\n\n    /// Returns the total number of input bytes which have been processed by\n    /// this compression object.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the total number of output bytes which have been produced by\n    /// this compression object.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n\n    /// Specifies the compression dictionary to use.\n    ///\n    /// Returns the Adler-32 checksum of the dictionary.\n    #[cfg(feature = \"any_zlib\")]\n    pub fn set_dictionary(&mut self, dictionary: &[u8]) -> Result<u32, CompressError> {\n        let stream = &mut *self.inner.inner.stream_wrapper;\n        let rc = unsafe {\n            assert!(dictionary.len() < ffi::uInt::max_value() as usize);\n            ffi::deflateSetDictionary(stream, dictionary.as_ptr(), dictionary.len() as ffi::uInt)\n        };\n\n        match rc {\n            ffi::MZ_STREAM_ERROR => Err(CompressError(())),\n            ffi::MZ_OK => Ok(stream.adler as u32),\n            c => panic!(\"unknown return code: {}\", c),\n        }\n    }\n\n    /// Quickly resets this compressor without having to reallocate anything.\n    ///\n    /// This is equivalent to dropping this object and then creating a new one.\n    pub fn reset(&mut self) {\n        self.inner.reset();\n    }\n\n    /// Dynamically updates the compression level.\n    ///\n    /// This can be used to switch between compression levels for different\n    /// kinds of data, or it can be used in conjunction with a call to reset\n    /// to reuse the compressor.\n    ///\n    /// This may return an error if there wasn't enough output space to complete\n    /// the compression of the available input data before changing the\n    /// compression level. Flushing the stream before calling this method\n    /// ensures that the function will succeed on the first call.\n    #[cfg(feature = \"any_zlib\")]\n    pub fn set_level(&mut self, level: Compression) -> Result<(), CompressError> {\n        use libc::c_int;\n        let stream = &mut *self.inner.inner.stream_wrapper;\n\n        let rc = unsafe { ffi::deflateParams(stream, level.0 as c_int, ffi::MZ_DEFAULT_STRATEGY) };\n\n        match rc {\n            ffi::MZ_OK => Ok(()),\n            ffi::MZ_BUF_ERROR => Err(CompressError(())),\n            c => panic!(\"unknown return code: {}\", c),\n        }\n    }\n\n    /// Compresses the input data into the output, consuming only as much\n    /// input as needed and writing as much output as possible.\n    ///\n    /// The flush option can be any of the available `FlushCompress` parameters.\n    ///\n    /// To learn how much data was consumed or how much output was produced, use\n    /// the `total_in` and `total_out` functions before/after this is called.\n    pub fn compress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError> {\n        self.inner.compress(input, output, flush)\n    }\n\n    /// Compresses the input data into the extra space of the output, consuming\n    /// only as much input as needed and writing as much output as possible.\n    ///\n    /// This function has the same semantics as `compress`, except that the\n    /// length of `vec` is managed by this function. This will not reallocate\n    /// the vector provided or attempt to grow it, so space for the output must\n    /// be reserved in the output vector by the caller before calling this\n    /// function.\n    pub fn compress_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError> {\n        let cap = output.capacity();\n        let len = output.len();\n\n        unsafe {\n            let before = self.total_out();\n            let ret = {\n                let ptr = output.as_mut_ptr().offset(len as isize);\n                let out = slice::from_raw_parts_mut(ptr, cap - len);\n                self.compress(input, out, flush)\n            };\n            output.set_len((self.total_out() - before) as usize + len);\n            return ret;\n        }\n    }\n}","impl Ops for Compress {\n    type Flush = FlushCompress;\n    fn total_in(&self) -> u64 {\n        self.total_in()\n    }\n    fn total_out(&self) -> u64 {\n        self.total_out()\n    }\n    fn run(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, DecompressError> {\n        Ok(self.compress(input, output, flush).unwrap())\n    }\n    fn run_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushCompress,\n    ) -> Result<Status, DecompressError> {\n        Ok(self.compress_vec(input, output, flush).unwrap())\n    }\n}"],"mem::CompressError":["Debug","impl Error for CompressError {}","impl fmt::Display for CompressError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"deflate decompression error\")\n    }\n}"],"mem::Decompress":["Debug","impl Decompress {\n    /// Creates a new object ready for decompressing data that it's given.\n    ///\n    /// The `zlib_header` argument indicates whether the input data is expected\n    /// to have a zlib header or not.\n    pub fn new(zlib_header: bool) -> Decompress {\n        Decompress {\n            inner: Inflate::make(zlib_header, ffi::MZ_DEFAULT_WINDOW_BITS as u8),\n        }\n    }\n\n    /// Creates a new object ready for decompressing data that it's given.\n    ///\n    /// The `zlib_header` argument indicates whether the input data is expected\n    /// to have a zlib header or not. The `window_bits` parameter indicates the\n    /// base-2 logarithm of the sliding window size and must be between 9 and 15.\n    ///\n    /// # Panics\n    ///\n    /// If `window_bits` does not fall into the range 9 ..= 15,\n    /// `new_with_window_bits` will panic.\n    ///\n    /// # Note\n    ///\n    /// This constructor is only available when the `zlib` feature is used.\n    /// Other backends currently do not support custom window bits.\n    #[cfg(feature = \"any_zlib\")]\n    pub fn new_with_window_bits(zlib_header: bool, window_bits: u8) -> Decompress {\n        Decompress {\n            inner: Inflate::make(zlib_header, window_bits),\n        }\n    }\n\n    /// Returns the total number of input bytes which have been processed by\n    /// this decompression object.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the total number of output bytes which have been produced by\n    /// this decompression object.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n\n    /// Decompresses the input data into the output, consuming only as much\n    /// input as needed and writing as much output as possible.\n    ///\n    /// The flush option can be any of the available `FlushDecompress` parameters.\n    ///\n    /// If the first call passes `FlushDecompress::Finish` it is assumed that\n    /// the input and output buffers are both sized large enough to decompress\n    /// the entire stream in a single call.\n    ///\n    /// A flush value of `FlushDecompress::Finish` indicates that there are no\n    /// more source bytes available beside what's already in the input buffer,\n    /// and the output buffer is large enough to hold the rest of the\n    /// decompressed data.\n    ///\n    /// To learn how much data was consumed or how much output was produced, use\n    /// the `total_in` and `total_out` functions before/after this is called.\n    ///\n    /// # Errors\n    ///\n    /// If the input data to this instance of `Decompress` is not a valid\n    /// zlib/deflate stream then this function may return an instance of\n    /// `DecompressError` to indicate that the stream of input bytes is corrupted.\n    pub fn decompress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError> {\n        self.inner.decompress(input, output, flush)\n    }\n\n    /// Decompresses the input data into the extra space in the output vector\n    /// specified by `output`.\n    ///\n    /// This function has the same semantics as `decompress`, except that the\n    /// length of `vec` is managed by this function. This will not reallocate\n    /// the vector provided or attempt to grow it, so space for the output must\n    /// be reserved in the output vector by the caller before calling this\n    /// function.\n    ///\n    /// # Errors\n    ///\n    /// If the input data to this instance of `Decompress` is not a valid\n    /// zlib/deflate stream then this function may return an instance of\n    /// `DecompressError` to indicate that the stream of input bytes is corrupted.\n    pub fn decompress_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError> {\n        let cap = output.capacity();\n        let len = output.len();\n\n        unsafe {\n            let before = self.total_out();\n            let ret = {\n                let ptr = output.as_mut_ptr().offset(len as isize);\n                let out = slice::from_raw_parts_mut(ptr, cap - len);\n                self.decompress(input, out, flush)\n            };\n            output.set_len((self.total_out() - before) as usize + len);\n            return ret;\n        }\n    }\n\n    /// Specifies the decompression dictionary to use.\n    #[cfg(feature = \"any_zlib\")]\n    pub fn set_dictionary(&mut self, dictionary: &[u8]) -> Result<u32, DecompressError> {\n        let stream = &mut *self.inner.inner.stream_wrapper;\n        let rc = unsafe {\n            assert!(dictionary.len() < ffi::uInt::max_value() as usize);\n            ffi::inflateSetDictionary(stream, dictionary.as_ptr(), dictionary.len() as ffi::uInt)\n        };\n\n        match rc {\n            ffi::MZ_STREAM_ERROR => Err(DecompressError(Default::default())),\n            ffi::MZ_DATA_ERROR => Err(DecompressError(DecompressErrorInner {\n                needs_dictionary: Some(stream.adler as u32),\n            })),\n            ffi::MZ_OK => Ok(stream.adler as u32),\n            c => panic!(\"unknown return code: {}\", c),\n        }\n    }\n\n    /// Performs the equivalent of replacing this decompression state with a\n    /// freshly allocated copy.\n    ///\n    /// This function may not allocate memory, though, and attempts to reuse any\n    /// previously existing resources.\n    ///\n    /// The argument provided here indicates whether the reset state will\n    /// attempt to decode a zlib header first or not.\n    pub fn reset(&mut self, zlib_header: bool) {\n        self.inner.reset(zlib_header);\n    }\n}","impl Ops for Decompress {\n    type Flush = FlushDecompress;\n    fn total_in(&self) -> u64 {\n        self.total_in()\n    }\n    fn total_out(&self) -> u64 {\n        self.total_out()\n    }\n    fn run(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError> {\n        self.decompress(input, output, flush)\n    }\n    fn run_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError> {\n        self.decompress_vec(input, output, flush)\n    }\n}"],"mem::DecompressError":["Debug","impl DecompressError {\n    /// Indicates whether decompression failed due to requiring a dictionary.\n    ///\n    /// The resulting integer is the Adler-32 checksum of the dictionary\n    /// required.\n    pub fn needs_dictionary(&self) -> Option<u32> {\n        self.0.needs_dictionary\n    }\n}","impl Error for DecompressError {}","impl fmt::Display for DecompressError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"deflate decompression error\")\n    }\n}"],"mem::DecompressErrorInner":["Debug","Default"],"mem::FlushCompress":["Clone","Copy","Debug","Eq","PartialEq","impl Flush for FlushCompress {\n    fn none() -> Self {\n        FlushCompress::None\n    }\n\n    fn sync() -> Self {\n        FlushCompress::Sync\n    }\n\n    fn finish() -> Self {\n        FlushCompress::Finish\n    }\n}"],"mem::FlushDecompress":["Clone","Copy","Debug","Eq","PartialEq","impl Flush for FlushDecompress {\n    fn none() -> Self {\n        FlushDecompress::None\n    }\n\n    fn sync() -> Self {\n        FlushDecompress::Sync\n    }\n\n    fn finish() -> Self {\n        FlushDecompress::Finish\n    }\n}"],"mem::Status":["Clone","Copy","Debug","Eq","PartialEq"],"std::io::Error":["impl From<CompressError> for io::Error {\n    fn from(data: CompressError) -> io::Error {\n        io::Error::new(io::ErrorKind::Other, data)\n    }\n}","impl From<DecompressError> for io::Error {\n    fn from(data: DecompressError) -> io::Error {\n        io::Error::new(io::ErrorKind::Other, data)\n    }\n}"],"zio::Writer":["Debug","impl<W: Write, D: Ops> Drop for Writer<W, D> {\n    fn drop(&mut self) {\n        if self.obj.is_some() {\n            let _ = self.finish();\n        }\n    }\n}","impl<W: Write, D: Ops> Write for Writer<W, D> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.write_with_status(buf).map(|res| res.0)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.data\n            .run_vec(&[], &mut self.buf, D::Flush::sync())\n            .unwrap();\n\n        // Unfortunately miniz doesn't actually tell us when we're done with\n        // pulling out all the data from the internal stream. To remedy this we\n        // have to continually ask the stream for more memory until it doesn't\n        // give us a chunk of memory the same size as our own internal buffer,\n        // at which point we assume it's reached the end.\n        loop {\n            self.dump()?;\n            let before = self.data.total_out();\n            self.data\n                .run_vec(&[], &mut self.buf, D::Flush::none())\n                .unwrap();\n            if before == self.data.total_out() {\n                break;\n            }\n        }\n\n        self.obj.as_mut().unwrap().flush()\n    }\n}","impl<W: Write, D: Ops> Writer<W, D> {\n    pub fn new(w: W, d: D) -> Writer<W, D> {\n        Writer {\n            obj: Some(w),\n            data: d,\n            buf: Vec::with_capacity(32 * 1024),\n        }\n    }\n\n    pub fn finish(&mut self) -> io::Result<()> {\n        loop {\n            self.dump()?;\n\n            let before = self.data.total_out();\n            self.data.run_vec(&[], &mut self.buf, D::Flush::finish())?;\n            if before == self.data.total_out() {\n                return Ok(());\n            }\n        }\n    }\n\n    pub fn replace(&mut self, w: W) -> W {\n        self.buf.truncate(0);\n        mem::replace(self.get_mut(), w)\n    }\n\n    pub fn get_ref(&self) -> &W {\n        self.obj.as_ref().unwrap()\n    }\n\n    pub fn get_mut(&mut self) -> &mut W {\n        self.obj.as_mut().unwrap()\n    }\n\n    // Note that this should only be called if the outer object is just about\n    // to be consumed!\n    //\n    // (e.g. an implementation of `into_inner`)\n    pub fn take_inner(&mut self) -> W {\n        self.obj.take().unwrap()\n    }\n\n    pub fn is_present(&self) -> bool {\n        self.obj.is_some()\n    }\n\n    // Returns total written bytes and status of underlying codec\n    pub(crate) fn write_with_status(&mut self, buf: &[u8]) -> io::Result<(usize, Status)> {\n        // miniz isn't guaranteed to actually write any of the buffer provided,\n        // it may be in a flushing mode where it's just giving us data before\n        // we're actually giving it any data. We don't want to spuriously return\n        // `Ok(0)` when possible as it will cause calls to write_all() to fail.\n        // As a result we execute this in a loop to ensure that we try our\n        // darndest to write the data.\n        loop {\n            self.dump()?;\n\n            let before_in = self.data.total_in();\n            let ret = self.data.run_vec(buf, &mut self.buf, D::Flush::none());\n            let written = (self.data.total_in() - before_in) as usize;\n\n            let is_stream_end = match ret {\n                Ok(Status::StreamEnd) => true,\n                _ => false,\n            };\n\n            if buf.len() > 0 && written == 0 && ret.is_ok() && !is_stream_end {\n                continue;\n            }\n            return match ret {\n                Ok(st) => match st {\n                    Status::Ok | Status::BufError | Status::StreamEnd => Ok((written, st)),\n                },\n                Err(..) => Err(io::Error::new(\n                    io::ErrorKind::InvalidInput,\n                    \"corrupt deflate stream\",\n                )),\n            };\n        }\n    }\n\n    fn dump(&mut self) -> io::Result<()> {\n        // TODO: should manage this buffer not with `drain` but probably more of\n        // a deque-like strategy.\n        while self.buf.len() > 0 {\n            let n = self.obj.as_mut().unwrap().write(&self.buf)?;\n            if n == 0 {\n                return Err(io::ErrorKind::WriteZero.into());\n            }\n            self.buf.drain(..n);\n        }\n        Ok(())\n    }\n}"],"zlib::bufread::ZlibDecoder":["Debug","impl<R: BufRead + Write> Write for ZlibDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: BufRead> Read for ZlibDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        zio::read(&mut self.obj, &mut self.data, into)\n    }\n}","impl<R: BufRead> ZlibDecoder<R> {\n    /// Creates a new decoder which will decompress data read from the given\n    /// stream.\n    pub fn new(r: R) -> ZlibDecoder<R> {\n        ZlibDecoder {\n            obj: r,\n            data: Decompress::new(true),\n        }\n    }\n}","impl<R> ZlibDecoder<R> {\n    /// Resets the state of this decoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This will reset the internal state of this decoder and replace the\n    /// input stream with the one provided, returning the previous input\n    /// stream. Future data read from this decoder will be the decompressed\n    /// version of `r`'s data.\n    pub fn reset(&mut self, r: R) -> R {\n        reset_decoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }\n\n    /// Acquires a reference to the underlying stream\n    pub fn get_ref(&self) -> &R {\n        &self.obj\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.obj\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.obj\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed.\n    ///\n    /// Note that this will likely be smaller than what the decompressor\n    /// actually read from the underlying stream due to buffering.\n    pub fn total_in(&self) -> u64 {\n        self.data.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has produced.\n    pub fn total_out(&self) -> u64 {\n        self.data.total_out()\n    }\n}"],"zlib::bufread::ZlibEncoder":["Debug","impl<R: BufRead + Write> Write for ZlibEncoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: BufRead> Read for ZlibEncoder<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        zio::read(&mut self.obj, &mut self.data, buf)\n    }\n}","impl<R: BufRead> ZlibEncoder<R> {\n    /// Creates a new encoder which will read uncompressed data from the given\n    /// stream and emit the compressed stream.\n    pub fn new(r: R, level: crate::Compression) -> ZlibEncoder<R> {\n        ZlibEncoder {\n            obj: r,\n            data: Compress::new(level, true),\n        }\n    }\n}","impl<R> ZlibEncoder<R> {\n    /// Resets the state of this encoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This function will reset the internal state of this encoder and replace\n    /// the input stream with the one provided, returning the previous input\n    /// stream. Future data read from this encoder will be the compressed\n    /// version of `r`'s data.\n    pub fn reset(&mut self, r: R) -> R {\n        reset_encoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }\n\n    /// Acquires a reference to the underlying reader\n    pub fn get_ref(&self) -> &R {\n        &self.obj\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.obj\n    }\n\n    /// Consumes this encoder, returning the underlying reader.\n    pub fn into_inner(self) -> R {\n        self.obj\n    }\n\n    /// Returns the number of bytes that have been read into this compressor.\n    ///\n    /// Note that not all bytes read from the underlying object may be accounted\n    /// for, there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.data.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been read yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.data.total_out()\n    }\n}"],"zlib::read::ZlibDecoder":["Debug","impl<R: Read + Write> Write for ZlibDecoder<R> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}","impl<R: Read> Read for ZlibDecoder<R> {\n    fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(into)\n    }\n}","impl<R: Read> ZlibDecoder<R> {\n    /// Creates a new decoder which will decompress data read from the given\n    /// stream.\n    pub fn new(r: R) -> ZlibDecoder<R> {\n        ZlibDecoder::new_with_buf(r, vec![0; 32 * 1024])\n    }\n\n    /// Same as `new`, but the intermediate buffer for data is specified.\n    ///\n    /// Note that the specified buffer will only be used up to its current\n    /// length. The buffer's capacity will also not grow over time.\n    pub fn new_with_buf(r: R, buf: Vec<u8>) -> ZlibDecoder<R> {\n        ZlibDecoder {\n            inner: bufread::ZlibDecoder::new(BufReader::with_buf(buf, r)),\n        }\n    }\n}","impl<R> ZlibDecoder<R> {\n    /// Resets the state of this decoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This will reset the internal state of this decoder and replace the\n    /// input stream with the one provided, returning the previous input\n    /// stream. Future data read from this decoder will be the decompressed\n    /// version of `r`'s data.\n    ///\n    /// Note that there may be currently buffered data when this function is\n    /// called, and in that case the buffered data is discarded.\n    pub fn reset(&mut self, r: R) -> R {\n        super::bufread::reset_decoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }\n\n    /// Acquires a reference to the underlying stream\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this decoder, returning the underlying reader.\n    ///\n    /// Note that there may be buffered bytes which are not re-acquired as part\n    /// of this transition. It's recommended to only call this function after\n    /// EOF has been reached.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed.\n    ///\n    /// Note that this will likely be smaller than what the decompressor\n    /// actually read from the underlying stream due to buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has produced.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n}"],"zlib::read::ZlibEncoder":["Debug","impl<R: Read> Read for ZlibEncoder<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n}","impl<R: Read> ZlibEncoder<R> {\n    /// Creates a new encoder which will read uncompressed data from the given\n    /// stream and emit the compressed stream.\n    pub fn new(r: R, level: crate::Compression) -> ZlibEncoder<R> {\n        ZlibEncoder {\n            inner: bufread::ZlibEncoder::new(BufReader::new(r), level),\n        }\n    }\n}","impl<R> ZlibEncoder<R> {\n    /// Resets the state of this encoder entirely, swapping out the input\n    /// stream for another.\n    ///\n    /// This function will reset the internal state of this encoder and replace\n    /// the input stream with the one provided, returning the previous input\n    /// stream. Future data read from this encoder will be the compressed\n    /// version of `r`'s data.\n    ///\n    /// Note that there may be currently buffered data when this function is\n    /// called, and in that case the buffered data is discarded.\n    pub fn reset(&mut self, r: R) -> R {\n        super::bufread::reset_encoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }\n\n    /// Acquires a reference to the underlying stream\n    pub fn get_ref(&self) -> &R {\n        self.inner.get_ref().get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying stream\n    ///\n    /// Note that mutation of the stream may result in surprising results if\n    /// this encoder is continued to be used.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.inner.get_mut().get_mut()\n    }\n\n    /// Consumes this encoder, returning the underlying reader.\n    ///\n    /// Note that there may be buffered bytes which are not re-acquired as part\n    /// of this transition. It's recommended to only call this function after\n    /// EOF has been reached.\n    pub fn into_inner(self) -> R {\n        self.inner.into_inner().into_inner()\n    }\n\n    /// Returns the number of bytes that have been read into this compressor.\n    ///\n    /// Note that not all bytes read from the underlying object may be accounted\n    /// for, there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been read yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.inner.total_out()\n    }\n}","impl<W: Read + Write> Write for ZlibEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.get_mut().write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.get_mut().flush()\n    }\n}"],"zlib::write::ZlibDecoder":["Debug","impl<W: Read + Write> Read for ZlibDecoder<W> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.get_mut().read(buf)\n    }\n}","impl<W: Write> Write for ZlibDecoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}","impl<W: Write> ZlibDecoder<W> {\n    /// Creates a new decoder which will write uncompressed data to the stream.\n    ///\n    /// When this decoder is dropped or unwrapped the final pieces of data will\n    /// be flushed.\n    pub fn new(w: W) -> ZlibDecoder<W> {\n        ZlibDecoder {\n            inner: zio::Writer::new(w, Decompress::new(true)),\n        }\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutating the output/input state of the stream may corrupt this\n    /// object, so care must be taken when using this method.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Resets the state of this decoder entirely, swapping out the output\n    /// stream for another.\n    ///\n    /// This will reset the internal state of this decoder and replace the\n    /// output stream with the one provided, returning the previous output\n    /// stream. Future data written to this decoder will be decompressed into\n    /// the output stream `w`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn reset(&mut self, w: W) -> io::Result<W> {\n        self.inner.finish()?;\n        self.inner.data = Decompress::new(true);\n        Ok(self.inner.replace(w))\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.inner.finish()\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream and then return the contained\n    /// writer if the flush succeeded.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Returns the number of bytes that the decompressor has consumed for\n    /// decompression.\n    ///\n    /// Note that this will likely be smaller than the number of bytes\n    /// successfully written to this stream due to internal buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.data.total_in()\n    }\n\n    /// Returns the number of bytes that the decompressor has written to its\n    /// output stream.\n    pub fn total_out(&self) -> u64 {\n        self.inner.data.total_out()\n    }\n}"],"zlib::write::ZlibEncoder":["Debug","impl<W: Read + Write> Read for ZlibEncoder<W> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.get_mut().read(buf)\n    }\n}","impl<W: Write> Write for ZlibEncoder<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}","impl<W: Write> ZlibEncoder<W> {\n    /// Creates a new encoder which will write compressed data to the stream\n    /// given at the given compression level.\n    ///\n    /// When this encoder is dropped or unwrapped the final pieces of data will\n    /// be flushed.\n    pub fn new(w: W, level: crate::Compression) -> ZlibEncoder<W> {\n        ZlibEncoder {\n            inner: zio::Writer::new(w, Compress::new(level, true)),\n        }\n    }\n\n    /// Acquires a reference to the underlying writer.\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Acquires a mutable reference to the underlying writer.\n    ///\n    /// Note that mutating the output/input state of the stream may corrupt this\n    /// object, so care must be taken when using this method.\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Resets the state of this encoder entirely, swapping out the output\n    /// stream for another.\n    ///\n    /// This function will finish encoding the current stream into the current\n    /// output stream before swapping out the two output streams.\n    ///\n    /// After the current stream has been finished, this will reset the internal\n    /// state of this encoder and replace the output stream with the one\n    /// provided, returning the previous output stream. Future data written to\n    /// this encoder will be the compressed into the stream `w` provided.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn reset(&mut self, w: W) -> io::Result<W> {\n        self.inner.finish()?;\n        self.inner.data.reset();\n        Ok(self.inner.replace(w))\n    }\n\n    /// Attempt to finish this output stream, writing out final chunks of data.\n    ///\n    /// Note that this function can only be used once data has finished being\n    /// written to the output stream. After this function is called then further\n    /// calls to `write` may result in a panic.\n    ///\n    /// # Panics\n    ///\n    /// Attempts to write data to this stream may result in a panic after this\n    /// function is called.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn try_finish(&mut self) -> io::Result<()> {\n        self.inner.finish()\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream, close off the compressed\n    /// stream and, if successful, return the contained writer.\n    ///\n    /// Note that this function may not be suitable to call in a situation where\n    /// the underlying stream is an asynchronous I/O stream. To finish a stream\n    /// the `try_finish` (or `shutdown`) method should be used instead. To\n    /// re-acquire ownership of a stream it is safe to call this method after\n    /// `try_finish` or `shutdown` has returned `Ok`.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn finish(mut self) -> io::Result<W> {\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Consumes this encoder, flushing the output stream.\n    ///\n    /// This will flush the underlying data stream and then return the contained\n    /// writer if the flush succeeded.\n    /// The compressed stream will not closed but only flushed. This\n    /// means that obtained byte array can by extended by another deflated\n    /// stream. To close the stream add the two bytes 0x3 and 0x0.\n    ///\n    /// # Errors\n    ///\n    /// This function will perform I/O to complete this stream, and any I/O\n    /// errors which occur will be returned from this function.\n    pub fn flush_finish(mut self) -> io::Result<W> {\n        self.inner.flush()?;\n        Ok(self.inner.take_inner())\n    }\n\n    /// Returns the number of bytes that have been written to this compresor.\n    ///\n    /// Note that not all bytes written to this object may be accounted for,\n    /// there may still be some active buffering.\n    pub fn total_in(&self) -> u64 {\n        self.inner.data.total_in()\n    }\n\n    /// Returns the number of bytes that the compressor has produced.\n    ///\n    /// Note that not all bytes may have been written yet, some may still be\n    /// buffered.\n    pub fn total_out(&self) -> u64 {\n        self.inner.data.total_out()\n    }\n}"]},"single_path_import":{"crc::Crc":"Crc","crc::CrcReader":"CrcReader","crc::CrcWriter":"CrcWriter","deflate::bufread::DeflateDecoder":"bufread::DeflateDecoder","deflate::bufread::DeflateEncoder":"bufread::DeflateEncoder","deflate::read::DeflateDecoder":"read::DeflateDecoder","deflate::read::DeflateEncoder":"read::DeflateEncoder","deflate::write::DeflateDecoder":"write::DeflateDecoder","deflate::write::DeflateEncoder":"write::DeflateEncoder","gz::GzBuilder":"GzBuilder","gz::GzHeader":"GzHeader","gz::bufread::GzDecoder":"bufread::GzDecoder","gz::bufread::GzEncoder":"bufread::GzEncoder","gz::bufread::MultiGzDecoder":"bufread::MultiGzDecoder","gz::read::GzDecoder":"read::GzDecoder","gz::read::GzEncoder":"read::GzEncoder","gz::read::MultiGzDecoder":"read::MultiGzDecoder","gz::write::GzDecoder":"write::GzDecoder","gz::write::GzEncoder":"write::GzEncoder","mem::Compress":"Compress","mem::CompressError":"CompressError","mem::Decompress":"Decompress","mem::DecompressError":"DecompressError","mem::FlushCompress":"FlushCompress","mem::FlushDecompress":"FlushDecompress","mem::Status":"Status","zlib::bufread::ZlibDecoder":"bufread::ZlibDecoder","zlib::bufread::ZlibEncoder":"bufread::ZlibEncoder","zlib::read::ZlibDecoder":"read::ZlibDecoder","zlib::read::ZlibEncoder":"read::ZlibEncoder","zlib::write::ZlibDecoder":"write::ZlibDecoder","zlib::write::ZlibEncoder":"write::ZlibEncoder"},"srcs":{"<Compression as std::default::Default>::default":["fn default() -> Compression{\n        Compression(6)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<bufreader::BufReader<R> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>{\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()),\n            )\n            .finish()\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"<bufreader::BufReader<R> as std::io::BufRead>::consume":["fn consume(&mut self, amt: usize){\n        self.pos = cmp::min(self.pos + amt, self.cap);\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"<bufreader::BufReader<R> as std::io::BufRead>::fill_buf":["fn fill_buf(&mut self) -> io::Result<&[u8]>{\n        // If we've reached the end of our internal buffer then we need to fetch\n        // some more data from the underlying reader.\n        if self.pos == self.cap {\n            self.cap = self.inner.read(&mut self.buf)?;\n            self.pos = 0;\n        }\n        Ok(&self.buf[self.pos..self.cap])\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"<bufreader::BufReader<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"<crc::CrcReader<R> as std::io::BufRead>::consume":["fn consume(&mut self, amt: usize){\n        if let Ok(data) = self.inner.fill_buf() {\n            self.crc.update(&data[..amt]);\n        }\n        self.inner.consume(amt);\n    }","Real(LocalPath(\"src/crc.rs\"))"],"<crc::CrcReader<R> as std::io::BufRead>::fill_buf":["fn fill_buf(&mut self) -> io::Result<&[u8]>{\n        self.inner.fill_buf()\n    }","Real(LocalPath(\"src/crc.rs\"))"],"<crc::CrcReader<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        let amt = self.inner.read(into)?;\n        self.crc.update(&into[..amt]);\n        Ok(amt)\n    }","Real(LocalPath(\"src/crc.rs\"))"],"<crc::CrcWriter<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/crc.rs\"))"],"<crc::CrcWriter<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        let amt = self.inner.write(buf)?;\n        self.crc.update(&buf[..amt]);\n        Ok(amt)\n    }","Real(LocalPath(\"src/crc.rs\"))"],"<deflate::bufread::DeflateDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        zio::read(&mut self.obj, &mut self.data, into)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::bufread::DeflateEncoder<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        zio::read(&mut self.obj, &mut self.data, buf)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"<deflate::read::DeflateDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(into)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::read::DeflateEncoder<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(buf)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"<deflate::write::DeflateDecoder<W> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.get_mut().read(buf)\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.inner.write(buf)\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<deflate::write::DeflateEncoder<W> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.get_mut().read(buf)\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.inner.write(buf)\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"<ffi::rust::Deflate as ffi::Backend>::total_in":["#[inline]\nfn total_in(&self) -> u64{\n        self.total_in\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Deflate as ffi::Backend>::total_out":["#[inline]\nfn total_out(&self) -> u64{\n        self.total_out\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Deflate as ffi::DeflateBackend>::compress":["fn compress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError>{\n        let flush = MZFlush::new(flush as i32).unwrap();\n        let res = deflate::stream::deflate(&mut self.inner, input, output, flush);\n        self.total_in += res.bytes_consumed as u64;\n        self.total_out += res.bytes_written as u64;\n\n        match res.status {\n            Ok(status) => match status {\n                MZStatus::Ok => Ok(Status::Ok),\n                MZStatus::StreamEnd => Ok(Status::StreamEnd),\n                MZStatus::NeedDict => Err(CompressError(())),\n            },\n            Err(status) => match status {\n                MZError::Buf => Ok(Status::BufError),\n                _ => Err(CompressError(())),\n            },\n        }\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Deflate as ffi::DeflateBackend>::make":["fn make(level: Compression, zlib_header: bool, window_bits: u8) -> Self{\n        assert!(\n            window_bits > 8 && window_bits < 16,\n            \"window_bits must be within 9 ..= 15\"\n        );\n\n        // Check in case the integer value changes at some point.\n        debug_assert!(level.level() <= 10);\n\n        let mut inner: Box<CompressorOxide> = Box::default();\n        let format = format_from_bool(zlib_header);\n        inner.set_format_and_level(format, level.level().try_into().unwrap_or(1));\n\n        Deflate {\n            inner,\n            total_in: 0,\n            total_out: 0,\n        }\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Deflate as ffi::DeflateBackend>::reset":["fn reset(&mut self){\n        self.total_in = 0;\n        self.total_out = 0;\n        self.inner.reset();\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Deflate as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        write!(\n            f,\n            \"miniz_oxide deflate internal state. total_in: {}, total_out: {}\",\n            self.total_in, self.total_out,\n        )\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as ffi::Backend>::total_in":["#[inline]\nfn total_in(&self) -> u64{\n        self.total_in\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as ffi::Backend>::total_out":["#[inline]\nfn total_out(&self) -> u64{\n        self.total_out\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as ffi::InflateBackend>::decompress":["fn decompress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>{\n        let flush = MZFlush::new(flush as i32).unwrap();\n\n        let res = inflate::stream::inflate(&mut self.inner, input, output, flush);\n        self.total_in += res.bytes_consumed as u64;\n        self.total_out += res.bytes_written as u64;\n\n        match res.status {\n            Ok(status) => match status {\n                MZStatus::Ok => Ok(Status::Ok),\n                MZStatus::StreamEnd => Ok(Status::StreamEnd),\n                MZStatus::NeedDict => {\n                    mem::decompress_need_dict(self.inner.decompressor().adler32().unwrap_or(0))\n                }\n            },\n            Err(status) => match status {\n                MZError::Buf => Ok(Status::BufError),\n                _ => mem::decompress_failed(),\n            },\n        }\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as ffi::InflateBackend>::make":["fn make(zlib_header: bool, window_bits: u8) -> Self{\n        assert!(\n            window_bits > 8 && window_bits < 16,\n            \"window_bits must be within 9 ..= 15\"\n        );\n\n        let format = format_from_bool(zlib_header);\n\n        Inflate {\n            inner: InflateState::new_boxed(format),\n            total_in: 0,\n            total_out: 0,\n        }\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as ffi::InflateBackend>::reset":["fn reset(&mut self, zlib_header: bool){\n        self.inner.reset(format_from_bool(zlib_header));\n        self.total_in = 0;\n        self.total_out = 0;\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<ffi::rust::Inflate as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        write!(\n            f,\n            \"miniz_oxide inflate internal state. total_in: {}, total_out: {}\",\n            self.total_in, self.total_out,\n        )\n    }","Real(LocalPath(\"src/ffi/rust.rs\"))"],"<gz::bufread::Buffer<'a, T> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        if self.buf_cur == self.buf_max {\n            let len = self.reader.read(buf)?;\n            self.buf.extend_from_slice(&buf[..len]);\n            Ok(len)\n        } else {\n            let len = (&self.buf[self.buf_cur..self.buf_max]).read(buf)?;\n            self.buf_cur += len;\n            Ok(len)\n        }\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        let GzDecoder {\n            inner,\n            header,\n            reader,\n            multi,\n        } = self;\n\n        loop {\n            *inner = match mem::replace(inner, GzState::End) {\n                GzState::Header(mut buf) => {\n                    let result = {\n                        let mut reader = Buffer::new(&mut buf, reader.get_mut().get_mut());\n                        read_gz_header(&mut reader)\n                    };\n                    let hdr = result.map_err(|err| {\n                        if io::ErrorKind::WouldBlock == err.kind() {\n                            *inner = GzState::Header(buf);\n                        }\n\n                        err\n                    })?;\n                    *header = Some(hdr);\n                    GzState::Body\n                }\n                GzState::Body => {\n                    if into.is_empty() {\n                        *inner = GzState::Body;\n                        return Ok(0);\n                    }\n\n                    let n = reader.read(into).map_err(|err| {\n                        if io::ErrorKind::WouldBlock == err.kind() {\n                            *inner = GzState::Body;\n                        }\n\n                        err\n                    })?;\n\n                    match n {\n                        0 => GzState::Finished(0, [0; 8]),\n                        n => {\n                            *inner = GzState::Body;\n                            return Ok(n);\n                        }\n                    }\n                }\n                GzState::Finished(pos, mut buf) => {\n                    if pos < buf.len() {\n                        let n = reader\n                            .get_mut()\n                            .get_mut()\n                            .read(&mut buf[pos..])\n                            .and_then(|n| {\n                                if n == 0 {\n                                    Err(io::ErrorKind::UnexpectedEof.into())\n                                } else {\n                                    Ok(n)\n                                }\n                            })\n                            .map_err(|err| {\n                                if io::ErrorKind::WouldBlock == err.kind() {\n                                    *inner = GzState::Finished(pos, buf);\n                                }\n\n                                err\n                            })?;\n\n                        GzState::Finished(pos + n, buf)\n                    } else {\n                        let (crc, amt) = finish(&buf);\n\n                        if crc != reader.crc().sum() || amt != reader.crc().amount() {\n                            return Err(corrupt());\n                        } else if *multi {\n                            let is_eof = reader\n                                .get_mut()\n                                .get_mut()\n                                .fill_buf()\n                                .map(|buf| buf.is_empty())\n                                .map_err(|err| {\n                                    if io::ErrorKind::WouldBlock == err.kind() {\n                                        *inner = GzState::Finished(pos, buf);\n                                    }\n\n                                    err\n                                })?;\n\n                            if is_eof {\n                                GzState::End\n                            } else {\n                                reader.reset();\n                                reader.get_mut().reset_data();\n                                header.take();\n                                GzState::Header(Vec::with_capacity(10))\n                            }\n                        } else {\n                            GzState::End\n                        }\n                    }\n                }\n                GzState::Err(err) => return Err(err),\n                GzState::End => return Ok(0),\n            };\n        }\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzEncoder<R> as std::io::Read>::read":["fn read(&mut self, mut into: &mut [u8]) -> io::Result<usize>{\n        let mut amt = 0;\n        if self.eof {\n            return self.read_footer(into);\n        } else if self.pos < self.header.len() {\n            amt += copy(into, &self.header, &mut self.pos);\n            if amt == into.len() {\n                return Ok(amt);\n            }\n            let tmp = into;\n            into = &mut tmp[amt..];\n        }\n        match self.inner.read(into)? {\n            0 => {\n                self.eof = true;\n                self.pos = 0;\n                self.read_footer(into)\n            }\n            n => Ok(amt + n),\n        }\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzEncoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::GzEncoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::MultiGzDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.0.read(into)\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"<gz::read::GzDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(into)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::GzDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::GzDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::GzEncoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(into)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::GzEncoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::GzEncoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::MultiGzDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(into)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"<gz::write::Counter<T> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        let pos = self.inner.read(buf)?;\n        self.pos += pos;\n        Ok(pos)\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzDecoder<W> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.get_mut().get_mut().read(buf)\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzDecoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzDecoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        if self.header.is_none() {\n            // trying to avoid buffer usage\n            let (res, pos) = {\n                let mut counter = Counter {\n                    inner: self.header_buf.chain(buf),\n                    pos: 0,\n                };\n                let res = read_gz_header(&mut counter);\n                (res, counter.pos)\n            };\n\n            match res {\n                Err(err) => {\n                    if err.kind() == io::ErrorKind::UnexpectedEof {\n                        // not enough data for header, save to the buffer\n                        self.header_buf.extend(buf);\n                        Ok(buf.len())\n                    } else {\n                        Err(err)\n                    }\n                }\n                Ok(header) => {\n                    self.header = Some(header);\n                    let pos = pos - self.header_buf.len();\n                    self.header_buf.truncate(0);\n                    Ok(pos)\n                }\n            }\n        } else {\n            let (n, status) = self.inner.write_with_status(buf)?;\n\n            if status == Status::StreamEnd {\n                if n < buf.len() && self.crc_bytes.len() < 8 {\n                    let remaining = buf.len() - n;\n                    let crc_bytes = cmp::min(remaining, CRC_BYTES_LEN - self.crc_bytes.len());\n                    self.crc_bytes.extend(&buf[n..n + crc_bytes]);\n                    return Ok(n + crc_bytes);\n                }\n            }\n            Ok(n)\n        }\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzEncoder<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.get_mut().read(buf)\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        assert_eq!(self.crc_bytes_written, 0);\n        self.write_header()?;\n        self.inner.flush()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        assert_eq!(self.crc_bytes_written, 0);\n        self.write_header()?;\n        let n = self.inner.write(buf)?;\n        self.crc.update(&buf[..n]);\n        Ok(n)\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<gz::write::GzEncoder<W> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if self.inner.is_present() {\n            let _ = self.try_finish();\n        }\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"<mem::Compress as zio::Ops>::run":["fn run(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, DecompressError>{\n        Ok(self.compress(input, output, flush).unwrap())\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Compress as zio::Ops>::run_vec":["fn run_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushCompress,\n    ) -> Result<Status, DecompressError>{\n        Ok(self.compress_vec(input, output, flush).unwrap())\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Compress as zio::Ops>::total_in":["fn total_in(&self) -> u64{\n        self.total_in()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Compress as zio::Ops>::total_out":["fn total_out(&self) -> u64{\n        self.total_out()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::CompressError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"deflate decompression error\")\n    }","Real(LocalPath(\"src/mem.rs\"))"],"<mem::Decompress as zio::Ops>::run":["fn run(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>{\n        self.decompress(input, output, flush)\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Decompress as zio::Ops>::run_vec":["fn run_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>{\n        self.decompress_vec(input, output, flush)\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Decompress as zio::Ops>::total_in":["fn total_in(&self) -> u64{\n        self.total_in()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::Decompress as zio::Ops>::total_out":["fn total_out(&self) -> u64{\n        self.total_out()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::DecompressError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"deflate decompression error\")\n    }","Real(LocalPath(\"src/mem.rs\"))"],"<mem::FlushCompress as zio::Flush>::finish":["fn finish() -> Self{\n        FlushCompress::Finish\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::FlushCompress as zio::Flush>::none":["fn none() -> Self{\n        FlushCompress::None\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::FlushCompress as zio::Flush>::sync":["fn sync() -> Self{\n        FlushCompress::Sync\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::FlushDecompress as zio::Flush>::finish":["fn finish() -> Self{\n        FlushDecompress::Finish\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::FlushDecompress as zio::Flush>::none":["fn none() -> Self{\n        FlushDecompress::None\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<mem::FlushDecompress as zio::Flush>::sync":["fn sync() -> Self{\n        FlushDecompress::Sync\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<zio::Writer<W, D> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.data\n            .run_vec(&[], &mut self.buf, D::Flush::sync())\n            .unwrap();\n\n        // Unfortunately miniz doesn't actually tell us when we're done with\n        // pulling out all the data from the internal stream. To remedy this we\n        // have to continually ask the stream for more memory until it doesn't\n        // give us a chunk of memory the same size as our own internal buffer,\n        // at which point we assume it's reached the end.\n        loop {\n            self.dump()?;\n            let before = self.data.total_out();\n            self.data\n                .run_vec(&[], &mut self.buf, D::Flush::none())\n                .unwrap();\n            if before == self.data.total_out() {\n                break;\n            }\n        }\n\n        self.obj.as_mut().unwrap().flush()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<zio::Writer<W, D> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.write_with_status(buf).map(|res| res.0)\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<zio::Writer<W, D> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if self.obj.is_some() {\n            let _ = self.finish();\n        }\n    }","Real(LocalPath(\"src/zio.rs\"))"],"<zlib::bufread::ZlibDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        zio::read(&mut self.obj, &mut self.data, into)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::bufread::ZlibEncoder<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        zio::read(&mut self.obj, &mut self.data, buf)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"<zlib::read::ZlibDecoder<R> as std::io::Read>::read":["fn read(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(into)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::read::ZlibEncoder<R> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.read(buf)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.get_mut().flush()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.get_mut().write(buf)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"<zlib::write::ZlibDecoder<W> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.inner.get_mut().read(buf)\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.inner.write(buf)\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"<zlib::write::ZlibEncoder<W> as std::io::Read>::read":["fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        self.get_mut().read(buf)\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        self.inner.flush()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.inner.write(buf)\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"Compression":["/// When compressing data, the compression level can be specified by a value in\n/// this enum.\npub struct Compression(u32);","Real(LocalPath(\"src/lib.rs\"))"],"Compression::best":["/// Optimize for the size of data being encoded.\npub const fn best() -> Compression{\n        Compression(9)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Compression::fast":["/// Optimize for the best speed of encoding.\npub const fn fast() -> Compression{\n        Compression(1)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Compression::level":["/// Returns an integer representing the compression level, typically on a\n/// scale of 0-9\npub fn level(&self) -> u32{\n        self.0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Compression::new":["/// Creates a new description of the compression level with an explicitly\n/// specified integer.\n///\n/// The integer here is typically on a scale of 0-9 where 0 means \"no\n/// compression\" and 9 means \"take as long as you'd like\".\npub const fn new(level: u32) -> Compression{\n        Compression(level)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Compression::none":["/// No compression is to be performed, this may actually inflate data\n/// slightly when encoding.\npub const fn none() -> Compression{\n        Compression(0)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"_assert_send_sync":["fn _assert_send_sync(){\n    fn _assert_send_sync<T: Send + Sync>() {}\n\n    _assert_send_sync::<read::DeflateEncoder<&[u8]>>();\n    _assert_send_sync::<read::DeflateDecoder<&[u8]>>();\n    _assert_send_sync::<read::ZlibEncoder<&[u8]>>();\n    _assert_send_sync::<read::ZlibDecoder<&[u8]>>();\n    _assert_send_sync::<read::GzEncoder<&[u8]>>();\n    _assert_send_sync::<read::GzDecoder<&[u8]>>();\n    _assert_send_sync::<read::MultiGzDecoder<&[u8]>>();\n    _assert_send_sync::<write::DeflateEncoder<Vec<u8>>>();\n    _assert_send_sync::<write::DeflateDecoder<Vec<u8>>>();\n    _assert_send_sync::<write::ZlibEncoder<Vec<u8>>>();\n    _assert_send_sync::<write::ZlibDecoder<Vec<u8>>>();\n    _assert_send_sync::<write::GzEncoder<Vec<u8>>>();\n    _assert_send_sync::<write::GzDecoder<Vec<u8>>>();\n}","Real(LocalPath(\"src/lib.rs\"))"],"_assert_send_sync::_assert_send_sync":["fn _assert_send_sync<T: Send + Sync>(){}","Real(LocalPath(\"src/lib.rs\"))"],"bufreader::BufReader":["pub struct BufReader<R> {\n    inner: R,\n    buf: Box<[u8]>,\n    pos: usize,\n    cap: usize,\n}","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::get_mut":["pub fn get_mut(&mut self) -> &mut R{\n        &mut self.inner\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::get_ref":["pub fn get_ref(&self) -> &R{\n        &self.inner\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::into_inner":["pub fn into_inner(self) -> R{\n        self.inner\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::new":["pub fn new(inner: R) -> BufReader<R>{\n        BufReader::with_buf(vec![0; 32 * 1024], inner)\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::reset":["pub fn reset(&mut self, inner: R) -> R{\n        self.pos = 0;\n        self.cap = 0;\n        mem::replace(&mut self.inner, inner)\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"bufreader::BufReader::<R>::with_buf":["pub fn with_buf(buf: Vec<u8>, inner: R) -> BufReader<R>{\n        BufReader {\n            inner: inner,\n            buf: buf.into_boxed_slice(),\n            pos: 0,\n            cap: 0,\n        }\n    }","Real(LocalPath(\"src/bufreader.rs\"))"],"crc::Crc":["/// The CRC calculated by a [`CrcReader`].\n///\n/// [`CrcReader`]: struct.CrcReader.html\npub struct Crc {\n    amt: u32,\n    hasher: Hasher,\n}","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::amount":["/// The number of bytes that have been used to calculate the CRC.\n/// This value is only accurate if the amount is lower than 2<sup>32</sup>.\npub fn amount(&self) -> u32{\n        self.amt\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::combine":["/// Combine the CRC with the CRC for the subsequent block of bytes.\npub fn combine(&mut self, additional_crc: &Crc){\n        self.amt += additional_crc.amt;\n        self.hasher.combine(&additional_crc.hasher);\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::new":["/// Create a new CRC.\npub fn new() -> Crc{\n        Crc {\n            amt: 0,\n            hasher: Hasher::new(),\n        }\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::reset":["/// Reset the CRC.\npub fn reset(&mut self){\n        self.amt = 0;\n        self.hasher.reset();\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::sum":["/// Returns the current crc32 checksum.\npub fn sum(&self) -> u32{\n        self.hasher.clone().finalize()\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::Crc::update":["/// Update the CRC with the bytes in `data`.\npub fn update(&mut self, data: &[u8]){\n        self.amt = self.amt.wrapping_add(data.len() as u32);\n        self.hasher.update(data);\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader":["/// A wrapper around a [`Read`] that calculates the CRC.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\npub struct CrcReader<R> {\n    inner: R,\n    crc: Crc,\n}","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::crc":["/// Get the Crc for this CrcReader.\npub fn crc(&self) -> &Crc{\n        &self.crc\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::get_mut":["/// Get a mutable reference to the reader that is wrapped by this CrcReader.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::get_ref":["/// Get the reader that is wrapped by this CrcReader by reference.\npub fn get_ref(&self) -> &R{\n        &self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::into_inner":["/// Get the reader that is wrapped by this CrcReader.\npub fn into_inner(self) -> R{\n        self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::new":["/// Create a new CrcReader.\npub fn new(r: R) -> CrcReader<R>{\n        CrcReader {\n            inner: r,\n            crc: Crc::new(),\n        }\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcReader::<R>::reset":["/// Reset the Crc in this CrcReader.\npub fn reset(&mut self){\n        self.crc.reset();\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter":["/// A wrapper around a [`Write`] that calculates the CRC.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\npub struct CrcWriter<W> {\n    inner: W,\n    crc: Crc,\n}","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::crc":["/// Get the Crc for this CrcWriter.\npub fn crc(&self) -> &Crc{\n        &self.crc\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::get_mut":["/// Get a mutable reference to the writer that is wrapped by this CrcWriter.\npub fn get_mut(&mut self) -> &mut W{\n        &mut self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::get_ref":["/// Get the writer that is wrapped by this CrcWriter by reference.\npub fn get_ref(&self) -> &W{\n        &self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::into_inner":["/// Get the writer that is wrapped by this CrcWriter.\npub fn into_inner(self) -> W{\n        self.inner\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::new":["/// Create a new CrcWriter.\npub fn new(w: W) -> CrcWriter<W>{\n        CrcWriter {\n            inner: w,\n            crc: Crc::new(),\n        }\n    }","Real(LocalPath(\"src/crc.rs\"))"],"crc::CrcWriter::<W>::reset":["/// Reset the Crc in this CrcWriter.\npub fn reset(&mut self){\n        self.crc.reset();\n    }","Real(LocalPath(\"src/crc.rs\"))"],"deflate::bufread::DeflateDecoder":["/// A DEFLATE decoder, or decompressor.\n///\n/// This structure consumes a [`BufRead`] interface, reading compressed data\n/// from the underlying reader, and emitting uncompressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::DeflateEncoder;\n/// use flate2::bufread::DeflateDecoder;\n///\n/// # fn main() {\n/// #    let mut e = DeflateEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// // Uncompresses a Deflate Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements Read\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut deflater = DeflateDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    deflater.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct DeflateDecoder<R> {\n    obj: R,\n    data: Decompress,\n}","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::get_ref":["/// Acquires a reference to the underlying stream\npub fn get_ref(&self) -> &R{\n        &self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::new":["/// Creates a new decoder which will decompress data read from the given\n/// stream.\npub fn new(r: R) -> DeflateDecoder<R>{\n        DeflateDecoder {\n            obj: r,\n            data: Decompress::new(false),\n        }\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::reset":["/// Resets the state of this decoder entirely, swapping out the input\n/// stream for another.\n///\n/// This will reset the internal state of this decoder and replace the\n/// input stream with the one provided, returning the previous input\n/// stream. Future data read from this decoder will be the decompressed\n/// version of `r`'s data.\npub fn reset(&mut self, r: R) -> R{\n        reset_decoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::reset_data":["/// Resets the state of this decoder's data\n///\n/// This will reset the internal state of this decoder. It will continue\n/// reading from the same stream.\npub fn reset_data(&mut self){\n        reset_decoder_data(self);\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::total_in":["/// Returns the number of bytes that the decompressor has consumed.\n///\n/// Note that this will likely be smaller than what the decompressor\n/// actually read from the underlying stream due to buffering.\npub fn total_in(&self) -> u64{\n        self.data.total_in()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateDecoder::<R>::total_out":["/// Returns the number of bytes that the decompressor has produced.\npub fn total_out(&self) -> u64{\n        self.data.total_out()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder":["/// A DEFLATE encoder, or compressor.\n///\n/// This structure consumes a [`BufRead`] interface, reading uncompressed data\n/// from the underlying reader, and emitting compressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// use flate2::Compression;\n/// use flate2::bufread::DeflateEncoder;\n/// use std::fs::File;\n/// use std::io::BufReader;\n///\n/// # fn main() {\n/// #    println!(\"{:?}\", open_hello_world().unwrap());\n/// # }\n/// #\n/// // Opens sample file, compresses the contents and returns a Vector\n/// fn open_hello_world() -> io::Result<Vec<u8>> {\n///    let f = File::open(\"examples/hello_world.txt\")?;\n///    let b = BufReader::new(f);\n///    let mut deflater = DeflateEncoder::new(b, Compression::fast());\n///    let mut buffer = Vec::new();\n///    deflater.read_to_end(&mut buffer)?;\n///    Ok(buffer)\n/// }\n/// ```\npub struct DeflateEncoder<R> {\n    obj: R,\n    data: Compress,\n}","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::get_ref":["/// Acquires a reference to the underlying reader\npub fn get_ref(&self) -> &R{\n        &self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::into_inner":["/// Consumes this encoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.obj\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::new":["/// Creates a new encoder which will read uncompressed data from the given\n/// stream and emit the compressed stream.\npub fn new(r: R, level: crate::Compression) -> DeflateEncoder<R>{\n        DeflateEncoder {\n            obj: r,\n            data: Compress::new(level, false),\n        }\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::reset":["/// Resets the state of this encoder entirely, swapping out the input\n/// stream for another.\n///\n/// This function will reset the internal state of this encoder and replace\n/// the input stream with the one provided, returning the previous input\n/// stream. Future data read from this encoder will be the compressed\n/// version of `r`'s data.\npub fn reset(&mut self, r: R) -> R{\n        reset_encoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::total_in":["/// Returns the number of bytes that have been read into this compressor.\n///\n/// Note that not all bytes read from the underlying object may be accounted\n/// for, there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.data.total_in()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::DeflateEncoder::<R>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been read yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.data.total_out()\n    }","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::reset_decoder_data":["pub fn reset_decoder_data<R>(zlib: &mut DeflateDecoder<R>){\n    zlib.data = Decompress::new(false);\n}","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::bufread::reset_encoder_data":["pub fn reset_encoder_data<R>(zlib: &mut DeflateEncoder<R>){\n    zlib.data.reset();\n}","Real(LocalPath(\"src/deflate/bufread.rs\"))"],"deflate::read::DeflateDecoder":["/// A DEFLATE decoder, or decompressor.\n///\n/// This structure implements a [`Read`] interface and takes a stream of\n/// compressed data as input, providing the decompressed data when read from.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::DeflateEncoder;\n/// use flate2::read::DeflateDecoder;\n///\n/// # fn main() {\n/// #    let mut e = DeflateEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// // Uncompresses a Deflate Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements Read\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut deflater = DeflateDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    deflater.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct DeflateDecoder<R> {\n    inner: bufread::DeflateDecoder<BufReader<R>>,\n}","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::get_ref":["/// Acquires a reference to the underlying stream\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\n///\n/// Note that there may be buffered bytes which are not re-acquired as part\n/// of this transition. It's recommended to only call this function after\n/// EOF has been reached.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::new":["/// Creates a new decoder which will decompress data read from the given\n/// stream.\npub fn new(r: R) -> DeflateDecoder<R>{\n        DeflateDecoder::new_with_buf(r, vec![0; 32 * 1024])\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::new_with_buf":["/// Same as `new`, but the intermediate buffer for data is specified.\n///\n/// Note that the capacity of the intermediate buffer is never increased,\n/// and it is recommended for it to be large.\npub fn new_with_buf(r: R, buf: Vec<u8>) -> DeflateDecoder<R>{\n        DeflateDecoder {\n            inner: bufread::DeflateDecoder::new(BufReader::with_buf(buf, r)),\n        }\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::reset":["/// Resets the state of this decoder entirely, swapping out the input\n/// stream for another.\n///\n/// This will reset the internal state of this decoder and replace the\n/// input stream with the one provided, returning the previous input\n/// stream. Future data read from this decoder will be the decompressed\n/// version of `r`'s data.\n///\n/// Note that there may be currently buffered data when this function is\n/// called, and in that case the buffered data is discarded.\npub fn reset(&mut self, r: R) -> R{\n        super::bufread::reset_decoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::total_in":["/// Returns the number of bytes that the decompressor has consumed.\n///\n/// Note that this will likely be smaller than what the decompressor\n/// actually read from the underlying stream due to buffering.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateDecoder::<R>::total_out":["/// Returns the number of bytes that the decompressor has produced.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder":["/// A DEFLATE encoder, or compressor.\n///\n/// This structure implements a [`Read`] interface and will read uncompressed\n/// data from an underlying stream and emit a stream of compressed data.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// use flate2::Compression;\n/// use flate2::read::DeflateEncoder;\n///\n/// # fn main() {\n/// #    println!(\"{:?}\", deflateencoder_read_hello_world().unwrap());\n/// # }\n/// #\n/// // Return a vector containing the Deflate compressed version of hello world\n/// fn deflateencoder_read_hello_world() -> io::Result<Vec<u8>> {\n///    let mut ret_vec = [0;100];\n///    let c = b\"hello world\";\n///    let mut deflater = DeflateEncoder::new(&c[..], Compression::fast());\n///    let count = deflater.read(&mut ret_vec)?;\n///    Ok(ret_vec[0..count].to_vec())\n/// }\n/// ```\npub struct DeflateEncoder<R> {\n    inner: bufread::DeflateEncoder<BufReader<R>>,\n}","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::get_ref":["/// Acquires a reference to the underlying reader\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::into_inner":["/// Consumes this encoder, returning the underlying reader.\n///\n/// Note that there may be buffered bytes which are not re-acquired as part\n/// of this transition. It's recommended to only call this function after\n/// EOF has been reached.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::new":["/// Creates a new encoder which will read uncompressed data from the given\n/// stream and emit the compressed stream.\npub fn new(r: R, level: crate::Compression) -> DeflateEncoder<R>{\n        DeflateEncoder {\n            inner: bufread::DeflateEncoder::new(BufReader::new(r), level),\n        }\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::reset":["/// Resets the state of this encoder entirely, swapping out the input\n/// stream for another.\n///\n/// This function will reset the internal state of this encoder and replace\n/// the input stream with the one provided, returning the previous input\n/// stream. Future data read from this encoder will be the compressed\n/// version of `r`'s data.\n///\n/// Note that there may be currently buffered data when this function is\n/// called, and in that case the buffered data is discarded.\npub fn reset(&mut self, r: R) -> R{\n        super::bufread::reset_encoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::total_in":["/// Returns the number of bytes that have been read into this compressor.\n///\n/// Note that not all bytes read from the underlying object may be accounted\n/// for, there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::read::DeflateEncoder::<R>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been read yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/deflate/read.rs\"))"],"deflate::write::DeflateDecoder":["/// A DEFLATE decoder, or decompressor.\n///\n/// This structure implements a [`Write`] and will emit a stream of decompressed\n/// data when fed a stream of compressed data.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::DeflateEncoder;\n/// use flate2::write::DeflateDecoder;\n///\n/// # fn main() {\n/// #    let mut e = DeflateEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_writer(bytes).unwrap());\n/// # }\n/// // Uncompresses a Deflate Encoded vector of bytes and returns a string or error\n/// // Here Vec<u8> implements Write\n/// fn decode_writer(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut writer = Vec::new();\n///    let mut deflater = DeflateDecoder::new(writer);\n///    deflater.write_all(&bytes[..])?;\n///    writer = deflater.finish()?;\n///    let return_string = String::from_utf8(writer).expect(\"String parsing error\");\n///    Ok(return_string)\n/// }\n/// ```\npub struct DeflateDecoder<W: Write> {\n    inner: zio::Writer<W, Decompress>,\n}","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream and then return the contained\n/// writer if the flush succeeded.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutating the output/input state of the stream may corrupt this\n/// object, so care must be taken when using this method.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::new":["/// Creates a new decoder which will write uncompressed data to the stream.\n///\n/// When this encoder is dropped or unwrapped the final pieces of data will\n/// be flushed.\npub fn new(w: W) -> DeflateDecoder<W>{\n        DeflateDecoder {\n            inner: zio::Writer::new(w, Decompress::new(false)),\n        }\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::reset":["/// Resets the state of this decoder entirely, swapping out the output\n/// stream for another.\n///\n/// This function will finish encoding the current stream into the current\n/// output stream before swapping out the two output streams.\n///\n/// This will then reset the internal state of this decoder and replace the\n/// output stream with the one provided, returning the previous output\n/// stream. Future data written to this decoder will be decompressed into\n/// the output stream `w`.\n///\n/// # Errors\n///\n/// This function will perform I/O to finish the stream, and if that I/O\n/// returns an error then that will be returned from this function.\npub fn reset(&mut self, w: W) -> io::Result<W>{\n        self.inner.finish()?;\n        self.inner.data = Decompress::new(false);\n        Ok(self.inner.replace(w))\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::total_in":["/// Returns the number of bytes that the decompressor has consumed for\n/// decompression.\n///\n/// Note that this will likely be smaller than the number of bytes\n/// successfully written to this stream due to internal buffering.\npub fn total_in(&self) -> u64{\n        self.inner.data.total_in()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::total_out":["/// Returns the number of bytes that the decompressor has written to its\n/// output stream.\npub fn total_out(&self) -> u64{\n        self.inner.data.total_out()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateDecoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to finish the stream, returning any\n/// errors which happen.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.inner.finish()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder":["/// A DEFLATE encoder, or compressor.\n///\n/// This structure implements a [`Write`] interface and takes a stream of\n/// uncompressed data, writing the compressed data to the wrapped writer.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use flate2::Compression;\n/// use flate2::write::DeflateEncoder;\n///\n/// // Vec<u8> implements Write to print the compressed bytes of sample string\n/// # fn main() {\n///\n/// let mut e = DeflateEncoder::new(Vec::new(), Compression::default());\n/// e.write_all(b\"Hello World\").unwrap();\n/// println!(\"{:?}\", e.finish().unwrap());\n/// # }\n/// ```\npub struct DeflateEncoder<W: Write> {\n    inner: zio::Writer<W, Compress>,\n}","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream, close off the compressed\n/// stream and, if successful, return the contained writer.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::flush_finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream and then return the contained\n/// writer if the flush succeeded.\n/// The compressed stream will not closed but only flushed. This\n/// means that obtained byte array can by extended by another deflated\n/// stream. To close the stream add the two bytes 0x3 and 0x0.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn flush_finish(mut self) -> io::Result<W>{\n        self.inner.flush()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutating the output/input state of the stream may corrupt this\n/// object, so care must be taken when using this method.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::new":["/// Creates a new encoder which will write compressed data to the stream\n/// given at the given compression level.\n///\n/// When this encoder is dropped or unwrapped the final pieces of data will\n/// be flushed.\npub fn new(w: W, level: crate::Compression) -> DeflateEncoder<W>{\n        DeflateEncoder {\n            inner: zio::Writer::new(w, Compress::new(level, false)),\n        }\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::reset":["/// Resets the state of this encoder entirely, swapping out the output\n/// stream for another.\n///\n/// This function will finish encoding the current stream into the current\n/// output stream before swapping out the two output streams. If the stream\n/// cannot be finished an error is returned.\n///\n/// After the current stream has been finished, this will reset the internal\n/// state of this encoder and replace the output stream with the one\n/// provided, returning the previous output stream. Future data written to\n/// this encoder will be the compressed into the stream `w` provided.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn reset(&mut self, w: W) -> io::Result<W>{\n        self.inner.finish()?;\n        self.inner.data.reset();\n        Ok(self.inner.replace(w))\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::total_in":["/// Returns the number of bytes that have been written to this compresor.\n///\n/// Note that not all bytes written to this object may be accounted for,\n/// there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.inner.data.total_in()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been written yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.inner.data.total_out()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"deflate::write::DeflateEncoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.inner.finish()\n    }","Real(LocalPath(\"src/deflate/write.rs\"))"],"ffi::Backend":["/// Traits specifying the interface of the backends.\n///\n/// Sync + Send are added as a condition to ensure they are available\n/// for the frontend.\npub trait Backend: Sync + Send {\n    fn total_in(&self) -> u64;\n    fn total_out(&self) -> u64;\n}","Real(LocalPath(\"src/ffi/mod.rs\"))"],"ffi::DeflateBackend":["pub trait DeflateBackend: Backend {\n    fn make(level: Compression, zlib_header: bool, window_bits: u8) -> Self;\n    fn compress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError>;\n    fn reset(&mut self);\n}","Real(LocalPath(\"src/ffi/mod.rs\"))"],"ffi::InflateBackend":["pub trait InflateBackend: Backend {\n    fn make(zlib_header: bool, window_bits: u8) -> Self;\n    fn decompress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>;\n    fn reset(&mut self, zlib_header: bool);\n}","Real(LocalPath(\"src/ffi/mod.rs\"))"],"ffi::rust::Deflate":["pub struct Deflate {\n    inner: Box<CompressorOxide>,\n    total_in: u64,\n    total_out: u64,\n}","Real(LocalPath(\"src/ffi/rust.rs\"))"],"ffi::rust::Inflate":["pub struct Inflate {\n    inner: Box<InflateState>,\n    total_in: u64,\n    total_out: u64,\n}","Real(LocalPath(\"src/ffi/rust.rs\"))"],"ffi::rust::format_from_bool":["fn format_from_bool(zlib_header: bool) -> DataFormat{\n    if zlib_header {\n        DataFormat::Zlib\n    } else {\n        DataFormat::Raw\n    }\n}","Real(LocalPath(\"src/ffi/rust.rs\"))"],"gz::GzBuilder":["/// A builder structure to create a new gzip Encoder.\n///\n/// This structure controls header configuration options such as the filename.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// # use std::io;\n/// use std::fs::File;\n/// use flate2::GzBuilder;\n/// use flate2::Compression;\n///\n/// // GzBuilder opens a file and writes a sample string using GzBuilder pattern\n///\n/// # fn sample_builder() -> Result<(), io::Error> {\n/// let f = File::create(\"examples/hello_world.gz\")?;\n/// let mut gz = GzBuilder::new()\n///                 .filename(\"hello_world.txt\")\n///                 .comment(\"test file, please delete\")\n///                 .write(f, Compression::default());\n/// gz.write_all(b\"hello world\")?;\n/// gz.finish()?;\n/// # Ok(())\n/// # }\n/// ```\npub struct GzBuilder {\n    extra: Option<Vec<u8>>,\n    filename: Option<CString>,\n    comment: Option<CString>,\n    operating_system: Option<u8>,\n    mtime: u32,\n}","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::buf_read":["/// Consume this builder, creating a reader encoder in the process.\n///\n/// Data read from the returned encoder will be the compressed version of\n/// the data read from the given reader.\npub fn buf_read<R>(self, r: R, lvl: Compression) -> bufread::GzEncoder<R>\n    where\n        R: BufRead,{\n        bufread::gz_encoder(self.into_header(lvl), r, lvl)\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::comment":["/// Configure the `comment` field in the gzip header.\n///\n/// # Panics\n///\n/// Panics if the `comment` slice contains a zero.\npub fn comment<T: Into<Vec<u8>>>(mut self, comment: T) -> GzBuilder{\n        self.comment = Some(CString::new(comment.into()).unwrap());\n        self\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::extra":["/// Configure the `extra` field in the gzip header.\npub fn extra<T: Into<Vec<u8>>>(mut self, extra: T) -> GzBuilder{\n        self.extra = Some(extra.into());\n        self\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::filename":["/// Configure the `filename` field in the gzip header.\n///\n/// # Panics\n///\n/// Panics if the `filename` slice contains a zero.\npub fn filename<T: Into<Vec<u8>>>(mut self, filename: T) -> GzBuilder{\n        self.filename = Some(CString::new(filename.into()).unwrap());\n        self\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::into_header":["fn into_header(self, lvl: Compression) -> Vec<u8>{\n        let GzBuilder {\n            extra,\n            filename,\n            comment,\n            operating_system,\n            mtime,\n        } = self;\n        let mut flg = 0;\n        let mut header = vec![0u8; 10];\n        match extra {\n            Some(v) => {\n                flg |= FEXTRA;\n                header.push((v.len() >> 0) as u8);\n                header.push((v.len() >> 8) as u8);\n                header.extend(v);\n            }\n            None => {}\n        }\n        match filename {\n            Some(filename) => {\n                flg |= FNAME;\n                header.extend(filename.as_bytes_with_nul().iter().map(|x| *x));\n            }\n            None => {}\n        }\n        match comment {\n            Some(comment) => {\n                flg |= FCOMMENT;\n                header.extend(comment.as_bytes_with_nul().iter().map(|x| *x));\n            }\n            None => {}\n        }\n        header[0] = 0x1f;\n        header[1] = 0x8b;\n        header[2] = 8;\n        header[3] = flg;\n        header[4] = (mtime >> 0) as u8;\n        header[5] = (mtime >> 8) as u8;\n        header[6] = (mtime >> 16) as u8;\n        header[7] = (mtime >> 24) as u8;\n        header[8] = if lvl.0 >= Compression::best().0 {\n            2\n        } else if lvl.0 <= Compression::fast().0 {\n            4\n        } else {\n            0\n        };\n\n        // Typically this byte indicates what OS the gz stream was created on,\n        // but in an effort to have cross-platform reproducible streams just\n        // default this value to 255. I'm not sure that if we \"correctly\" set\n        // this it'd do anything anyway...\n        header[9] = operating_system.unwrap_or(255);\n        return header;\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::mtime":["/// Configure the `mtime` field in the gzip header.\npub fn mtime(mut self, mtime: u32) -> GzBuilder{\n        self.mtime = mtime;\n        self\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::new":["/// Create a new blank builder with no header by default.\npub fn new() -> GzBuilder{\n        GzBuilder {\n            extra: None,\n            filename: None,\n            comment: None,\n            operating_system: None,\n            mtime: 0,\n        }\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::operating_system":["/// Configure the `operating_system` field in the gzip header.\npub fn operating_system(mut self, os: u8) -> GzBuilder{\n        self.operating_system = Some(os);\n        self\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::read":["/// Consume this builder, creating a reader encoder in the process.\n///\n/// Data read from the returned encoder will be the compressed version of\n/// the data read from the given reader.\npub fn read<R: Read>(self, r: R, lvl: Compression) -> read::GzEncoder<R>{\n        read::gz_encoder(self.buf_read(BufReader::new(r), lvl))\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzBuilder::write":["/// Consume this builder, creating a writer encoder in the process.\n///\n/// The data written to the returned encoder will be compressed and then\n/// written out to the supplied parameter `w`.\npub fn write<W: Write>(self, w: W, lvl: Compression) -> write::GzEncoder<W>{\n        write::gz_encoder(self.into_header(lvl), w, lvl)\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader":["/// A structure representing the header of a gzip stream.\n///\n/// The header can contain metadata about the file that was compressed, if\n/// present.\npub struct GzHeader {\n    extra: Option<Vec<u8>>,\n    filename: Option<Vec<u8>>,\n    comment: Option<Vec<u8>>,\n    operating_system: u8,\n    mtime: u32,\n}","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::comment":["/// Returns the `comment` field of this gzip stream's header, if present.\npub fn comment(&self) -> Option<&[u8]>{\n        self.comment.as_ref().map(|s| &s[..])\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::extra":["/// Returns the `extra` field of this gzip stream's header, if present.\npub fn extra(&self) -> Option<&[u8]>{\n        self.extra.as_ref().map(|s| &s[..])\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::filename":["/// Returns the `filename` field of this gzip stream's header, if present.\npub fn filename(&self) -> Option<&[u8]>{\n        self.filename.as_ref().map(|s| &s[..])\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::mtime":["/// This gives the most recent modification time of the original file being compressed.\n///\n/// The time is in Unix format, i.e., seconds since 00:00:00 GMT, Jan. 1, 1970.\n/// (Note that this may cause problems for MS-DOS and other systems that use local\n/// rather than Universal time.) If the compressed data did not come from a file,\n/// `mtime` is set to the time at which compression started.\n/// `mtime` = 0 means no time stamp is available.\n///\n/// The usage of `mtime` is discouraged because of Year 2038 problem.\npub fn mtime(&self) -> u32{\n        self.mtime\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::mtime_as_datetime":["/// Returns the most recent modification time represented by a date-time type.\n/// Returns `None` if the value of the underlying counter is 0,\n/// indicating no time stamp is available.\n///\n///\n/// The time is measured as seconds since 00:00:00 GMT, Jan. 1 1970.\n/// See [`mtime`](#method.mtime) for more detail.\npub fn mtime_as_datetime(&self) -> Option<time::SystemTime>{\n        if self.mtime == 0 {\n            None\n        } else {\n            let duration = time::Duration::new(u64::from(self.mtime), 0);\n            let datetime = time::UNIX_EPOCH + duration;\n            Some(datetime)\n        }\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::GzHeader::operating_system":["/// Returns the `operating_system` field of this gzip stream's header.\n///\n/// There are predefined values for various operating systems.\n/// 255 means that the value is unknown.\npub fn operating_system(&self) -> u8{\n        self.operating_system\n    }","Real(LocalPath(\"src/gz/mod.rs\"))"],"gz::bufread::Buffer":["/// A small adapter which reads data originally from `buf` and then reads all\n/// further data from `reader`. This will also buffer all data read from\n/// `reader` into `buf` for reuse on a further call.\nstruct Buffer<'a, T: 'a> {\n    buf: &'a mut Vec<u8>,\n    buf_cur: usize,\n    buf_max: usize,\n    reader: &'a mut T,\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::Buffer::<'a, T>::new":["fn new(buf: &'a mut Vec<u8>, reader: &'a mut T) -> Buffer<'a, T>{\n        Buffer {\n            reader,\n            buf_cur: 0,\n            buf_max: buf.len(),\n            buf,\n        }\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder":["/// A gzip streaming decoder\n///\n/// This structure consumes a [`BufRead`] interface, reading compressed data\n/// from the underlying reader, and emitting uncompressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::GzEncoder;\n/// use flate2::bufread::GzDecoder;\n///\n/// # fn main() {\n/// #   let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// #   e.write_all(b\"Hello World\").unwrap();\n/// #   let bytes = e.finish().unwrap();\n/// #   println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Gz Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements BufRead\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut gz = GzDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    gz.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct GzDecoder<R> {\n    inner: GzState,\n    header: Option<GzHeader>,\n    reader: CrcReader<deflate::bufread::DeflateDecoder<R>>,\n    multi: bool,\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream.\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.reader.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.reader.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::header":["/// Returns the header associated with this stream, if it was valid\npub fn header(&self) -> Option<&GzHeader>{\n        self.header.as_ref()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.reader.into_inner().into_inner()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::multi":["fn multi(mut self, flag: bool) -> GzDecoder<R>{\n        self.multi = flag;\n        self\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzDecoder::<R>::new":["/// Creates a new decoder from the given reader, immediately parsing the\n/// gzip header.\npub fn new(mut r: R) -> GzDecoder<R>{\n        let mut buf = Vec::with_capacity(10); // minimum header length\n        let mut header = None;\n\n        let result = {\n            let mut reader = Buffer::new(&mut buf, &mut r);\n            read_gz_header(&mut reader)\n        };\n\n        let state = match result {\n            Ok(hdr) => {\n                header = Some(hdr);\n                GzState::Body\n            }\n            Err(ref err) if io::ErrorKind::WouldBlock == err.kind() => GzState::Header(buf),\n            Err(err) => GzState::Err(err),\n        };\n\n        GzDecoder {\n            inner: state,\n            reader: CrcReader::new(deflate::bufread::DeflateDecoder::new(r)),\n            multi: false,\n            header,\n        }\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder":["/// A gzip streaming encoder\n///\n/// This structure exposes a [`BufRead`] interface that will read uncompressed data\n/// from the underlying reader and expose the compressed version as a [`BufRead`]\n/// interface.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// use flate2::Compression;\n/// use flate2::bufread::GzEncoder;\n/// use std::fs::File;\n/// use std::io::BufReader;\n///\n/// // Opens sample file, compresses the contents and returns a Vector or error\n/// // File wrapped in a BufReader implements BufRead\n///\n/// fn open_hello_world() -> io::Result<Vec<u8>> {\n///     let f = File::open(\"examples/hello_world.txt\")?;\n///     let b = BufReader::new(f);\n///     let mut gz = GzEncoder::new(b, Compression::fast());\n///     let mut buffer = Vec::new();\n///     gz.read_to_end(&mut buffer)?;\n///     Ok(buffer)\n/// }\n/// ```\npub struct GzEncoder<R> {\n    inner: deflate::bufread::DeflateEncoder<CrcReader<R>>,\n    header: Vec<u8>,\n    pos: usize,\n    eof: bool,\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying reader.\n///\n/// Note that mutation of the reader may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder::<R>::into_inner":["/// Returns the underlying stream, consuming this encoder\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder::<R>::new":["/// Creates a new encoder which will use the given compression level.\n///\n/// The encoder is not configured specially for the emitted header. For\n/// header configuration, see the `GzBuilder` type.\n///\n/// The data read from the stream `r` will be compressed and available\n/// through the returned reader.\npub fn new(r: R, level: Compression) -> GzEncoder<R>{\n        GzBuilder::new().buf_read(r, level)\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzEncoder::<R>::read_footer":["fn read_footer(&mut self, into: &mut [u8]) -> io::Result<usize>{\n        if self.pos == 8 {\n            return Ok(0);\n        }\n        let crc = self.inner.get_ref().crc();\n        let ref arr = [\n            (crc.sum() >> 0) as u8,\n            (crc.sum() >> 8) as u8,\n            (crc.sum() >> 16) as u8,\n            (crc.sum() >> 24) as u8,\n            (crc.amount() >> 0) as u8,\n            (crc.amount() >> 8) as u8,\n            (crc.amount() >> 16) as u8,\n            (crc.amount() >> 24) as u8,\n        ];\n        Ok(copy(into, arr, &mut self.pos))\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::GzState":["enum GzState {\n    Header(Vec<u8>),\n    Body,\n    Finished(usize, [u8; 8]),\n    Err(io::Error),\n    End,\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder":["/// A gzip streaming decoder that decodes all members of a multistream\n///\n/// A gzip member consists of a header, compressed data and a trailer. The [gzip\n/// specification](https://tools.ietf.org/html/rfc1952), however, allows multiple\n/// gzip members to be joined in a single stream. `MultiGzDecoder` will\n/// decode all consecutive members while `GzDecoder` will only decompress\n/// the first gzip member. The multistream format is commonly used in\n/// bioinformatics, for example when using the BGZF compressed data.\n///\n/// This structure exposes a [`BufRead`] interface that will consume all gzip members\n/// from the underlying reader and emit uncompressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::GzEncoder;\n/// use flate2::bufread::MultiGzDecoder;\n///\n/// # fn main() {\n/// #   let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// #   e.write_all(b\"Hello World\").unwrap();\n/// #   let bytes = e.finish().unwrap();\n/// #   println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Gz Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements BufRead\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut gz = MultiGzDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    gz.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct MultiGzDecoder<R>(GzDecoder<R>);","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream.\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.0.get_mut()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.0.get_ref()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder::<R>::header":["/// Returns the current header associated with this stream, if it's valid\npub fn header(&self) -> Option<&GzHeader>{\n        self.0.header()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.0.into_inner()\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::MultiGzDecoder::<R>::new":["/// Creates a new decoder from the given reader, immediately parsing the\n/// (first) gzip header. If the gzip stream contains multiple members all will\n/// be decoded.\npub fn new(r: R) -> MultiGzDecoder<R>{\n        MultiGzDecoder(GzDecoder::new(r).multi(true))\n    }","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::bad_header":["fn bad_header() -> io::Error{\n    io::Error::new(io::ErrorKind::InvalidInput, \"invalid gzip header\")\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::copy":["fn copy(into: &mut [u8], from: &[u8], pos: &mut usize) -> usize{\n    let min = cmp::min(into.len(), from.len() - *pos);\n    for (slot, val) in into.iter_mut().zip(from[*pos..*pos + min].iter()) {\n        *slot = *val;\n    }\n    *pos += min;\n    return min;\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::corrupt":["pub(crate) fn corrupt() -> io::Error{\n    io::Error::new(\n        io::ErrorKind::InvalidInput,\n        \"corrupt gzip stream does not have a matching checksum\",\n    )\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::finish":["#[inline]\nfn finish(buf: &[u8; 8]) -> (u32, u32){\n    let crc = ((buf[0] as u32) << 0)\n        | ((buf[1] as u32) << 8)\n        | ((buf[2] as u32) << 16)\n        | ((buf[3] as u32) << 24);\n    let amt = ((buf[4] as u32) << 0)\n        | ((buf[5] as u32) << 8)\n        | ((buf[6] as u32) << 16)\n        | ((buf[7] as u32) << 24);\n    (crc, amt)\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::gz_encoder":["pub fn gz_encoder<R: BufRead>(header: Vec<u8>, r: R, lvl: Compression) -> GzEncoder<R>{\n    let crc = CrcReader::new(r);\n    GzEncoder {\n        inner: deflate::bufread::DeflateEncoder::new(crc, lvl),\n        header: header,\n        pos: 0,\n        eof: false,\n    }\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::read_gz_header":["pub(crate) fn read_gz_header<R: Read>(r: &mut R) -> io::Result<GzHeader>{\n    let mut crc_reader = CrcReader::new(r);\n    let mut header = [0; 10];\n    crc_reader.read_exact(&mut header)?;\n\n    let id1 = header[0];\n    let id2 = header[1];\n    if id1 != 0x1f || id2 != 0x8b {\n        return Err(bad_header());\n    }\n    let cm = header[2];\n    if cm != 8 {\n        return Err(bad_header());\n    }\n\n    let flg = header[3];\n    let mtime = ((header[4] as u32) << 0)\n        | ((header[5] as u32) << 8)\n        | ((header[6] as u32) << 16)\n        | ((header[7] as u32) << 24);\n    let _xfl = header[8];\n    let os = header[9];\n\n    let extra = if flg & FEXTRA != 0 {\n        let xlen = read_le_u16(&mut crc_reader)?;\n        let mut extra = vec![0; xlen as usize];\n        crc_reader.read_exact(&mut extra)?;\n        Some(extra)\n    } else {\n        None\n    };\n    let filename = if flg & FNAME != 0 {\n        // wow this is slow\n        let mut b = Vec::new();\n        for byte in crc_reader.by_ref().bytes() {\n            let byte = byte?;\n            if byte == 0 {\n                break;\n            }\n            b.push(byte);\n        }\n        Some(b)\n    } else {\n        None\n    };\n    let comment = if flg & FCOMMENT != 0 {\n        // wow this is slow\n        let mut b = Vec::new();\n        for byte in crc_reader.by_ref().bytes() {\n            let byte = byte?;\n            if byte == 0 {\n                break;\n            }\n            b.push(byte);\n        }\n        Some(b)\n    } else {\n        None\n    };\n\n    if flg & FHCRC != 0 {\n        let calced_crc = crc_reader.crc().sum() as u16;\n        let stored_crc = read_le_u16(&mut crc_reader)?;\n        if calced_crc != stored_crc {\n            return Err(corrupt());\n        }\n    }\n\n    Ok(GzHeader {\n        extra: extra,\n        filename: filename,\n        comment: comment,\n        operating_system: os,\n        mtime: mtime,\n    })\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::bufread::read_le_u16":["fn read_le_u16<R: Read>(r: &mut R) -> io::Result<u16>{\n    let mut b = [0; 2];\n    r.read_exact(&mut b)?;\n    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n}","Real(LocalPath(\"src/gz/bufread.rs\"))"],"gz::read::GzDecoder":["/// A gzip streaming decoder\n///\n/// This structure exposes a [`Read`] interface that will consume compressed\n/// data from the underlying reader and emit uncompressed data.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n///\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::GzEncoder;\n/// use flate2::read::GzDecoder;\n///\n/// # fn main() {\n/// #    let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Gz Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements Read\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut gz = GzDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    gz.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct GzDecoder<R> {\n    inner: bufread::GzDecoder<BufReader<R>>,\n}","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream.\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzDecoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzDecoder::<R>::header":["/// Returns the header associated with this stream, if it was valid.\npub fn header(&self) -> Option<&GzHeader>{\n        self.inner.header()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzDecoder::<R>::new":["/// Creates a new decoder from the given reader, immediately parsing the\n/// gzip header.\npub fn new(r: R) -> GzDecoder<R>{\n        GzDecoder {\n            inner: bufread::GzDecoder::new(BufReader::new(r)),\n        }\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzEncoder":["/// A gzip streaming encoder\n///\n/// This structure exposes a [`Read`] interface that will read uncompressed data\n/// from the underlying reader and expose the compressed version as a [`Read`]\n/// interface.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// use flate2::Compression;\n/// use flate2::read::GzEncoder;\n///\n/// // Return a vector containing the GZ compressed version of hello world\n///\n/// fn gzencode_hello_world() -> io::Result<Vec<u8>> {\n///     let mut ret_vec = [0;100];\n///     let bytestring = b\"hello world\";\n///     let mut gz = GzEncoder::new(&bytestring[..], Compression::fast());\n///     let count = gz.read(&mut ret_vec)?;\n///     Ok(ret_vec[0..count].to_vec())\n/// }\n/// ```\npub struct GzEncoder<R> {\n    inner: bufread::GzEncoder<BufReader<R>>,\n}","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying reader.\n///\n/// Note that mutation of the reader may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzEncoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzEncoder::<R>::into_inner":["/// Returns the underlying stream, consuming this encoder\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::GzEncoder::<R>::new":["/// Creates a new encoder which will use the given compression level.\n///\n/// The encoder is not configured specially for the emitted header. For\n/// header configuration, see the `GzBuilder` type.\n///\n/// The data read from the stream `r` will be compressed and available\n/// through the returned reader.\npub fn new(r: R, level: Compression) -> GzEncoder<R>{\n        GzBuilder::new().read(r, level)\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder":["/// A gzip streaming decoder that decodes all members of a multistream\n///\n/// A gzip member consists of a header, compressed data and a trailer. The [gzip\n/// specification](https://tools.ietf.org/html/rfc1952), however, allows multiple\n/// gzip members to be joined in a single stream.  `MultiGzDecoder` will\n/// decode all consecutive members while `GzDecoder` will only decompress the\n/// first gzip member. The multistream format is commonly used in bioinformatics,\n/// for example when using the BGZF compressed data.\n///\n/// This structure exposes a [`Read`] interface that will consume all gzip members\n/// from the underlying reader and emit uncompressed data.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::GzEncoder;\n/// use flate2::read::MultiGzDecoder;\n///\n/// # fn main() {\n/// #    let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Gz Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements Read\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut gz = MultiGzDecoder::new(&bytes[..]);\n///    let mut s = String::new();\n///    gz.read_to_string(&mut s)?;\n///    Ok(s)\n/// }\n/// ```\npub struct MultiGzDecoder<R> {\n    inner: bufread::MultiGzDecoder<BufReader<R>>,\n}","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream.\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder::<R>::get_ref":["/// Acquires a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder::<R>::header":["/// Returns the current header associated with this stream, if it's valid.\npub fn header(&self) -> Option<&GzHeader>{\n        self.inner.header()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::MultiGzDecoder::<R>::new":["/// Creates a new decoder from the given reader, immediately parsing the\n/// (first) gzip header. If the gzip stream contains multiple members all will\n/// be decoded.\npub fn new(r: R) -> MultiGzDecoder<R>{\n        MultiGzDecoder {\n            inner: bufread::MultiGzDecoder::new(BufReader::new(r)),\n        }\n    }","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::read::gz_encoder":["pub fn gz_encoder<R: Read>(inner: bufread::GzEncoder<BufReader<R>>) -> GzEncoder<R>{\n    GzEncoder { inner: inner }\n}","Real(LocalPath(\"src/gz/read.rs\"))"],"gz::write::Counter":["struct Counter<T: Read> {\n    inner: T,\n    pos: usize,\n}","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder":["/// A gzip streaming decoder\n///\n/// This structure exposes a [`Write`] interface that will emit compressed data\n/// to the underlying writer `W`.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// use flate2::Compression;\n/// use flate2::write::{GzEncoder, GzDecoder};\n///\n/// # fn main() {\n/// #    let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// #    e.write(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    assert_eq!(\"Hello World\", decode_writer(bytes).unwrap());\n/// # }\n/// // Uncompresses a gzip encoded vector of bytes and returns a string or error\n/// // Here Vec<u8> implements Write\n/// fn decode_writer(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut writer = Vec::new();\n///    let mut decoder = GzDecoder::new(writer);\n///    decoder.write_all(&bytes[..])?;\n///    writer = decoder.finish()?;\n///    let return_string = String::from_utf8(writer).expect(\"String parsing error\");\n///    Ok(return_string)\n/// }\n/// ```\npub struct GzDecoder<W: Write> {\n    inner: zio::Writer<CrcWriter<W>, Decompress>,\n    crc_bytes: Vec<u8>,\n    header: Option<GzHeader>,\n    header_buf: Vec<u8>,\n}","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::finish":["/// Consumes this decoder, flushing the output stream.\n///\n/// This will flush the underlying data stream and then return the contained\n/// writer if the flush succeeded.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.finish_and_check_crc()?;\n        Ok(self.inner.take_inner().into_inner())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::finish_and_check_crc":["fn finish_and_check_crc(&mut self) -> io::Result<()>{\n        self.inner.finish()?;\n\n        if self.crc_bytes.len() != 8 {\n            return Err(corrupt());\n        }\n\n        let crc = ((self.crc_bytes[0] as u32) << 0)\n            | ((self.crc_bytes[1] as u32) << 8)\n            | ((self.crc_bytes[2] as u32) << 16)\n            | ((self.crc_bytes[3] as u32) << 24);\n        let amt = ((self.crc_bytes[4] as u32) << 0)\n            | ((self.crc_bytes[5] as u32) << 8)\n            | ((self.crc_bytes[6] as u32) << 16)\n            | ((self.crc_bytes[7] as u32) << 24);\n        if crc != self.inner.get_ref().crc().sum() as u32 {\n            return Err(corrupt());\n        }\n        if amt != self.inner.get_ref().crc().amount() {\n            return Err(corrupt());\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutating the output/input state of the stream may corrupt this\n/// object, so care must be taken when using this method.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::header":["/// Returns the header associated with this stream.\npub fn header(&self) -> Option<&GzHeader>{\n        self.header.as_ref()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::new":["/// Creates a new decoder which will write uncompressed data to the stream.\n///\n/// When this encoder is dropped or unwrapped the final pieces of data will\n/// be flushed.\npub fn new(w: W) -> GzDecoder<W>{\n        GzDecoder {\n            inner: zio::Writer::new(CrcWriter::new(w), Decompress::new(false)),\n            crc_bytes: Vec::with_capacity(CRC_BYTES_LEN),\n            header: None,\n            header_buf: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzDecoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to finish the stream, returning any\n/// errors which happen.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.finish_and_check_crc()?;\n        Ok(())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder":["/// A gzip streaming encoder\n///\n/// This structure exposes a [`Write`] interface that will emit compressed data\n/// to the underlying writer `W`.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use flate2::Compression;\n/// use flate2::write::GzEncoder;\n///\n/// // Vec<u8> implements Write to print the compressed bytes of sample string\n/// # fn main() {\n///\n/// let mut e = GzEncoder::new(Vec::new(), Compression::default());\n/// e.write_all(b\"Hello World\").unwrap();\n/// println!(\"{:?}\", e.finish().unwrap());\n/// # }\n/// ```\npub struct GzEncoder<W: Write> {\n    inner: zio::Writer<W, Compress>,\n    crc: Crc,\n    crc_bytes_written: usize,\n    header: Vec<u8>,\n}","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::finish":["/// Finish encoding this stream, returning the underlying writer once the\n/// encoding is done.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.try_finish()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutation of the writer may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref()\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::new":["/// Creates a new encoder which will use the given compression level.\n///\n/// The encoder is not configured specially for the emitted header. For\n/// header configuration, see the `GzBuilder` type.\n///\n/// The data written to the returned encoder will be compressed and then\n/// written to the stream `w`.\npub fn new(w: W, level: Compression) -> GzEncoder<W>{\n        GzBuilder::new().write(w, level)\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.write_header()?;\n        self.inner.finish()?;\n\n        while self.crc_bytes_written < 8 {\n            let (sum, amt) = (self.crc.sum() as u32, self.crc.amount());\n            let buf = [\n                (sum >> 0) as u8,\n                (sum >> 8) as u8,\n                (sum >> 16) as u8,\n                (sum >> 24) as u8,\n                (amt >> 0) as u8,\n                (amt >> 8) as u8,\n                (amt >> 16) as u8,\n                (amt >> 24) as u8,\n            ];\n            let inner = self.inner.get_mut();\n            let n = inner.write(&buf[self.crc_bytes_written..])?;\n            self.crc_bytes_written += n;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::GzEncoder::<W>::write_header":["fn write_header(&mut self) -> io::Result<()>{\n        while self.header.len() > 0 {\n            let n = self.inner.get_mut().write(&self.header)?;\n            self.header.drain(..n);\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/gz/write.rs\"))"],"gz::write::gz_encoder":["pub fn gz_encoder<W: Write>(header: Vec<u8>, w: W, lvl: Compression) -> GzEncoder<W>{\n    GzEncoder {\n        inner: zio::Writer::new(w, Compress::new(lvl, false)),\n        crc: Crc::new(),\n        header: header,\n        crc_bytes_written: 0,\n    }\n}","Real(LocalPath(\"src/gz/write.rs\"))"],"mem::<impl std::convert::From<mem::CompressError> for std::io::Error>::from":["fn from(data: CompressError) -> io::Error{\n        io::Error::new(io::ErrorKind::Other, data)\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::<impl std::convert::From<mem::DecompressError> for std::io::Error>::from":["fn from(data: DecompressError) -> io::Error{\n        io::Error::new(io::ErrorKind::Other, data)\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress":["/// Raw in-memory compression stream for blocks of data.\n///\n/// This type is the building block for the I/O streams in the rest of this\n/// crate. It requires more management than the [`Read`]/[`Write`] API but is\n/// maximally flexible in terms of accepting input from any source and being\n/// able to produce output to any memory location.\n///\n/// It is recommended to use the I/O stream adaptors over this type as they're\n/// easier to use.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\npub struct Compress {\n    inner: Deflate,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::compress":["/// Compresses the input data into the output, consuming only as much\n/// input as needed and writing as much output as possible.\n///\n/// The flush option can be any of the available `FlushCompress` parameters.\n///\n/// To learn how much data was consumed or how much output was produced, use\n/// the `total_in` and `total_out` functions before/after this is called.\npub fn compress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError>{\n        self.inner.compress(input, output, flush)\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::compress_vec":["/// Compresses the input data into the extra space of the output, consuming\n/// only as much input as needed and writing as much output as possible.\n///\n/// This function has the same semantics as `compress`, except that the\n/// length of `vec` is managed by this function. This will not reallocate\n/// the vector provided or attempt to grow it, so space for the output must\n/// be reserved in the output vector by the caller before calling this\n/// function.\npub fn compress_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushCompress,\n    ) -> Result<Status, CompressError>{\n        let cap = output.capacity();\n        let len = output.len();\n\n        unsafe {\n            let before = self.total_out();\n            let ret = {\n                let ptr = output.as_mut_ptr().offset(len as isize);\n                let out = slice::from_raw_parts_mut(ptr, cap - len);\n                self.compress(input, out, flush)\n            };\n            output.set_len((self.total_out() - before) as usize + len);\n            return ret;\n        }\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::new":["/// Creates a new object ready for compressing data that it's given.\n///\n/// The `level` argument here indicates what level of compression is going\n/// to be performed, and the `zlib_header` argument indicates whether the\n/// output data should have a zlib header or not.\npub fn new(level: Compression, zlib_header: bool) -> Compress{\n        Compress {\n            inner: Deflate::make(level, zlib_header, ffi::MZ_DEFAULT_WINDOW_BITS as u8),\n        }\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::reset":["/// Quickly resets this compressor without having to reallocate anything.\n///\n/// This is equivalent to dropping this object and then creating a new one.\npub fn reset(&mut self){\n        self.inner.reset();\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::total_in":["/// Returns the total number of input bytes which have been processed by\n/// this compression object.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Compress::total_out":["/// Returns the total number of output bytes which have been produced by\n/// this compression object.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::CompressError":["/// Error returned when a compression object is used incorrectly or otherwise\n/// generates an error.\npub struct CompressError(pub(crate) ());","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress":["/// Raw in-memory decompression stream for blocks of data.\n///\n/// This type is the building block for the I/O streams in the rest of this\n/// crate. It requires more management than the [`Read`]/[`Write`] API but is\n/// maximally flexible in terms of accepting input from any source and being\n/// able to produce output to any memory location.\n///\n/// It is recommended to use the I/O stream adaptors over this type as they're\n/// easier to use.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\npub struct Decompress {\n    inner: Inflate,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::decompress":["/// Decompresses the input data into the output, consuming only as much\n/// input as needed and writing as much output as possible.\n///\n/// The flush option can be any of the available `FlushDecompress` parameters.\n///\n/// If the first call passes `FlushDecompress::Finish` it is assumed that\n/// the input and output buffers are both sized large enough to decompress\n/// the entire stream in a single call.\n///\n/// A flush value of `FlushDecompress::Finish` indicates that there are no\n/// more source bytes available beside what's already in the input buffer,\n/// and the output buffer is large enough to hold the rest of the\n/// decompressed data.\n///\n/// To learn how much data was consumed or how much output was produced, use\n/// the `total_in` and `total_out` functions before/after this is called.\n///\n/// # Errors\n///\n/// If the input data to this instance of `Decompress` is not a valid\n/// zlib/deflate stream then this function may return an instance of\n/// `DecompressError` to indicate that the stream of input bytes is corrupted.\npub fn decompress(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>{\n        self.inner.decompress(input, output, flush)\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::decompress_vec":["/// Decompresses the input data into the extra space in the output vector\n/// specified by `output`.\n///\n/// This function has the same semantics as `decompress`, except that the\n/// length of `vec` is managed by this function. This will not reallocate\n/// the vector provided or attempt to grow it, so space for the output must\n/// be reserved in the output vector by the caller before calling this\n/// function.\n///\n/// # Errors\n///\n/// If the input data to this instance of `Decompress` is not a valid\n/// zlib/deflate stream then this function may return an instance of\n/// `DecompressError` to indicate that the stream of input bytes is corrupted.\npub fn decompress_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: FlushDecompress,\n    ) -> Result<Status, DecompressError>{\n        let cap = output.capacity();\n        let len = output.len();\n\n        unsafe {\n            let before = self.total_out();\n            let ret = {\n                let ptr = output.as_mut_ptr().offset(len as isize);\n                let out = slice::from_raw_parts_mut(ptr, cap - len);\n                self.decompress(input, out, flush)\n            };\n            output.set_len((self.total_out() - before) as usize + len);\n            return ret;\n        }\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::new":["/// Creates a new object ready for decompressing data that it's given.\n///\n/// The `zlib_header` argument indicates whether the input data is expected\n/// to have a zlib header or not.\npub fn new(zlib_header: bool) -> Decompress{\n        Decompress {\n            inner: Inflate::make(zlib_header, ffi::MZ_DEFAULT_WINDOW_BITS as u8),\n        }\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::reset":["/// Performs the equivalent of replacing this decompression state with a\n/// freshly allocated copy.\n///\n/// This function may not allocate memory, though, and attempts to reuse any\n/// previously existing resources.\n///\n/// The argument provided here indicates whether the reset state will\n/// attempt to decode a zlib header first or not.\npub fn reset(&mut self, zlib_header: bool){\n        self.inner.reset(zlib_header);\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::total_in":["/// Returns the total number of input bytes which have been processed by\n/// this decompression object.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::Decompress::total_out":["/// Returns the total number of output bytes which have been produced by\n/// this decompression object.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::DecompressError":["/// Error returned when a decompression object finds that the input stream of\n/// bytes was not a valid input stream of bytes.\npub struct DecompressError(pub(crate) DecompressErrorInner);","Real(LocalPath(\"src/mem.rs\"))"],"mem::DecompressError::needs_dictionary":["/// Indicates whether decompression failed due to requiring a dictionary.\n///\n/// The resulting integer is the Adler-32 checksum of the dictionary\n/// required.\npub fn needs_dictionary(&self) -> Option<u32>{\n        self.0.needs_dictionary\n    }","Real(LocalPath(\"src/mem.rs\"))"],"mem::DecompressErrorInner":["/// The inner state for an error when decompressing\npub(crate) struct DecompressErrorInner {\n    pub(crate) needs_dictionary: Option<u32>,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::FlushCompress":["/// Values which indicate the form of flushing to be used when compressing\n/// in-memory data.\npub enum FlushCompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer, but the output is\n    /// not aligned to a byte boundary.\n    ///\n    /// All of the input data so far will be available to the decompressor (as\n    /// with `Flush::Sync`. This completes the current deflate block and follows\n    /// it with an empty fixed codes block that is 10 bites long, and it assures\n    /// that enough bytes are output in order for the decompessor to finish the\n    /// block before the empty fixed code block.\n    Partial = ffi::MZ_PARTIAL_FLUSH as isize,\n\n    /// All output is flushed as with `Flush::Sync` and the compression state is\n    /// reset so decompression can restart from this point if previous\n    /// compressed data has been damaged or if random access is desired.\n    ///\n    /// Using this option too often can seriously degrade compression.\n    Full = ffi::MZ_FULL_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n\n    #[doc(hidden)]\n    _Nonexhaustive,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::FlushDecompress":["/// Values which indicate the form of flushing to be used when\n/// decompressing in-memory data.\npub enum FlushDecompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n\n    #[doc(hidden)]\n    _Nonexhaustive,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::Status":["/// Possible status results of compressing some data or successfully\n/// decompressing a block of data.\npub enum Status {\n    /// Indicates success.\n    ///\n    /// Means that more input may be needed but isn't available\n    /// and/or there's more output to be written but the output buffer is full.\n    Ok,\n\n    /// Indicates that forward progress is not possible due to input or output\n    /// buffers being empty.\n    ///\n    /// For compression it means the input buffer needs some more data or the\n    /// output buffer needs to be freed up before trying again.\n    ///\n    /// For decompression this means that more input is needed to continue or\n    /// the output buffer isn't large enough to contain the result. The function\n    /// can be called again after fixing both.\n    BufError,\n\n    /// Indicates that all input has been consumed and all output bytes have\n    /// been written. Decompression/compression should not be called again.\n    ///\n    /// For decompression with zlib streams the adler-32 of the decompressed\n    /// data has also been verified.\n    StreamEnd,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::decompress_failed":["#[inline]\npub(crate) fn decompress_failed() -> Result<Status, DecompressError>{\n    Err(DecompressError(Default::default()))\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::decompress_need_dict":["#[inline]\npub(crate) fn decompress_need_dict(adler: u32) -> Result<Status, DecompressError>{\n    Err(DecompressError(DecompressErrorInner {\n        needs_dictionary: Some(adler),\n    }))\n}","Real(LocalPath(\"src/mem.rs\"))"],"zio::Flush":["pub trait Flush {\n    fn none() -> Self;\n    fn sync() -> Self;\n    fn finish() -> Self;\n}","Real(LocalPath(\"src/zio.rs\"))"],"zio::Ops":["pub trait Ops {\n    type Flush: Flush;\n    fn total_in(&self) -> u64;\n    fn total_out(&self) -> u64;\n    fn run(\n        &mut self,\n        input: &[u8],\n        output: &mut [u8],\n        flush: Self::Flush,\n    ) -> Result<Status, DecompressError>;\n    fn run_vec(\n        &mut self,\n        input: &[u8],\n        output: &mut Vec<u8>,\n        flush: Self::Flush,\n    ) -> Result<Status, DecompressError>;\n}","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer":["pub struct Writer<W: Write, D: Ops> {\n    obj: Option<W>,\n    pub data: D,\n    buf: Vec<u8>,\n}","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::dump":["fn dump(&mut self) -> io::Result<()>{\n        // TODO: should manage this buffer not with `drain` but probably more of\n        // a deque-like strategy.\n        while self.buf.len() > 0 {\n            let n = self.obj.as_mut().unwrap().write(&self.buf)?;\n            if n == 0 {\n                return Err(io::ErrorKind::WriteZero.into());\n            }\n            self.buf.drain(..n);\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::finish":["pub fn finish(&mut self) -> io::Result<()>{\n        loop {\n            self.dump()?;\n\n            let before = self.data.total_out();\n            self.data.run_vec(&[], &mut self.buf, D::Flush::finish())?;\n            if before == self.data.total_out() {\n                return Ok(());\n            }\n        }\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::get_mut":["pub fn get_mut(&mut self) -> &mut W{\n        self.obj.as_mut().unwrap()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::get_ref":["pub fn get_ref(&self) -> &W{\n        self.obj.as_ref().unwrap()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::is_present":["pub fn is_present(&self) -> bool{\n        self.obj.is_some()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::new":["pub fn new(w: W, d: D) -> Writer<W, D>{\n        Writer {\n            obj: Some(w),\n            data: d,\n            buf: Vec::with_capacity(32 * 1024),\n        }\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::replace":["pub fn replace(&mut self, w: W) -> W{\n        self.buf.truncate(0);\n        mem::replace(self.get_mut(), w)\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::take_inner":["pub fn take_inner(&mut self) -> W{\n        self.obj.take().unwrap()\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::Writer::<W, D>::write_with_status":["pub(crate) fn write_with_status(&mut self, buf: &[u8]) -> io::Result<(usize, Status)>{\n        // miniz isn't guaranteed to actually write any of the buffer provided,\n        // it may be in a flushing mode where it's just giving us data before\n        // we're actually giving it any data. We don't want to spuriously return\n        // `Ok(0)` when possible as it will cause calls to write_all() to fail.\n        // As a result we execute this in a loop to ensure that we try our\n        // darndest to write the data.\n        loop {\n            self.dump()?;\n\n            let before_in = self.data.total_in();\n            let ret = self.data.run_vec(buf, &mut self.buf, D::Flush::none());\n            let written = (self.data.total_in() - before_in) as usize;\n\n            let is_stream_end = match ret {\n                Ok(Status::StreamEnd) => true,\n                _ => false,\n            };\n\n            if buf.len() > 0 && written == 0 && ret.is_ok() && !is_stream_end {\n                continue;\n            }\n            return match ret {\n                Ok(st) => match st {\n                    Status::Ok | Status::BufError | Status::StreamEnd => Ok((written, st)),\n                },\n                Err(..) => Err(io::Error::new(\n                    io::ErrorKind::InvalidInput,\n                    \"corrupt deflate stream\",\n                )),\n            };\n        }\n    }","Real(LocalPath(\"src/zio.rs\"))"],"zio::read":["pub fn read<R, D>(obj: &mut R, data: &mut D, dst: &mut [u8]) -> io::Result<usize>\nwhere\n    R: BufRead,\n    D: Ops,{\n    loop {\n        let (read, consumed, ret, eof);\n        {\n            let input = obj.fill_buf()?;\n            eof = input.is_empty();\n            let before_out = data.total_out();\n            let before_in = data.total_in();\n            let flush = if eof {\n                D::Flush::finish()\n            } else {\n                D::Flush::none()\n            };\n            ret = data.run(input, dst, flush);\n            read = (data.total_out() - before_out) as usize;\n            consumed = (data.total_in() - before_in) as usize;\n        }\n        obj.consume(consumed);\n\n        match ret {\n            // If we haven't ready any data and we haven't hit EOF yet,\n            // then we need to keep asking for more data because if we\n            // return that 0 bytes of data have been read then it will\n            // be interpreted as EOF.\n            Ok(Status::Ok) | Ok(Status::BufError) if read == 0 && !eof && dst.len() > 0 => continue,\n            Ok(Status::Ok) | Ok(Status::BufError) | Ok(Status::StreamEnd) => return Ok(read),\n\n            Err(..) => {\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidInput,\n                    \"corrupt deflate stream\",\n                ))\n            }\n        }\n    }\n}","Real(LocalPath(\"src/zio.rs\"))"],"zlib::bufread::ZlibDecoder":["/// A ZLIB decoder, or decompressor.\n///\n/// This structure consumes a [`BufRead`] interface, reading compressed data\n/// from the underlying reader, and emitting uncompressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::ZlibEncoder;\n/// use flate2::bufread::ZlibDecoder;\n///\n/// # fn main() {\n/// # let mut e = ZlibEncoder::new(Vec::new(), Compression::default());\n/// # e.write_all(b\"Hello World\").unwrap();\n/// # let bytes = e.finish().unwrap();\n/// # println!(\"{}\", decode_bufreader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Zlib Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements BufRead\n///\n/// fn decode_bufreader(bytes: Vec<u8>) -> io::Result<String> {\n///     let mut z = ZlibDecoder::new(&bytes[..]);\n///     let mut s = String::new();\n///     z.read_to_string(&mut s)?;\n///     Ok(s)\n/// }\n/// ```\npub struct ZlibDecoder<R> {\n    obj: R,\n    data: Decompress,\n}","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::get_ref":["/// Acquires a reference to the underlying stream\npub fn get_ref(&self) -> &R{\n        &self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::new":["/// Creates a new decoder which will decompress data read from the given\n/// stream.\npub fn new(r: R) -> ZlibDecoder<R>{\n        ZlibDecoder {\n            obj: r,\n            data: Decompress::new(true),\n        }\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::reset":["/// Resets the state of this decoder entirely, swapping out the input\n/// stream for another.\n///\n/// This will reset the internal state of this decoder and replace the\n/// input stream with the one provided, returning the previous input\n/// stream. Future data read from this decoder will be the decompressed\n/// version of `r`'s data.\npub fn reset(&mut self, r: R) -> R{\n        reset_decoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::total_in":["/// Returns the number of bytes that the decompressor has consumed.\n///\n/// Note that this will likely be smaller than what the decompressor\n/// actually read from the underlying stream due to buffering.\npub fn total_in(&self) -> u64{\n        self.data.total_in()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibDecoder::<R>::total_out":["/// Returns the number of bytes that the decompressor has produced.\npub fn total_out(&self) -> u64{\n        self.data.total_out()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder":["/// A ZLIB encoder, or compressor.\n///\n/// This structure consumes a [`BufRead`] interface, reading uncompressed data\n/// from the underlying reader, and emitting compressed data.\n///\n/// [`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use flate2::Compression;\n/// use flate2::bufread::ZlibEncoder;\n/// use std::fs::File;\n/// use std::io::BufReader;\n///\n/// // Use a buffered file to compress contents into a Vec<u8>\n///\n/// # fn open_hello_world() -> std::io::Result<Vec<u8>> {\n/// let f = File::open(\"examples/hello_world.txt\")?;\n/// let b = BufReader::new(f);\n/// let mut z = ZlibEncoder::new(b, Compression::fast());\n/// let mut buffer = Vec::new();\n/// z.read_to_end(&mut buffer)?;\n/// # Ok(buffer)\n/// # }\n/// ```\npub struct ZlibEncoder<R> {\n    obj: R,\n    data: Compress,\n}","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::get_ref":["/// Acquires a reference to the underlying reader\npub fn get_ref(&self) -> &R{\n        &self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::into_inner":["/// Consumes this encoder, returning the underlying reader.\npub fn into_inner(self) -> R{\n        self.obj\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::new":["/// Creates a new encoder which will read uncompressed data from the given\n/// stream and emit the compressed stream.\npub fn new(r: R, level: crate::Compression) -> ZlibEncoder<R>{\n        ZlibEncoder {\n            obj: r,\n            data: Compress::new(level, true),\n        }\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::reset":["/// Resets the state of this encoder entirely, swapping out the input\n/// stream for another.\n///\n/// This function will reset the internal state of this encoder and replace\n/// the input stream with the one provided, returning the previous input\n/// stream. Future data read from this encoder will be the compressed\n/// version of `r`'s data.\npub fn reset(&mut self, r: R) -> R{\n        reset_encoder_data(self);\n        mem::replace(&mut self.obj, r)\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::total_in":["/// Returns the number of bytes that have been read into this compressor.\n///\n/// Note that not all bytes read from the underlying object may be accounted\n/// for, there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.data.total_in()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::ZlibEncoder::<R>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been read yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.data.total_out()\n    }","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::reset_decoder_data":["pub fn reset_decoder_data<R>(zlib: &mut ZlibDecoder<R>){\n    zlib.data = Decompress::new(true);\n}","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::bufread::reset_encoder_data":["pub fn reset_encoder_data<R>(zlib: &mut ZlibEncoder<R>){\n    zlib.data.reset()\n}","Real(LocalPath(\"src/zlib/bufread.rs\"))"],"zlib::read::ZlibDecoder":["/// A ZLIB decoder, or decompressor.\n///\n/// This structure implements a [`Read`] interface and takes a stream of\n/// compressed data as input, providing the decompressed data when read from.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::ZlibEncoder;\n/// use flate2::read::ZlibDecoder;\n///\n/// # fn main() {\n/// # let mut e = ZlibEncoder::new(Vec::new(), Compression::default());\n/// # e.write_all(b\"Hello World\").unwrap();\n/// # let bytes = e.finish().unwrap();\n/// # println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Zlib Encoded vector of bytes and returns a string or error\n/// // Here &[u8] implements Read\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///     let mut z = ZlibDecoder::new(&bytes[..]);\n///     let mut s = String::new();\n///     z.read_to_string(&mut s)?;\n///     Ok(s)\n/// }\n/// ```\npub struct ZlibDecoder<R> {\n    inner: bufread::ZlibDecoder<BufReader<R>>,\n}","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::get_ref":["/// Acquires a reference to the underlying stream\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::into_inner":["/// Consumes this decoder, returning the underlying reader.\n///\n/// Note that there may be buffered bytes which are not re-acquired as part\n/// of this transition. It's recommended to only call this function after\n/// EOF has been reached.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::new":["/// Creates a new decoder which will decompress data read from the given\n/// stream.\npub fn new(r: R) -> ZlibDecoder<R>{\n        ZlibDecoder::new_with_buf(r, vec![0; 32 * 1024])\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::new_with_buf":["/// Same as `new`, but the intermediate buffer for data is specified.\n///\n/// Note that the specified buffer will only be used up to its current\n/// length. The buffer's capacity will also not grow over time.\npub fn new_with_buf(r: R, buf: Vec<u8>) -> ZlibDecoder<R>{\n        ZlibDecoder {\n            inner: bufread::ZlibDecoder::new(BufReader::with_buf(buf, r)),\n        }\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::reset":["/// Resets the state of this decoder entirely, swapping out the input\n/// stream for another.\n///\n/// This will reset the internal state of this decoder and replace the\n/// input stream with the one provided, returning the previous input\n/// stream. Future data read from this decoder will be the decompressed\n/// version of `r`'s data.\n///\n/// Note that there may be currently buffered data when this function is\n/// called, and in that case the buffered data is discarded.\npub fn reset(&mut self, r: R) -> R{\n        super::bufread::reset_decoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::total_in":["/// Returns the number of bytes that the decompressor has consumed.\n///\n/// Note that this will likely be smaller than what the decompressor\n/// actually read from the underlying stream due to buffering.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibDecoder::<R>::total_out":["/// Returns the number of bytes that the decompressor has produced.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder":["/// A ZLIB encoder, or compressor.\n///\n/// This structure implements a [`Read`] interface and will read uncompressed\n/// data from an underlying stream and emit a stream of compressed data.\n///\n/// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use flate2::Compression;\n/// use flate2::read::ZlibEncoder;\n/// use std::fs::File;\n///\n/// // Open example file and compress the contents using Read interface\n///\n/// # fn open_hello_world() -> std::io::Result<Vec<u8>> {\n/// let f = File::open(\"examples/hello_world.txt\")?;\n/// let mut z = ZlibEncoder::new(f, Compression::fast());\n/// let mut buffer = [0;50];\n/// let byte_count = z.read(&mut buffer)?;\n/// # Ok(buffer[0..byte_count].to_vec())\n/// # }\n/// ```\npub struct ZlibEncoder<R> {\n    inner: bufread::ZlibEncoder<BufReader<R>>,\n}","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::get_mut":["/// Acquires a mutable reference to the underlying stream\n///\n/// Note that mutation of the stream may result in surprising results if\n/// this encoder is continued to be used.\npub fn get_mut(&mut self) -> &mut R{\n        self.inner.get_mut().get_mut()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::get_ref":["/// Acquires a reference to the underlying stream\npub fn get_ref(&self) -> &R{\n        self.inner.get_ref().get_ref()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::into_inner":["/// Consumes this encoder, returning the underlying reader.\n///\n/// Note that there may be buffered bytes which are not re-acquired as part\n/// of this transition. It's recommended to only call this function after\n/// EOF has been reached.\npub fn into_inner(self) -> R{\n        self.inner.into_inner().into_inner()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::new":["/// Creates a new encoder which will read uncompressed data from the given\n/// stream and emit the compressed stream.\npub fn new(r: R, level: crate::Compression) -> ZlibEncoder<R>{\n        ZlibEncoder {\n            inner: bufread::ZlibEncoder::new(BufReader::new(r), level),\n        }\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::reset":["/// Resets the state of this encoder entirely, swapping out the input\n/// stream for another.\n///\n/// This function will reset the internal state of this encoder and replace\n/// the input stream with the one provided, returning the previous input\n/// stream. Future data read from this encoder will be the compressed\n/// version of `r`'s data.\n///\n/// Note that there may be currently buffered data when this function is\n/// called, and in that case the buffered data is discarded.\npub fn reset(&mut self, r: R) -> R{\n        super::bufread::reset_encoder_data(&mut self.inner);\n        self.inner.get_mut().reset(r)\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::total_in":["/// Returns the number of bytes that have been read into this compressor.\n///\n/// Note that not all bytes read from the underlying object may be accounted\n/// for, there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.inner.total_in()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::read::ZlibEncoder::<R>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been read yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.inner.total_out()\n    }","Real(LocalPath(\"src/zlib/read.rs\"))"],"zlib::write::ZlibDecoder":["/// A ZLIB decoder, or decompressor.\n///\n/// This structure implements a [`Write`] and will emit a stream of decompressed\n/// data when fed a stream of compressed data.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io;\n/// # use flate2::Compression;\n/// # use flate2::write::ZlibEncoder;\n/// use flate2::write::ZlibDecoder;\n///\n/// # fn main() {\n/// #    let mut e = ZlibEncoder::new(Vec::new(), Compression::default());\n/// #    e.write_all(b\"Hello World\").unwrap();\n/// #    let bytes = e.finish().unwrap();\n/// #    println!(\"{}\", decode_reader(bytes).unwrap());\n/// # }\n/// #\n/// // Uncompresses a Zlib Encoded vector of bytes and returns a string or error\n/// // Here Vec<u8> implements Write\n///\n/// fn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n///    let mut writer = Vec::new();\n///    let mut z = ZlibDecoder::new(writer);\n///    z.write_all(&bytes[..])?;\n///    writer = z.finish()?;\n///    let return_string = String::from_utf8(writer).expect(\"String parsing error\");\n///    Ok(return_string)\n/// }\n/// ```\npub struct ZlibDecoder<W: Write> {\n    inner: zio::Writer<W, Decompress>,\n}","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream and then return the contained\n/// writer if the flush succeeded.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutating the output/input state of the stream may corrupt this\n/// object, so care must be taken when using this method.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::new":["/// Creates a new decoder which will write uncompressed data to the stream.\n///\n/// When this decoder is dropped or unwrapped the final pieces of data will\n/// be flushed.\npub fn new(w: W) -> ZlibDecoder<W>{\n        ZlibDecoder {\n            inner: zio::Writer::new(w, Decompress::new(true)),\n        }\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::reset":["/// Resets the state of this decoder entirely, swapping out the output\n/// stream for another.\n///\n/// This will reset the internal state of this decoder and replace the\n/// output stream with the one provided, returning the previous output\n/// stream. Future data written to this decoder will be decompressed into\n/// the output stream `w`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn reset(&mut self, w: W) -> io::Result<W>{\n        self.inner.finish()?;\n        self.inner.data = Decompress::new(true);\n        Ok(self.inner.replace(w))\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::total_in":["/// Returns the number of bytes that the decompressor has consumed for\n/// decompression.\n///\n/// Note that this will likely be smaller than the number of bytes\n/// successfully written to this stream due to internal buffering.\npub fn total_in(&self) -> u64{\n        self.inner.data.total_in()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::total_out":["/// Returns the number of bytes that the decompressor has written to its\n/// output stream.\npub fn total_out(&self) -> u64{\n        self.inner.data.total_out()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibDecoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.inner.finish()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder":["/// A ZLIB encoder, or compressor.\n///\n/// This structure implements a [`Write`] interface and takes a stream of\n/// uncompressed data, writing the compressed data to the wrapped writer.\n///\n/// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use flate2::Compression;\n/// use flate2::write::ZlibEncoder;\n///\n/// // Vec<u8> implements Write, assigning the compressed bytes of sample string\n///\n/// # fn zlib_encoding() -> std::io::Result<()> {\n/// let mut e = ZlibEncoder::new(Vec::new(), Compression::default());\n/// e.write_all(b\"Hello World\")?;\n/// let compressed = e.finish()?;\n/// # Ok(())\n/// # }\n/// ```\npub struct ZlibEncoder<W: Write> {\n    inner: zio::Writer<W, Compress>,\n}","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream, close off the compressed\n/// stream and, if successful, return the contained writer.\n///\n/// Note that this function may not be suitable to call in a situation where\n/// the underlying stream is an asynchronous I/O stream. To finish a stream\n/// the `try_finish` (or `shutdown`) method should be used instead. To\n/// re-acquire ownership of a stream it is safe to call this method after\n/// `try_finish` or `shutdown` has returned `Ok`.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn finish(mut self) -> io::Result<W>{\n        self.inner.finish()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::flush_finish":["/// Consumes this encoder, flushing the output stream.\n///\n/// This will flush the underlying data stream and then return the contained\n/// writer if the flush succeeded.\n/// The compressed stream will not closed but only flushed. This\n/// means that obtained byte array can by extended by another deflated\n/// stream. To close the stream add the two bytes 0x3 and 0x0.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn flush_finish(mut self) -> io::Result<W>{\n        self.inner.flush()?;\n        Ok(self.inner.take_inner())\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::get_mut":["/// Acquires a mutable reference to the underlying writer.\n///\n/// Note that mutating the output/input state of the stream may corrupt this\n/// object, so care must be taken when using this method.\npub fn get_mut(&mut self) -> &mut W{\n        self.inner.get_mut()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::get_ref":["/// Acquires a reference to the underlying writer.\npub fn get_ref(&self) -> &W{\n        self.inner.get_ref()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::new":["/// Creates a new encoder which will write compressed data to the stream\n/// given at the given compression level.\n///\n/// When this encoder is dropped or unwrapped the final pieces of data will\n/// be flushed.\npub fn new(w: W, level: crate::Compression) -> ZlibEncoder<W>{\n        ZlibEncoder {\n            inner: zio::Writer::new(w, Compress::new(level, true)),\n        }\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::reset":["/// Resets the state of this encoder entirely, swapping out the output\n/// stream for another.\n///\n/// This function will finish encoding the current stream into the current\n/// output stream before swapping out the two output streams.\n///\n/// After the current stream has been finished, this will reset the internal\n/// state of this encoder and replace the output stream with the one\n/// provided, returning the previous output stream. Future data written to\n/// this encoder will be the compressed into the stream `w` provided.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn reset(&mut self, w: W) -> io::Result<W>{\n        self.inner.finish()?;\n        self.inner.data.reset();\n        Ok(self.inner.replace(w))\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::total_in":["/// Returns the number of bytes that have been written to this compresor.\n///\n/// Note that not all bytes written to this object may be accounted for,\n/// there may still be some active buffering.\npub fn total_in(&self) -> u64{\n        self.inner.data.total_in()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::total_out":["/// Returns the number of bytes that the compressor has produced.\n///\n/// Note that not all bytes may have been written yet, some may still be\n/// buffered.\npub fn total_out(&self) -> u64{\n        self.inner.data.total_out()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"],"zlib::write::ZlibEncoder::<W>::try_finish":["/// Attempt to finish this output stream, writing out final chunks of data.\n///\n/// Note that this function can only be used once data has finished being\n/// written to the output stream. After this function is called then further\n/// calls to `write` may result in a panic.\n///\n/// # Panics\n///\n/// Attempts to write data to this stream may result in a panic after this\n/// function is called.\n///\n/// # Errors\n///\n/// This function will perform I/O to complete this stream, and any I/O\n/// errors which occur will be returned from this function.\npub fn try_finish(&mut self) -> io::Result<()>{\n        self.inner.finish()\n    }","Real(LocalPath(\"src/zlib/write.rs\"))"]},"struct_constructor":{"&[u8]":["comment","extra","filename","fill_buf"],"&crc::Crc":["crc"],"&gz::GzHeader":["header"],"(u32, u32)":["finish"],"(usize, mem::Status)":["write_with_status"],"Compression":["best","clone","default","fast","new","none"],"bool":["eq","is_present"],"bufreader::BufReader":["new","with_buf"],"crc::Crc":["new"],"crc::CrcReader":["new"],"crc::CrcWriter":["new"],"deflate::bufread::DeflateDecoder":["new"],"deflate::bufread::DeflateEncoder":["new"],"deflate::read::DeflateDecoder":["new","new_with_buf"],"deflate::read::DeflateEncoder":["new"],"deflate::write::DeflateDecoder":["new"],"deflate::write::DeflateEncoder":["new"],"ffi::rust::Deflate":["make"],"ffi::rust::Inflate":["make"],"gz::GzBuilder":["new"],"gz::GzHeader":["clone","default","read_gz_header"],"gz::bufread::Buffer":["new"],"gz::bufread::GzDecoder":["new"],"gz::bufread::GzEncoder":["buf_read","gz_encoder","new"],"gz::bufread::MultiGzDecoder":["new"],"gz::read::GzDecoder":["new"],"gz::read::GzEncoder":["gz_encoder","new","read"],"gz::read::MultiGzDecoder":["new"],"gz::write::GzDecoder":["new"],"gz::write::GzEncoder":["gz_encoder","new","write"],"mem::Compress":["new"],"mem::Decompress":["new"],"mem::DecompressErrorInner":["default"],"mem::FlushCompress":["clone","finish","none","sync"],"mem::FlushDecompress":["clone","finish","none","sync"],"mem::Status":["clone","compress","compress_vec","decompress","decompress_failed","decompress_need_dict","decompress_vec","run","run_vec"],"miniz_oxide::DataFormat":["format_from_bool"],"std::io::Error":["bad_header","corrupt","from"],"std::time::SystemTime":["mtime_as_datetime"],"std::vec::Vec":["into_header"],"u16":["read_le_u16"],"u32":["amount","level","mtime","needs_dictionary","sum"],"u64":["total_in","total_out"],"u8":["operating_system"],"usize":["copy","read","read_footer","write"],"zio::Writer":["new"],"zlib::bufread::ZlibDecoder":["new"],"zlib::bufread::ZlibEncoder":["new"],"zlib::read::ZlibDecoder":["new","new_with_buf"],"zlib::read::ZlibEncoder":["new"],"zlib::write::ZlibDecoder":["new"],"zlib::write::ZlibEncoder":["new"]},"struct_to_trait":{"Compression":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"bufreader::BufReader":["std::fmt::Debug","std::io::BufRead","std::io::Read"],"crc::Crc":["std::fmt::Debug"],"crc::CrcReader":["std::fmt::Debug","std::io::BufRead","std::io::Read"],"crc::CrcWriter":["std::fmt::Debug","std::io::Write"],"deflate::bufread::DeflateDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"deflate::bufread::DeflateEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"deflate::read::DeflateDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"deflate::read::DeflateEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"deflate::write::DeflateDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"deflate::write::DeflateEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"ffi::rust::Deflate":["ffi::Backend","ffi::DeflateBackend","std::fmt::Debug"],"ffi::rust::Inflate":["ffi::Backend","ffi::InflateBackend","std::fmt::Debug"],"gz::GzBuilder":["std::fmt::Debug"],"gz::GzHeader":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralPartialEq"],"gz::bufread::Buffer":["std::io::Read"],"gz::bufread::GzDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::bufread::GzEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::bufread::GzState":["std::fmt::Debug"],"gz::bufread::MultiGzDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::read::GzDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::read::GzEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::read::MultiGzDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::write::Counter":["std::io::Read"],"gz::write::GzDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"gz::write::GzEncoder":["std::fmt::Debug","std::io::Read","std::io::Write","std::ops::Drop"],"mem::Compress":["std::fmt::Debug","zio::Ops"],"mem::CompressError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"mem::Decompress":["std::fmt::Debug","zio::Ops"],"mem::DecompressError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"mem::DecompressErrorInner":["std::default::Default","std::fmt::Debug"],"mem::FlushCompress":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","zio::Flush"],"mem::FlushDecompress":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","zio::Flush"],"mem::Status":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::io::Error":["std::convert::From"],"zio::Writer":["std::fmt::Debug","std::io::Write","std::ops::Drop"],"zlib::bufread::ZlibDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"zlib::bufread::ZlibEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"zlib::read::ZlibDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"zlib::read::ZlibEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"zlib::write::ZlibDecoder":["std::fmt::Debug","std::io::Read","std::io::Write"],"zlib::write::ZlibEncoder":["std::fmt::Debug","std::io::Read","std::io::Write"]},"targets":{"<Compression as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<bufreader::BufReader<R> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/bufreader.rs\"))","std::fmt::Debug"],"<bufreader::BufReader<R> as std::io::BufRead>::consume":["consume","Real(LocalPath(\"src/bufreader.rs\"))","std::io::BufRead"],"<bufreader::BufReader<R> as std::io::BufRead>::fill_buf":["fill_buf","Real(LocalPath(\"src/bufreader.rs\"))","std::io::BufRead"],"<bufreader::BufReader<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/bufreader.rs\"))","std::io::Read"],"<crc::CrcReader<R> as std::io::BufRead>::consume":["consume","Real(LocalPath(\"src/crc.rs\"))","std::io::BufRead"],"<crc::CrcReader<R> as std::io::BufRead>::fill_buf":["fill_buf","Real(LocalPath(\"src/crc.rs\"))","std::io::BufRead"],"<crc::CrcReader<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/crc.rs\"))","std::io::Read"],"<crc::CrcWriter<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/crc.rs\"))","std::io::Write"],"<crc::CrcWriter<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/crc.rs\"))","std::io::Write"],"<deflate::bufread::DeflateDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Read"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Write"],"<deflate::bufread::DeflateDecoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Write"],"<deflate::bufread::DeflateEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Read"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Write"],"<deflate::bufread::DeflateEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/bufread.rs\"))","std::io::Write"],"<deflate::read::DeflateDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Read"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Write"],"<deflate::read::DeflateDecoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Write"],"<deflate::read::DeflateEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Read"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Write"],"<deflate::read::DeflateEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/read.rs\"))","std::io::Write"],"<deflate::write::DeflateDecoder<W> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Read"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Write"],"<deflate::write::DeflateDecoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Write"],"<deflate::write::DeflateEncoder<W> as std::io::Read>::read":["read","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Read"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Write"],"<deflate::write::DeflateEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/deflate/write.rs\"))","std::io::Write"],"<ffi::rust::Deflate as ffi::Backend>::total_in":["total_in","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::Backend"],"<ffi::rust::Deflate as ffi::Backend>::total_out":["total_out","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::Backend"],"<ffi::rust::Deflate as ffi::DeflateBackend>::compress":["compress","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::DeflateBackend"],"<ffi::rust::Deflate as ffi::DeflateBackend>::make":["make","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::DeflateBackend"],"<ffi::rust::Deflate as ffi::DeflateBackend>::reset":["reset","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::DeflateBackend"],"<ffi::rust::Deflate as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ffi/rust.rs\"))","std::fmt::Debug"],"<ffi::rust::Inflate as ffi::Backend>::total_in":["total_in","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::Backend"],"<ffi::rust::Inflate as ffi::Backend>::total_out":["total_out","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::Backend"],"<ffi::rust::Inflate as ffi::InflateBackend>::decompress":["decompress","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::InflateBackend"],"<ffi::rust::Inflate as ffi::InflateBackend>::make":["make","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::InflateBackend"],"<ffi::rust::Inflate as ffi::InflateBackend>::reset":["reset","Real(LocalPath(\"src/ffi/rust.rs\"))","ffi::InflateBackend"],"<ffi::rust::Inflate as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ffi/rust.rs\"))","std::fmt::Debug"],"<gz::bufread::Buffer<'a, T> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Read"],"<gz::bufread::GzDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Read"],"<gz::bufread::GzDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::bufread::GzDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::bufread::GzEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Read"],"<gz::bufread::GzEncoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::bufread::GzEncoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::bufread::MultiGzDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Read"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::bufread::MultiGzDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/bufread.rs\"))","std::io::Write"],"<gz::read::GzDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Read"],"<gz::read::GzDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::read::GzDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::read::GzEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Read"],"<gz::read::GzEncoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::read::GzEncoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::read::MultiGzDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Read"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::read::MultiGzDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/read.rs\"))","std::io::Write"],"<gz::write::Counter<T> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Read"],"<gz::write::GzDecoder<W> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Read"],"<gz::write::GzDecoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Write"],"<gz::write::GzDecoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Write"],"<gz::write::GzEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Read"],"<gz::write::GzEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Write"],"<gz::write::GzEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/gz/write.rs\"))","std::io::Write"],"<gz::write::GzEncoder<W> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/gz/write.rs\"))","std::ops::Drop"],"<mem::Compress as zio::Ops>::run":["run","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Compress as zio::Ops>::run_vec":["run_vec","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Compress as zio::Ops>::total_in":["total_in","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Compress as zio::Ops>::total_out":["total_out","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::CompressError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/mem.rs\"))","std::fmt::Display"],"<mem::Decompress as zio::Ops>::run":["run","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Decompress as zio::Ops>::run_vec":["run_vec","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Decompress as zio::Ops>::total_in":["total_in","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::Decompress as zio::Ops>::total_out":["total_out","Real(LocalPath(\"src/zio.rs\"))","zio::Ops"],"<mem::DecompressError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/mem.rs\"))","std::fmt::Display"],"<mem::FlushCompress as zio::Flush>::finish":["finish","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<mem::FlushCompress as zio::Flush>::none":["none","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<mem::FlushCompress as zio::Flush>::sync":["sync","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<mem::FlushDecompress as zio::Flush>::finish":["finish","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<mem::FlushDecompress as zio::Flush>::none":["none","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<mem::FlushDecompress as zio::Flush>::sync":["sync","Real(LocalPath(\"src/zio.rs\"))","zio::Flush"],"<zio::Writer<W, D> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zio.rs\"))","std::io::Write"],"<zio::Writer<W, D> as std::io::Write>::write":["write","Real(LocalPath(\"src/zio.rs\"))","std::io::Write"],"<zio::Writer<W, D> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/zio.rs\"))","std::ops::Drop"],"<zlib::bufread::ZlibDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Read"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Write"],"<zlib::bufread::ZlibDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Write"],"<zlib::bufread::ZlibEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Read"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Write"],"<zlib::bufread::ZlibEncoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/bufread.rs\"))","std::io::Write"],"<zlib::read::ZlibDecoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Read"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Write"],"<zlib::read::ZlibDecoder<R> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Write"],"<zlib::read::ZlibEncoder<R> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Read"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Write"],"<zlib::read::ZlibEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/read.rs\"))","std::io::Write"],"<zlib::write::ZlibDecoder<W> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Read"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Write"],"<zlib::write::ZlibDecoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Write"],"<zlib::write::ZlibEncoder<W> as std::io::Read>::read":["read","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Read"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Write"],"<zlib::write::ZlibEncoder<W> as std::io::Write>::write":["write","Real(LocalPath(\"src/zlib/write.rs\"))","std::io::Write"],"Compression::best":["best","Real(LocalPath(\"src/lib.rs\"))",""],"Compression::fast":["fast","Real(LocalPath(\"src/lib.rs\"))",""],"Compression::level":["level","Real(LocalPath(\"src/lib.rs\"))",""],"Compression::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Compression::none":["none","Real(LocalPath(\"src/lib.rs\"))",""],"_assert_send_sync":["_assert_send_sync","Real(LocalPath(\"src/lib.rs\"))",""],"_assert_send_sync::_assert_send_sync":["_assert_send_sync","Real(LocalPath(\"src/lib.rs\"))",""],"bufreader::BufReader::<R>::get_mut":["get_mut","Real(LocalPath(\"src/bufreader.rs\"))",""],"bufreader::BufReader::<R>::get_ref":["get_ref","Real(LocalPath(\"src/bufreader.rs\"))",""],"bufreader::BufReader::<R>::into_inner":["into_inner","Real(LocalPath(\"src/bufreader.rs\"))",""],"bufreader::BufReader::<R>::new":["new","Real(LocalPath(\"src/bufreader.rs\"))",""],"bufreader::BufReader::<R>::reset":["reset","Real(LocalPath(\"src/bufreader.rs\"))",""],"bufreader::BufReader::<R>::with_buf":["with_buf","Real(LocalPath(\"src/bufreader.rs\"))",""],"crc::Crc::amount":["amount","Real(LocalPath(\"src/crc.rs\"))",""],"crc::Crc::combine":["combine","Real(LocalPath(\"src/crc.rs\"))",""],"crc::Crc::new":["new","Real(LocalPath(\"src/crc.rs\"))",""],"crc::Crc::reset":["reset","Real(LocalPath(\"src/crc.rs\"))",""],"crc::Crc::sum":["sum","Real(LocalPath(\"src/crc.rs\"))",""],"crc::Crc::update":["update","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::crc":["crc","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::get_mut":["get_mut","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::get_ref":["get_ref","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::into_inner":["into_inner","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::new":["new","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcReader::<R>::reset":["reset","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::crc":["crc","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::get_mut":["get_mut","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::get_ref":["get_ref","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::into_inner":["into_inner","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::new":["new","Real(LocalPath(\"src/crc.rs\"))",""],"crc::CrcWriter::<W>::reset":["reset","Real(LocalPath(\"src/crc.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::new":["new","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::reset":["reset","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::reset_data":["reset_data","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::total_in":["total_in","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateDecoder::<R>::total_out":["total_out","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::new":["new","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::reset":["reset","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::total_in":["total_in","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::DeflateEncoder::<R>::total_out":["total_out","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::reset_decoder_data":["reset_decoder_data","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::bufread::reset_encoder_data":["reset_encoder_data","Real(LocalPath(\"src/deflate/bufread.rs\"))",""],"deflate::read::DeflateDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::new":["new","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::new_with_buf":["new_with_buf","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::reset":["reset","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::total_in":["total_in","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateDecoder::<R>::total_out":["total_out","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::new":["new","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::reset":["reset","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::total_in":["total_in","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::read::DeflateEncoder::<R>::total_out":["total_out","Real(LocalPath(\"src/deflate/read.rs\"))",""],"deflate::write::DeflateDecoder::<W>::finish":["finish","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::new":["new","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::reset":["reset","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::total_in":["total_in","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::total_out":["total_out","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateDecoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::finish":["finish","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::flush_finish":["flush_finish","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::new":["new","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::reset":["reset","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::total_in":["total_in","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::total_out":["total_out","Real(LocalPath(\"src/deflate/write.rs\"))",""],"deflate::write::DeflateEncoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/deflate/write.rs\"))",""],"ffi::rust::format_from_bool":["format_from_bool","Real(LocalPath(\"src/ffi/rust.rs\"))",""],"gz::GzBuilder::buf_read":["buf_read","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::comment":["comment","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::extra":["extra","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::filename":["filename","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::into_header":["into_header","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::mtime":["mtime","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::new":["new","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::operating_system":["operating_system","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::read":["read","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzBuilder::write":["write","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::comment":["comment","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::extra":["extra","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::filename":["filename","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::mtime":["mtime","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::mtime_as_datetime":["mtime_as_datetime","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::GzHeader::operating_system":["operating_system","Real(LocalPath(\"src/gz/mod.rs\"))",""],"gz::bufread::Buffer::<'a, T>::new":["new","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::header":["header","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::multi":["multi","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzDecoder::<R>::new":["new","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzEncoder::<R>::new":["new","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::GzEncoder::<R>::read_footer":["read_footer","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::MultiGzDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::MultiGzDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::MultiGzDecoder::<R>::header":["header","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::MultiGzDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::MultiGzDecoder::<R>::new":["new","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::bad_header":["bad_header","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::copy":["copy","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::corrupt":["corrupt","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::finish":["finish","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::gz_encoder":["gz_encoder","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::read_gz_header":["read_gz_header","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::bufread::read_le_u16":["read_le_u16","Real(LocalPath(\"src/gz/bufread.rs\"))",""],"gz::read::GzDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzDecoder::<R>::header":["header","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzDecoder::<R>::new":["new","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::GzEncoder::<R>::new":["new","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::MultiGzDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::MultiGzDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::MultiGzDecoder::<R>::header":["header","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::MultiGzDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::MultiGzDecoder::<R>::new":["new","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::read::gz_encoder":["gz_encoder","Real(LocalPath(\"src/gz/read.rs\"))",""],"gz::write::GzDecoder::<W>::finish":["finish","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::finish_and_check_crc":["finish_and_check_crc","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::header":["header","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::new":["new","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzDecoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::finish":["finish","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::new":["new","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::GzEncoder::<W>::write_header":["write_header","Real(LocalPath(\"src/gz/write.rs\"))",""],"gz::write::gz_encoder":["gz_encoder","Real(LocalPath(\"src/gz/write.rs\"))",""],"mem::<impl std::convert::From<mem::CompressError> for std::io::Error>::from":["from","Real(LocalPath(\"src/mem.rs\"))","std::convert::From"],"mem::<impl std::convert::From<mem::DecompressError> for std::io::Error>::from":["from","Real(LocalPath(\"src/mem.rs\"))","std::convert::From"],"mem::Compress::compress":["compress","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Compress::compress_vec":["compress_vec","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Compress::new":["new","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Compress::reset":["reset","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Compress::total_in":["total_in","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Compress::total_out":["total_out","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::decompress":["decompress","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::decompress_vec":["decompress_vec","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::new":["new","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::reset":["reset","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::total_in":["total_in","Real(LocalPath(\"src/mem.rs\"))",""],"mem::Decompress::total_out":["total_out","Real(LocalPath(\"src/mem.rs\"))",""],"mem::DecompressError::needs_dictionary":["needs_dictionary","Real(LocalPath(\"src/mem.rs\"))",""],"mem::decompress_failed":["decompress_failed","Real(LocalPath(\"src/mem.rs\"))",""],"mem::decompress_need_dict":["decompress_need_dict","Real(LocalPath(\"src/mem.rs\"))",""],"zio::Writer::<W, D>::dump":["dump","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::finish":["finish","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::get_mut":["get_mut","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::get_ref":["get_ref","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::is_present":["is_present","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::new":["new","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::replace":["replace","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::take_inner":["take_inner","Real(LocalPath(\"src/zio.rs\"))",""],"zio::Writer::<W, D>::write_with_status":["write_with_status","Real(LocalPath(\"src/zio.rs\"))",""],"zio::read":["read","Real(LocalPath(\"src/zio.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::new":["new","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::reset":["reset","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::total_in":["total_in","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibDecoder::<R>::total_out":["total_out","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::new":["new","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::reset":["reset","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::total_in":["total_in","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::ZlibEncoder::<R>::total_out":["total_out","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::reset_decoder_data":["reset_decoder_data","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::bufread::reset_encoder_data":["reset_encoder_data","Real(LocalPath(\"src/zlib/bufread.rs\"))",""],"zlib::read::ZlibDecoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::new":["new","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::new_with_buf":["new_with_buf","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::reset":["reset","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::total_in":["total_in","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibDecoder::<R>::total_out":["total_out","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::new":["new","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::reset":["reset","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::total_in":["total_in","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::read::ZlibEncoder::<R>::total_out":["total_out","Real(LocalPath(\"src/zlib/read.rs\"))",""],"zlib::write::ZlibDecoder::<W>::finish":["finish","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::new":["new","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::reset":["reset","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::total_in":["total_in","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::total_out":["total_out","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibDecoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::finish":["finish","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::flush_finish":["flush_finish","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::get_mut":["get_mut","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::get_ref":["get_ref","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::new":["new","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::reset":["reset","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::total_in":["total_in","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::total_out":["total_out","Real(LocalPath(\"src/zlib/write.rs\"))",""],"zlib::write::ZlibEncoder::<W>::try_finish":["try_finish","Real(LocalPath(\"src/zlib/write.rs\"))",""]},"trait_to_struct":{"ffi::Backend":["ffi::rust::Deflate","ffi::rust::Inflate"],"ffi::DeflateBackend":["ffi::rust::Deflate"],"ffi::InflateBackend":["ffi::rust::Inflate"],"std::clone::Clone":["Compression","gz::GzHeader","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::cmp::Eq":["Compression","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::cmp::PartialEq":["Compression","gz::GzHeader","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::convert::From":["std::io::Error"],"std::default::Default":["Compression","gz::GzHeader","mem::DecompressErrorInner"],"std::error::Error":["mem::CompressError","mem::DecompressError"],"std::fmt::Debug":["Compression","bufreader::BufReader","crc::Crc","crc::CrcReader","crc::CrcWriter","deflate::bufread::DeflateDecoder","deflate::bufread::DeflateEncoder","deflate::read::DeflateDecoder","deflate::read::DeflateEncoder","deflate::write::DeflateDecoder","deflate::write::DeflateEncoder","ffi::rust::Deflate","ffi::rust::Inflate","gz::GzBuilder","gz::GzHeader","gz::bufread::GzDecoder","gz::bufread::GzEncoder","gz::bufread::GzState","gz::bufread::MultiGzDecoder","gz::read::GzDecoder","gz::read::GzEncoder","gz::read::MultiGzDecoder","gz::write::GzDecoder","gz::write::GzEncoder","mem::Compress","mem::CompressError","mem::Decompress","mem::DecompressError","mem::DecompressErrorInner","mem::FlushCompress","mem::FlushDecompress","mem::Status","zio::Writer","zlib::bufread::ZlibDecoder","zlib::bufread::ZlibEncoder","zlib::read::ZlibDecoder","zlib::read::ZlibEncoder","zlib::write::ZlibDecoder","zlib::write::ZlibEncoder"],"std::fmt::Display":["mem::CompressError","mem::DecompressError"],"std::io::BufRead":["bufreader::BufReader","crc::CrcReader"],"std::io::Read":["bufreader::BufReader","crc::CrcReader","deflate::bufread::DeflateDecoder","deflate::bufread::DeflateEncoder","deflate::read::DeflateDecoder","deflate::read::DeflateEncoder","deflate::write::DeflateDecoder","deflate::write::DeflateEncoder","gz::bufread::Buffer","gz::bufread::GzDecoder","gz::bufread::GzEncoder","gz::bufread::MultiGzDecoder","gz::read::GzDecoder","gz::read::GzEncoder","gz::read::MultiGzDecoder","gz::write::Counter","gz::write::GzDecoder","gz::write::GzEncoder","zlib::bufread::ZlibDecoder","zlib::bufread::ZlibEncoder","zlib::read::ZlibDecoder","zlib::read::ZlibEncoder","zlib::write::ZlibDecoder","zlib::write::ZlibEncoder"],"std::io::Write":["crc::CrcWriter","deflate::bufread::DeflateDecoder","deflate::bufread::DeflateEncoder","deflate::read::DeflateDecoder","deflate::read::DeflateEncoder","deflate::write::DeflateDecoder","deflate::write::DeflateEncoder","gz::bufread::GzDecoder","gz::bufread::GzEncoder","gz::bufread::MultiGzDecoder","gz::read::GzDecoder","gz::read::GzEncoder","gz::read::MultiGzDecoder","gz::write::GzDecoder","gz::write::GzEncoder","zio::Writer","zlib::bufread::ZlibDecoder","zlib::bufread::ZlibEncoder","zlib::read::ZlibDecoder","zlib::read::ZlibEncoder","zlib::write::ZlibDecoder","zlib::write::ZlibEncoder"],"std::marker::Copy":["Compression","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::marker::StructuralEq":["Compression","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::marker::StructuralPartialEq":["Compression","gz::GzHeader","mem::FlushCompress","mem::FlushDecompress","mem::Status"],"std::ops::Drop":["gz::write::GzEncoder","zio::Writer"],"zio::Flush":["mem::FlushCompress","mem::FlushDecompress"],"zio::Ops":["mem::Compress","mem::Decompress"]},"type_to_def_path":{"Compression":"Compression","bufreader::BufReader<R>":"bufreader::BufReader","crc::Crc":"crc::Crc","crc::CrcReader<R>":"crc::CrcReader","crc::CrcWriter<W>":"crc::CrcWriter","deflate::bufread::DeflateDecoder<R>":"deflate::bufread::DeflateDecoder","deflate::bufread::DeflateEncoder<R>":"deflate::bufread::DeflateEncoder","deflate::read::DeflateDecoder<R>":"deflate::read::DeflateDecoder","deflate::read::DeflateEncoder<R>":"deflate::read::DeflateEncoder","deflate::write::DeflateDecoder<W>":"deflate::write::DeflateDecoder","deflate::write::DeflateEncoder<W>":"deflate::write::DeflateEncoder","ffi::rust::Deflate":"ffi::rust::Deflate","ffi::rust::Inflate":"ffi::rust::Inflate","gz::GzBuilder":"gz::GzBuilder","gz::GzHeader":"gz::GzHeader","gz::bufread::Buffer<'a, T>":"gz::bufread::Buffer","gz::bufread::GzDecoder<R>":"gz::bufread::GzDecoder","gz::bufread::GzEncoder<R>":"gz::bufread::GzEncoder","gz::bufread::GzState":"gz::bufread::GzState","gz::bufread::MultiGzDecoder<R>":"gz::bufread::MultiGzDecoder","gz::read::GzDecoder<R>":"gz::read::GzDecoder","gz::read::GzEncoder<R>":"gz::read::GzEncoder","gz::read::MultiGzDecoder<R>":"gz::read::MultiGzDecoder","gz::write::Counter<T>":"gz::write::Counter","gz::write::GzDecoder<W>":"gz::write::GzDecoder","gz::write::GzEncoder<W>":"gz::write::GzEncoder","mem::Compress":"mem::Compress","mem::CompressError":"mem::CompressError","mem::Decompress":"mem::Decompress","mem::DecompressError":"mem::DecompressError","mem::DecompressErrorInner":"mem::DecompressErrorInner","mem::FlushCompress":"mem::FlushCompress","mem::FlushDecompress":"mem::FlushDecompress","mem::Status":"mem::Status","zio::Writer<W, D>":"zio::Writer","zlib::bufread::ZlibDecoder<R>":"zlib::bufread::ZlibDecoder","zlib::bufread::ZlibEncoder<R>":"zlib::bufread::ZlibEncoder","zlib::read::ZlibDecoder<R>":"zlib::read::ZlibDecoder","zlib::read::ZlibEncoder<R>":"zlib::read::ZlibEncoder","zlib::write::ZlibDecoder<W>":"zlib::write::ZlibDecoder","zlib::write::ZlibEncoder<W>":"zlib::write::ZlibEncoder"}}